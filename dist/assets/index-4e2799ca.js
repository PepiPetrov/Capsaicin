function HD(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n]
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(r, o)
          i &&
            Object.defineProperty(
              e,
              o,
              i.get ? i : { enumerable: !0, get: () => r[o] }
            )
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })
  )
}
;(function () {
  const t = document.createElement("link").relList
  if (t && t.supports && t.supports("modulepreload")) return
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o)
  new MutationObserver((o) => {
    for (const i of o)
      if (i.type === "childList")
        for (const s of i.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(o) {
    const i = {}
    return (
      o.integrity && (i.integrity = o.integrity),
      o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === "use-credentials"
        ? (i.credentials = "include")
        : o.crossOrigin === "anonymous"
          ? (i.credentials = "omit")
          : (i.credentials = "same-origin"),
      i
    )
  }
  function r(o) {
    if (o.ep) return
    o.ep = !0
    const i = n(o)
    fetch(o.href, i)
  }
})()
function n0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e
}
var WS = { exports: {} },
  th = {},
  KS = { exports: {} },
  Re = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var xu = Symbol.for("react.element"),
  WD = Symbol.for("react.portal"),
  KD = Symbol.for("react.fragment"),
  GD = Symbol.for("react.strict_mode"),
  qD = Symbol.for("react.profiler"),
  ZD = Symbol.for("react.provider"),
  YD = Symbol.for("react.context"),
  XD = Symbol.for("react.forward_ref"),
  QD = Symbol.for("react.suspense"),
  JD = Symbol.for("react.memo"),
  e5 = Symbol.for("react.lazy"),
  cx = Symbol.iterator
function t5(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (cx && e[cx]) || e["@@iterator"]),
      typeof e == "function" ? e : null)
}
var GS = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  qS = Object.assign,
  ZS = {}
function ul(e, t, n) {
  ;(this.props = e),
    (this.context = t),
    (this.refs = ZS),
    (this.updater = n || GS)
}
ul.prototype.isReactComponent = {}
ul.prototype.setState = function (e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    )
  this.updater.enqueueSetState(this, e, t, "setState")
}
ul.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
function YS() {}
YS.prototype = ul.prototype
function r0(e, t, n) {
  ;(this.props = e),
    (this.context = t),
    (this.refs = ZS),
    (this.updater = n || GS)
}
var o0 = (r0.prototype = new YS())
o0.constructor = r0
qS(o0, ul.prototype)
o0.isPureReactComponent = !0
var ux = Array.isArray,
  XS = Object.prototype.hasOwnProperty,
  i0 = { current: null },
  QS = { key: !0, ref: !0, __self: !0, __source: !0 }
function JS(e, t, n) {
  var r,
    o = {},
    i = null,
    s = null
  if (t != null)
    for (r in (t.ref !== void 0 && (s = t.ref),
    t.key !== void 0 && (i = "" + t.key),
    t))
      XS.call(t, r) && !QS.hasOwnProperty(r) && (o[r] = t[r])
  var a = arguments.length - 2
  if (a === 1) o.children = n
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2]
    o.children = l
  }
  if (e && e.defaultProps)
    for (r in ((a = e.defaultProps), a)) o[r] === void 0 && (o[r] = a[r])
  return { $$typeof: xu, type: e, key: i, ref: s, props: o, _owner: i0.current }
}
function n5(e, t) {
  return {
    $$typeof: xu,
    type: e.type,
    key: t,
    ref: e.ref,
    props: e.props,
    _owner: e._owner,
  }
}
function s0(e) {
  return typeof e == "object" && e !== null && e.$$typeof === xu
}
function r5(e) {
  var t = { "=": "=0", ":": "=2" }
  return (
    "$" +
    e.replace(/[=:]/g, function (n) {
      return t[n]
    })
  )
}
var dx = /\/+/g
function Sm(e, t) {
  return typeof e == "object" && e !== null && e.key != null
    ? r5("" + e.key)
    : t.toString(36)
}
function Vd(e, t, n, r, o) {
  var i = typeof e
  ;(i === "undefined" || i === "boolean") && (e = null)
  var s = !1
  if (e === null) s = !0
  else
    switch (i) {
      case "string":
      case "number":
        s = !0
        break
      case "object":
        switch (e.$$typeof) {
          case xu:
          case WD:
            s = !0
        }
    }
  if (s)
    return (
      (s = e),
      (o = o(s)),
      (e = r === "" ? "." + Sm(s, 0) : r),
      ux(o)
        ? ((n = ""),
          e != null && (n = e.replace(dx, "$&/") + "/"),
          Vd(o, t, n, "", function (c) {
            return c
          }))
        : o != null &&
          (s0(o) &&
            (o = n5(
              o,
              n +
                (!o.key || (s && s.key === o.key)
                  ? ""
                  : ("" + o.key).replace(dx, "$&/") + "/") +
                e
            )),
          t.push(o)),
      1
    )
  if (((s = 0), (r = r === "" ? "." : r + ":"), ux(e)))
    for (var a = 0; a < e.length; a++) {
      i = e[a]
      var l = r + Sm(i, a)
      s += Vd(i, t, n, l, o)
    }
  else if (((l = t5(e)), typeof l == "function"))
    for (e = l.call(e), a = 0; !(i = e.next()).done; )
      (i = i.value), (l = r + Sm(i, a++)), (s += Vd(i, t, n, l, o))
  else if (i === "object")
    throw (
      ((t = String(e)),
      Error(
        "Objects are not valid as a React child (found: " +
          (t === "[object Object]"
            ? "object with keys {" + Object.keys(e).join(", ") + "}"
            : t) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    )
  return s
}
function Ku(e, t, n) {
  if (e == null) return e
  var r = [],
    o = 0
  return (
    Vd(e, r, "", "", function (i) {
      return t.call(n, i, o++)
    }),
    r
  )
}
function o5(e) {
  if (e._status === -1) {
    var t = e._result
    ;(t = t()),
      t.then(
        function (n) {
          ;(e._status === 0 || e._status === -1) &&
            ((e._status = 1), (e._result = n))
        },
        function (n) {
          ;(e._status === 0 || e._status === -1) &&
            ((e._status = 2), (e._result = n))
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t))
  }
  if (e._status === 1) return e._result.default
  throw e._result
}
var bn = { current: null },
  Hd = { transition: null },
  i5 = {
    ReactCurrentDispatcher: bn,
    ReactCurrentBatchConfig: Hd,
    ReactCurrentOwner: i0,
  }
function e_() {
  throw Error("act(...) is not supported in production builds of React.")
}
Re.Children = {
  map: Ku,
  forEach: function (e, t, n) {
    Ku(
      e,
      function () {
        t.apply(this, arguments)
      },
      n
    )
  },
  count: function (e) {
    var t = 0
    return (
      Ku(e, function () {
        t++
      }),
      t
    )
  },
  toArray: function (e) {
    return (
      Ku(e, function (t) {
        return t
      }) || []
    )
  },
  only: function (e) {
    if (!s0(e))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      )
    return e
  },
}
Re.Component = ul
Re.Fragment = KD
Re.Profiler = qD
Re.PureComponent = r0
Re.StrictMode = GD
Re.Suspense = QD
Re.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = i5
Re.act = e_
Re.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        e +
        "."
    )
  var r = qS({}, e.props),
    o = e.key,
    i = e.ref,
    s = e._owner
  if (t != null) {
    if (
      (t.ref !== void 0 && ((i = t.ref), (s = i0.current)),
      t.key !== void 0 && (o = "" + t.key),
      e.type && e.type.defaultProps)
    )
      var a = e.type.defaultProps
    for (l in t)
      XS.call(t, l) &&
        !QS.hasOwnProperty(l) &&
        (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
  }
  var l = arguments.length - 2
  if (l === 1) r.children = n
  else if (1 < l) {
    a = Array(l)
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2]
    r.children = a
  }
  return { $$typeof: xu, type: e.type, key: o, ref: i, props: r, _owner: s }
}
Re.createContext = function (e) {
  return (
    (e = {
      $$typeof: YD,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (e.Provider = { $$typeof: ZD, _context: e }),
    (e.Consumer = e)
  )
}
Re.createElement = JS
Re.createFactory = function (e) {
  var t = JS.bind(null, e)
  return (t.type = e), t
}
Re.createRef = function () {
  return { current: null }
}
Re.forwardRef = function (e) {
  return { $$typeof: XD, render: e }
}
Re.isValidElement = s0
Re.lazy = function (e) {
  return { $$typeof: e5, _payload: { _status: -1, _result: e }, _init: o5 }
}
Re.memo = function (e, t) {
  return { $$typeof: JD, type: e, compare: t === void 0 ? null : t }
}
Re.startTransition = function (e) {
  var t = Hd.transition
  Hd.transition = {}
  try {
    e()
  } finally {
    Hd.transition = t
  }
}
Re.unstable_act = e_
Re.useCallback = function (e, t) {
  return bn.current.useCallback(e, t)
}
Re.useContext = function (e) {
  return bn.current.useContext(e)
}
Re.useDebugValue = function () {}
Re.useDeferredValue = function (e) {
  return bn.current.useDeferredValue(e)
}
Re.useEffect = function (e, t) {
  return bn.current.useEffect(e, t)
}
Re.useId = function () {
  return bn.current.useId()
}
Re.useImperativeHandle = function (e, t, n) {
  return bn.current.useImperativeHandle(e, t, n)
}
Re.useInsertionEffect = function (e, t) {
  return bn.current.useInsertionEffect(e, t)
}
Re.useLayoutEffect = function (e, t) {
  return bn.current.useLayoutEffect(e, t)
}
Re.useMemo = function (e, t) {
  return bn.current.useMemo(e, t)
}
Re.useReducer = function (e, t, n) {
  return bn.current.useReducer(e, t, n)
}
Re.useRef = function (e) {
  return bn.current.useRef(e)
}
Re.useState = function (e) {
  return bn.current.useState(e)
}
Re.useSyncExternalStore = function (e, t, n) {
  return bn.current.useSyncExternalStore(e, t, n)
}
Re.useTransition = function () {
  return bn.current.useTransition()
}
Re.version = "18.3.1"
KS.exports = Re
var m = KS.exports
const G = n0(m),
  a0 = HD({ __proto__: null, default: G }, [m])
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var s5 = m,
  a5 = Symbol.for("react.element"),
  l5 = Symbol.for("react.fragment"),
  c5 = Object.prototype.hasOwnProperty,
  u5 = s5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  d5 = { key: !0, ref: !0, __self: !0, __source: !0 }
function t_(e, t, n) {
  var r,
    o = {},
    i = null,
    s = null
  n !== void 0 && (i = "" + n),
    t.key !== void 0 && (i = "" + t.key),
    t.ref !== void 0 && (s = t.ref)
  for (r in t) c5.call(t, r) && !d5.hasOwnProperty(r) && (o[r] = t[r])
  if (e && e.defaultProps)
    for (r in ((t = e.defaultProps), t)) o[r] === void 0 && (o[r] = t[r])
  return { $$typeof: a5, type: e, key: i, ref: s, props: o, _owner: u5.current }
}
th.Fragment = l5
th.jsx = t_
th.jsxs = t_
WS.exports = th
var h = WS.exports,
  nv = {},
  n_ = { exports: {} },
  Vn = {},
  r_ = { exports: {} },
  o_ = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (e) {
  function t(_, A) {
    var P = _.length
    _.push(A)
    e: for (; 0 < P; ) {
      var H = (P - 1) >>> 1,
        X = _[H]
      if (0 < o(X, A)) (_[H] = A), (_[P] = X), (P = H)
      else break e
    }
  }
  function n(_) {
    return _.length === 0 ? null : _[0]
  }
  function r(_) {
    if (_.length === 0) return null
    var A = _[0],
      P = _.pop()
    if (P !== A) {
      _[0] = P
      e: for (var H = 0, X = _.length, ae = X >>> 1; H < ae; ) {
        var ve = 2 * (H + 1) - 1,
          he = _[ve],
          xe = ve + 1,
          Ae = _[xe]
        if (0 > o(he, P))
          xe < X && 0 > o(Ae, he)
            ? ((_[H] = Ae), (_[xe] = P), (H = xe))
            : ((_[H] = he), (_[ve] = P), (H = ve))
        else if (xe < X && 0 > o(Ae, P)) (_[H] = Ae), (_[xe] = P), (H = xe)
        else break e
      }
    }
    return A
  }
  function o(_, A) {
    var P = _.sortIndex - A.sortIndex
    return P !== 0 ? P : _.id - A.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var i = performance
    e.unstable_now = function () {
      return i.now()
    }
  } else {
    var s = Date,
      a = s.now()
    e.unstable_now = function () {
      return s.now() - a
    }
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    f = 3,
    p = !1,
    g = !1,
    v = !1,
    b = typeof setTimeout == "function" ? setTimeout : null,
    y = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function E(_) {
    for (var A = n(c); A !== null; ) {
      if (A.callback === null) r(c)
      else if (A.startTime <= _) r(c), (A.sortIndex = A.expirationTime), t(l, A)
      else break
      A = n(c)
    }
  }
  function w(_) {
    if (((v = !1), E(_), !g))
      if (n(l) !== null) (g = !0), I(C)
      else {
        var A = n(c)
        A !== null && O(w, A.startTime - _)
      }
  }
  function C(_, A) {
    ;(g = !1), v && ((v = !1), y(N), (N = -1)), (p = !0)
    var P = f
    try {
      for (
        E(A), d = n(l);
        d !== null && (!(d.expirationTime > A) || (_ && !V()));

      ) {
        var H = d.callback
        if (typeof H == "function") {
          ;(d.callback = null), (f = d.priorityLevel)
          var X = H(d.expirationTime <= A)
          ;(A = e.unstable_now()),
            typeof X == "function" ? (d.callback = X) : d === n(l) && r(l),
            E(A)
        } else r(l)
        d = n(l)
      }
      if (d !== null) var ae = !0
      else {
        var ve = n(c)
        ve !== null && O(w, ve.startTime - A), (ae = !1)
      }
      return ae
    } finally {
      ;(d = null), (f = P), (p = !1)
    }
  }
  var S = !1,
    M = null,
    N = -1,
    R = 5,
    B = -1
  function V() {
    return !(e.unstable_now() - B < R)
  }
  function j() {
    if (M !== null) {
      var _ = e.unstable_now()
      B = _
      var A = !0
      try {
        A = M(!0, _)
      } finally {
        A ? U() : ((S = !1), (M = null))
      }
    } else S = !1
  }
  var U
  if (typeof x == "function")
    U = function () {
      x(j)
    }
  else if (typeof MessageChannel < "u") {
    var W = new MessageChannel(),
      ee = W.port2
    ;(W.port1.onmessage = j),
      (U = function () {
        ee.postMessage(null)
      })
  } else
    U = function () {
      b(j, 0)
    }
  function I(_) {
    ;(M = _), S || ((S = !0), U())
  }
  function O(_, A) {
    N = b(function () {
      _(e.unstable_now())
    }, A)
  }
  ;(e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (_) {
      _.callback = null
    }),
    (e.unstable_continueExecution = function () {
      g || p || ((g = !0), I(C))
    }),
    (e.unstable_forceFrameRate = function (_) {
      0 > _ || 125 < _
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < _ ? Math.floor(1e3 / _) : 5)
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return f
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(l)
    }),
    (e.unstable_next = function (_) {
      switch (f) {
        case 1:
        case 2:
        case 3:
          var A = 3
          break
        default:
          A = f
      }
      var P = f
      f = A
      try {
        return _()
      } finally {
        f = P
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (_, A) {
      switch (_) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          _ = 3
      }
      var P = f
      f = _
      try {
        return A()
      } finally {
        f = P
      }
    }),
    (e.unstable_scheduleCallback = function (_, A, P) {
      var H = e.unstable_now()
      switch (
        (typeof P == "object" && P !== null
          ? ((P = P.delay), (P = typeof P == "number" && 0 < P ? H + P : H))
          : (P = H),
        _)
      ) {
        case 1:
          var X = -1
          break
        case 2:
          X = 250
          break
        case 5:
          X = 1073741823
          break
        case 4:
          X = 1e4
          break
        default:
          X = 5e3
      }
      return (
        (X = P + X),
        (_ = {
          id: u++,
          callback: A,
          priorityLevel: _,
          startTime: P,
          expirationTime: X,
          sortIndex: -1,
        }),
        P > H
          ? ((_.sortIndex = P),
            t(c, _),
            n(l) === null &&
              _ === n(c) &&
              (v ? (y(N), (N = -1)) : (v = !0), O(w, P - H)))
          : ((_.sortIndex = X), t(l, _), g || p || ((g = !0), I(C))),
        _
      )
    }),
    (e.unstable_shouldYield = V),
    (e.unstable_wrapCallback = function (_) {
      var A = f
      return function () {
        var P = f
        f = A
        try {
          return _.apply(this, arguments)
        } finally {
          f = P
        }
      }
    })
})(o_)
r_.exports = o_
var f5 = r_.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var p5 = m,
  zn = f5
function J(e) {
  for (
    var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1;
    n < arguments.length;
    n++
  )
    t += "&args[]=" + encodeURIComponent(arguments[n])
  return (
    "Minified React error #" +
    e +
    "; visit " +
    t +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  )
}
var i_ = new Set(),
  Cc = {}
function Os(e, t) {
  La(e, t), La(e + "Capture", t)
}
function La(e, t) {
  for (Cc[e] = t, e = 0; e < t.length; e++) i_.add(t[e])
}
var ko = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  rv = Object.prototype.hasOwnProperty,
  h5 =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  fx = {},
  px = {}
function m5(e) {
  return rv.call(px, e)
    ? !0
    : rv.call(fx, e)
      ? !1
      : h5.test(e)
        ? (px[e] = !0)
        : ((fx[e] = !0), !1)
}
function g5(e, t, n, r) {
  if (n !== null && n.type === 0) return !1
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0
    case "boolean":
      return r
        ? !1
        : n !== null
          ? !n.acceptsBooleans
          : ((e = e.toLowerCase().slice(0, 5)), e !== "data-" && e !== "aria-")
    default:
      return !1
  }
}
function v5(e, t, n, r) {
  if (t === null || typeof t > "u" || g5(e, t, n, r)) return !0
  if (r) return !1
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t
      case 4:
        return t === !1
      case 5:
        return isNaN(t)
      case 6:
        return isNaN(t) || 1 > t
    }
  return !1
}
function xn(e, t, n, r, o, i, s) {
  ;(this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = r),
    (this.attributeNamespace = o),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = i),
    (this.removeEmptyString = s)
}
var Zt = {}
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (e) {
    Zt[e] = new xn(e, 0, !1, e, null, !1, !1)
  })
;[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (e) {
  var t = e[0]
  Zt[t] = new xn(t, 1, !1, e[1], null, !1, !1)
})
;["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
  Zt[e] = new xn(e, 2, !1, e.toLowerCase(), null, !1, !1)
})
;[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (e) {
  Zt[e] = new xn(e, 2, !1, e, null, !1, !1)
})
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (e) {
    Zt[e] = new xn(e, 3, !1, e.toLowerCase(), null, !1, !1)
  })
;["checked", "multiple", "muted", "selected"].forEach(function (e) {
  Zt[e] = new xn(e, 3, !0, e, null, !1, !1)
})
;["capture", "download"].forEach(function (e) {
  Zt[e] = new xn(e, 4, !1, e, null, !1, !1)
})
;["cols", "rows", "size", "span"].forEach(function (e) {
  Zt[e] = new xn(e, 6, !1, e, null, !1, !1)
})
;["rowSpan", "start"].forEach(function (e) {
  Zt[e] = new xn(e, 5, !1, e.toLowerCase(), null, !1, !1)
})
var l0 = /[\-:]([a-z])/g
function c0(e) {
  return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(l0, c0)
    Zt[t] = new xn(t, 1, !1, e, null, !1, !1)
  })
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(l0, c0)
    Zt[t] = new xn(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
  })
;["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
  var t = e.replace(l0, c0)
  Zt[t] = new xn(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
})
;["tabIndex", "crossOrigin"].forEach(function (e) {
  Zt[e] = new xn(e, 1, !1, e.toLowerCase(), null, !1, !1)
})
Zt.xlinkHref = new xn(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
)
;["src", "href", "action", "formAction"].forEach(function (e) {
  Zt[e] = new xn(e, 1, !1, e.toLowerCase(), null, !0, !0)
})
function u0(e, t, n, r) {
  var o = Zt.hasOwnProperty(t) ? Zt[t] : null
  ;(o !== null
    ? o.type !== 0
    : r ||
      !(2 < t.length) ||
      (t[0] !== "o" && t[0] !== "O") ||
      (t[1] !== "n" && t[1] !== "N")) &&
    (v5(t, n, o, r) && (n = null),
    r || o === null
      ? m5(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
      : o.mustUseProperty
        ? (e[o.propertyName] = n === null ? (o.type === 3 ? !1 : "") : n)
        : ((t = o.attributeName),
          (r = o.attributeNamespace),
          n === null
            ? e.removeAttribute(t)
            : ((o = o.type),
              (n = o === 3 || (o === 4 && n === !0) ? "" : "" + n),
              r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var Do = p5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Gu = Symbol.for("react.element"),
  aa = Symbol.for("react.portal"),
  la = Symbol.for("react.fragment"),
  d0 = Symbol.for("react.strict_mode"),
  ov = Symbol.for("react.profiler"),
  s_ = Symbol.for("react.provider"),
  a_ = Symbol.for("react.context"),
  f0 = Symbol.for("react.forward_ref"),
  iv = Symbol.for("react.suspense"),
  sv = Symbol.for("react.suspense_list"),
  p0 = Symbol.for("react.memo"),
  zo = Symbol.for("react.lazy"),
  l_ = Symbol.for("react.offscreen"),
  hx = Symbol.iterator
function Cl(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (hx && e[hx]) || e["@@iterator"]),
      typeof e == "function" ? e : null)
}
var at = Object.assign,
  _m
function jl(e) {
  if (_m === void 0)
    try {
      throw Error()
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/)
      _m = (t && t[1]) || ""
    }
  return (
    `
` +
    _m +
    e
  )
}
var km = !1
function Nm(e, t) {
  if (!e || km) return ""
  km = !0
  var n = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (t)
      if (
        ((t = function () {
          throw Error()
        }),
        Object.defineProperty(t.prototype, "props", {
          set: function () {
            throw Error()
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, [])
        } catch (c) {
          var r = c
        }
        Reflect.construct(e, [], t)
      } else {
        try {
          t.call()
        } catch (c) {
          r = c
        }
        e.call(t.prototype)
      }
    else {
      try {
        throw Error()
      } catch (c) {
        r = c
      }
      e()
    }
  } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (
        var o = c.stack.split(`
`),
          i = r.stack.split(`
`),
          s = o.length - 1,
          a = i.length - 1;
        1 <= s && 0 <= a && o[s] !== i[a];

      )
        a--
      for (; 1 <= s && 0 <= a; s--, a--)
        if (o[s] !== i[a]) {
          if (s !== 1 || a !== 1)
            do
              if ((s--, a--, 0 > a || o[s] !== i[a])) {
                var l =
                  `
` + o[s].replace(" at new ", " at ")
                return (
                  e.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", e.displayName)),
                  l
                )
              }
            while (1 <= s && 0 <= a)
          break
        }
    }
  } finally {
    ;(km = !1), (Error.prepareStackTrace = n)
  }
  return (e = e ? e.displayName || e.name : "") ? jl(e) : ""
}
function y5(e) {
  switch (e.tag) {
    case 5:
      return jl(e.type)
    case 16:
      return jl("Lazy")
    case 13:
      return jl("Suspense")
    case 19:
      return jl("SuspenseList")
    case 0:
    case 2:
    case 15:
      return (e = Nm(e.type, !1)), e
    case 11:
      return (e = Nm(e.type.render, !1)), e
    case 1:
      return (e = Nm(e.type, !0)), e
    default:
      return ""
  }
}
function av(e) {
  if (e == null) return null
  if (typeof e == "function") return e.displayName || e.name || null
  if (typeof e == "string") return e
  switch (e) {
    case la:
      return "Fragment"
    case aa:
      return "Portal"
    case ov:
      return "Profiler"
    case d0:
      return "StrictMode"
    case iv:
      return "Suspense"
    case sv:
      return "SuspenseList"
  }
  if (typeof e == "object")
    switch (e.$$typeof) {
      case a_:
        return (e.displayName || "Context") + ".Consumer"
      case s_:
        return (e._context.displayName || "Context") + ".Provider"
      case f0:
        var t = e.render
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ""),
            (e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")),
          e
        )
      case p0:
        return (
          (t = e.displayName || null), t !== null ? t : av(e.type) || "Memo"
        )
      case zo:
        ;(t = e._payload), (e = e._init)
        try {
          return av(e(t))
        } catch {}
    }
  return null
}
function b5(e) {
  var t = e.type
  switch (e.tag) {
    case 24:
      return "Cache"
    case 9:
      return (t.displayName || "Context") + ".Consumer"
    case 10:
      return (t._context.displayName || "Context") + ".Provider"
    case 18:
      return "DehydratedFragment"
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ""),
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")
      )
    case 7:
      return "Fragment"
    case 5:
      return t
    case 4:
      return "Portal"
    case 3:
      return "Root"
    case 6:
      return "Text"
    case 16:
      return av(t)
    case 8:
      return t === d0 ? "StrictMode" : "Mode"
    case 22:
      return "Offscreen"
    case 12:
      return "Profiler"
    case 21:
      return "Scope"
    case 13:
      return "Suspense"
    case 19:
      return "SuspenseList"
    case 25:
      return "TracingMarker"
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null
      if (typeof t == "string") return t
  }
  return null
}
function xi(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e
    case "object":
      return e
    default:
      return ""
  }
}
function c_(e) {
  var t = e.type
  return (
    (e = e.nodeName) &&
    e.toLowerCase() === "input" &&
    (t === "checkbox" || t === "radio")
  )
}
function x5(e) {
  var t = c_(e) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = "" + e[t]
  if (
    !e.hasOwnProperty(t) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var o = n.get,
      i = n.set
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return o.call(this)
        },
        set: function (s) {
          ;(r = "" + s), i.call(this, s)
        },
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r
        },
        setValue: function (s) {
          r = "" + s
        },
        stopTracking: function () {
          ;(e._valueTracker = null), delete e[t]
        },
      }
    )
  }
}
function qu(e) {
  e._valueTracker || (e._valueTracker = x5(e))
}
function u_(e) {
  if (!e) return !1
  var t = e._valueTracker
  if (!t) return !0
  var n = t.getValue(),
    r = ""
  return (
    e && (r = c_(e) ? (e.checked ? "true" : "false") : e.value),
    (e = r),
    e !== n ? (t.setValue(e), !0) : !1
  )
}
function ff(e) {
  if (((e = e || (typeof document < "u" ? document : void 0)), typeof e > "u"))
    return null
  try {
    return e.activeElement || e.body
  } catch {
    return e.body
  }
}
function lv(e, t) {
  var n = t.checked
  return at({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n != null ? n : e._wrapperState.initialChecked,
  })
}
function mx(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked
  ;(n = xi(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        t.type === "checkbox" || t.type === "radio"
          ? t.checked != null
          : t.value != null,
    })
}
function d_(e, t) {
  ;(t = t.checked), t != null && u0(e, "checked", t, !1)
}
function cv(e, t) {
  d_(e, t)
  var n = xi(t.value),
    r = t.type
  if (n != null)
    r === "number"
      ? ((n === 0 && e.value === "") || e.value != n) && (e.value = "" + n)
      : e.value !== "" + n && (e.value = "" + n)
  else if (r === "submit" || r === "reset") {
    e.removeAttribute("value")
    return
  }
  t.hasOwnProperty("value")
    ? uv(e, t.type, n)
    : t.hasOwnProperty("defaultValue") && uv(e, t.type, xi(t.defaultValue)),
    t.checked == null &&
      t.defaultChecked != null &&
      (e.defaultChecked = !!t.defaultChecked)
}
function gx(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var r = t.type
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (t.value !== void 0 && t.value !== null)
      )
    )
      return
    ;(t = "" + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t)
  }
  ;(n = e.name),
    n !== "" && (e.name = ""),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== "" && (e.name = n)
}
function uv(e, t, n) {
  ;(t !== "number" || ff(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = "" + e._wrapperState.initialValue)
      : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Fl = Array.isArray
function Ea(e, t, n, r) {
  if (((e = e.options), t)) {
    t = {}
    for (var o = 0; o < n.length; o++) t["$" + n[o]] = !0
    for (n = 0; n < e.length; n++)
      (o = t.hasOwnProperty("$" + e[n].value)),
        e[n].selected !== o && (e[n].selected = o),
        o && r && (e[n].defaultSelected = !0)
  } else {
    for (n = "" + xi(n), t = null, o = 0; o < e.length; o++) {
      if (e[o].value === n) {
        ;(e[o].selected = !0), r && (e[o].defaultSelected = !0)
        return
      }
      t !== null || e[o].disabled || (t = e[o])
    }
    t !== null && (t.selected = !0)
  }
}
function dv(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(J(91))
  return at({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: "" + e._wrapperState.initialValue,
  })
}
function vx(e, t) {
  var n = t.value
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(J(92))
      if (Fl(n)) {
        if (1 < n.length) throw Error(J(93))
        n = n[0]
      }
      t = n
    }
    t == null && (t = ""), (n = t)
  }
  e._wrapperState = { initialValue: xi(n) }
}
function f_(e, t) {
  var n = xi(t.value),
    r = xi(t.defaultValue)
  n != null &&
    ((n = "" + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = "" + r)
}
function yx(e) {
  var t = e.textContent
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function p_(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg"
    case "math":
      return "http://www.w3.org/1998/Math/MathML"
    default:
      return "http://www.w3.org/1999/xhtml"
  }
}
function fv(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml"
    ? p_(t)
    : e === "http://www.w3.org/2000/svg" && t === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : e
}
var Zu,
  h_ = (function (e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (t, n, r, o) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, o)
          })
        }
      : e
  })(function (e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e)
      e.innerHTML = t
    else {
      for (
        Zu = Zu || document.createElement("div"),
          Zu.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
          t = Zu.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild)
      for (; t.firstChild; ) e.appendChild(t.firstChild)
    }
  })
function Sc(e, t) {
  if (t) {
    var n = e.firstChild
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t
      return
    }
  }
  e.textContent = t
}
var Xl = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  w5 = ["Webkit", "ms", "Moz", "O"]
Object.keys(Xl).forEach(function (e) {
  w5.forEach(function (t) {
    ;(t = t + e.charAt(0).toUpperCase() + e.substring(1)), (Xl[t] = Xl[e])
  })
})
function m_(e, t, n) {
  return t == null || typeof t == "boolean" || t === ""
    ? ""
    : n || typeof t != "number" || t === 0 || (Xl.hasOwnProperty(e) && Xl[e])
      ? ("" + t).trim()
      : t + "px"
}
function g_(e, t) {
  e = e.style
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        o = m_(n, t[n], r)
      n === "float" && (n = "cssFloat"), r ? e.setProperty(n, o) : (e[n] = o)
    }
}
var E5 = at(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function pv(e, t) {
  if (t) {
    if (E5[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
      throw Error(J(137, e))
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(J(60))
      if (
        typeof t.dangerouslySetInnerHTML != "object" ||
        !("__html" in t.dangerouslySetInnerHTML)
      )
        throw Error(J(61))
    }
    if (t.style != null && typeof t.style != "object") throw Error(J(62))
  }
}
function hv(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string"
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1
    default:
      return !0
  }
}
var mv = null
function h0(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  )
}
var gv = null,
  Ca = null,
  Sa = null
function bx(e) {
  if ((e = Cu(e))) {
    if (typeof gv != "function") throw Error(J(280))
    var t = e.stateNode
    t && ((t = sh(t)), gv(e.stateNode, e.type, t))
  }
}
function v_(e) {
  Ca ? (Sa ? Sa.push(e) : (Sa = [e])) : (Ca = e)
}
function y_() {
  if (Ca) {
    var e = Ca,
      t = Sa
    if (((Sa = Ca = null), bx(e), t)) for (e = 0; e < t.length; e++) bx(t[e])
  }
}
function b_(e, t) {
  return e(t)
}
function x_() {}
var Tm = !1
function w_(e, t, n) {
  if (Tm) return e(t, n)
  Tm = !0
  try {
    return b_(e, t, n)
  } finally {
    ;(Tm = !1), (Ca !== null || Sa !== null) && (x_(), y_())
  }
}
function _c(e, t) {
  var n = e.stateNode
  if (n === null) return null
  var r = sh(n)
  if (r === null) return null
  n = r[t]
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      ;(r = !r.disabled) ||
        ((e = e.type),
        (r = !(
          e === "button" ||
          e === "input" ||
          e === "select" ||
          e === "textarea"
        ))),
        (e = !r)
      break e
    default:
      e = !1
  }
  if (e) return null
  if (n && typeof n != "function") throw Error(J(231, t, typeof n))
  return n
}
var vv = !1
if (ko)
  try {
    var Sl = {}
    Object.defineProperty(Sl, "passive", {
      get: function () {
        vv = !0
      },
    }),
      window.addEventListener("test", Sl, Sl),
      window.removeEventListener("test", Sl, Sl)
  } catch {
    vv = !1
  }
function C5(e, t, n, r, o, i, s, a, l) {
  var c = Array.prototype.slice.call(arguments, 3)
  try {
    t.apply(n, c)
  } catch (u) {
    this.onError(u)
  }
}
var Ql = !1,
  pf = null,
  hf = !1,
  yv = null,
  S5 = {
    onError: function (e) {
      ;(Ql = !0), (pf = e)
    },
  }
function _5(e, t, n, r, o, i, s, a, l) {
  ;(Ql = !1), (pf = null), C5.apply(S5, arguments)
}
function k5(e, t, n, r, o, i, s, a, l) {
  if ((_5.apply(this, arguments), Ql)) {
    if (Ql) {
      var c = pf
      ;(Ql = !1), (pf = null)
    } else throw Error(J(198))
    hf || ((hf = !0), (yv = c))
  }
}
function As(e) {
  var t = e,
    n = e
  if (e.alternate) for (; t.return; ) t = t.return
  else {
    e = t
    do (t = e), t.flags & 4098 && (n = t.return), (e = t.return)
    while (e)
  }
  return t.tag === 3 ? n : null
}
function E_(e) {
  if (e.tag === 13) {
    var t = e.memoizedState
    if (
      (t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)),
      t !== null)
    )
      return t.dehydrated
  }
  return null
}
function xx(e) {
  if (As(e) !== e) throw Error(J(188))
}
function N5(e) {
  var t = e.alternate
  if (!t) {
    if (((t = As(e)), t === null)) throw Error(J(188))
    return t !== e ? null : e
  }
  for (var n = e, r = t; ; ) {
    var o = n.return
    if (o === null) break
    var i = o.alternate
    if (i === null) {
      if (((r = o.return), r !== null)) {
        n = r
        continue
      }
      break
    }
    if (o.child === i.child) {
      for (i = o.child; i; ) {
        if (i === n) return xx(o), e
        if (i === r) return xx(o), t
        i = i.sibling
      }
      throw Error(J(188))
    }
    if (n.return !== r.return) (n = o), (r = i)
    else {
      for (var s = !1, a = o.child; a; ) {
        if (a === n) {
          ;(s = !0), (n = o), (r = i)
          break
        }
        if (a === r) {
          ;(s = !0), (r = o), (n = i)
          break
        }
        a = a.sibling
      }
      if (!s) {
        for (a = i.child; a; ) {
          if (a === n) {
            ;(s = !0), (n = i), (r = o)
            break
          }
          if (a === r) {
            ;(s = !0), (r = i), (n = o)
            break
          }
          a = a.sibling
        }
        if (!s) throw Error(J(189))
      }
    }
    if (n.alternate !== r) throw Error(J(190))
  }
  if (n.tag !== 3) throw Error(J(188))
  return n.stateNode.current === n ? e : t
}
function C_(e) {
  return (e = N5(e)), e !== null ? S_(e) : null
}
function S_(e) {
  if (e.tag === 5 || e.tag === 6) return e
  for (e = e.child; e !== null; ) {
    var t = S_(e)
    if (t !== null) return t
    e = e.sibling
  }
  return null
}
var __ = zn.unstable_scheduleCallback,
  wx = zn.unstable_cancelCallback,
  T5 = zn.unstable_shouldYield,
  M5 = zn.unstable_requestPaint,
  xt = zn.unstable_now,
  O5 = zn.unstable_getCurrentPriorityLevel,
  m0 = zn.unstable_ImmediatePriority,
  k_ = zn.unstable_UserBlockingPriority,
  mf = zn.unstable_NormalPriority,
  A5 = zn.unstable_LowPriority,
  N_ = zn.unstable_IdlePriority,
  nh = null,
  Wr = null
function R5(e) {
  if (Wr && typeof Wr.onCommitFiberRoot == "function")
    try {
      Wr.onCommitFiberRoot(nh, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var Cr = Math.clz32 ? Math.clz32 : L5,
  I5 = Math.log,
  D5 = Math.LN2
function L5(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((I5(e) / D5) | 0)) | 0
}
var Yu = 64,
  Xu = 4194304
function zl(e) {
  switch (e & -e) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return e
  }
}
function gf(e, t) {
  var n = e.pendingLanes
  if (n === 0) return 0
  var r = 0,
    o = e.suspendedLanes,
    i = e.pingedLanes,
    s = n & 268435455
  if (s !== 0) {
    var a = s & ~o
    a !== 0 ? (r = zl(a)) : ((i &= s), i !== 0 && (r = zl(i)))
  } else (s = n & ~o), s !== 0 ? (r = zl(s)) : i !== 0 && (r = zl(i))
  if (r === 0) return 0
  if (
    t !== 0 &&
    t !== r &&
    !(t & o) &&
    ((o = r & -r), (i = t & -t), o >= i || (o === 16 && (i & 4194240) !== 0))
  )
    return t
  if ((r & 4 && (r |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= r; 0 < t; )
      (n = 31 - Cr(t)), (o = 1 << n), (r |= e[n]), (t &= ~o)
  return r
}
function P5(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function $5(e, t) {
  for (
    var n = e.suspendedLanes,
      r = e.pingedLanes,
      o = e.expirationTimes,
      i = e.pendingLanes;
    0 < i;

  ) {
    var s = 31 - Cr(i),
      a = 1 << s,
      l = o[s]
    l === -1
      ? (!(a & n) || a & r) && (o[s] = P5(a, t))
      : l <= t && (e.expiredLanes |= a),
      (i &= ~a)
  }
}
function bv(e) {
  return (
    (e = e.pendingLanes & -1073741825),
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
  )
}
function T_() {
  var e = Yu
  return (Yu <<= 1), !(Yu & 4194240) && (Yu = 64), e
}
function Mm(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e)
  return t
}
function wu(e, t, n) {
  ;(e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - Cr(t)),
    (e[t] = n)
}
function B5(e, t) {
  var n = e.pendingLanes & ~t
  ;(e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements)
  var r = e.eventTimes
  for (e = e.expirationTimes; 0 < n; ) {
    var o = 31 - Cr(n),
      i = 1 << o
    ;(t[o] = 0), (r[o] = -1), (e[o] = -1), (n &= ~i)
  }
}
function g0(e, t) {
  var n = (e.entangledLanes |= t)
  for (e = e.entanglements; n; ) {
    var r = 31 - Cr(n),
      o = 1 << r
    ;(o & t) | (e[r] & t) && (e[r] |= t), (n &= ~o)
  }
}
var Ve = 0
function M_(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1
}
var O_,
  v0,
  A_,
  R_,
  I_,
  xv = !1,
  Qu = [],
  oi = null,
  ii = null,
  si = null,
  kc = new Map(),
  Nc = new Map(),
  Ko = [],
  j5 =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    )
function Ex(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      oi = null
      break
    case "dragenter":
    case "dragleave":
      ii = null
      break
    case "mouseover":
    case "mouseout":
      si = null
      break
    case "pointerover":
    case "pointerout":
      kc.delete(t.pointerId)
      break
    case "gotpointercapture":
    case "lostpointercapture":
      Nc.delete(t.pointerId)
  }
}
function _l(e, t, n, r, o, i) {
  return e === null || e.nativeEvent !== i
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: i,
        targetContainers: [o],
      }),
      t !== null && ((t = Cu(t)), t !== null && v0(t)),
      e)
    : ((e.eventSystemFlags |= r),
      (t = e.targetContainers),
      o !== null && t.indexOf(o) === -1 && t.push(o),
      e)
}
function F5(e, t, n, r, o) {
  switch (t) {
    case "focusin":
      return (oi = _l(oi, e, t, n, r, o)), !0
    case "dragenter":
      return (ii = _l(ii, e, t, n, r, o)), !0
    case "mouseover":
      return (si = _l(si, e, t, n, r, o)), !0
    case "pointerover":
      var i = o.pointerId
      return kc.set(i, _l(kc.get(i) || null, e, t, n, r, o)), !0
    case "gotpointercapture":
      return (
        (i = o.pointerId), Nc.set(i, _l(Nc.get(i) || null, e, t, n, r, o)), !0
      )
  }
  return !1
}
function D_(e) {
  var t = Ki(e.target)
  if (t !== null) {
    var n = As(t)
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = E_(n)), t !== null)) {
          ;(e.blockedOn = t),
            I_(e.priority, function () {
              A_(n)
            })
          return
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null
        return
      }
    }
  }
  e.blockedOn = null
}
function Wd(e) {
  if (e.blockedOn !== null) return !1
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = wv(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent)
    if (n === null) {
      n = e.nativeEvent
      var r = new n.constructor(n.type, n)
      ;(mv = r), n.target.dispatchEvent(r), (mv = null)
    } else return (t = Cu(n)), t !== null && v0(t), (e.blockedOn = n), !1
    t.shift()
  }
  return !0
}
function Cx(e, t, n) {
  Wd(e) && n.delete(t)
}
function z5() {
  ;(xv = !1),
    oi !== null && Wd(oi) && (oi = null),
    ii !== null && Wd(ii) && (ii = null),
    si !== null && Wd(si) && (si = null),
    kc.forEach(Cx),
    Nc.forEach(Cx)
}
function kl(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    xv ||
      ((xv = !0), zn.unstable_scheduleCallback(zn.unstable_NormalPriority, z5)))
}
function Tc(e) {
  function t(o) {
    return kl(o, e)
  }
  if (0 < Qu.length) {
    kl(Qu[0], e)
    for (var n = 1; n < Qu.length; n++) {
      var r = Qu[n]
      r.blockedOn === e && (r.blockedOn = null)
    }
  }
  for (
    oi !== null && kl(oi, e),
      ii !== null && kl(ii, e),
      si !== null && kl(si, e),
      kc.forEach(t),
      Nc.forEach(t),
      n = 0;
    n < Ko.length;
    n++
  )
    (r = Ko[n]), r.blockedOn === e && (r.blockedOn = null)
  for (; 0 < Ko.length && ((n = Ko[0]), n.blockedOn === null); )
    D_(n), n.blockedOn === null && Ko.shift()
}
var _a = Do.ReactCurrentBatchConfig,
  vf = !0
function U5(e, t, n, r) {
  var o = Ve,
    i = _a.transition
  _a.transition = null
  try {
    ;(Ve = 1), y0(e, t, n, r)
  } finally {
    ;(Ve = o), (_a.transition = i)
  }
}
function V5(e, t, n, r) {
  var o = Ve,
    i = _a.transition
  _a.transition = null
  try {
    ;(Ve = 4), y0(e, t, n, r)
  } finally {
    ;(Ve = o), (_a.transition = i)
  }
}
function y0(e, t, n, r) {
  if (vf) {
    var o = wv(e, t, n, r)
    if (o === null) jm(e, t, r, yf, n), Ex(e, r)
    else if (F5(o, e, t, n, r)) r.stopPropagation()
    else if ((Ex(e, r), t & 4 && -1 < j5.indexOf(e))) {
      for (; o !== null; ) {
        var i = Cu(o)
        if (
          (i !== null && O_(i),
          (i = wv(e, t, n, r)),
          i === null && jm(e, t, r, yf, n),
          i === o)
        )
          break
        o = i
      }
      o !== null && r.stopPropagation()
    } else jm(e, t, r, null, n)
  }
}
var yf = null
function wv(e, t, n, r) {
  if (((yf = null), (e = h0(r)), (e = Ki(e)), e !== null))
    if (((t = As(e)), t === null)) e = null
    else if (((n = t.tag), n === 13)) {
      if (((e = E_(t)), e !== null)) return e
      e = null
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null
      e = null
    } else t !== e && (e = null)
  return (yf = e), null
}
function L_(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4
    case "message":
      switch (O5()) {
        case m0:
          return 1
        case k_:
          return 4
        case mf:
        case A5:
          return 16
        case N_:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var Xo = null,
  b0 = null,
  Kd = null
function P_() {
  if (Kd) return Kd
  var e,
    t = b0,
    n = t.length,
    r,
    o = "value" in Xo ? Xo.value : Xo.textContent,
    i = o.length
  for (e = 0; e < n && t[e] === o[e]; e++);
  var s = n - e
  for (r = 1; r <= s && t[n - r] === o[i - r]; r++);
  return (Kd = o.slice(e, 1 < r ? 1 - r : void 0))
}
function Gd(e) {
  var t = e.keyCode
  return (
    "charCode" in e
      ? ((e = e.charCode), e === 0 && t === 13 && (e = 13))
      : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  )
}
function Ju() {
  return !0
}
function Sx() {
  return !1
}
function Hn(e) {
  function t(n, r, o, i, s) {
    ;(this._reactName = n),
      (this._targetInst = o),
      (this.type = r),
      (this.nativeEvent = i),
      (this.target = s),
      (this.currentTarget = null)
    for (var a in e)
      e.hasOwnProperty(a) && ((n = e[a]), (this[a] = n ? n(i) : i[a]))
    return (
      (this.isDefaultPrevented = (
        i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1
      )
        ? Ju
        : Sx),
      (this.isPropagationStopped = Sx),
      this
    )
  }
  return (
    at(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var n = this.nativeEvent
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = Ju))
      },
      stopPropagation: function () {
        var n = this.nativeEvent
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = Ju))
      },
      persist: function () {},
      isPersistent: Ju,
    }),
    t
  )
}
var dl = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  x0 = Hn(dl),
  Eu = at({}, dl, { view: 0, detail: 0 }),
  H5 = Hn(Eu),
  Om,
  Am,
  Nl,
  rh = at({}, Eu, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: w0,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget
    },
    movementX: function (e) {
      return "movementX" in e
        ? e.movementX
        : (e !== Nl &&
            (Nl && e.type === "mousemove"
              ? ((Om = e.screenX - Nl.screenX), (Am = e.screenY - Nl.screenY))
              : (Am = Om = 0),
            (Nl = e)),
          Om)
    },
    movementY: function (e) {
      return "movementY" in e ? e.movementY : Am
    },
  }),
  _x = Hn(rh),
  W5 = at({}, rh, { dataTransfer: 0 }),
  K5 = Hn(W5),
  G5 = at({}, Eu, { relatedTarget: 0 }),
  Rm = Hn(G5),
  q5 = at({}, dl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Z5 = Hn(q5),
  Y5 = at({}, dl, {
    clipboardData: function (e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData
    },
  }),
  X5 = Hn(Y5),
  Q5 = at({}, dl, { data: 0 }),
  kx = Hn(Q5),
  J5 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  e4 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  t4 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }
function n4(e) {
  var t = this.nativeEvent
  return t.getModifierState ? t.getModifierState(e) : (e = t4[e]) ? !!t[e] : !1
}
function w0() {
  return n4
}
var r4 = at({}, Eu, {
    key: function (e) {
      if (e.key) {
        var t = J5[e.key] || e.key
        if (t !== "Unidentified") return t
      }
      return e.type === "keypress"
        ? ((e = Gd(e)), e === 13 ? "Enter" : String.fromCharCode(e))
        : e.type === "keydown" || e.type === "keyup"
          ? e4[e.keyCode] || "Unidentified"
          : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: w0,
    charCode: function (e) {
      return e.type === "keypress" ? Gd(e) : 0
    },
    keyCode: function (e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function (e) {
      return e.type === "keypress"
        ? Gd(e)
        : e.type === "keydown" || e.type === "keyup"
          ? e.keyCode
          : 0
    },
  }),
  o4 = Hn(r4),
  i4 = at({}, rh, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Nx = Hn(i4),
  s4 = at({}, Eu, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: w0,
  }),
  a4 = Hn(s4),
  l4 = at({}, dl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  c4 = Hn(l4),
  u4 = at({}, rh, {
    deltaX: function (e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
    },
    deltaY: function (e) {
      return "deltaY" in e
        ? e.deltaY
        : "wheelDeltaY" in e
          ? -e.wheelDeltaY
          : "wheelDelta" in e
            ? -e.wheelDelta
            : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  d4 = Hn(u4),
  f4 = [9, 13, 27, 32],
  E0 = ko && "CompositionEvent" in window,
  Jl = null
ko && "documentMode" in document && (Jl = document.documentMode)
var p4 = ko && "TextEvent" in window && !Jl,
  $_ = ko && (!E0 || (Jl && 8 < Jl && 11 >= Jl)),
  Tx = String.fromCharCode(32),
  Mx = !1
function B_(e, t) {
  switch (e) {
    case "keyup":
      return f4.indexOf(t.keyCode) !== -1
    case "keydown":
      return t.keyCode !== 229
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0
    default:
      return !1
  }
}
function j_(e) {
  return (e = e.detail), typeof e == "object" && "data" in e ? e.data : null
}
var ca = !1
function h4(e, t) {
  switch (e) {
    case "compositionend":
      return j_(t)
    case "keypress":
      return t.which !== 32 ? null : ((Mx = !0), Tx)
    case "textInput":
      return (e = t.data), e === Tx && Mx ? null : e
    default:
      return null
  }
}
function m4(e, t) {
  if (ca)
    return e === "compositionend" || (!E0 && B_(e, t))
      ? ((e = P_()), (Kd = b0 = Xo = null), (ca = !1), e)
      : null
  switch (e) {
    case "paste":
      return null
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char
        if (t.which) return String.fromCharCode(t.which)
      }
      return null
    case "compositionend":
      return $_ && t.locale !== "ko" ? null : t.data
    default:
      return null
  }
}
var g4 = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function Ox(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return t === "input" ? !!g4[e.type] : t === "textarea"
}
function F_(e, t, n, r) {
  v_(r),
    (t = bf(t, "onChange")),
    0 < t.length &&
      ((n = new x0("onChange", "change", null, n, r)),
      e.push({ event: n, listeners: t }))
}
var ec = null,
  Mc = null
function v4(e) {
  X_(e, 0)
}
function oh(e) {
  var t = fa(e)
  if (u_(t)) return e
}
function y4(e, t) {
  if (e === "change") return t
}
var z_ = !1
if (ko) {
  var Im
  if (ko) {
    var Dm = "oninput" in document
    if (!Dm) {
      var Ax = document.createElement("div")
      Ax.setAttribute("oninput", "return;"),
        (Dm = typeof Ax.oninput == "function")
    }
    Im = Dm
  } else Im = !1
  z_ = Im && (!document.documentMode || 9 < document.documentMode)
}
function Rx() {
  ec && (ec.detachEvent("onpropertychange", U_), (Mc = ec = null))
}
function U_(e) {
  if (e.propertyName === "value" && oh(Mc)) {
    var t = []
    F_(t, Mc, e, h0(e)), w_(v4, t)
  }
}
function b4(e, t, n) {
  e === "focusin"
    ? (Rx(), (ec = t), (Mc = n), ec.attachEvent("onpropertychange", U_))
    : e === "focusout" && Rx()
}
function x4(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return oh(Mc)
}
function w4(e, t) {
  if (e === "click") return oh(t)
}
function E4(e, t) {
  if (e === "input" || e === "change") return oh(t)
}
function C4(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var kr = typeof Object.is == "function" ? Object.is : C4
function Oc(e, t) {
  if (kr(e, t)) return !0
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1
  var n = Object.keys(e),
    r = Object.keys(t)
  if (n.length !== r.length) return !1
  for (r = 0; r < n.length; r++) {
    var o = n[r]
    if (!rv.call(t, o) || !kr(e[o], t[o])) return !1
  }
  return !0
}
function Ix(e) {
  for (; e && e.firstChild; ) e = e.firstChild
  return e
}
function Dx(e, t) {
  var n = Ix(e)
  e = 0
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = e + n.textContent.length), e <= t && r >= t))
        return { node: n, offset: t - e }
      e = r
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling
          break e
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = Ix(n)
  }
}
function V_(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
        ? !1
        : t && t.nodeType === 3
          ? V_(e, t.parentNode)
          : "contains" in e
            ? e.contains(t)
            : e.compareDocumentPosition
              ? !!(e.compareDocumentPosition(t) & 16)
              : !1
    : !1
}
function H_() {
  for (var e = window, t = ff(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string"
    } catch {
      n = !1
    }
    if (n) e = t.contentWindow
    else break
    t = ff(e.document)
  }
  return t
}
function C0(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return (
    t &&
    ((t === "input" &&
      (e.type === "text" ||
        e.type === "search" ||
        e.type === "tel" ||
        e.type === "url" ||
        e.type === "password")) ||
      t === "textarea" ||
      e.contentEditable === "true")
  )
}
function S4(e) {
  var t = H_(),
    n = e.focusedElem,
    r = e.selectionRange
  if (
    t !== n &&
    n &&
    n.ownerDocument &&
    V_(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && C0(n)) {
      if (
        ((t = r.start),
        (e = r.end),
        e === void 0 && (e = t),
        "selectionStart" in n)
      )
        (n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length))
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window),
        e.getSelection)
      ) {
        e = e.getSelection()
        var o = n.textContent.length,
          i = Math.min(r.start, o)
        ;(r = r.end === void 0 ? i : Math.min(r.end, o)),
          !e.extend && i > r && ((o = r), (r = i), (i = o)),
          (o = Dx(n, i))
        var s = Dx(n, r)
        o &&
          s &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== o.node ||
            e.anchorOffset !== o.offset ||
            e.focusNode !== s.node ||
            e.focusOffset !== s.offset) &&
          ((t = t.createRange()),
          t.setStart(o.node, o.offset),
          e.removeAllRanges(),
          i > r
            ? (e.addRange(t), e.extend(s.node, s.offset))
            : (t.setEnd(s.node, s.offset), e.addRange(t)))
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 &&
        t.push({ element: e, left: e.scrollLeft, top: e.scrollTop })
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)
      (e = t[n]), (e.element.scrollLeft = e.left), (e.element.scrollTop = e.top)
  }
}
var _4 = ko && "documentMode" in document && 11 >= document.documentMode,
  ua = null,
  Ev = null,
  tc = null,
  Cv = !1
function Lx(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument
  Cv ||
    ua == null ||
    ua !== ff(r) ||
    ((r = ua),
    "selectionStart" in r && C0(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (tc && Oc(tc, r)) ||
      ((tc = r),
      (r = bf(Ev, "onSelect")),
      0 < r.length &&
        ((t = new x0("onSelect", "select", null, t, n)),
        e.push({ event: t, listeners: r }),
        (t.target = ua))))
}
function ed(e, t) {
  var n = {}
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n["Webkit" + e] = "webkit" + t),
    (n["Moz" + e] = "moz" + t),
    n
  )
}
var da = {
    animationend: ed("Animation", "AnimationEnd"),
    animationiteration: ed("Animation", "AnimationIteration"),
    animationstart: ed("Animation", "AnimationStart"),
    transitionend: ed("Transition", "TransitionEnd"),
  },
  Lm = {},
  W_ = {}
ko &&
  ((W_ = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete da.animationend.animation,
    delete da.animationiteration.animation,
    delete da.animationstart.animation),
  "TransitionEvent" in window || delete da.transitionend.transition)
function ih(e) {
  if (Lm[e]) return Lm[e]
  if (!da[e]) return e
  var t = da[e],
    n
  for (n in t) if (t.hasOwnProperty(n) && n in W_) return (Lm[e] = t[n])
  return e
}
var K_ = ih("animationend"),
  G_ = ih("animationiteration"),
  q_ = ih("animationstart"),
  Z_ = ih("transitionend"),
  Y_ = new Map(),
  Px =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    )
function Oi(e, t) {
  Y_.set(e, t), Os(t, [e])
}
for (var Pm = 0; Pm < Px.length; Pm++) {
  var $m = Px[Pm],
    k4 = $m.toLowerCase(),
    N4 = $m[0].toUpperCase() + $m.slice(1)
  Oi(k4, "on" + N4)
}
Oi(K_, "onAnimationEnd")
Oi(G_, "onAnimationIteration")
Oi(q_, "onAnimationStart")
Oi("dblclick", "onDoubleClick")
Oi("focusin", "onFocus")
Oi("focusout", "onBlur")
Oi(Z_, "onTransitionEnd")
La("onMouseEnter", ["mouseout", "mouseover"])
La("onMouseLeave", ["mouseout", "mouseover"])
La("onPointerEnter", ["pointerout", "pointerover"])
La("onPointerLeave", ["pointerout", "pointerover"])
Os(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
)
Os(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
)
Os("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"])
Os(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
)
Os(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
)
Os(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
)
var Ul =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  T4 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ul))
function $x(e, t, n) {
  var r = e.type || "unknown-event"
  ;(e.currentTarget = n), k5(r, t, void 0, e), (e.currentTarget = null)
}
function X_(e, t) {
  t = (t & 4) !== 0
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      o = r.event
    r = r.listeners
    e: {
      var i = void 0
      if (t)
        for (var s = r.length - 1; 0 <= s; s--) {
          var a = r[s],
            l = a.instance,
            c = a.currentTarget
          if (((a = a.listener), l !== i && o.isPropagationStopped())) break e
          $x(o, a, c), (i = l)
        }
      else
        for (s = 0; s < r.length; s++) {
          if (
            ((a = r[s]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== i && o.isPropagationStopped())
          )
            break e
          $x(o, a, c), (i = l)
        }
    }
  }
  if (hf) throw ((e = yv), (hf = !1), (yv = null), e)
}
function Xe(e, t) {
  var n = t[Tv]
  n === void 0 && (n = t[Tv] = new Set())
  var r = e + "__bubble"
  n.has(r) || (Q_(t, e, 2, !1), n.add(r))
}
function Bm(e, t, n) {
  var r = 0
  t && (r |= 4), Q_(n, e, r, t)
}
var td = "_reactListening" + Math.random().toString(36).slice(2)
function Ac(e) {
  if (!e[td]) {
    ;(e[td] = !0),
      i_.forEach(function (n) {
        n !== "selectionchange" && (T4.has(n) || Bm(n, !1, e), Bm(n, !0, e))
      })
    var t = e.nodeType === 9 ? e : e.ownerDocument
    t === null || t[td] || ((t[td] = !0), Bm("selectionchange", !1, t))
  }
}
function Q_(e, t, n, r) {
  switch (L_(t)) {
    case 1:
      var o = U5
      break
    case 4:
      o = V5
      break
    default:
      o = y0
  }
  ;(n = o.bind(null, t, n, e)),
    (o = void 0),
    !vv ||
      (t !== "touchstart" && t !== "touchmove" && t !== "wheel") ||
      (o = !0),
    r
      ? o !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: o })
        : e.addEventListener(t, n, !0)
      : o !== void 0
        ? e.addEventListener(t, n, { passive: o })
        : e.addEventListener(t, n, !1)
}
function jm(e, t, n, r, o) {
  var i = r
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (;;) {
      if (r === null) return
      var s = r.tag
      if (s === 3 || s === 4) {
        var a = r.stateNode.containerInfo
        if (a === o || (a.nodeType === 8 && a.parentNode === o)) break
        if (s === 4)
          for (s = r.return; s !== null; ) {
            var l = s.tag
            if (
              (l === 3 || l === 4) &&
              ((l = s.stateNode.containerInfo),
              l === o || (l.nodeType === 8 && l.parentNode === o))
            )
              return
            s = s.return
          }
        for (; a !== null; ) {
          if (((s = Ki(a)), s === null)) return
          if (((l = s.tag), l === 5 || l === 6)) {
            r = i = s
            continue e
          }
          a = a.parentNode
        }
      }
      r = r.return
    }
  w_(function () {
    var c = i,
      u = h0(n),
      d = []
    e: {
      var f = Y_.get(e)
      if (f !== void 0) {
        var p = x0,
          g = e
        switch (e) {
          case "keypress":
            if (Gd(n) === 0) break e
          case "keydown":
          case "keyup":
            p = o4
            break
          case "focusin":
            ;(g = "focus"), (p = Rm)
            break
          case "focusout":
            ;(g = "blur"), (p = Rm)
            break
          case "beforeblur":
          case "afterblur":
            p = Rm
            break
          case "click":
            if (n.button === 2) break e
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = _x
            break
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = K5
            break
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = a4
            break
          case K_:
          case G_:
          case q_:
            p = Z5
            break
          case Z_:
            p = c4
            break
          case "scroll":
            p = H5
            break
          case "wheel":
            p = d4
            break
          case "copy":
          case "cut":
          case "paste":
            p = X5
            break
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = Nx
        }
        var v = (t & 4) !== 0,
          b = !v && e === "scroll",
          y = v ? (f !== null ? f + "Capture" : null) : f
        v = []
        for (var x = c, E; x !== null; ) {
          E = x
          var w = E.stateNode
          if (
            (E.tag === 5 &&
              w !== null &&
              ((E = w),
              y !== null && ((w = _c(x, y)), w != null && v.push(Rc(x, w, E)))),
            b)
          )
            break
          x = x.return
        }
        0 < v.length &&
          ((f = new p(f, g, null, n, u)), d.push({ event: f, listeners: v }))
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((f = e === "mouseover" || e === "pointerover"),
          (p = e === "mouseout" || e === "pointerout"),
          f &&
            n !== mv &&
            (g = n.relatedTarget || n.fromElement) &&
            (Ki(g) || g[No]))
        )
          break e
        if (
          (p || f) &&
          ((f =
            u.window === u
              ? u
              : (f = u.ownerDocument)
                ? f.defaultView || f.parentWindow
                : window),
          p
            ? ((g = n.relatedTarget || n.toElement),
              (p = c),
              (g = g ? Ki(g) : null),
              g !== null &&
                ((b = As(g)), g !== b || (g.tag !== 5 && g.tag !== 6)) &&
                (g = null))
            : ((p = null), (g = c)),
          p !== g)
        ) {
          if (
            ((v = _x),
            (w = "onMouseLeave"),
            (y = "onMouseEnter"),
            (x = "mouse"),
            (e === "pointerout" || e === "pointerover") &&
              ((v = Nx),
              (w = "onPointerLeave"),
              (y = "onPointerEnter"),
              (x = "pointer")),
            (b = p == null ? f : fa(p)),
            (E = g == null ? f : fa(g)),
            (f = new v(w, x + "leave", p, n, u)),
            (f.target = b),
            (f.relatedTarget = E),
            (w = null),
            Ki(u) === c &&
              ((v = new v(y, x + "enter", g, n, u)),
              (v.target = E),
              (v.relatedTarget = b),
              (w = v)),
            (b = w),
            p && g)
          )
            t: {
              for (v = p, y = g, x = 0, E = v; E; E = Vs(E)) x++
              for (E = 0, w = y; w; w = Vs(w)) E++
              for (; 0 < x - E; ) (v = Vs(v)), x--
              for (; 0 < E - x; ) (y = Vs(y)), E--
              for (; x--; ) {
                if (v === y || (y !== null && v === y.alternate)) break t
                ;(v = Vs(v)), (y = Vs(y))
              }
              v = null
            }
          else v = null
          p !== null && Bx(d, f, p, v, !1),
            g !== null && b !== null && Bx(d, b, g, v, !0)
        }
      }
      e: {
        if (
          ((f = c ? fa(c) : window),
          (p = f.nodeName && f.nodeName.toLowerCase()),
          p === "select" || (p === "input" && f.type === "file"))
        )
          var C = y4
        else if (Ox(f))
          if (z_) C = E4
          else {
            C = x4
            var S = b4
          }
        else
          (p = f.nodeName) &&
            p.toLowerCase() === "input" &&
            (f.type === "checkbox" || f.type === "radio") &&
            (C = w4)
        if (C && (C = C(e, c))) {
          F_(d, C, n, u)
          break e
        }
        S && S(e, f, c),
          e === "focusout" &&
            (S = f._wrapperState) &&
            S.controlled &&
            f.type === "number" &&
            uv(f, "number", f.value)
      }
      switch (((S = c ? fa(c) : window), e)) {
        case "focusin":
          ;(Ox(S) || S.contentEditable === "true") &&
            ((ua = S), (Ev = c), (tc = null))
          break
        case "focusout":
          tc = Ev = ua = null
          break
        case "mousedown":
          Cv = !0
          break
        case "contextmenu":
        case "mouseup":
        case "dragend":
          ;(Cv = !1), Lx(d, n, u)
          break
        case "selectionchange":
          if (_4) break
        case "keydown":
        case "keyup":
          Lx(d, n, u)
      }
      var M
      if (E0)
        e: {
          switch (e) {
            case "compositionstart":
              var N = "onCompositionStart"
              break e
            case "compositionend":
              N = "onCompositionEnd"
              break e
            case "compositionupdate":
              N = "onCompositionUpdate"
              break e
          }
          N = void 0
        }
      else
        ca
          ? B_(e, n) && (N = "onCompositionEnd")
          : e === "keydown" && n.keyCode === 229 && (N = "onCompositionStart")
      N &&
        ($_ &&
          n.locale !== "ko" &&
          (ca || N !== "onCompositionStart"
            ? N === "onCompositionEnd" && ca && (M = P_())
            : ((Xo = u),
              (b0 = "value" in Xo ? Xo.value : Xo.textContent),
              (ca = !0))),
        (S = bf(c, N)),
        0 < S.length &&
          ((N = new kx(N, e, null, n, u)),
          d.push({ event: N, listeners: S }),
          M ? (N.data = M) : ((M = j_(n)), M !== null && (N.data = M)))),
        (M = p4 ? h4(e, n) : m4(e, n)) &&
          ((c = bf(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new kx("onBeforeInput", "beforeinput", null, n, u)),
            d.push({ event: u, listeners: c }),
            (u.data = M)))
    }
    X_(d, t)
  })
}
function Rc(e, t, n) {
  return { instance: e, listener: t, currentTarget: n }
}
function bf(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
    var o = e,
      i = o.stateNode
    o.tag === 5 &&
      i !== null &&
      ((o = i),
      (i = _c(e, n)),
      i != null && r.unshift(Rc(e, i, o)),
      (i = _c(e, t)),
      i != null && r.push(Rc(e, i, o))),
      (e = e.return)
  }
  return r
}
function Vs(e) {
  if (e === null) return null
  do e = e.return
  while (e && e.tag !== 5)
  return e || null
}
function Bx(e, t, n, r, o) {
  for (var i = t._reactName, s = []; n !== null && n !== r; ) {
    var a = n,
      l = a.alternate,
      c = a.stateNode
    if (l !== null && l === r) break
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      o
        ? ((l = _c(n, i)), l != null && s.unshift(Rc(n, l, a)))
        : o || ((l = _c(n, i)), l != null && s.push(Rc(n, l, a)))),
      (n = n.return)
  }
  s.length !== 0 && e.push({ event: t, listeners: s })
}
var M4 = /\r\n?/g,
  O4 = /\u0000|\uFFFD/g
function jx(e) {
  return (typeof e == "string" ? e : "" + e)
    .replace(
      M4,
      `
`
    )
    .replace(O4, "")
}
function nd(e, t, n) {
  if (((t = jx(t)), jx(e) !== t && n)) throw Error(J(425))
}
function xf() {}
var Sv = null,
  _v = null
function kv(e, t) {
  return (
    e === "textarea" ||
    e === "noscript" ||
    typeof t.children == "string" ||
    typeof t.children == "number" ||
    (typeof t.dangerouslySetInnerHTML == "object" &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  )
}
var Nv = typeof setTimeout == "function" ? setTimeout : void 0,
  A4 = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Fx = typeof Promise == "function" ? Promise : void 0,
  R4 =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Fx < "u"
        ? function (e) {
            return Fx.resolve(null).then(e).catch(I4)
          }
        : Nv
function I4(e) {
  setTimeout(function () {
    throw e
  })
}
function Fm(e, t) {
  var n = t,
    r = 0
  do {
    var o = n.nextSibling
    if ((e.removeChild(n), o && o.nodeType === 8))
      if (((n = o.data), n === "/$")) {
        if (r === 0) {
          e.removeChild(o), Tc(t)
          return
        }
        r--
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++
    n = o
  } while (n)
  Tc(t)
}
function ai(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType
    if (t === 1 || t === 3) break
    if (t === 8) {
      if (((t = e.data), t === "$" || t === "$!" || t === "$?")) break
      if (t === "/$") return null
    }
  }
  return e
}
function zx(e) {
  e = e.previousSibling
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e
        t--
      } else n === "/$" && t++
    }
    e = e.previousSibling
  }
  return null
}
var fl = Math.random().toString(36).slice(2),
  Ur = "__reactFiber$" + fl,
  Ic = "__reactProps$" + fl,
  No = "__reactContainer$" + fl,
  Tv = "__reactEvents$" + fl,
  D4 = "__reactListeners$" + fl,
  L4 = "__reactHandles$" + fl
function Ki(e) {
  var t = e[Ur]
  if (t) return t
  for (var n = e.parentNode; n; ) {
    if ((t = n[No] || n[Ur])) {
      if (
        ((n = t.alternate),
        t.child !== null || (n !== null && n.child !== null))
      )
        for (e = zx(e); e !== null; ) {
          if ((n = e[Ur])) return n
          e = zx(e)
        }
      return t
    }
    ;(e = n), (n = e.parentNode)
  }
  return null
}
function Cu(e) {
  return (
    (e = e[Ur] || e[No]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  )
}
function fa(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode
  throw Error(J(33))
}
function sh(e) {
  return e[Ic] || null
}
var Mv = [],
  pa = -1
function Ai(e) {
  return { current: e }
}
function Je(e) {
  0 > pa || ((e.current = Mv[pa]), (Mv[pa] = null), pa--)
}
function Ge(e, t) {
  pa++, (Mv[pa] = e.current), (e.current = t)
}
var wi = {},
  nn = Ai(wi),
  _n = Ai(!1),
  ps = wi
function Pa(e, t) {
  var n = e.type.contextTypes
  if (!n) return wi
  var r = e.stateNode
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
    return r.__reactInternalMemoizedMaskedChildContext
  var o = {},
    i
  for (i in n) o[i] = t[i]
  return (
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = o)),
    o
  )
}
function kn(e) {
  return (e = e.childContextTypes), e != null
}
function wf() {
  Je(_n), Je(nn)
}
function Ux(e, t, n) {
  if (nn.current !== wi) throw Error(J(168))
  Ge(nn, t), Ge(_n, n)
}
function J_(e, t, n) {
  var r = e.stateNode
  if (((t = t.childContextTypes), typeof r.getChildContext != "function"))
    return n
  r = r.getChildContext()
  for (var o in r) if (!(o in t)) throw Error(J(108, b5(e) || "Unknown", o))
  return at({}, n, r)
}
function Ef(e) {
  return (
    (e =
      ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || wi),
    (ps = nn.current),
    Ge(nn, e),
    Ge(_n, _n.current),
    !0
  )
}
function Vx(e, t, n) {
  var r = e.stateNode
  if (!r) throw Error(J(169))
  n
    ? ((e = J_(e, t, ps)),
      (r.__reactInternalMemoizedMergedChildContext = e),
      Je(_n),
      Je(nn),
      Ge(nn, e))
    : Je(_n),
    Ge(_n, n)
}
var mo = null,
  ah = !1,
  zm = !1
function ek(e) {
  mo === null ? (mo = [e]) : mo.push(e)
}
function P4(e) {
  ;(ah = !0), ek(e)
}
function Ri() {
  if (!zm && mo !== null) {
    zm = !0
    var e = 0,
      t = Ve
    try {
      var n = mo
      for (Ve = 1; e < n.length; e++) {
        var r = n[e]
        do r = r(!0)
        while (r !== null)
      }
      ;(mo = null), (ah = !1)
    } catch (o) {
      throw (mo !== null && (mo = mo.slice(e + 1)), __(m0, Ri), o)
    } finally {
      ;(Ve = t), (zm = !1)
    }
  }
  return null
}
var ha = [],
  ma = 0,
  Cf = null,
  Sf = 0,
  Jn = [],
  er = 0,
  hs = null,
  vo = 1,
  yo = ""
function zi(e, t) {
  ;(ha[ma++] = Sf), (ha[ma++] = Cf), (Cf = e), (Sf = t)
}
function tk(e, t, n) {
  ;(Jn[er++] = vo), (Jn[er++] = yo), (Jn[er++] = hs), (hs = e)
  var r = vo
  e = yo
  var o = 32 - Cr(r) - 1
  ;(r &= ~(1 << o)), (n += 1)
  var i = 32 - Cr(t) + o
  if (30 < i) {
    var s = o - (o % 5)
    ;(i = (r & ((1 << s) - 1)).toString(32)),
      (r >>= s),
      (o -= s),
      (vo = (1 << (32 - Cr(t) + o)) | (n << o) | r),
      (yo = i + e)
  } else (vo = (1 << i) | (n << o) | r), (yo = e)
}
function S0(e) {
  e.return !== null && (zi(e, 1), tk(e, 1, 0))
}
function _0(e) {
  for (; e === Cf; )
    (Cf = ha[--ma]), (ha[ma] = null), (Sf = ha[--ma]), (ha[ma] = null)
  for (; e === hs; )
    (hs = Jn[--er]),
      (Jn[er] = null),
      (yo = Jn[--er]),
      (Jn[er] = null),
      (vo = Jn[--er]),
      (Jn[er] = null)
}
var Bn = null,
  $n = null,
  nt = !1,
  gr = null
function nk(e, t) {
  var n = nr(5, null, null, 0)
  ;(n.elementType = "DELETED"),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)
}
function Hx(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type
      return (
        (t =
          t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase()
            ? null
            : t),
        t !== null
          ? ((e.stateNode = t), (Bn = e), ($n = ai(t.firstChild)), !0)
          : !1
      )
    case 6:
      return (
        (t = e.pendingProps === "" || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Bn = e), ($n = null), !0) : !1
      )
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = hs !== null ? { id: vo, overflow: yo } : null),
            (e.memoizedState = {
              dehydrated: t,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = nr(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (Bn = e),
            ($n = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function Ov(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function Av(e) {
  if (nt) {
    var t = $n
    if (t) {
      var n = t
      if (!Hx(e, t)) {
        if (Ov(e)) throw Error(J(418))
        t = ai(n.nextSibling)
        var r = Bn
        t && Hx(e, t)
          ? nk(r, n)
          : ((e.flags = (e.flags & -4097) | 2), (nt = !1), (Bn = e))
      }
    } else {
      if (Ov(e)) throw Error(J(418))
      ;(e.flags = (e.flags & -4097) | 2), (nt = !1), (Bn = e)
    }
  }
}
function Wx(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
    e = e.return
  Bn = e
}
function rd(e) {
  if (e !== Bn) return !1
  if (!nt) return Wx(e), (nt = !0), !1
  var t
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type),
      (t = t !== "head" && t !== "body" && !kv(e.type, e.memoizedProps))),
    t && (t = $n))
  ) {
    if (Ov(e)) throw (rk(), Error(J(418)))
    for (; t; ) nk(e, t), (t = ai(t.nextSibling))
  }
  if ((Wx(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e))
      throw Error(J(317))
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data
          if (n === "/$") {
            if (t === 0) {
              $n = ai(e.nextSibling)
              break e
            }
            t--
          } else (n !== "$" && n !== "$!" && n !== "$?") || t++
        }
        e = e.nextSibling
      }
      $n = null
    }
  } else $n = Bn ? ai(e.stateNode.nextSibling) : null
  return !0
}
function rk() {
  for (var e = $n; e; ) e = ai(e.nextSibling)
}
function $a() {
  ;($n = Bn = null), (nt = !1)
}
function k0(e) {
  gr === null ? (gr = [e]) : gr.push(e)
}
var $4 = Do.ReactCurrentBatchConfig
function Tl(e, t, n) {
  if (
    ((e = n.ref), e !== null && typeof e != "function" && typeof e != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(J(309))
        var r = n.stateNode
      }
      if (!r) throw Error(J(147, e))
      var o = r,
        i = "" + e
      return t !== null &&
        t.ref !== null &&
        typeof t.ref == "function" &&
        t.ref._stringRef === i
        ? t.ref
        : ((t = function (s) {
            var a = o.refs
            s === null ? delete a[i] : (a[i] = s)
          }),
          (t._stringRef = i),
          t)
    }
    if (typeof e != "string") throw Error(J(284))
    if (!n._owner) throw Error(J(290, e))
  }
  return e
}
function od(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      J(
        31,
        e === "[object Object]"
          ? "object with keys {" + Object.keys(t).join(", ") + "}"
          : e
      )
    ))
  )
}
function Kx(e) {
  var t = e._init
  return t(e._payload)
}
function ok(e) {
  function t(y, x) {
    if (e) {
      var E = y.deletions
      E === null ? ((y.deletions = [x]), (y.flags |= 16)) : E.push(x)
    }
  }
  function n(y, x) {
    if (!e) return null
    for (; x !== null; ) t(y, x), (x = x.sibling)
    return null
  }
  function r(y, x) {
    for (y = new Map(); x !== null; )
      x.key !== null ? y.set(x.key, x) : y.set(x.index, x), (x = x.sibling)
    return y
  }
  function o(y, x) {
    return (y = di(y, x)), (y.index = 0), (y.sibling = null), y
  }
  function i(y, x, E) {
    return (
      (y.index = E),
      e
        ? ((E = y.alternate),
          E !== null
            ? ((E = E.index), E < x ? ((y.flags |= 2), x) : E)
            : ((y.flags |= 2), x))
        : ((y.flags |= 1048576), x)
    )
  }
  function s(y) {
    return e && y.alternate === null && (y.flags |= 2), y
  }
  function a(y, x, E, w) {
    return x === null || x.tag !== 6
      ? ((x = qm(E, y.mode, w)), (x.return = y), x)
      : ((x = o(x, E)), (x.return = y), x)
  }
  function l(y, x, E, w) {
    var C = E.type
    return C === la
      ? u(y, x, E.props.children, w, E.key)
      : x !== null &&
          (x.elementType === C ||
            (typeof C == "object" &&
              C !== null &&
              C.$$typeof === zo &&
              Kx(C) === x.type))
        ? ((w = o(x, E.props)), (w.ref = Tl(y, x, E)), (w.return = y), w)
        : ((w = ef(E.type, E.key, E.props, null, y.mode, w)),
          (w.ref = Tl(y, x, E)),
          (w.return = y),
          w)
  }
  function c(y, x, E, w) {
    return x === null ||
      x.tag !== 4 ||
      x.stateNode.containerInfo !== E.containerInfo ||
      x.stateNode.implementation !== E.implementation
      ? ((x = Zm(E, y.mode, w)), (x.return = y), x)
      : ((x = o(x, E.children || [])), (x.return = y), x)
  }
  function u(y, x, E, w, C) {
    return x === null || x.tag !== 7
      ? ((x = ts(E, y.mode, w, C)), (x.return = y), x)
      : ((x = o(x, E)), (x.return = y), x)
  }
  function d(y, x, E) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return (x = qm("" + x, y.mode, E)), (x.return = y), x
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case Gu:
          return (
            (E = ef(x.type, x.key, x.props, null, y.mode, E)),
            (E.ref = Tl(y, null, x)),
            (E.return = y),
            E
          )
        case aa:
          return (x = Zm(x, y.mode, E)), (x.return = y), x
        case zo:
          var w = x._init
          return d(y, w(x._payload), E)
      }
      if (Fl(x) || Cl(x)) return (x = ts(x, y.mode, E, null)), (x.return = y), x
      od(y, x)
    }
    return null
  }
  function f(y, x, E, w) {
    var C = x !== null ? x.key : null
    if ((typeof E == "string" && E !== "") || typeof E == "number")
      return C !== null ? null : a(y, x, "" + E, w)
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case Gu:
          return E.key === C ? l(y, x, E, w) : null
        case aa:
          return E.key === C ? c(y, x, E, w) : null
        case zo:
          return (C = E._init), f(y, x, C(E._payload), w)
      }
      if (Fl(E) || Cl(E)) return C !== null ? null : u(y, x, E, w, null)
      od(y, E)
    }
    return null
  }
  function p(y, x, E, w, C) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (y = y.get(E) || null), a(x, y, "" + w, C)
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Gu:
          return (y = y.get(w.key === null ? E : w.key) || null), l(x, y, w, C)
        case aa:
          return (y = y.get(w.key === null ? E : w.key) || null), c(x, y, w, C)
        case zo:
          var S = w._init
          return p(y, x, E, S(w._payload), C)
      }
      if (Fl(w) || Cl(w)) return (y = y.get(E) || null), u(x, y, w, C, null)
      od(x, w)
    }
    return null
  }
  function g(y, x, E, w) {
    for (
      var C = null, S = null, M = x, N = (x = 0), R = null;
      M !== null && N < E.length;
      N++
    ) {
      M.index > N ? ((R = M), (M = null)) : (R = M.sibling)
      var B = f(y, M, E[N], w)
      if (B === null) {
        M === null && (M = R)
        break
      }
      e && M && B.alternate === null && t(y, M),
        (x = i(B, x, N)),
        S === null ? (C = B) : (S.sibling = B),
        (S = B),
        (M = R)
    }
    if (N === E.length) return n(y, M), nt && zi(y, N), C
    if (M === null) {
      for (; N < E.length; N++)
        (M = d(y, E[N], w)),
          M !== null &&
            ((x = i(M, x, N)), S === null ? (C = M) : (S.sibling = M), (S = M))
      return nt && zi(y, N), C
    }
    for (M = r(y, M); N < E.length; N++)
      (R = p(M, y, N, E[N], w)),
        R !== null &&
          (e && R.alternate !== null && M.delete(R.key === null ? N : R.key),
          (x = i(R, x, N)),
          S === null ? (C = R) : (S.sibling = R),
          (S = R))
    return (
      e &&
        M.forEach(function (V) {
          return t(y, V)
        }),
      nt && zi(y, N),
      C
    )
  }
  function v(y, x, E, w) {
    var C = Cl(E)
    if (typeof C != "function") throw Error(J(150))
    if (((E = C.call(E)), E == null)) throw Error(J(151))
    for (
      var S = (C = null), M = x, N = (x = 0), R = null, B = E.next();
      M !== null && !B.done;
      N++, B = E.next()
    ) {
      M.index > N ? ((R = M), (M = null)) : (R = M.sibling)
      var V = f(y, M, B.value, w)
      if (V === null) {
        M === null && (M = R)
        break
      }
      e && M && V.alternate === null && t(y, M),
        (x = i(V, x, N)),
        S === null ? (C = V) : (S.sibling = V),
        (S = V),
        (M = R)
    }
    if (B.done) return n(y, M), nt && zi(y, N), C
    if (M === null) {
      for (; !B.done; N++, B = E.next())
        (B = d(y, B.value, w)),
          B !== null &&
            ((x = i(B, x, N)), S === null ? (C = B) : (S.sibling = B), (S = B))
      return nt && zi(y, N), C
    }
    for (M = r(y, M); !B.done; N++, B = E.next())
      (B = p(M, y, N, B.value, w)),
        B !== null &&
          (e && B.alternate !== null && M.delete(B.key === null ? N : B.key),
          (x = i(B, x, N)),
          S === null ? (C = B) : (S.sibling = B),
          (S = B))
    return (
      e &&
        M.forEach(function (j) {
          return t(y, j)
        }),
      nt && zi(y, N),
      C
    )
  }
  function b(y, x, E, w) {
    if (
      (typeof E == "object" &&
        E !== null &&
        E.type === la &&
        E.key === null &&
        (E = E.props.children),
      typeof E == "object" && E !== null)
    ) {
      switch (E.$$typeof) {
        case Gu:
          e: {
            for (var C = E.key, S = x; S !== null; ) {
              if (S.key === C) {
                if (((C = E.type), C === la)) {
                  if (S.tag === 7) {
                    n(y, S.sibling),
                      (x = o(S, E.props.children)),
                      (x.return = y),
                      (y = x)
                    break e
                  }
                } else if (
                  S.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === zo &&
                    Kx(C) === S.type)
                ) {
                  n(y, S.sibling),
                    (x = o(S, E.props)),
                    (x.ref = Tl(y, S, E)),
                    (x.return = y),
                    (y = x)
                  break e
                }
                n(y, S)
                break
              } else t(y, S)
              S = S.sibling
            }
            E.type === la
              ? ((x = ts(E.props.children, y.mode, w, E.key)),
                (x.return = y),
                (y = x))
              : ((w = ef(E.type, E.key, E.props, null, y.mode, w)),
                (w.ref = Tl(y, x, E)),
                (w.return = y),
                (y = w))
          }
          return s(y)
        case aa:
          e: {
            for (S = E.key; x !== null; ) {
              if (x.key === S)
                if (
                  x.tag === 4 &&
                  x.stateNode.containerInfo === E.containerInfo &&
                  x.stateNode.implementation === E.implementation
                ) {
                  n(y, x.sibling),
                    (x = o(x, E.children || [])),
                    (x.return = y),
                    (y = x)
                  break e
                } else {
                  n(y, x)
                  break
                }
              else t(y, x)
              x = x.sibling
            }
            ;(x = Zm(E, y.mode, w)), (x.return = y), (y = x)
          }
          return s(y)
        case zo:
          return (S = E._init), b(y, x, S(E._payload), w)
      }
      if (Fl(E)) return g(y, x, E, w)
      if (Cl(E)) return v(y, x, E, w)
      od(y, E)
    }
    return (typeof E == "string" && E !== "") || typeof E == "number"
      ? ((E = "" + E),
        x !== null && x.tag === 6
          ? (n(y, x.sibling), (x = o(x, E)), (x.return = y), (y = x))
          : (n(y, x), (x = qm(E, y.mode, w)), (x.return = y), (y = x)),
        s(y))
      : n(y, x)
  }
  return b
}
var Ba = ok(!0),
  ik = ok(!1),
  _f = Ai(null),
  kf = null,
  ga = null,
  N0 = null
function T0() {
  N0 = ga = kf = null
}
function M0(e) {
  var t = _f.current
  Je(_f), (e._currentValue = t)
}
function Rv(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), r !== null && (r.childLanes |= t))
        : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
    )
      break
    e = e.return
  }
}
function ka(e, t) {
  ;(kf = e),
    (N0 = ga = null),
    (e = e.dependencies),
    e !== null &&
      e.firstContext !== null &&
      (e.lanes & t && (Sn = !0), (e.firstContext = null))
}
function lr(e) {
  var t = e._currentValue
  if (N0 !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), ga === null)) {
      if (kf === null) throw Error(J(308))
      ;(ga = e), (kf.dependencies = { lanes: 0, firstContext: e })
    } else ga = ga.next = e
  return t
}
var Gi = null
function O0(e) {
  Gi === null ? (Gi = [e]) : Gi.push(e)
}
function sk(e, t, n, r) {
  var o = t.interleaved
  return (
    o === null ? ((n.next = n), O0(t)) : ((n.next = o.next), (o.next = n)),
    (t.interleaved = n),
    To(e, r)
  )
}
function To(e, t) {
  e.lanes |= t
  var n = e.alternate
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return)
  return n.tag === 3 ? n.stateNode : null
}
var Uo = !1
function A0(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  }
}
function ak(e, t) {
  ;(e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects,
      })
}
function Eo(e, t) {
  return {
    eventTime: e,
    lane: t,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  }
}
function li(e, t, n) {
  var r = e.updateQueue
  if (r === null) return null
  if (((r = r.shared), Be & 2)) {
    var o = r.pending
    return (
      o === null ? (t.next = t) : ((t.next = o.next), (o.next = t)),
      (r.pending = t),
      To(e, n)
    )
  }
  return (
    (o = r.interleaved),
    o === null ? ((t.next = t), O0(r)) : ((t.next = o.next), (o.next = t)),
    (r.interleaved = t),
    To(e, n)
  )
}
function qd(e, t, n) {
  if (
    ((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))
  ) {
    var r = t.lanes
    ;(r &= e.pendingLanes), (n |= r), (t.lanes = n), g0(e, n)
  }
}
function Gx(e, t) {
  var n = e.updateQueue,
    r = e.alternate
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var o = null,
      i = null
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var s = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        }
        i === null ? (o = i = s) : (i = i.next = s), (n = n.next)
      } while (n !== null)
      i === null ? (o = i = t) : (i = i.next = t)
    } else o = i = t
    ;(n = {
      baseState: r.baseState,
      firstBaseUpdate: o,
      lastBaseUpdate: i,
      shared: r.shared,
      effects: r.effects,
    }),
      (e.updateQueue = n)
    return
  }
  ;(e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t)
}
function Nf(e, t, n, r) {
  var o = e.updateQueue
  Uo = !1
  var i = o.firstBaseUpdate,
    s = o.lastBaseUpdate,
    a = o.shared.pending
  if (a !== null) {
    o.shared.pending = null
    var l = a,
      c = l.next
    ;(l.next = null), s === null ? (i = c) : (s.next = c), (s = l)
    var u = e.alternate
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== s &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)))
  }
  if (i !== null) {
    var d = o.baseState
    ;(s = 0), (u = c = l = null), (a = i)
    do {
      var f = a.lane,
        p = a.eventTime
      if ((r & f) === f) {
        u !== null &&
          (u = u.next =
            {
              eventTime: p,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            })
        e: {
          var g = e,
            v = a
          switch (((f = t), (p = n), v.tag)) {
            case 1:
              if (((g = v.payload), typeof g == "function")) {
                d = g.call(p, d, f)
                break e
              }
              d = g
              break e
            case 3:
              g.flags = (g.flags & -65537) | 128
            case 0:
              if (
                ((g = v.payload),
                (f = typeof g == "function" ? g.call(p, d, f) : g),
                f == null)
              )
                break e
              d = at({}, d, f)
              break e
            case 2:
              Uo = !0
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((e.flags |= 64),
          (f = o.effects),
          f === null ? (o.effects = [a]) : f.push(a))
      } else
        (p = {
          eventTime: p,
          lane: f,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = p), (l = d)) : (u = u.next = p),
          (s |= f)
      if (((a = a.next), a === null)) {
        if (((a = o.shared.pending), a === null)) break
        ;(f = a),
          (a = f.next),
          (f.next = null),
          (o.lastBaseUpdate = f),
          (o.shared.pending = null)
      }
    } while (1)
    if (
      (u === null && (l = d),
      (o.baseState = l),
      (o.firstBaseUpdate = c),
      (o.lastBaseUpdate = u),
      (t = o.shared.interleaved),
      t !== null)
    ) {
      o = t
      do (s |= o.lane), (o = o.next)
      while (o !== t)
    } else i === null && (o.shared.lanes = 0)
    ;(gs |= s), (e.lanes = s), (e.memoizedState = d)
  }
}
function qx(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        o = r.callback
      if (o !== null) {
        if (((r.callback = null), (r = n), typeof o != "function"))
          throw Error(J(191, o))
        o.call(r)
      }
    }
}
var Su = {},
  Kr = Ai(Su),
  Dc = Ai(Su),
  Lc = Ai(Su)
function qi(e) {
  if (e === Su) throw Error(J(174))
  return e
}
function R0(e, t) {
  switch ((Ge(Lc, t), Ge(Dc, e), Ge(Kr, Su), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : fv(null, "")
      break
    default:
      ;(e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = fv(t, e))
  }
  Je(Kr), Ge(Kr, t)
}
function ja() {
  Je(Kr), Je(Dc), Je(Lc)
}
function lk(e) {
  qi(Lc.current)
  var t = qi(Kr.current),
    n = fv(t, e.type)
  t !== n && (Ge(Dc, e), Ge(Kr, n))
}
function I0(e) {
  Dc.current === e && (Je(Kr), Je(Dc))
}
var it = Ai(0)
function Tf(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return t
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t
    } else if (t.child !== null) {
      ;(t.child.return = t), (t = t.child)
      continue
    }
    if (t === e) break
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null
      t = t.return
    }
    ;(t.sibling.return = t.return), (t = t.sibling)
  }
  return null
}
var Um = []
function D0() {
  for (var e = 0; e < Um.length; e++) Um[e]._workInProgressVersionPrimary = null
  Um.length = 0
}
var Zd = Do.ReactCurrentDispatcher,
  Vm = Do.ReactCurrentBatchConfig,
  ms = 0,
  st = null,
  Tt = null,
  It = null,
  Mf = !1,
  nc = !1,
  Pc = 0,
  B4 = 0
function Yt() {
  throw Error(J(321))
}
function L0(e, t) {
  if (t === null) return !1
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!kr(e[n], t[n])) return !1
  return !0
}
function P0(e, t, n, r, o, i) {
  if (
    ((ms = i),
    (st = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (Zd.current = e === null || e.memoizedState === null ? U4 : V4),
    (e = n(r, o)),
    nc)
  ) {
    i = 0
    do {
      if (((nc = !1), (Pc = 0), 25 <= i)) throw Error(J(301))
      ;(i += 1),
        (It = Tt = null),
        (t.updateQueue = null),
        (Zd.current = H4),
        (e = n(r, o))
    } while (nc)
  }
  if (
    ((Zd.current = Of),
    (t = Tt !== null && Tt.next !== null),
    (ms = 0),
    (It = Tt = st = null),
    (Mf = !1),
    t)
  )
    throw Error(J(300))
  return e
}
function $0() {
  var e = Pc !== 0
  return (Pc = 0), e
}
function $r() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  }
  return It === null ? (st.memoizedState = It = e) : (It = It.next = e), It
}
function cr() {
  if (Tt === null) {
    var e = st.alternate
    e = e !== null ? e.memoizedState : null
  } else e = Tt.next
  var t = It === null ? st.memoizedState : It.next
  if (t !== null) (It = t), (Tt = e)
  else {
    if (e === null) throw Error(J(310))
    ;(Tt = e),
      (e = {
        memoizedState: Tt.memoizedState,
        baseState: Tt.baseState,
        baseQueue: Tt.baseQueue,
        queue: Tt.queue,
        next: null,
      }),
      It === null ? (st.memoizedState = It = e) : (It = It.next = e)
  }
  return It
}
function $c(e, t) {
  return typeof t == "function" ? t(e) : t
}
function Hm(e) {
  var t = cr(),
    n = t.queue
  if (n === null) throw Error(J(311))
  n.lastRenderedReducer = e
  var r = Tt,
    o = r.baseQueue,
    i = n.pending
  if (i !== null) {
    if (o !== null) {
      var s = o.next
      ;(o.next = i.next), (i.next = s)
    }
    ;(r.baseQueue = o = i), (n.pending = null)
  }
  if (o !== null) {
    ;(i = o.next), (r = r.baseState)
    var a = (s = null),
      l = null,
      c = i
    do {
      var u = c.lane
      if ((ms & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : e(r, c.action))
      else {
        var d = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        }
        l === null ? ((a = l = d), (s = r)) : (l = l.next = d),
          (st.lanes |= u),
          (gs |= u)
      }
      c = c.next
    } while (c !== null && c !== i)
    l === null ? (s = r) : (l.next = a),
      kr(r, t.memoizedState) || (Sn = !0),
      (t.memoizedState = r),
      (t.baseState = s),
      (t.baseQueue = l),
      (n.lastRenderedState = r)
  }
  if (((e = n.interleaved), e !== null)) {
    o = e
    do (i = o.lane), (st.lanes |= i), (gs |= i), (o = o.next)
    while (o !== e)
  } else o === null && (n.lanes = 0)
  return [t.memoizedState, n.dispatch]
}
function Wm(e) {
  var t = cr(),
    n = t.queue
  if (n === null) throw Error(J(311))
  n.lastRenderedReducer = e
  var r = n.dispatch,
    o = n.pending,
    i = t.memoizedState
  if (o !== null) {
    n.pending = null
    var s = (o = o.next)
    do (i = e(i, s.action)), (s = s.next)
    while (s !== o)
    kr(i, t.memoizedState) || (Sn = !0),
      (t.memoizedState = i),
      t.baseQueue === null && (t.baseState = i),
      (n.lastRenderedState = i)
  }
  return [i, r]
}
function ck() {}
function uk(e, t) {
  var n = st,
    r = cr(),
    o = t(),
    i = !kr(r.memoizedState, o)
  if (
    (i && ((r.memoizedState = o), (Sn = !0)),
    (r = r.queue),
    B0(pk.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || i || (It !== null && It.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Bc(9, fk.bind(null, n, r, o, t), void 0, null),
      $t === null)
    )
      throw Error(J(349))
    ms & 30 || dk(n, t, o)
  }
  return o
}
function dk(e, t, n) {
  ;(e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = st.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (st.updateQueue = t),
        (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e))
}
function fk(e, t, n, r) {
  ;(t.value = n), (t.getSnapshot = r), hk(t) && mk(e)
}
function pk(e, t, n) {
  return n(function () {
    hk(t) && mk(e)
  })
}
function hk(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !kr(e, n)
  } catch {
    return !0
  }
}
function mk(e) {
  var t = To(e, 1)
  t !== null && Sr(t, e, 1, -1)
}
function Zx(e) {
  var t = $r()
  return (
    typeof e == "function" && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: $c,
      lastRenderedState: e,
    }),
    (t.queue = e),
    (e = e.dispatch = z4.bind(null, st, e)),
    [t.memoizedState, e]
  )
}
function Bc(e, t, n, r) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
    (t = st.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (st.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e))),
    e
  )
}
function gk() {
  return cr().memoizedState
}
function Yd(e, t, n, r) {
  var o = $r()
  ;(st.flags |= e),
    (o.memoizedState = Bc(1 | t, n, void 0, r === void 0 ? null : r))
}
function lh(e, t, n, r) {
  var o = cr()
  r = r === void 0 ? null : r
  var i = void 0
  if (Tt !== null) {
    var s = Tt.memoizedState
    if (((i = s.destroy), r !== null && L0(r, s.deps))) {
      o.memoizedState = Bc(t, n, i, r)
      return
    }
  }
  ;(st.flags |= e), (o.memoizedState = Bc(1 | t, n, i, r))
}
function Yx(e, t) {
  return Yd(8390656, 8, e, t)
}
function B0(e, t) {
  return lh(2048, 8, e, t)
}
function vk(e, t) {
  return lh(4, 2, e, t)
}
function yk(e, t) {
  return lh(4, 4, e, t)
}
function bk(e, t) {
  if (typeof t == "function")
    return (
      (e = e()),
      t(e),
      function () {
        t(null)
      }
    )
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null
      }
    )
}
function xk(e, t, n) {
  return (
    (n = n != null ? n.concat([e]) : null), lh(4, 4, bk.bind(null, t, e), n)
  )
}
function j0() {}
function wk(e, t) {
  var n = cr()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && L0(t, r[1])
    ? r[0]
    : ((n.memoizedState = [e, t]), e)
}
function Ek(e, t) {
  var n = cr()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && L0(t, r[1])
    ? r[0]
    : ((e = e()), (n.memoizedState = [e, t]), e)
}
function Ck(e, t, n) {
  return ms & 21
    ? (kr(n, t) || ((n = T_()), (st.lanes |= n), (gs |= n), (e.baseState = !0)),
      t)
    : (e.baseState && ((e.baseState = !1), (Sn = !0)), (e.memoizedState = n))
}
function j4(e, t) {
  var n = Ve
  ;(Ve = n !== 0 && 4 > n ? n : 4), e(!0)
  var r = Vm.transition
  Vm.transition = {}
  try {
    e(!1), t()
  } finally {
    ;(Ve = n), (Vm.transition = r)
  }
}
function Sk() {
  return cr().memoizedState
}
function F4(e, t, n) {
  var r = ui(e)
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    _k(e))
  )
    kk(t, n)
  else if (((n = sk(e, t, n, r)), n !== null)) {
    var o = hn()
    Sr(n, e, r, o), Nk(n, t, r)
  }
}
function z4(e, t, n) {
  var r = ui(e),
    o = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }
  if (_k(e)) kk(t, o)
  else {
    var i = e.alternate
    if (
      e.lanes === 0 &&
      (i === null || i.lanes === 0) &&
      ((i = t.lastRenderedReducer), i !== null)
    )
      try {
        var s = t.lastRenderedState,
          a = i(s, n)
        if (((o.hasEagerState = !0), (o.eagerState = a), kr(a, s))) {
          var l = t.interleaved
          l === null
            ? ((o.next = o), O0(t))
            : ((o.next = l.next), (l.next = o)),
            (t.interleaved = o)
          return
        }
      } catch {
      } finally {
      }
    ;(n = sk(e, t, o, r)),
      n !== null && ((o = hn()), Sr(n, e, r, o), Nk(n, t, r))
  }
}
function _k(e) {
  var t = e.alternate
  return e === st || (t !== null && t === st)
}
function kk(e, t) {
  nc = Mf = !0
  var n = e.pending
  n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)), (e.pending = t)
}
function Nk(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes
    ;(r &= e.pendingLanes), (n |= r), (t.lanes = n), g0(e, n)
  }
}
var Of = {
    readContext: lr,
    useCallback: Yt,
    useContext: Yt,
    useEffect: Yt,
    useImperativeHandle: Yt,
    useInsertionEffect: Yt,
    useLayoutEffect: Yt,
    useMemo: Yt,
    useReducer: Yt,
    useRef: Yt,
    useState: Yt,
    useDebugValue: Yt,
    useDeferredValue: Yt,
    useTransition: Yt,
    useMutableSource: Yt,
    useSyncExternalStore: Yt,
    useId: Yt,
    unstable_isNewReconciler: !1,
  },
  U4 = {
    readContext: lr,
    useCallback: function (e, t) {
      return ($r().memoizedState = [e, t === void 0 ? null : t]), e
    },
    useContext: lr,
    useEffect: Yx,
    useImperativeHandle: function (e, t, n) {
      return (
        (n = n != null ? n.concat([e]) : null),
        Yd(4194308, 4, bk.bind(null, t, e), n)
      )
    },
    useLayoutEffect: function (e, t) {
      return Yd(4194308, 4, e, t)
    },
    useInsertionEffect: function (e, t) {
      return Yd(4, 2, e, t)
    },
    useMemo: function (e, t) {
      var n = $r()
      return (
        (t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e
      )
    },
    useReducer: function (e, t, n) {
      var r = $r()
      return (
        (t = n !== void 0 ? n(t) : t),
        (r.memoizedState = r.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t,
        }),
        (r.queue = e),
        (e = e.dispatch = F4.bind(null, st, e)),
        [r.memoizedState, e]
      )
    },
    useRef: function (e) {
      var t = $r()
      return (e = { current: e }), (t.memoizedState = e)
    },
    useState: Zx,
    useDebugValue: j0,
    useDeferredValue: function (e) {
      return ($r().memoizedState = e)
    },
    useTransition: function () {
      var e = Zx(!1),
        t = e[0]
      return (e = j4.bind(null, e[1])), ($r().memoizedState = e), [t, e]
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = st,
        o = $r()
      if (nt) {
        if (n === void 0) throw Error(J(407))
        n = n()
      } else {
        if (((n = t()), $t === null)) throw Error(J(349))
        ms & 30 || dk(r, t, n)
      }
      o.memoizedState = n
      var i = { value: n, getSnapshot: t }
      return (
        (o.queue = i),
        Yx(pk.bind(null, r, i, e), [e]),
        (r.flags |= 2048),
        Bc(9, fk.bind(null, r, i, n, t), void 0, null),
        n
      )
    },
    useId: function () {
      var e = $r(),
        t = $t.identifierPrefix
      if (nt) {
        var n = yo,
          r = vo
        ;(n = (r & ~(1 << (32 - Cr(r) - 1))).toString(32) + n),
          (t = ":" + t + "R" + n),
          (n = Pc++),
          0 < n && (t += "H" + n.toString(32)),
          (t += ":")
      } else (n = B4++), (t = ":" + t + "r" + n.toString(32) + ":")
      return (e.memoizedState = t)
    },
    unstable_isNewReconciler: !1,
  },
  V4 = {
    readContext: lr,
    useCallback: wk,
    useContext: lr,
    useEffect: B0,
    useImperativeHandle: xk,
    useInsertionEffect: vk,
    useLayoutEffect: yk,
    useMemo: Ek,
    useReducer: Hm,
    useRef: gk,
    useState: function () {
      return Hm($c)
    },
    useDebugValue: j0,
    useDeferredValue: function (e) {
      var t = cr()
      return Ck(t, Tt.memoizedState, e)
    },
    useTransition: function () {
      var e = Hm($c)[0],
        t = cr().memoizedState
      return [e, t]
    },
    useMutableSource: ck,
    useSyncExternalStore: uk,
    useId: Sk,
    unstable_isNewReconciler: !1,
  },
  H4 = {
    readContext: lr,
    useCallback: wk,
    useContext: lr,
    useEffect: B0,
    useImperativeHandle: xk,
    useInsertionEffect: vk,
    useLayoutEffect: yk,
    useMemo: Ek,
    useReducer: Wm,
    useRef: gk,
    useState: function () {
      return Wm($c)
    },
    useDebugValue: j0,
    useDeferredValue: function (e) {
      var t = cr()
      return Tt === null ? (t.memoizedState = e) : Ck(t, Tt.memoizedState, e)
    },
    useTransition: function () {
      var e = Wm($c)[0],
        t = cr().memoizedState
      return [e, t]
    },
    useMutableSource: ck,
    useSyncExternalStore: uk,
    useId: Sk,
    unstable_isNewReconciler: !1,
  }
function hr(e, t) {
  if (e && e.defaultProps) {
    ;(t = at({}, t)), (e = e.defaultProps)
    for (var n in e) t[n] === void 0 && (t[n] = e[n])
    return t
  }
  return t
}
function Iv(e, t, n, r) {
  ;(t = e.memoizedState),
    (n = n(r, t)),
    (n = n == null ? t : at({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n)
}
var ch = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? As(e) === e : !1
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals
    var r = hn(),
      o = ui(e),
      i = Eo(r, o)
    ;(i.payload = t),
      n != null && (i.callback = n),
      (t = li(e, i, o)),
      t !== null && (Sr(t, e, o, r), qd(t, e, o))
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals
    var r = hn(),
      o = ui(e),
      i = Eo(r, o)
    ;(i.tag = 1),
      (i.payload = t),
      n != null && (i.callback = n),
      (t = li(e, i, o)),
      t !== null && (Sr(t, e, o, r), qd(t, e, o))
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals
    var n = hn(),
      r = ui(e),
      o = Eo(n, r)
    ;(o.tag = 2),
      t != null && (o.callback = t),
      (t = li(e, o, r)),
      t !== null && (Sr(t, e, r, n), qd(t, e, r))
  },
}
function Xx(e, t, n, r, o, i, s) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == "function"
      ? e.shouldComponentUpdate(r, i, s)
      : t.prototype && t.prototype.isPureReactComponent
        ? !Oc(n, r) || !Oc(o, i)
        : !0
  )
}
function Tk(e, t, n) {
  var r = !1,
    o = wi,
    i = t.contextType
  return (
    typeof i == "object" && i !== null
      ? (i = lr(i))
      : ((o = kn(t) ? ps : nn.current),
        (r = t.contextTypes),
        (i = (r = r != null) ? Pa(e, o) : wi)),
    (t = new t(n, i)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = ch),
    (e.stateNode = t),
    (t._reactInternals = e),
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = o),
      (e.__reactInternalMemoizedMaskedChildContext = i)),
    t
  )
}
function Qx(e, t, n, r) {
  ;(e = t.state),
    typeof t.componentWillReceiveProps == "function" &&
      t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == "function" &&
      t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && ch.enqueueReplaceState(t, t.state, null)
}
function Dv(e, t, n, r) {
  var o = e.stateNode
  ;(o.props = n), (o.state = e.memoizedState), (o.refs = {}), A0(e)
  var i = t.contextType
  typeof i == "object" && i !== null
    ? (o.context = lr(i))
    : ((i = kn(t) ? ps : nn.current), (o.context = Pa(e, i))),
    (o.state = e.memoizedState),
    (i = t.getDerivedStateFromProps),
    typeof i == "function" && (Iv(e, t, i, n), (o.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function" ||
      (typeof o.UNSAFE_componentWillMount != "function" &&
        typeof o.componentWillMount != "function") ||
      ((t = o.state),
      typeof o.componentWillMount == "function" && o.componentWillMount(),
      typeof o.UNSAFE_componentWillMount == "function" &&
        o.UNSAFE_componentWillMount(),
      t !== o.state && ch.enqueueReplaceState(o, o.state, null),
      Nf(e, n, o, r),
      (o.state = e.memoizedState)),
    typeof o.componentDidMount == "function" && (e.flags |= 4194308)
}
function Fa(e, t) {
  try {
    var n = "",
      r = t
    do (n += y5(r)), (r = r.return)
    while (r)
    var o = n
  } catch (i) {
    o =
      `
Error generating stack: ` +
      i.message +
      `
` +
      i.stack
  }
  return { value: e, source: t, stack: o, digest: null }
}
function Km(e, t, n) {
  return {
    value: e,
    source: null,
    stack: n != null ? n : null,
    digest: t != null ? t : null,
  }
}
function Lv(e, t) {
  try {
    console.error(t.value)
  } catch (n) {
    setTimeout(function () {
      throw n
    })
  }
}
var W4 = typeof WeakMap == "function" ? WeakMap : Map
function Mk(e, t, n) {
  ;(n = Eo(-1, n)), (n.tag = 3), (n.payload = { element: null })
  var r = t.value
  return (
    (n.callback = function () {
      Rf || ((Rf = !0), (Wv = r)), Lv(e, t)
    }),
    n
  )
}
function Ok(e, t, n) {
  ;(n = Eo(-1, n)), (n.tag = 3)
  var r = e.type.getDerivedStateFromError
  if (typeof r == "function") {
    var o = t.value
    ;(n.payload = function () {
      return r(o)
    }),
      (n.callback = function () {
        Lv(e, t)
      })
  }
  var i = e.stateNode
  return (
    i !== null &&
      typeof i.componentDidCatch == "function" &&
      (n.callback = function () {
        Lv(e, t),
          typeof r != "function" &&
            (ci === null ? (ci = new Set([this])) : ci.add(this))
        var s = t.stack
        this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" })
      }),
    n
  )
}
function Jx(e, t, n) {
  var r = e.pingCache
  if (r === null) {
    r = e.pingCache = new W4()
    var o = new Set()
    r.set(t, o)
  } else (o = r.get(t)), o === void 0 && ((o = new Set()), r.set(t, o))
  o.has(n) || (o.add(n), (e = i3.bind(null, e, t, n)), t.then(e, e))
}
function ew(e) {
  do {
    var t
    if (
      ((t = e.tag === 13) &&
        ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e
    e = e.return
  } while (e !== null)
  return null
}
function tw(e, t, n, r, o) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = o), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((t = Eo(-1, 1)), (t.tag = 2), li(n, t, 1))),
          (n.lanes |= 1)),
      e)
}
var K4 = Do.ReactCurrentOwner,
  Sn = !1
function dn(e, t, n, r) {
  t.child = e === null ? ik(t, null, n, r) : Ba(t, e.child, n, r)
}
function nw(e, t, n, r, o) {
  n = n.render
  var i = t.ref
  return (
    ka(t, o),
    (r = P0(e, t, n, r, i, o)),
    (n = $0()),
    e !== null && !Sn
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~o),
        Mo(e, t, o))
      : (nt && n && S0(t), (t.flags |= 1), dn(e, t, r, o), t.child)
  )
}
function rw(e, t, n, r, o) {
  if (e === null) {
    var i = n.type
    return typeof i == "function" &&
      !G0(i) &&
      i.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = i), Ak(e, t, i, r, o))
      : ((e = ef(n.type, null, r, t, t.mode, o)),
        (e.ref = t.ref),
        (e.return = t),
        (t.child = e))
  }
  if (((i = e.child), !(e.lanes & o))) {
    var s = i.memoizedProps
    if (
      ((n = n.compare), (n = n !== null ? n : Oc), n(s, r) && e.ref === t.ref)
    )
      return Mo(e, t, o)
  }
  return (
    (t.flags |= 1),
    (e = di(i, r)),
    (e.ref = t.ref),
    (e.return = t),
    (t.child = e)
  )
}
function Ak(e, t, n, r, o) {
  if (e !== null) {
    var i = e.memoizedProps
    if (Oc(i, r) && e.ref === t.ref)
      if (((Sn = !1), (t.pendingProps = r = i), (e.lanes & o) !== 0))
        e.flags & 131072 && (Sn = !0)
      else return (t.lanes = e.lanes), Mo(e, t, o)
  }
  return Pv(e, t, n, r, o)
}
function Rk(e, t, n) {
  var r = t.pendingProps,
    o = r.children,
    i = e !== null ? e.memoizedState : null
  if (r.mode === "hidden")
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Ge(ya, In),
        (In |= n)
    else {
      if (!(n & 1073741824))
        return (
          (e = i !== null ? i.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = {
            baseLanes: e,
            cachePool: null,
            transitions: null,
          }),
          (t.updateQueue = null),
          Ge(ya, In),
          (In |= e),
          null
        )
      ;(t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = i !== null ? i.baseLanes : n),
        Ge(ya, In),
        (In |= r)
    }
  else
    i !== null ? ((r = i.baseLanes | n), (t.memoizedState = null)) : (r = n),
      Ge(ya, In),
      (In |= r)
  return dn(e, t, o, n), t.child
}
function Ik(e, t) {
  var n = t.ref
  ;((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152))
}
function Pv(e, t, n, r, o) {
  var i = kn(n) ? ps : nn.current
  return (
    (i = Pa(t, i)),
    ka(t, o),
    (n = P0(e, t, n, r, i, o)),
    (r = $0()),
    e !== null && !Sn
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~o),
        Mo(e, t, o))
      : (nt && r && S0(t), (t.flags |= 1), dn(e, t, n, o), t.child)
  )
}
function ow(e, t, n, r, o) {
  if (kn(n)) {
    var i = !0
    Ef(t)
  } else i = !1
  if ((ka(t, o), t.stateNode === null))
    Xd(e, t), Tk(t, n, r), Dv(t, n, r, o), (r = !0)
  else if (e === null) {
    var s = t.stateNode,
      a = t.memoizedProps
    s.props = a
    var l = s.context,
      c = n.contextType
    typeof c == "object" && c !== null
      ? (c = lr(c))
      : ((c = kn(n) ? ps : nn.current), (c = Pa(t, c)))
    var u = n.getDerivedStateFromProps,
      d =
        typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function"
    d ||
      (typeof s.UNSAFE_componentWillReceiveProps != "function" &&
        typeof s.componentWillReceiveProps != "function") ||
      ((a !== r || l !== c) && Qx(t, s, r, c)),
      (Uo = !1)
    var f = t.memoizedState
    ;(s.state = f),
      Nf(t, r, s, o),
      (l = t.memoizedState),
      a !== r || f !== l || _n.current || Uo
        ? (typeof u == "function" && (Iv(t, n, u, r), (l = t.memoizedState)),
          (a = Uo || Xx(t, n, a, r, f, l, c))
            ? (d ||
                (typeof s.UNSAFE_componentWillMount != "function" &&
                  typeof s.componentWillMount != "function") ||
                (typeof s.componentWillMount == "function" &&
                  s.componentWillMount(),
                typeof s.UNSAFE_componentWillMount == "function" &&
                  s.UNSAFE_componentWillMount()),
              typeof s.componentDidMount == "function" && (t.flags |= 4194308))
            : (typeof s.componentDidMount == "function" && (t.flags |= 4194308),
              (t.memoizedProps = r),
              (t.memoizedState = l)),
          (s.props = r),
          (s.state = l),
          (s.context = c),
          (r = a))
        : (typeof s.componentDidMount == "function" && (t.flags |= 4194308),
          (r = !1))
  } else {
    ;(s = t.stateNode),
      ak(e, t),
      (a = t.memoizedProps),
      (c = t.type === t.elementType ? a : hr(t.type, a)),
      (s.props = c),
      (d = t.pendingProps),
      (f = s.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = lr(l))
        : ((l = kn(n) ? ps : nn.current), (l = Pa(t, l)))
    var p = n.getDerivedStateFromProps
    ;(u =
      typeof p == "function" ||
      typeof s.getSnapshotBeforeUpdate == "function") ||
      (typeof s.UNSAFE_componentWillReceiveProps != "function" &&
        typeof s.componentWillReceiveProps != "function") ||
      ((a !== d || f !== l) && Qx(t, s, r, l)),
      (Uo = !1),
      (f = t.memoizedState),
      (s.state = f),
      Nf(t, r, s, o)
    var g = t.memoizedState
    a !== d || f !== g || _n.current || Uo
      ? (typeof p == "function" && (Iv(t, n, p, r), (g = t.memoizedState)),
        (c = Uo || Xx(t, n, c, r, f, g, l) || !1)
          ? (u ||
              (typeof s.UNSAFE_componentWillUpdate != "function" &&
                typeof s.componentWillUpdate != "function") ||
              (typeof s.componentWillUpdate == "function" &&
                s.componentWillUpdate(r, g, l),
              typeof s.UNSAFE_componentWillUpdate == "function" &&
                s.UNSAFE_componentWillUpdate(r, g, l)),
            typeof s.componentDidUpdate == "function" && (t.flags |= 4),
            typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024))
          : (typeof s.componentDidUpdate != "function" ||
              (a === e.memoizedProps && f === e.memoizedState) ||
              (t.flags |= 4),
            typeof s.getSnapshotBeforeUpdate != "function" ||
              (a === e.memoizedProps && f === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = r),
            (t.memoizedState = g)),
        (s.props = r),
        (s.state = g),
        (s.context = l),
        (r = c))
      : (typeof s.componentDidUpdate != "function" ||
          (a === e.memoizedProps && f === e.memoizedState) ||
          (t.flags |= 4),
        typeof s.getSnapshotBeforeUpdate != "function" ||
          (a === e.memoizedProps && f === e.memoizedState) ||
          (t.flags |= 1024),
        (r = !1))
  }
  return $v(e, t, n, r, i, o)
}
function $v(e, t, n, r, o, i) {
  Ik(e, t)
  var s = (t.flags & 128) !== 0
  if (!r && !s) return o && Vx(t, n, !1), Mo(e, t, i)
  ;(r = t.stateNode), (K4.current = t)
  var a =
    s && typeof n.getDerivedStateFromError != "function" ? null : r.render()
  return (
    (t.flags |= 1),
    e !== null && s
      ? ((t.child = Ba(t, e.child, null, i)), (t.child = Ba(t, null, a, i)))
      : dn(e, t, a, i),
    (t.memoizedState = r.state),
    o && Vx(t, n, !0),
    t.child
  )
}
function Dk(e) {
  var t = e.stateNode
  t.pendingContext
    ? Ux(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && Ux(e, t.context, !1),
    R0(e, t.containerInfo)
}
function iw(e, t, n, r, o) {
  return $a(), k0(o), (t.flags |= 256), dn(e, t, n, r), t.child
}
var Bv = { dehydrated: null, treeContext: null, retryLane: 0 }
function jv(e) {
  return { baseLanes: e, cachePool: null, transitions: null }
}
function Lk(e, t, n) {
  var r = t.pendingProps,
    o = it.current,
    i = !1,
    s = (t.flags & 128) !== 0,
    a
  if (
    ((a = s) ||
      (a = e !== null && e.memoizedState === null ? !1 : (o & 2) !== 0),
    a
      ? ((i = !0), (t.flags &= -129))
      : (e === null || e.memoizedState !== null) && (o |= 1),
    Ge(it, o & 1),
    e === null)
  )
    return (
      Av(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1
            ? e.data === "$!"
              ? (t.lanes = 8)
              : (t.lanes = 1073741824)
            : (t.lanes = 1),
          null)
        : ((s = r.children),
          (e = r.fallback),
          i
            ? ((r = t.mode),
              (i = t.child),
              (s = { mode: "hidden", children: s }),
              !(r & 1) && i !== null
                ? ((i.childLanes = 0), (i.pendingProps = s))
                : (i = fh(s, r, 0, null)),
              (e = ts(e, r, n, null)),
              (i.return = t),
              (e.return = t),
              (i.sibling = e),
              (t.child = i),
              (t.child.memoizedState = jv(n)),
              (t.memoizedState = Bv),
              e)
            : F0(t, s))
    )
  if (((o = e.memoizedState), o !== null && ((a = o.dehydrated), a !== null)))
    return G4(e, t, s, r, a, o, n)
  if (i) {
    ;(i = r.fallback), (s = t.mode), (o = e.child), (a = o.sibling)
    var l = { mode: "hidden", children: r.children }
    return (
      !(s & 1) && t.child !== o
        ? ((r = t.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (t.deletions = null))
        : ((r = di(o, l)), (r.subtreeFlags = o.subtreeFlags & 14680064)),
      a !== null ? (i = di(a, i)) : ((i = ts(i, s, n, null)), (i.flags |= 2)),
      (i.return = t),
      (r.return = t),
      (r.sibling = i),
      (t.child = r),
      (r = i),
      (i = t.child),
      (s = e.child.memoizedState),
      (s =
        s === null
          ? jv(n)
          : {
              baseLanes: s.baseLanes | n,
              cachePool: null,
              transitions: s.transitions,
            }),
      (i.memoizedState = s),
      (i.childLanes = e.childLanes & ~n),
      (t.memoizedState = Bv),
      r
    )
  }
  return (
    (i = e.child),
    (e = i.sibling),
    (r = di(i, { mode: "visible", children: r.children })),
    !(t.mode & 1) && (r.lanes = n),
    (r.return = t),
    (r.sibling = null),
    e !== null &&
      ((n = t.deletions),
      n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = r),
    (t.memoizedState = null),
    r
  )
}
function F0(e, t) {
  return (
    (t = fh({ mode: "visible", children: t }, e.mode, 0, null)),
    (t.return = e),
    (e.child = t)
  )
}
function id(e, t, n, r) {
  return (
    r !== null && k0(r),
    Ba(t, e.child, null, n),
    (e = F0(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  )
}
function G4(e, t, n, r, o, i, s) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (r = Km(Error(J(422)))), id(e, t, s, r))
      : t.memoizedState !== null
        ? ((t.child = e.child), (t.flags |= 128), null)
        : ((i = r.fallback),
          (o = t.mode),
          (r = fh({ mode: "visible", children: r.children }, o, 0, null)),
          (i = ts(i, o, s, null)),
          (i.flags |= 2),
          (r.return = t),
          (i.return = t),
          (r.sibling = i),
          (t.child = r),
          t.mode & 1 && Ba(t, e.child, null, s),
          (t.child.memoizedState = jv(s)),
          (t.memoizedState = Bv),
          i)
  if (!(t.mode & 1)) return id(e, t, s, null)
  if (o.data === "$!") {
    if (((r = o.nextSibling && o.nextSibling.dataset), r)) var a = r.dgst
    return (r = a), (i = Error(J(419))), (r = Km(i, r, void 0)), id(e, t, s, r)
  }
  if (((a = (s & e.childLanes) !== 0), Sn || a)) {
    if (((r = $t), r !== null)) {
      switch (s & -s) {
        case 4:
          o = 2
          break
        case 16:
          o = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          o = 32
          break
        case 536870912:
          o = 268435456
          break
        default:
          o = 0
      }
      ;(o = o & (r.suspendedLanes | s) ? 0 : o),
        o !== 0 &&
          o !== i.retryLane &&
          ((i.retryLane = o), To(e, o), Sr(r, e, o, -1))
    }
    return K0(), (r = Km(Error(J(421)))), id(e, t, s, r)
  }
  return o.data === "$?"
    ? ((t.flags |= 128),
      (t.child = e.child),
      (t = s3.bind(null, e)),
      (o._reactRetry = t),
      null)
    : ((e = i.treeContext),
      ($n = ai(o.nextSibling)),
      (Bn = t),
      (nt = !0),
      (gr = null),
      e !== null &&
        ((Jn[er++] = vo),
        (Jn[er++] = yo),
        (Jn[er++] = hs),
        (vo = e.id),
        (yo = e.overflow),
        (hs = t)),
      (t = F0(t, r.children)),
      (t.flags |= 4096),
      t)
}
function sw(e, t, n) {
  e.lanes |= t
  var r = e.alternate
  r !== null && (r.lanes |= t), Rv(e.return, t, n)
}
function Gm(e, t, n, r, o) {
  var i = e.memoizedState
  i === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: o,
      })
    : ((i.isBackwards = t),
      (i.rendering = null),
      (i.renderingStartTime = 0),
      (i.last = r),
      (i.tail = n),
      (i.tailMode = o))
}
function Pk(e, t, n) {
  var r = t.pendingProps,
    o = r.revealOrder,
    i = r.tail
  if ((dn(e, t, r.children, n), (r = it.current), r & 2))
    (r = (r & 1) | 2), (t.flags |= 128)
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && sw(e, n, t)
        else if (e.tag === 19) sw(e, n, t)
        else if (e.child !== null) {
          ;(e.child.return = e), (e = e.child)
          continue
        }
        if (e === t) break e
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e
          e = e.return
        }
        ;(e.sibling.return = e.return), (e = e.sibling)
      }
    r &= 1
  }
  if ((Ge(it, r), !(t.mode & 1))) t.memoizedState = null
  else
    switch (o) {
      case "forwards":
        for (n = t.child, o = null; n !== null; )
          (e = n.alternate),
            e !== null && Tf(e) === null && (o = n),
            (n = n.sibling)
        ;(n = o),
          n === null
            ? ((o = t.child), (t.child = null))
            : ((o = n.sibling), (n.sibling = null)),
          Gm(t, !1, o, n, i)
        break
      case "backwards":
        for (n = null, o = t.child, t.child = null; o !== null; ) {
          if (((e = o.alternate), e !== null && Tf(e) === null)) {
            t.child = o
            break
          }
          ;(e = o.sibling), (o.sibling = n), (n = o), (o = e)
        }
        Gm(t, !0, n, null, i)
        break
      case "together":
        Gm(t, !1, null, null, void 0)
        break
      default:
        t.memoizedState = null
    }
  return t.child
}
function Xd(e, t) {
  !(t.mode & 1) &&
    e !== null &&
    ((e.alternate = null), (t.alternate = null), (t.flags |= 2))
}
function Mo(e, t, n) {
  if (
    (e !== null && (t.dependencies = e.dependencies),
    (gs |= t.lanes),
    !(n & t.childLanes))
  )
    return null
  if (e !== null && t.child !== e.child) throw Error(J(153))
  if (t.child !== null) {
    for (
      e = t.child, n = di(e, e.pendingProps), t.child = n, n.return = t;
      e.sibling !== null;

    )
      (e = e.sibling), (n = n.sibling = di(e, e.pendingProps)), (n.return = t)
    n.sibling = null
  }
  return t.child
}
function q4(e, t, n) {
  switch (t.tag) {
    case 3:
      Dk(t), $a()
      break
    case 5:
      lk(t)
      break
    case 1:
      kn(t.type) && Ef(t)
      break
    case 4:
      R0(t, t.stateNode.containerInfo)
      break
    case 10:
      var r = t.type._context,
        o = t.memoizedProps.value
      Ge(_f, r._currentValue), (r._currentValue = o)
      break
    case 13:
      if (((r = t.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (Ge(it, it.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
            ? Lk(e, t, n)
            : (Ge(it, it.current & 1),
              (e = Mo(e, t, n)),
              e !== null ? e.sibling : null)
      Ge(it, it.current & 1)
      break
    case 19:
      if (((r = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (r) return Pk(e, t, n)
        t.flags |= 128
      }
      if (
        ((o = t.memoizedState),
        o !== null &&
          ((o.rendering = null), (o.tail = null), (o.lastEffect = null)),
        Ge(it, it.current),
        r)
      )
        break
      return null
    case 22:
    case 23:
      return (t.lanes = 0), Rk(e, t, n)
  }
  return Mo(e, t, n)
}
var $k, Fv, Bk, jk
$k = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode)
    else if (n.tag !== 4 && n.child !== null) {
      ;(n.child.return = n), (n = n.child)
      continue
    }
    if (n === t) break
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return
      n = n.return
    }
    ;(n.sibling.return = n.return), (n = n.sibling)
  }
}
Fv = function () {}
Bk = function (e, t, n, r) {
  var o = e.memoizedProps
  if (o !== r) {
    ;(e = t.stateNode), qi(Kr.current)
    var i = null
    switch (n) {
      case "input":
        ;(o = lv(e, o)), (r = lv(e, r)), (i = [])
        break
      case "select":
        ;(o = at({}, o, { value: void 0 })),
          (r = at({}, r, { value: void 0 })),
          (i = [])
        break
      case "textarea":
        ;(o = dv(e, o)), (r = dv(e, r)), (i = [])
        break
      default:
        typeof o.onClick != "function" &&
          typeof r.onClick == "function" &&
          (e.onclick = xf)
    }
    pv(n, r)
    var s
    n = null
    for (c in o)
      if (!r.hasOwnProperty(c) && o.hasOwnProperty(c) && o[c] != null)
        if (c === "style") {
          var a = o[c]
          for (s in a) a.hasOwnProperty(s) && (n || (n = {}), (n[s] = ""))
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (Cc.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null))
    for (c in r) {
      var l = r[c]
      if (
        ((a = o != null ? o[c] : void 0),
        r.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (s in a)
              !a.hasOwnProperty(s) ||
                (l && l.hasOwnProperty(s)) ||
                (n || (n = {}), (n[s] = ""))
            for (s in l)
              l.hasOwnProperty(s) &&
                a[s] !== l[s] &&
                (n || (n = {}), (n[s] = l[s]))
          } else n || (i || (i = []), i.push(c, n)), (n = l)
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (i = i || []).push(c, l))
            : c === "children"
              ? (typeof l != "string" && typeof l != "number") ||
                (i = i || []).push(c, "" + l)
              : c !== "suppressContentEditableWarning" &&
                c !== "suppressHydrationWarning" &&
                (Cc.hasOwnProperty(c)
                  ? (l != null && c === "onScroll" && Xe("scroll", e),
                    i || a === l || (i = []))
                  : (i = i || []).push(c, l))
    }
    n && (i = i || []).push("style", n)
    var c = i
    ;(t.updateQueue = c) && (t.flags |= 4)
  }
}
jk = function (e, t, n, r) {
  n !== r && (t.flags |= 4)
}
function Ml(e, t) {
  if (!nt)
    switch (e.tailMode) {
      case "hidden":
        t = e.tail
        for (var n = null; t !== null; )
          t.alternate !== null && (n = t), (t = t.sibling)
        n === null ? (e.tail = null) : (n.sibling = null)
        break
      case "collapsed":
        n = e.tail
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling)
        r === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (r.sibling = null)
    }
}
function Xt(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0
  if (t)
    for (var o = e.child; o !== null; )
      (n |= o.lanes | o.childLanes),
        (r |= o.subtreeFlags & 14680064),
        (r |= o.flags & 14680064),
        (o.return = e),
        (o = o.sibling)
  else
    for (o = e.child; o !== null; )
      (n |= o.lanes | o.childLanes),
        (r |= o.subtreeFlags),
        (r |= o.flags),
        (o.return = e),
        (o = o.sibling)
  return (e.subtreeFlags |= r), (e.childLanes = n), t
}
function Z4(e, t, n) {
  var r = t.pendingProps
  switch ((_0(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Xt(t), null
    case 1:
      return kn(t.type) && wf(), Xt(t), null
    case 3:
      return (
        (r = t.stateNode),
        ja(),
        Je(_n),
        Je(nn),
        D0(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (e === null || e.child === null) &&
          (rd(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), gr !== null && (qv(gr), (gr = null)))),
        Fv(e, t),
        Xt(t),
        null
      )
    case 5:
      I0(t)
      var o = qi(Lc.current)
      if (((n = t.type), e !== null && t.stateNode != null))
        Bk(e, t, n, r, o),
          e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152))
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(J(166))
          return Xt(t), null
        }
        if (((e = qi(Kr.current)), rd(t))) {
          ;(r = t.stateNode), (n = t.type)
          var i = t.memoizedProps
          switch (((r[Ur] = t), (r[Ic] = i), (e = (t.mode & 1) !== 0), n)) {
            case "dialog":
              Xe("cancel", r), Xe("close", r)
              break
            case "iframe":
            case "object":
            case "embed":
              Xe("load", r)
              break
            case "video":
            case "audio":
              for (o = 0; o < Ul.length; o++) Xe(Ul[o], r)
              break
            case "source":
              Xe("error", r)
              break
            case "img":
            case "image":
            case "link":
              Xe("error", r), Xe("load", r)
              break
            case "details":
              Xe("toggle", r)
              break
            case "input":
              mx(r, i), Xe("invalid", r)
              break
            case "select":
              ;(r._wrapperState = { wasMultiple: !!i.multiple }),
                Xe("invalid", r)
              break
            case "textarea":
              vx(r, i), Xe("invalid", r)
          }
          pv(n, i), (o = null)
          for (var s in i)
            if (i.hasOwnProperty(s)) {
              var a = i[s]
              s === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (i.suppressHydrationWarning !== !0 &&
                      nd(r.textContent, a, e),
                    (o = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (i.suppressHydrationWarning !== !0 &&
                      nd(r.textContent, a, e),
                    (o = ["children", "" + a]))
                : Cc.hasOwnProperty(s) &&
                  a != null &&
                  s === "onScroll" &&
                  Xe("scroll", r)
            }
          switch (n) {
            case "input":
              qu(r), gx(r, i, !0)
              break
            case "textarea":
              qu(r), yx(r)
              break
            case "select":
            case "option":
              break
            default:
              typeof i.onClick == "function" && (r.onclick = xf)
          }
          ;(r = o), (t.updateQueue = r), r !== null && (t.flags |= 4)
        } else {
          ;(s = o.nodeType === 9 ? o : o.ownerDocument),
            e === "http://www.w3.org/1999/xhtml" && (e = p_(n)),
            e === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((e = s.createElement("div")),
                  (e.innerHTML = "<script><\/script>"),
                  (e = e.removeChild(e.firstChild)))
                : typeof r.is == "string"
                  ? (e = s.createElement(n, { is: r.is }))
                  : ((e = s.createElement(n)),
                    n === "select" &&
                      ((s = e),
                      r.multiple
                        ? (s.multiple = !0)
                        : r.size && (s.size = r.size)))
              : (e = s.createElementNS(e, n)),
            (e[Ur] = t),
            (e[Ic] = r),
            $k(e, t, !1, !1),
            (t.stateNode = e)
          e: {
            switch (((s = hv(n, r)), n)) {
              case "dialog":
                Xe("cancel", e), Xe("close", e), (o = r)
                break
              case "iframe":
              case "object":
              case "embed":
                Xe("load", e), (o = r)
                break
              case "video":
              case "audio":
                for (o = 0; o < Ul.length; o++) Xe(Ul[o], e)
                o = r
                break
              case "source":
                Xe("error", e), (o = r)
                break
              case "img":
              case "image":
              case "link":
                Xe("error", e), Xe("load", e), (o = r)
                break
              case "details":
                Xe("toggle", e), (o = r)
                break
              case "input":
                mx(e, r), (o = lv(e, r)), Xe("invalid", e)
                break
              case "option":
                o = r
                break
              case "select":
                ;(e._wrapperState = { wasMultiple: !!r.multiple }),
                  (o = at({}, r, { value: void 0 })),
                  Xe("invalid", e)
                break
              case "textarea":
                vx(e, r), (o = dv(e, r)), Xe("invalid", e)
                break
              default:
                o = r
            }
            pv(n, o), (a = o)
            for (i in a)
              if (a.hasOwnProperty(i)) {
                var l = a[i]
                i === "style"
                  ? g_(e, l)
                  : i === "dangerouslySetInnerHTML"
                    ? ((l = l ? l.__html : void 0), l != null && h_(e, l))
                    : i === "children"
                      ? typeof l == "string"
                        ? (n !== "textarea" || l !== "") && Sc(e, l)
                        : typeof l == "number" && Sc(e, "" + l)
                      : i !== "suppressContentEditableWarning" &&
                        i !== "suppressHydrationWarning" &&
                        i !== "autoFocus" &&
                        (Cc.hasOwnProperty(i)
                          ? l != null && i === "onScroll" && Xe("scroll", e)
                          : l != null && u0(e, i, l, s))
              }
            switch (n) {
              case "input":
                qu(e), gx(e, r, !1)
                break
              case "textarea":
                qu(e), yx(e)
                break
              case "option":
                r.value != null && e.setAttribute("value", "" + xi(r.value))
                break
              case "select":
                ;(e.multiple = !!r.multiple),
                  (i = r.value),
                  i != null
                    ? Ea(e, !!r.multiple, i, !1)
                    : r.defaultValue != null &&
                      Ea(e, !!r.multiple, r.defaultValue, !0)
                break
              default:
                typeof o.onClick == "function" && (e.onclick = xf)
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus
                break e
              case "img":
                r = !0
                break e
              default:
                r = !1
            }
          }
          r && (t.flags |= 4)
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152))
      }
      return Xt(t), null
    case 6:
      if (e && t.stateNode != null) jk(e, t, e.memoizedProps, r)
      else {
        if (typeof r != "string" && t.stateNode === null) throw Error(J(166))
        if (((n = qi(Lc.current)), qi(Kr.current), rd(t))) {
          if (
            ((r = t.stateNode),
            (n = t.memoizedProps),
            (r[Ur] = t),
            (i = r.nodeValue !== n) && ((e = Bn), e !== null))
          )
            switch (e.tag) {
              case 3:
                nd(r.nodeValue, n, (e.mode & 1) !== 0)
                break
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  nd(r.nodeValue, n, (e.mode & 1) !== 0)
            }
          i && (t.flags |= 4)
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Ur] = t),
            (t.stateNode = r)
      }
      return Xt(t), null
    case 13:
      if (
        (Je(it),
        (r = t.memoizedState),
        e === null ||
          (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (nt && $n !== null && t.mode & 1 && !(t.flags & 128))
          rk(), $a(), (t.flags |= 98560), (i = !1)
        else if (((i = rd(t)), r !== null && r.dehydrated !== null)) {
          if (e === null) {
            if (!i) throw Error(J(318))
            if (
              ((i = t.memoizedState),
              (i = i !== null ? i.dehydrated : null),
              !i)
            )
              throw Error(J(317))
            i[Ur] = t
          } else
            $a(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4)
          Xt(t), (i = !1)
        } else gr !== null && (qv(gr), (gr = null)), (i = !0)
        if (!i) return t.flags & 65536 ? t : null
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((r = r !== null),
          r !== (e !== null && e.memoizedState !== null) &&
            r &&
            ((t.child.flags |= 8192),
            t.mode & 1 &&
              (e === null || it.current & 1 ? Ot === 0 && (Ot = 3) : K0())),
          t.updateQueue !== null && (t.flags |= 4),
          Xt(t),
          null)
    case 4:
      return (
        ja(), Fv(e, t), e === null && Ac(t.stateNode.containerInfo), Xt(t), null
      )
    case 10:
      return M0(t.type._context), Xt(t), null
    case 17:
      return kn(t.type) && wf(), Xt(t), null
    case 19:
      if ((Je(it), (i = t.memoizedState), i === null)) return Xt(t), null
      if (((r = (t.flags & 128) !== 0), (s = i.rendering), s === null))
        if (r) Ml(i, !1)
        else {
          if (Ot !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((s = Tf(e)), s !== null)) {
                for (
                  t.flags |= 128,
                    Ml(i, !1),
                    r = s.updateQueue,
                    r !== null && ((t.updateQueue = r), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    r = n,
                    n = t.child;
                  n !== null;

                )
                  (i = n),
                    (e = r),
                    (i.flags &= 14680066),
                    (s = i.alternate),
                    s === null
                      ? ((i.childLanes = 0),
                        (i.lanes = e),
                        (i.child = null),
                        (i.subtreeFlags = 0),
                        (i.memoizedProps = null),
                        (i.memoizedState = null),
                        (i.updateQueue = null),
                        (i.dependencies = null),
                        (i.stateNode = null))
                      : ((i.childLanes = s.childLanes),
                        (i.lanes = s.lanes),
                        (i.child = s.child),
                        (i.subtreeFlags = 0),
                        (i.deletions = null),
                        (i.memoizedProps = s.memoizedProps),
                        (i.memoizedState = s.memoizedState),
                        (i.updateQueue = s.updateQueue),
                        (i.type = s.type),
                        (e = s.dependencies),
                        (i.dependencies =
                          e === null
                            ? null
                            : {
                                lanes: e.lanes,
                                firstContext: e.firstContext,
                              })),
                    (n = n.sibling)
                return Ge(it, (it.current & 1) | 2), t.child
              }
              e = e.sibling
            }
          i.tail !== null &&
            xt() > za &&
            ((t.flags |= 128), (r = !0), Ml(i, !1), (t.lanes = 4194304))
        }
      else {
        if (!r)
          if (((e = Tf(s)), e !== null)) {
            if (
              ((t.flags |= 128),
              (r = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              Ml(i, !0),
              i.tail === null && i.tailMode === "hidden" && !s.alternate && !nt)
            )
              return Xt(t), null
          } else
            2 * xt() - i.renderingStartTime > za &&
              n !== 1073741824 &&
              ((t.flags |= 128), (r = !0), Ml(i, !1), (t.lanes = 4194304))
        i.isBackwards
          ? ((s.sibling = t.child), (t.child = s))
          : ((n = i.last),
            n !== null ? (n.sibling = s) : (t.child = s),
            (i.last = s))
      }
      return i.tail !== null
        ? ((t = i.tail),
          (i.rendering = t),
          (i.tail = t.sibling),
          (i.renderingStartTime = xt()),
          (t.sibling = null),
          (n = it.current),
          Ge(it, r ? (n & 1) | 2 : n & 1),
          t)
        : (Xt(t), null)
    case 22:
    case 23:
      return (
        W0(),
        (r = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== r && (t.flags |= 8192),
        r && t.mode & 1
          ? In & 1073741824 && (Xt(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : Xt(t),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(J(156, t.tag))
}
function Y4(e, t) {
  switch ((_0(t), t.tag)) {
    case 1:
      return (
        kn(t.type) && wf(),
        (e = t.flags),
        e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 3:
      return (
        ja(),
        Je(_n),
        Je(nn),
        D0(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 5:
      return I0(t), null
    case 13:
      if (
        (Je(it), (e = t.memoizedState), e !== null && e.dehydrated !== null)
      ) {
        if (t.alternate === null) throw Error(J(340))
        $a()
      }
      return (
        (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 19:
      return Je(it), null
    case 4:
      return ja(), null
    case 10:
      return M0(t.type._context), null
    case 22:
    case 23:
      return W0(), null
    case 24:
      return null
    default:
      return null
  }
}
var sd = !1,
  Jt = !1,
  X4 = typeof WeakSet == "function" ? WeakSet : Set,
  le = null
function va(e, t) {
  var n = e.ref
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null)
      } catch (r) {
        ht(e, t, r)
      }
    else n.current = null
}
function zv(e, t, n) {
  try {
    n()
  } catch (r) {
    ht(e, t, r)
  }
}
var aw = !1
function Q4(e, t) {
  if (((Sv = vf), (e = H_()), C0(e))) {
    if ("selectionStart" in e)
      var n = { start: e.selectionStart, end: e.selectionEnd }
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window
        var r = n.getSelection && n.getSelection()
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode
          var o = r.anchorOffset,
            i = r.focusNode
          r = r.focusOffset
          try {
            n.nodeType, i.nodeType
          } catch {
            n = null
            break e
          }
          var s = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            d = e,
            f = null
          t: for (;;) {
            for (
              var p;
              d !== n || (o !== 0 && d.nodeType !== 3) || (a = s + o),
                d !== i || (r !== 0 && d.nodeType !== 3) || (l = s + r),
                d.nodeType === 3 && (s += d.nodeValue.length),
                (p = d.firstChild) !== null;

            )
              (f = d), (d = p)
            for (;;) {
              if (d === e) break t
              if (
                (f === n && ++c === o && (a = s),
                f === i && ++u === r && (l = s),
                (p = d.nextSibling) !== null)
              )
                break
              ;(d = f), (f = d.parentNode)
            }
            d = p
          }
          n = a === -1 || l === -1 ? null : { start: a, end: l }
        } else n = null
      }
    n = n || { start: 0, end: 0 }
  } else n = null
  for (
    _v = { focusedElem: e, selectionRange: n }, vf = !1, le = t;
    le !== null;

  )
    if (((t = le), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (le = e)
    else
      for (; le !== null; ) {
        t = le
        try {
          var g = t.alternate
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (g !== null) {
                  var v = g.memoizedProps,
                    b = g.memoizedState,
                    y = t.stateNode,
                    x = y.getSnapshotBeforeUpdate(
                      t.elementType === t.type ? v : hr(t.type, v),
                      b
                    )
                  y.__reactInternalSnapshotBeforeUpdate = x
                }
                break
              case 3:
                var E = t.stateNode.containerInfo
                E.nodeType === 1
                  ? (E.textContent = "")
                  : E.nodeType === 9 &&
                    E.documentElement &&
                    E.removeChild(E.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(J(163))
            }
        } catch (w) {
          ht(t, t.return, w)
        }
        if (((e = t.sibling), e !== null)) {
          ;(e.return = t.return), (le = e)
          break
        }
        le = t.return
      }
  return (g = aw), (aw = !1), g
}
function rc(e, t, n) {
  var r = t.updateQueue
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var o = (r = r.next)
    do {
      if ((o.tag & e) === e) {
        var i = o.destroy
        ;(o.destroy = void 0), i !== void 0 && zv(t, n, i)
      }
      o = o.next
    } while (o !== r)
  }
}
function uh(e, t) {
  if (
    ((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)
  ) {
    var n = (t = t.next)
    do {
      if ((n.tag & e) === e) {
        var r = n.create
        n.destroy = r()
      }
      n = n.next
    } while (n !== t)
  }
}
function Uv(e) {
  var t = e.ref
  if (t !== null) {
    var n = e.stateNode
    switch (e.tag) {
      case 5:
        e = n
        break
      default:
        e = n
    }
    typeof t == "function" ? t(e) : (t.current = e)
  }
}
function Fk(e) {
  var t = e.alternate
  t !== null && ((e.alternate = null), Fk(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null &&
        (delete t[Ur], delete t[Ic], delete t[Tv], delete t[D4], delete t[L4])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null)
}
function zk(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function lw(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || zk(e.return)) return null
      e = e.return
    }
    for (
      e.sibling.return = e.return, e = e.sibling;
      e.tag !== 5 && e.tag !== 6 && e.tag !== 18;

    ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e
      ;(e.child.return = e), (e = e.child)
    }
    if (!(e.flags & 2)) return e.stateNode
  }
}
function Vv(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6)
    (e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = xf))
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Vv(e, t, n), e = e.sibling; e !== null; ) Vv(e, t, n), (e = e.sibling)
}
function Hv(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6)
    (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e)
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Hv(e, t, n), e = e.sibling; e !== null; ) Hv(e, t, n), (e = e.sibling)
}
var Ut = null,
  mr = !1
function Lo(e, t, n) {
  for (n = n.child; n !== null; ) Uk(e, t, n), (n = n.sibling)
}
function Uk(e, t, n) {
  if (Wr && typeof Wr.onCommitFiberUnmount == "function")
    try {
      Wr.onCommitFiberUnmount(nh, n)
    } catch {}
  switch (n.tag) {
    case 5:
      Jt || va(n, t)
    case 6:
      var r = Ut,
        o = mr
      ;(Ut = null),
        Lo(e, t, n),
        (Ut = r),
        (mr = o),
        Ut !== null &&
          (mr
            ? ((e = Ut),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : Ut.removeChild(n.stateNode))
      break
    case 18:
      Ut !== null &&
        (mr
          ? ((e = Ut),
            (n = n.stateNode),
            e.nodeType === 8
              ? Fm(e.parentNode, n)
              : e.nodeType === 1 && Fm(e, n),
            Tc(e))
          : Fm(Ut, n.stateNode))
      break
    case 4:
      ;(r = Ut),
        (o = mr),
        (Ut = n.stateNode.containerInfo),
        (mr = !0),
        Lo(e, t, n),
        (Ut = r),
        (mr = o)
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Jt &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        o = r = r.next
        do {
          var i = o,
            s = i.destroy
          ;(i = i.tag),
            s !== void 0 && (i & 2 || i & 4) && zv(n, t, s),
            (o = o.next)
        } while (o !== r)
      }
      Lo(e, t, n)
      break
    case 1:
      if (
        !Jt &&
        (va(n, t),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          ;(r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount()
        } catch (a) {
          ht(n, t, a)
        }
      Lo(e, t, n)
      break
    case 21:
      Lo(e, t, n)
      break
    case 22:
      n.mode & 1
        ? ((Jt = (r = Jt) || n.memoizedState !== null), Lo(e, t, n), (Jt = r))
        : Lo(e, t, n)
      break
    default:
      Lo(e, t, n)
  }
}
function cw(e) {
  var t = e.updateQueue
  if (t !== null) {
    e.updateQueue = null
    var n = e.stateNode
    n === null && (n = e.stateNode = new X4()),
      t.forEach(function (r) {
        var o = a3.bind(null, e, r)
        n.has(r) || (n.add(r), r.then(o, o))
      })
  }
}
function fr(e, t) {
  var n = t.deletions
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var o = n[r]
      try {
        var i = e,
          s = t,
          a = s
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              ;(Ut = a.stateNode), (mr = !1)
              break e
            case 3:
              ;(Ut = a.stateNode.containerInfo), (mr = !0)
              break e
            case 4:
              ;(Ut = a.stateNode.containerInfo), (mr = !0)
              break e
          }
          a = a.return
        }
        if (Ut === null) throw Error(J(160))
        Uk(i, s, o), (Ut = null), (mr = !1)
        var l = o.alternate
        l !== null && (l.return = null), (o.return = null)
      } catch (c) {
        ht(o, t, c)
      }
    }
  if (t.subtreeFlags & 12854)
    for (t = t.child; t !== null; ) Vk(t, e), (t = t.sibling)
}
function Vk(e, t) {
  var n = e.alternate,
    r = e.flags
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((fr(t, e), Lr(e), r & 4)) {
        try {
          rc(3, e, e.return), uh(3, e)
        } catch (v) {
          ht(e, e.return, v)
        }
        try {
          rc(5, e, e.return)
        } catch (v) {
          ht(e, e.return, v)
        }
      }
      break
    case 1:
      fr(t, e), Lr(e), r & 512 && n !== null && va(n, n.return)
      break
    case 5:
      if (
        (fr(t, e),
        Lr(e),
        r & 512 && n !== null && va(n, n.return),
        e.flags & 32)
      ) {
        var o = e.stateNode
        try {
          Sc(o, "")
        } catch (v) {
          ht(e, e.return, v)
        }
      }
      if (r & 4 && ((o = e.stateNode), o != null)) {
        var i = e.memoizedProps,
          s = n !== null ? n.memoizedProps : i,
          a = e.type,
          l = e.updateQueue
        if (((e.updateQueue = null), l !== null))
          try {
            a === "input" && i.type === "radio" && i.name != null && d_(o, i),
              hv(a, s)
            var c = hv(a, i)
            for (s = 0; s < l.length; s += 2) {
              var u = l[s],
                d = l[s + 1]
              u === "style"
                ? g_(o, d)
                : u === "dangerouslySetInnerHTML"
                  ? h_(o, d)
                  : u === "children"
                    ? Sc(o, d)
                    : u0(o, u, d, c)
            }
            switch (a) {
              case "input":
                cv(o, i)
                break
              case "textarea":
                f_(o, i)
                break
              case "select":
                var f = o._wrapperState.wasMultiple
                o._wrapperState.wasMultiple = !!i.multiple
                var p = i.value
                p != null
                  ? Ea(o, !!i.multiple, p, !1)
                  : f !== !!i.multiple &&
                    (i.defaultValue != null
                      ? Ea(o, !!i.multiple, i.defaultValue, !0)
                      : Ea(o, !!i.multiple, i.multiple ? [] : "", !1))
            }
            o[Ic] = i
          } catch (v) {
            ht(e, e.return, v)
          }
      }
      break
    case 6:
      if ((fr(t, e), Lr(e), r & 4)) {
        if (e.stateNode === null) throw Error(J(162))
        ;(o = e.stateNode), (i = e.memoizedProps)
        try {
          o.nodeValue = i
        } catch (v) {
          ht(e, e.return, v)
        }
      }
      break
    case 3:
      if (
        (fr(t, e), Lr(e), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          Tc(t.containerInfo)
        } catch (v) {
          ht(e, e.return, v)
        }
      break
    case 4:
      fr(t, e), Lr(e)
      break
    case 13:
      fr(t, e),
        Lr(e),
        (o = e.child),
        o.flags & 8192 &&
          ((i = o.memoizedState !== null),
          (o.stateNode.isHidden = i),
          !i ||
            (o.alternate !== null && o.alternate.memoizedState !== null) ||
            (V0 = xt())),
        r & 4 && cw(e)
      break
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        e.mode & 1 ? ((Jt = (c = Jt) || u), fr(t, e), (Jt = c)) : fr(t, e),
        Lr(e),
        r & 8192)
      ) {
        if (
          ((c = e.memoizedState !== null),
          (e.stateNode.isHidden = c) && !u && e.mode & 1)
        )
          for (le = e, u = e.child; u !== null; ) {
            for (d = le = u; le !== null; ) {
              switch (((f = le), (p = f.child), f.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  rc(4, f, f.return)
                  break
                case 1:
                  va(f, f.return)
                  var g = f.stateNode
                  if (typeof g.componentWillUnmount == "function") {
                    ;(r = f), (n = f.return)
                    try {
                      ;(t = r),
                        (g.props = t.memoizedProps),
                        (g.state = t.memoizedState),
                        g.componentWillUnmount()
                    } catch (v) {
                      ht(r, n, v)
                    }
                  }
                  break
                case 5:
                  va(f, f.return)
                  break
                case 22:
                  if (f.memoizedState !== null) {
                    dw(d)
                    continue
                  }
              }
              p !== null ? ((p.return = f), (le = p)) : dw(d)
            }
            u = u.sibling
          }
        e: for (u = null, d = e; ; ) {
          if (d.tag === 5) {
            if (u === null) {
              u = d
              try {
                ;(o = d.stateNode),
                  c
                    ? ((i = o.style),
                      typeof i.setProperty == "function"
                        ? i.setProperty("display", "none", "important")
                        : (i.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (s =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = m_("display", s)))
              } catch (v) {
                ht(e, e.return, v)
              }
            }
          } else if (d.tag === 6) {
            if (u === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps
              } catch (v) {
                ht(e, e.return, v)
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === e) &&
            d.child !== null
          ) {
            ;(d.child.return = d), (d = d.child)
            continue
          }
          if (d === e) break e
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === e) break e
            u === d && (u = null), (d = d.return)
          }
          u === d && (u = null), (d.sibling.return = d.return), (d = d.sibling)
        }
      }
      break
    case 19:
      fr(t, e), Lr(e), r & 4 && cw(e)
      break
    case 21:
      break
    default:
      fr(t, e), Lr(e)
  }
}
function Lr(e) {
  var t = e.flags
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (zk(n)) {
            var r = n
            break e
          }
          n = n.return
        }
        throw Error(J(160))
      }
      switch (r.tag) {
        case 5:
          var o = r.stateNode
          r.flags & 32 && (Sc(o, ""), (r.flags &= -33))
          var i = lw(e)
          Hv(e, i, o)
          break
        case 3:
        case 4:
          var s = r.stateNode.containerInfo,
            a = lw(e)
          Vv(e, a, s)
          break
        default:
          throw Error(J(161))
      }
    } catch (l) {
      ht(e, e.return, l)
    }
    e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}
function J4(e, t, n) {
  ;(le = e), Hk(e)
}
function Hk(e, t, n) {
  for (var r = (e.mode & 1) !== 0; le !== null; ) {
    var o = le,
      i = o.child
    if (o.tag === 22 && r) {
      var s = o.memoizedState !== null || sd
      if (!s) {
        var a = o.alternate,
          l = (a !== null && a.memoizedState !== null) || Jt
        a = sd
        var c = Jt
        if (((sd = s), (Jt = l) && !c))
          for (le = o; le !== null; )
            (s = le),
              (l = s.child),
              s.tag === 22 && s.memoizedState !== null
                ? fw(o)
                : l !== null
                  ? ((l.return = s), (le = l))
                  : fw(o)
        for (; i !== null; ) (le = i), Hk(i), (i = i.sibling)
        ;(le = o), (sd = a), (Jt = c)
      }
      uw(e)
    } else
      o.subtreeFlags & 8772 && i !== null ? ((i.return = o), (le = i)) : uw(e)
  }
}
function uw(e) {
  for (; le !== null; ) {
    var t = le
    if (t.flags & 8772) {
      var n = t.alternate
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              Jt || uh(5, t)
              break
            case 1:
              var r = t.stateNode
              if (t.flags & 4 && !Jt)
                if (n === null) r.componentDidMount()
                else {
                  var o =
                    t.elementType === t.type
                      ? n.memoizedProps
                      : hr(t.type, n.memoizedProps)
                  r.componentDidUpdate(
                    o,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  )
                }
              var i = t.updateQueue
              i !== null && qx(t, i, r)
              break
            case 3:
              var s = t.updateQueue
              if (s !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode
                      break
                    case 1:
                      n = t.child.stateNode
                  }
                qx(t, s, n)
              }
              break
            case 5:
              var a = t.stateNode
              if (n === null && t.flags & 4) {
                n = a
                var l = t.memoizedProps
                switch (t.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus()
                    break
                  case "img":
                    l.src && (n.src = l.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (t.memoizedState === null) {
                var c = t.alternate
                if (c !== null) {
                  var u = c.memoizedState
                  if (u !== null) {
                    var d = u.dehydrated
                    d !== null && Tc(d)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(J(163))
          }
        Jt || (t.flags & 512 && Uv(t))
      } catch (f) {
        ht(t, t.return, f)
      }
    }
    if (t === e) {
      le = null
      break
    }
    if (((n = t.sibling), n !== null)) {
      ;(n.return = t.return), (le = n)
      break
    }
    le = t.return
  }
}
function dw(e) {
  for (; le !== null; ) {
    var t = le
    if (t === e) {
      le = null
      break
    }
    var n = t.sibling
    if (n !== null) {
      ;(n.return = t.return), (le = n)
      break
    }
    le = t.return
  }
}
function fw(e) {
  for (; le !== null; ) {
    var t = le
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return
          try {
            uh(4, t)
          } catch (l) {
            ht(t, n, l)
          }
          break
        case 1:
          var r = t.stateNode
          if (typeof r.componentDidMount == "function") {
            var o = t.return
            try {
              r.componentDidMount()
            } catch (l) {
              ht(t, o, l)
            }
          }
          var i = t.return
          try {
            Uv(t)
          } catch (l) {
            ht(t, i, l)
          }
          break
        case 5:
          var s = t.return
          try {
            Uv(t)
          } catch (l) {
            ht(t, s, l)
          }
      }
    } catch (l) {
      ht(t, t.return, l)
    }
    if (t === e) {
      le = null
      break
    }
    var a = t.sibling
    if (a !== null) {
      ;(a.return = t.return), (le = a)
      break
    }
    le = t.return
  }
}
var e3 = Math.ceil,
  Af = Do.ReactCurrentDispatcher,
  z0 = Do.ReactCurrentOwner,
  rr = Do.ReactCurrentBatchConfig,
  Be = 0,
  $t = null,
  Ct = null,
  qt = 0,
  In = 0,
  ya = Ai(0),
  Ot = 0,
  jc = null,
  gs = 0,
  dh = 0,
  U0 = 0,
  oc = null,
  En = null,
  V0 = 0,
  za = 1 / 0,
  po = null,
  Rf = !1,
  Wv = null,
  ci = null,
  ad = !1,
  Qo = null,
  If = 0,
  ic = 0,
  Kv = null,
  Qd = -1,
  Jd = 0
function hn() {
  return Be & 6 ? xt() : Qd !== -1 ? Qd : (Qd = xt())
}
function ui(e) {
  return e.mode & 1
    ? Be & 2 && qt !== 0
      ? qt & -qt
      : $4.transition !== null
        ? (Jd === 0 && (Jd = T_()), Jd)
        : ((e = Ve),
          e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : L_(e.type))),
          e)
    : 1
}
function Sr(e, t, n, r) {
  if (50 < ic) throw ((ic = 0), (Kv = null), Error(J(185)))
  wu(e, n, r),
    (!(Be & 2) || e !== $t) &&
      (e === $t && (!(Be & 2) && (dh |= n), Ot === 4 && Go(e, qt)),
      Nn(e, r),
      n === 1 && Be === 0 && !(t.mode & 1) && ((za = xt() + 500), ah && Ri()))
}
function Nn(e, t) {
  var n = e.callbackNode
  $5(e, t)
  var r = gf(e, e === $t ? qt : 0)
  if (r === 0)
    n !== null && wx(n), (e.callbackNode = null), (e.callbackPriority = 0)
  else if (((t = r & -r), e.callbackPriority !== t)) {
    if ((n != null && wx(n), t === 1))
      e.tag === 0 ? P4(pw.bind(null, e)) : ek(pw.bind(null, e)),
        R4(function () {
          !(Be & 6) && Ri()
        }),
        (n = null)
    else {
      switch (M_(r)) {
        case 1:
          n = m0
          break
        case 4:
          n = k_
          break
        case 16:
          n = mf
          break
        case 536870912:
          n = N_
          break
        default:
          n = mf
      }
      n = Qk(n, Wk.bind(null, e))
    }
    ;(e.callbackPriority = t), (e.callbackNode = n)
  }
}
function Wk(e, t) {
  if (((Qd = -1), (Jd = 0), Be & 6)) throw Error(J(327))
  var n = e.callbackNode
  if (Na() && e.callbackNode !== n) return null
  var r = gf(e, e === $t ? qt : 0)
  if (r === 0) return null
  if (r & 30 || r & e.expiredLanes || t) t = Df(e, r)
  else {
    t = r
    var o = Be
    Be |= 2
    var i = Gk()
    ;($t !== e || qt !== t) && ((po = null), (za = xt() + 500), es(e, t))
    do
      try {
        r3()
        break
      } catch (a) {
        Kk(e, a)
      }
    while (1)
    T0(),
      (Af.current = i),
      (Be = o),
      Ct !== null ? (t = 0) : (($t = null), (qt = 0), (t = Ot))
  }
  if (t !== 0) {
    if (
      (t === 2 && ((o = bv(e)), o !== 0 && ((r = o), (t = Gv(e, o)))), t === 1)
    )
      throw ((n = jc), es(e, 0), Go(e, r), Nn(e, xt()), n)
    if (t === 6) Go(e, r)
    else {
      if (
        ((o = e.current.alternate),
        !(r & 30) &&
          !t3(o) &&
          ((t = Df(e, r)),
          t === 2 && ((i = bv(e)), i !== 0 && ((r = i), (t = Gv(e, i)))),
          t === 1))
      )
        throw ((n = jc), es(e, 0), Go(e, r), Nn(e, xt()), n)
      switch (((e.finishedWork = o), (e.finishedLanes = r), t)) {
        case 0:
        case 1:
          throw Error(J(345))
        case 2:
          Ui(e, En, po)
          break
        case 3:
          if (
            (Go(e, r), (r & 130023424) === r && ((t = V0 + 500 - xt()), 10 < t))
          ) {
            if (gf(e, 0) !== 0) break
            if (((o = e.suspendedLanes), (o & r) !== r)) {
              hn(), (e.pingedLanes |= e.suspendedLanes & o)
              break
            }
            e.timeoutHandle = Nv(Ui.bind(null, e, En, po), t)
            break
          }
          Ui(e, En, po)
          break
        case 4:
          if ((Go(e, r), (r & 4194240) === r)) break
          for (t = e.eventTimes, o = -1; 0 < r; ) {
            var s = 31 - Cr(r)
            ;(i = 1 << s), (s = t[s]), s > o && (o = s), (r &= ~i)
          }
          if (
            ((r = o),
            (r = xt() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                  ? 480
                  : 1080 > r
                    ? 1080
                    : 1920 > r
                      ? 1920
                      : 3e3 > r
                        ? 3e3
                        : 4320 > r
                          ? 4320
                          : 1960 * e3(r / 1960)) - r),
            10 < r)
          ) {
            e.timeoutHandle = Nv(Ui.bind(null, e, En, po), r)
            break
          }
          Ui(e, En, po)
          break
        case 5:
          Ui(e, En, po)
          break
        default:
          throw Error(J(329))
      }
    }
  }
  return Nn(e, xt()), e.callbackNode === n ? Wk.bind(null, e) : null
}
function Gv(e, t) {
  var n = oc
  return (
    e.current.memoizedState.isDehydrated && (es(e, t).flags |= 256),
    (e = Df(e, t)),
    e !== 2 && ((t = En), (En = n), t !== null && qv(t)),
    e
  )
}
function qv(e) {
  En === null ? (En = e) : En.push.apply(En, e)
}
function t3(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var o = n[r],
            i = o.getSnapshot
          o = o.value
          try {
            if (!kr(i(), o)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null))
      (n.return = t), (t = n)
    else {
      if (t === e) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0
        t = t.return
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  return !0
}
function Go(e, t) {
  for (
    t &= ~U0,
      t &= ~dh,
      e.suspendedLanes |= t,
      e.pingedLanes &= ~t,
      e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - Cr(t),
      r = 1 << n
    ;(e[n] = -1), (t &= ~r)
  }
}
function pw(e) {
  if (Be & 6) throw Error(J(327))
  Na()
  var t = gf(e, 0)
  if (!(t & 1)) return Nn(e, xt()), null
  var n = Df(e, t)
  if (e.tag !== 0 && n === 2) {
    var r = bv(e)
    r !== 0 && ((t = r), (n = Gv(e, r)))
  }
  if (n === 1) throw ((n = jc), es(e, 0), Go(e, t), Nn(e, xt()), n)
  if (n === 6) throw Error(J(345))
  return (
    (e.finishedWork = e.current.alternate),
    (e.finishedLanes = t),
    Ui(e, En, po),
    Nn(e, xt()),
    null
  )
}
function H0(e, t) {
  var n = Be
  Be |= 1
  try {
    return e(t)
  } finally {
    ;(Be = n), Be === 0 && ((za = xt() + 500), ah && Ri())
  }
}
function vs(e) {
  Qo !== null && Qo.tag === 0 && !(Be & 6) && Na()
  var t = Be
  Be |= 1
  var n = rr.transition,
    r = Ve
  try {
    if (((rr.transition = null), (Ve = 1), e)) return e()
  } finally {
    ;(Ve = r), (rr.transition = n), (Be = t), !(Be & 6) && Ri()
  }
}
function W0() {
  ;(In = ya.current), Je(ya)
}
function es(e, t) {
  ;(e.finishedWork = null), (e.finishedLanes = 0)
  var n = e.timeoutHandle
  if ((n !== -1 && ((e.timeoutHandle = -1), A4(n)), Ct !== null))
    for (n = Ct.return; n !== null; ) {
      var r = n
      switch ((_0(r), r.tag)) {
        case 1:
          ;(r = r.type.childContextTypes), r != null && wf()
          break
        case 3:
          ja(), Je(_n), Je(nn), D0()
          break
        case 5:
          I0(r)
          break
        case 4:
          ja()
          break
        case 13:
          Je(it)
          break
        case 19:
          Je(it)
          break
        case 10:
          M0(r.type._context)
          break
        case 22:
        case 23:
          W0()
      }
      n = n.return
    }
  if (
    (($t = e),
    (Ct = e = di(e.current, null)),
    (qt = In = t),
    (Ot = 0),
    (jc = null),
    (U0 = dh = gs = 0),
    (En = oc = null),
    Gi !== null)
  ) {
    for (t = 0; t < Gi.length; t++)
      if (((n = Gi[t]), (r = n.interleaved), r !== null)) {
        n.interleaved = null
        var o = r.next,
          i = n.pending
        if (i !== null) {
          var s = i.next
          ;(i.next = o), (r.next = s)
        }
        n.pending = r
      }
    Gi = null
  }
  return e
}
function Kk(e, t) {
  do {
    var n = Ct
    try {
      if ((T0(), (Zd.current = Of), Mf)) {
        for (var r = st.memoizedState; r !== null; ) {
          var o = r.queue
          o !== null && (o.pending = null), (r = r.next)
        }
        Mf = !1
      }
      if (
        ((ms = 0),
        (It = Tt = st = null),
        (nc = !1),
        (Pc = 0),
        (z0.current = null),
        n === null || n.return === null)
      ) {
        ;(Ot = 1), (jc = t), (Ct = null)
        break
      }
      e: {
        var i = e,
          s = n.return,
          a = n,
          l = t
        if (
          ((t = qt),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            d = u.tag
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var f = u.alternate
            f
              ? ((u.updateQueue = f.updateQueue),
                (u.memoizedState = f.memoizedState),
                (u.lanes = f.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null))
          }
          var p = ew(s)
          if (p !== null) {
            ;(p.flags &= -257),
              tw(p, s, a, i, t),
              p.mode & 1 && Jx(i, c, t),
              (t = p),
              (l = c)
            var g = t.updateQueue
            if (g === null) {
              var v = new Set()
              v.add(l), (t.updateQueue = v)
            } else g.add(l)
            break e
          } else {
            if (!(t & 1)) {
              Jx(i, c, t), K0()
              break e
            }
            l = Error(J(426))
          }
        } else if (nt && a.mode & 1) {
          var b = ew(s)
          if (b !== null) {
            !(b.flags & 65536) && (b.flags |= 256),
              tw(b, s, a, i, t),
              k0(Fa(l, a))
            break e
          }
        }
        ;(i = l = Fa(l, a)),
          Ot !== 4 && (Ot = 2),
          oc === null ? (oc = [i]) : oc.push(i),
          (i = s)
        do {
          switch (i.tag) {
            case 3:
              ;(i.flags |= 65536), (t &= -t), (i.lanes |= t)
              var y = Mk(i, l, t)
              Gx(i, y)
              break e
            case 1:
              a = l
              var x = i.type,
                E = i.stateNode
              if (
                !(i.flags & 128) &&
                (typeof x.getDerivedStateFromError == "function" ||
                  (E !== null &&
                    typeof E.componentDidCatch == "function" &&
                    (ci === null || !ci.has(E))))
              ) {
                ;(i.flags |= 65536), (t &= -t), (i.lanes |= t)
                var w = Ok(i, a, t)
                Gx(i, w)
                break e
              }
          }
          i = i.return
        } while (i !== null)
      }
      Zk(n)
    } catch (C) {
      ;(t = C), Ct === n && n !== null && (Ct = n = n.return)
      continue
    }
    break
  } while (1)
}
function Gk() {
  var e = Af.current
  return (Af.current = Of), e === null ? Of : e
}
function K0() {
  ;(Ot === 0 || Ot === 3 || Ot === 2) && (Ot = 4),
    $t === null || (!(gs & 268435455) && !(dh & 268435455)) || Go($t, qt)
}
function Df(e, t) {
  var n = Be
  Be |= 2
  var r = Gk()
  ;($t !== e || qt !== t) && ((po = null), es(e, t))
  do
    try {
      n3()
      break
    } catch (o) {
      Kk(e, o)
    }
  while (1)
  if ((T0(), (Be = n), (Af.current = r), Ct !== null)) throw Error(J(261))
  return ($t = null), (qt = 0), Ot
}
function n3() {
  for (; Ct !== null; ) qk(Ct)
}
function r3() {
  for (; Ct !== null && !T5(); ) qk(Ct)
}
function qk(e) {
  var t = Xk(e.alternate, e, In)
  ;(e.memoizedProps = e.pendingProps),
    t === null ? Zk(e) : (Ct = t),
    (z0.current = null)
}
function Zk(e) {
  var t = e
  do {
    var n = t.alternate
    if (((e = t.return), t.flags & 32768)) {
      if (((n = Y4(n, t)), n !== null)) {
        ;(n.flags &= 32767), (Ct = n)
        return
      }
      if (e !== null)
        (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null)
      else {
        ;(Ot = 6), (Ct = null)
        return
      }
    } else if (((n = Z4(n, t, In)), n !== null)) {
      Ct = n
      return
    }
    if (((t = t.sibling), t !== null)) {
      Ct = t
      return
    }
    Ct = t = e
  } while (t !== null)
  Ot === 0 && (Ot = 5)
}
function Ui(e, t, n) {
  var r = Ve,
    o = rr.transition
  try {
    ;(rr.transition = null), (Ve = 1), o3(e, t, n, r)
  } finally {
    ;(rr.transition = o), (Ve = r)
  }
  return null
}
function o3(e, t, n, r) {
  do Na()
  while (Qo !== null)
  if (Be & 6) throw Error(J(327))
  n = e.finishedWork
  var o = e.finishedLanes
  if (n === null) return null
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current))
    throw Error(J(177))
  ;(e.callbackNode = null), (e.callbackPriority = 0)
  var i = n.lanes | n.childLanes
  if (
    (B5(e, i),
    e === $t && ((Ct = $t = null), (qt = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      ad ||
      ((ad = !0),
      Qk(mf, function () {
        return Na(), null
      })),
    (i = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || i)
  ) {
    ;(i = rr.transition), (rr.transition = null)
    var s = Ve
    Ve = 1
    var a = Be
    ;(Be |= 4),
      (z0.current = null),
      Q4(e, n),
      Vk(n, e),
      S4(_v),
      (vf = !!Sv),
      (_v = Sv = null),
      (e.current = n),
      J4(n),
      M5(),
      (Be = a),
      (Ve = s),
      (rr.transition = i)
  } else e.current = n
  if (
    (ad && ((ad = !1), (Qo = e), (If = o)),
    (i = e.pendingLanes),
    i === 0 && (ci = null),
    R5(n.stateNode),
    Nn(e, xt()),
    t !== null)
  )
    for (r = e.onRecoverableError, n = 0; n < t.length; n++)
      (o = t[n]), r(o.value, { componentStack: o.stack, digest: o.digest })
  if (Rf) throw ((Rf = !1), (e = Wv), (Wv = null), e)
  return (
    If & 1 && e.tag !== 0 && Na(),
    (i = e.pendingLanes),
    i & 1 ? (e === Kv ? ic++ : ((ic = 0), (Kv = e))) : (ic = 0),
    Ri(),
    null
  )
}
function Na() {
  if (Qo !== null) {
    var e = M_(If),
      t = rr.transition,
      n = Ve
    try {
      if (((rr.transition = null), (Ve = 16 > e ? 16 : e), Qo === null))
        var r = !1
      else {
        if (((e = Qo), (Qo = null), (If = 0), Be & 6)) throw Error(J(331))
        var o = Be
        for (Be |= 4, le = e.current; le !== null; ) {
          var i = le,
            s = i.child
          if (le.flags & 16) {
            var a = i.deletions
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l]
                for (le = c; le !== null; ) {
                  var u = le
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      rc(8, u, i)
                  }
                  var d = u.child
                  if (d !== null) (d.return = u), (le = d)
                  else
                    for (; le !== null; ) {
                      u = le
                      var f = u.sibling,
                        p = u.return
                      if ((Fk(u), u === c)) {
                        le = null
                        break
                      }
                      if (f !== null) {
                        ;(f.return = p), (le = f)
                        break
                      }
                      le = p
                    }
                }
              }
              var g = i.alternate
              if (g !== null) {
                var v = g.child
                if (v !== null) {
                  g.child = null
                  do {
                    var b = v.sibling
                    ;(v.sibling = null), (v = b)
                  } while (v !== null)
                }
              }
              le = i
            }
          }
          if (i.subtreeFlags & 2064 && s !== null) (s.return = i), (le = s)
          else
            e: for (; le !== null; ) {
              if (((i = le), i.flags & 2048))
                switch (i.tag) {
                  case 0:
                  case 11:
                  case 15:
                    rc(9, i, i.return)
                }
              var y = i.sibling
              if (y !== null) {
                ;(y.return = i.return), (le = y)
                break e
              }
              le = i.return
            }
        }
        var x = e.current
        for (le = x; le !== null; ) {
          s = le
          var E = s.child
          if (s.subtreeFlags & 2064 && E !== null) (E.return = s), (le = E)
          else
            e: for (s = x; le !== null; ) {
              if (((a = le), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      uh(9, a)
                  }
                } catch (C) {
                  ht(a, a.return, C)
                }
              if (a === s) {
                le = null
                break e
              }
              var w = a.sibling
              if (w !== null) {
                ;(w.return = a.return), (le = w)
                break e
              }
              le = a.return
            }
        }
        if (
          ((Be = o), Ri(), Wr && typeof Wr.onPostCommitFiberRoot == "function")
        )
          try {
            Wr.onPostCommitFiberRoot(nh, e)
          } catch {}
        r = !0
      }
      return r
    } finally {
      ;(Ve = n), (rr.transition = t)
    }
  }
  return !1
}
function hw(e, t, n) {
  ;(t = Fa(n, t)),
    (t = Mk(e, t, 1)),
    (e = li(e, t, 1)),
    (t = hn()),
    e !== null && (wu(e, 1, t), Nn(e, t))
}
function ht(e, t, n) {
  if (e.tag === 3) hw(e, e, n)
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        hw(t, e, n)
        break
      } else if (t.tag === 1) {
        var r = t.stateNode
        if (
          typeof t.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (ci === null || !ci.has(r)))
        ) {
          ;(e = Fa(n, e)),
            (e = Ok(t, e, 1)),
            (t = li(t, e, 1)),
            (e = hn()),
            t !== null && (wu(t, 1, e), Nn(t, e))
          break
        }
      }
      t = t.return
    }
}
function i3(e, t, n) {
  var r = e.pingCache
  r !== null && r.delete(t),
    (t = hn()),
    (e.pingedLanes |= e.suspendedLanes & n),
    $t === e &&
      (qt & n) === n &&
      (Ot === 4 || (Ot === 3 && (qt & 130023424) === qt && 500 > xt() - V0)
        ? es(e, 0)
        : (U0 |= n)),
    Nn(e, t)
}
function Yk(e, t) {
  t === 0 &&
    (e.mode & 1
      ? ((t = Xu), (Xu <<= 1), !(Xu & 130023424) && (Xu = 4194304))
      : (t = 1))
  var n = hn()
  ;(e = To(e, t)), e !== null && (wu(e, t, n), Nn(e, n))
}
function s3(e) {
  var t = e.memoizedState,
    n = 0
  t !== null && (n = t.retryLane), Yk(e, n)
}
function a3(e, t) {
  var n = 0
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        o = e.memoizedState
      o !== null && (n = o.retryLane)
      break
    case 19:
      r = e.stateNode
      break
    default:
      throw Error(J(314))
  }
  r !== null && r.delete(t), Yk(e, n)
}
var Xk
Xk = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || _n.current) Sn = !0
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return (Sn = !1), q4(e, t, n)
      Sn = !!(e.flags & 131072)
    }
  else (Sn = !1), nt && t.flags & 1048576 && tk(t, Sf, t.index)
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var r = t.type
      Xd(e, t), (e = t.pendingProps)
      var o = Pa(t, nn.current)
      ka(t, n), (o = P0(null, t, r, e, o, n))
      var i = $0()
      return (
        (t.flags |= 1),
        typeof o == "object" &&
        o !== null &&
        typeof o.render == "function" &&
        o.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            kn(r) ? ((i = !0), Ef(t)) : (i = !1),
            (t.memoizedState =
              o.state !== null && o.state !== void 0 ? o.state : null),
            A0(t),
            (o.updater = ch),
            (t.stateNode = o),
            (o._reactInternals = t),
            Dv(t, r, e, n),
            (t = $v(null, t, r, !0, i, n)))
          : ((t.tag = 0), nt && i && S0(t), dn(null, t, o, n), (t = t.child)),
        t
      )
    case 16:
      r = t.elementType
      e: {
        switch (
          (Xd(e, t),
          (e = t.pendingProps),
          (o = r._init),
          (r = o(r._payload)),
          (t.type = r),
          (o = t.tag = c3(r)),
          (e = hr(r, e)),
          o)
        ) {
          case 0:
            t = Pv(null, t, r, e, n)
            break e
          case 1:
            t = ow(null, t, r, e, n)
            break e
          case 11:
            t = nw(null, t, r, e, n)
            break e
          case 14:
            t = rw(null, t, r, hr(r.type, e), n)
            break e
        }
        throw Error(J(306, r, ""))
      }
      return t
    case 0:
      return (
        (r = t.type),
        (o = t.pendingProps),
        (o = t.elementType === r ? o : hr(r, o)),
        Pv(e, t, r, o, n)
      )
    case 1:
      return (
        (r = t.type),
        (o = t.pendingProps),
        (o = t.elementType === r ? o : hr(r, o)),
        ow(e, t, r, o, n)
      )
    case 3:
      e: {
        if ((Dk(t), e === null)) throw Error(J(387))
        ;(r = t.pendingProps),
          (i = t.memoizedState),
          (o = i.element),
          ak(e, t),
          Nf(t, r, null, n)
        var s = t.memoizedState
        if (((r = s.element), i.isDehydrated))
          if (
            ((i = {
              element: r,
              isDehydrated: !1,
              cache: s.cache,
              pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
              transitions: s.transitions,
            }),
            (t.updateQueue.baseState = i),
            (t.memoizedState = i),
            t.flags & 256)
          ) {
            ;(o = Fa(Error(J(423)), t)), (t = iw(e, t, r, n, o))
            break e
          } else if (r !== o) {
            ;(o = Fa(Error(J(424)), t)), (t = iw(e, t, r, n, o))
            break e
          } else
            for (
              $n = ai(t.stateNode.containerInfo.firstChild),
                Bn = t,
                nt = !0,
                gr = null,
                n = ik(t, null, r, n),
                t.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling)
        else {
          if (($a(), r === o)) {
            t = Mo(e, t, n)
            break e
          }
          dn(e, t, r, n)
        }
        t = t.child
      }
      return t
    case 5:
      return (
        lk(t),
        e === null && Av(t),
        (r = t.type),
        (o = t.pendingProps),
        (i = e !== null ? e.memoizedProps : null),
        (s = o.children),
        kv(r, o) ? (s = null) : i !== null && kv(r, i) && (t.flags |= 32),
        Ik(e, t),
        dn(e, t, s, n),
        t.child
      )
    case 6:
      return e === null && Av(t), null
    case 13:
      return Lk(e, t, n)
    case 4:
      return (
        R0(t, t.stateNode.containerInfo),
        (r = t.pendingProps),
        e === null ? (t.child = Ba(t, null, r, n)) : dn(e, t, r, n),
        t.child
      )
    case 11:
      return (
        (r = t.type),
        (o = t.pendingProps),
        (o = t.elementType === r ? o : hr(r, o)),
        nw(e, t, r, o, n)
      )
    case 7:
      return dn(e, t, t.pendingProps, n), t.child
    case 8:
      return dn(e, t, t.pendingProps.children, n), t.child
    case 12:
      return dn(e, t, t.pendingProps.children, n), t.child
    case 10:
      e: {
        if (
          ((r = t.type._context),
          (o = t.pendingProps),
          (i = t.memoizedProps),
          (s = o.value),
          Ge(_f, r._currentValue),
          (r._currentValue = s),
          i !== null)
        )
          if (kr(i.value, s)) {
            if (i.children === o.children && !_n.current) {
              t = Mo(e, t, n)
              break e
            }
          } else
            for (i = t.child, i !== null && (i.return = t); i !== null; ) {
              var a = i.dependencies
              if (a !== null) {
                s = i.child
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (i.tag === 1) {
                      ;(l = Eo(-1, n & -n)), (l.tag = 2)
                      var c = i.updateQueue
                      if (c !== null) {
                        c = c.shared
                        var u = c.pending
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l)
                      }
                    }
                    ;(i.lanes |= n),
                      (l = i.alternate),
                      l !== null && (l.lanes |= n),
                      Rv(i.return, n, t),
                      (a.lanes |= n)
                    break
                  }
                  l = l.next
                }
              } else if (i.tag === 10) s = i.type === t.type ? null : i.child
              else if (i.tag === 18) {
                if (((s = i.return), s === null)) throw Error(J(341))
                ;(s.lanes |= n),
                  (a = s.alternate),
                  a !== null && (a.lanes |= n),
                  Rv(s, n, t),
                  (s = i.sibling)
              } else s = i.child
              if (s !== null) s.return = i
              else
                for (s = i; s !== null; ) {
                  if (s === t) {
                    s = null
                    break
                  }
                  if (((i = s.sibling), i !== null)) {
                    ;(i.return = s.return), (s = i)
                    break
                  }
                  s = s.return
                }
              i = s
            }
        dn(e, t, o.children, n), (t = t.child)
      }
      return t
    case 9:
      return (
        (o = t.type),
        (r = t.pendingProps.children),
        ka(t, n),
        (o = lr(o)),
        (r = r(o)),
        (t.flags |= 1),
        dn(e, t, r, n),
        t.child
      )
    case 14:
      return (
        (r = t.type),
        (o = hr(r, t.pendingProps)),
        (o = hr(r.type, o)),
        rw(e, t, r, o, n)
      )
    case 15:
      return Ak(e, t, t.type, t.pendingProps, n)
    case 17:
      return (
        (r = t.type),
        (o = t.pendingProps),
        (o = t.elementType === r ? o : hr(r, o)),
        Xd(e, t),
        (t.tag = 1),
        kn(r) ? ((e = !0), Ef(t)) : (e = !1),
        ka(t, n),
        Tk(t, r, o),
        Dv(t, r, o, n),
        $v(null, t, r, !0, e, n)
      )
    case 19:
      return Pk(e, t, n)
    case 22:
      return Rk(e, t, n)
  }
  throw Error(J(156, t.tag))
}
function Qk(e, t) {
  return __(e, t)
}
function l3(e, t, n, r) {
  ;(this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null)
}
function nr(e, t, n, r) {
  return new l3(e, t, n, r)
}
function G0(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent)
}
function c3(e) {
  if (typeof e == "function") return G0(e) ? 1 : 0
  if (e != null) {
    if (((e = e.$$typeof), e === f0)) return 11
    if (e === p0) return 14
  }
  return 2
}
function di(e, t) {
  var n = e.alternate
  return (
    n === null
      ? ((n = nr(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies =
      t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  )
}
function ef(e, t, n, r, o, i) {
  var s = 2
  if (((r = e), typeof e == "function")) G0(e) && (s = 1)
  else if (typeof e == "string") s = 5
  else
    e: switch (e) {
      case la:
        return ts(n.children, o, i, t)
      case d0:
        ;(s = 8), (o |= 8)
        break
      case ov:
        return (e = nr(12, n, t, o | 2)), (e.elementType = ov), (e.lanes = i), e
      case iv:
        return (e = nr(13, n, t, o)), (e.elementType = iv), (e.lanes = i), e
      case sv:
        return (e = nr(19, n, t, o)), (e.elementType = sv), (e.lanes = i), e
      case l_:
        return fh(n, o, i, t)
      default:
        if (typeof e == "object" && e !== null)
          switch (e.$$typeof) {
            case s_:
              s = 10
              break e
            case a_:
              s = 9
              break e
            case f0:
              s = 11
              break e
            case p0:
              s = 14
              break e
            case zo:
              ;(s = 16), (r = null)
              break e
          }
        throw Error(J(130, e == null ? e : typeof e, ""))
    }
  return (
    (t = nr(s, n, t, o)), (t.elementType = e), (t.type = r), (t.lanes = i), t
  )
}
function ts(e, t, n, r) {
  return (e = nr(7, e, r, t)), (e.lanes = n), e
}
function fh(e, t, n, r) {
  return (
    (e = nr(22, e, r, t)),
    (e.elementType = l_),
    (e.lanes = n),
    (e.stateNode = { isHidden: !1 }),
    e
  )
}
function qm(e, t, n) {
  return (e = nr(6, e, null, t)), (e.lanes = n), e
}
function Zm(e, t, n) {
  return (
    (t = nr(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation,
    }),
    t
  )
}
function u3(e, t, n, r, o) {
  ;(this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Mm(0)),
    (this.expirationTimes = Mm(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Mm(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = o),
    (this.mutableSourceEagerHydrationData = null)
}
function q0(e, t, n, r, o, i, s, a, l) {
  return (
    (e = new u3(e, t, n, a, l)),
    t === 1 ? ((t = 1), i === !0 && (t |= 8)) : (t = 0),
    (i = nr(3, null, null, t)),
    (e.current = i),
    (i.stateNode = e),
    (i.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    A0(i),
    e
  )
}
function d3(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: aa,
    key: r == null ? null : "" + r,
    children: e,
    containerInfo: t,
    implementation: n,
  }
}
function Jk(e) {
  if (!e) return wi
  e = e._reactInternals
  e: {
    if (As(e) !== e || e.tag !== 1) throw Error(J(170))
    var t = e
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context
          break e
        case 1:
          if (kn(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext
            break e
          }
      }
      t = t.return
    } while (t !== null)
    throw Error(J(171))
  }
  if (e.tag === 1) {
    var n = e.type
    if (kn(n)) return J_(e, n, t)
  }
  return t
}
function eN(e, t, n, r, o, i, s, a, l) {
  return (
    (e = q0(n, r, !0, e, o, i, s, a, l)),
    (e.context = Jk(null)),
    (n = e.current),
    (r = hn()),
    (o = ui(n)),
    (i = Eo(r, o)),
    (i.callback = t != null ? t : null),
    li(n, i, o),
    (e.current.lanes = o),
    wu(e, o, r),
    Nn(e, r),
    e
  )
}
function ph(e, t, n, r) {
  var o = t.current,
    i = hn(),
    s = ui(o)
  return (
    (n = Jk(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = Eo(i, s)),
    (t.payload = { element: e }),
    (r = r === void 0 ? null : r),
    r !== null && (t.callback = r),
    (e = li(o, t, s)),
    e !== null && (Sr(e, o, s, i), qd(e, o, s)),
    s
  )
}
function Lf(e) {
  if (((e = e.current), !e.child)) return null
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode
    default:
      return e.child.stateNode
  }
}
function mw(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane
    e.retryLane = n !== 0 && n < t ? n : t
  }
}
function Z0(e, t) {
  mw(e, t), (e = e.alternate) && mw(e, t)
}
function f3() {
  return null
}
var tN =
  typeof reportError == "function"
    ? reportError
    : function (e) {
        console.error(e)
      }
function Y0(e) {
  this._internalRoot = e
}
hh.prototype.render = Y0.prototype.render = function (e) {
  var t = this._internalRoot
  if (t === null) throw Error(J(409))
  ph(e, t, null, null)
}
hh.prototype.unmount = Y0.prototype.unmount = function () {
  var e = this._internalRoot
  if (e !== null) {
    this._internalRoot = null
    var t = e.containerInfo
    vs(function () {
      ph(null, e, null, null)
    }),
      (t[No] = null)
  }
}
function hh(e) {
  this._internalRoot = e
}
hh.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = R_()
    e = { blockedOn: null, target: e, priority: t }
    for (var n = 0; n < Ko.length && t !== 0 && t < Ko[n].priority; n++);
    Ko.splice(n, 0, e), n === 0 && D_(e)
  }
}
function X0(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11))
}
function mh(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
  )
}
function gw() {}
function p3(e, t, n, r, o) {
  if (o) {
    if (typeof r == "function") {
      var i = r
      r = function () {
        var c = Lf(s)
        i.call(c)
      }
    }
    var s = eN(t, r, e, 0, null, !1, !1, "", gw)
    return (
      (e._reactRootContainer = s),
      (e[No] = s.current),
      Ac(e.nodeType === 8 ? e.parentNode : e),
      vs(),
      s
    )
  }
  for (; (o = e.lastChild); ) e.removeChild(o)
  if (typeof r == "function") {
    var a = r
    r = function () {
      var c = Lf(l)
      a.call(c)
    }
  }
  var l = q0(e, 0, !1, null, null, !1, !1, "", gw)
  return (
    (e._reactRootContainer = l),
    (e[No] = l.current),
    Ac(e.nodeType === 8 ? e.parentNode : e),
    vs(function () {
      ph(t, l, n, r)
    }),
    l
  )
}
function gh(e, t, n, r, o) {
  var i = n._reactRootContainer
  if (i) {
    var s = i
    if (typeof o == "function") {
      var a = o
      o = function () {
        var l = Lf(s)
        a.call(l)
      }
    }
    ph(t, s, e, o)
  } else s = p3(n, t, e, o, r)
  return Lf(s)
}
O_ = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode
      if (t.current.memoizedState.isDehydrated) {
        var n = zl(t.pendingLanes)
        n !== 0 &&
          (g0(t, n | 1), Nn(t, xt()), !(Be & 6) && ((za = xt() + 500), Ri()))
      }
      break
    case 13:
      vs(function () {
        var r = To(e, 1)
        if (r !== null) {
          var o = hn()
          Sr(r, e, 1, o)
        }
      }),
        Z0(e, 1)
  }
}
v0 = function (e) {
  if (e.tag === 13) {
    var t = To(e, 134217728)
    if (t !== null) {
      var n = hn()
      Sr(t, e, 134217728, n)
    }
    Z0(e, 134217728)
  }
}
A_ = function (e) {
  if (e.tag === 13) {
    var t = ui(e),
      n = To(e, t)
    if (n !== null) {
      var r = hn()
      Sr(n, e, t, r)
    }
    Z0(e, t)
  }
}
R_ = function () {
  return Ve
}
I_ = function (e, t) {
  var n = Ve
  try {
    return (Ve = e), t()
  } finally {
    Ve = n
  }
}
gv = function (e, t, n) {
  switch (t) {
    case "input":
      if ((cv(e, n), (t = n.name), n.type === "radio" && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
          ),
            t = 0;
          t < n.length;
          t++
        ) {
          var r = n[t]
          if (r !== e && r.form === e.form) {
            var o = sh(r)
            if (!o) throw Error(J(90))
            u_(r), cv(r, o)
          }
        }
      }
      break
    case "textarea":
      f_(e, n)
      break
    case "select":
      ;(t = n.value), t != null && Ea(e, !!n.multiple, t, !1)
  }
}
b_ = H0
x_ = vs
var h3 = { usingClientEntryPoint: !1, Events: [Cu, fa, sh, v_, y_, H0] },
  Ol = {
    findFiberByHostInstance: Ki,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  m3 = {
    bundleType: Ol.bundleType,
    version: Ol.version,
    rendererPackageName: Ol.rendererPackageName,
    rendererConfig: Ol.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Do.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = C_(e)), e === null ? null : e.stateNode
    },
    findFiberByHostInstance: Ol.findFiberByHostInstance || f3,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var ld = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!ld.isDisabled && ld.supportsFiber)
    try {
      ;(nh = ld.inject(m3)), (Wr = ld)
    } catch {}
}
Vn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = h3
Vn.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!X0(t)) throw Error(J(200))
  return d3(e, t, null, n)
}
Vn.createRoot = function (e, t) {
  if (!X0(e)) throw Error(J(299))
  var n = !1,
    r = "",
    o = tN
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (t = q0(e, 1, !1, null, null, n, !1, r, o)),
    (e[No] = t.current),
    Ac(e.nodeType === 8 ? e.parentNode : e),
    new Y0(t)
  )
}
Vn.findDOMNode = function (e) {
  if (e == null) return null
  if (e.nodeType === 1) return e
  var t = e._reactInternals
  if (t === void 0)
    throw typeof e.render == "function"
      ? Error(J(188))
      : ((e = Object.keys(e).join(",")), Error(J(268, e)))
  return (e = C_(t)), (e = e === null ? null : e.stateNode), e
}
Vn.flushSync = function (e) {
  return vs(e)
}
Vn.hydrate = function (e, t, n) {
  if (!mh(t)) throw Error(J(200))
  return gh(null, e, t, !0, n)
}
Vn.hydrateRoot = function (e, t, n) {
  if (!X0(e)) throw Error(J(405))
  var r = (n != null && n.hydratedSources) || null,
    o = !1,
    i = "",
    s = tN
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (o = !0),
      n.identifierPrefix !== void 0 && (i = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (s = n.onRecoverableError)),
    (t = eN(t, null, e, 1, n != null ? n : null, o, !1, i, s)),
    (e[No] = t.current),
    Ac(e),
    r)
  )
    for (e = 0; e < r.length; e++)
      (n = r[e]),
        (o = n._getVersion),
        (o = o(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, o])
          : t.mutableSourceEagerHydrationData.push(n, o)
  return new hh(t)
}
Vn.render = function (e, t, n) {
  if (!mh(t)) throw Error(J(200))
  return gh(null, e, t, !1, n)
}
Vn.unmountComponentAtNode = function (e) {
  if (!mh(e)) throw Error(J(40))
  return e._reactRootContainer
    ? (vs(function () {
        gh(null, null, e, !1, function () {
          ;(e._reactRootContainer = null), (e[No] = null)
        })
      }),
      !0)
    : !1
}
Vn.unstable_batchedUpdates = H0
Vn.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!mh(n)) throw Error(J(200))
  if (e == null || e._reactInternals === void 0) throw Error(J(38))
  return gh(e, t, n, !1, r)
}
Vn.version = "18.3.1-next-f1338f8080-20240426"
function nN() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(nN)
    } catch (e) {
      console.error(e)
    }
}
nN(), (n_.exports = Vn)
var Rs = n_.exports
const vh = n0(Rs)
var vw = Rs
;(nv.createRoot = vw.createRoot), (nv.hydrateRoot = vw.hydrateRoot)
function g3(e, t) {
  if (e instanceof RegExp) return { keys: !1, pattern: e }
  var n,
    r,
    o,
    i,
    s = [],
    a = "",
    l = e.split("/")
  for (l[0] || l.shift(); (o = l.shift()); )
    (n = o[0]),
      n === "*"
        ? (s.push(n), (a += o[1] === "?" ? "(?:/(.*))?" : "/(.*)"))
        : n === ":"
          ? ((r = o.indexOf("?", 1)),
            (i = o.indexOf(".", 1)),
            s.push(o.substring(1, ~r ? r : ~i ? i : o.length)),
            (a += ~r && !~i ? "(?:/([^/]+?))?" : "/([^/]+?)"),
            ~i && (a += (~r ? "?" : "") + "\\" + o.substring(i)))
          : (a += "/" + o)
  return {
    keys: s,
    pattern: new RegExp("^" + a + (t ? "(?=$|/)" : "/?$"), "i"),
  }
}
var rN = { exports: {} },
  oN = {}
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ua = m
function v3(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var y3 = typeof Object.is == "function" ? Object.is : v3,
  b3 = Ua.useState,
  x3 = Ua.useEffect,
  w3 = Ua.useLayoutEffect,
  E3 = Ua.useDebugValue
function C3(e, t) {
  var n = t(),
    r = b3({ inst: { value: n, getSnapshot: t } }),
    o = r[0].inst,
    i = r[1]
  return (
    w3(
      function () {
        ;(o.value = n), (o.getSnapshot = t), Ym(o) && i({ inst: o })
      },
      [e, n, t]
    ),
    x3(
      function () {
        return (
          Ym(o) && i({ inst: o }),
          e(function () {
            Ym(o) && i({ inst: o })
          })
        )
      },
      [e]
    ),
    E3(n),
    n
  )
}
function Ym(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !y3(e, n)
  } catch {
    return !0
  }
}
function S3(e, t) {
  return t()
}
var _3 =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? S3
    : C3
oN.useSyncExternalStore =
  Ua.useSyncExternalStore !== void 0 ? Ua.useSyncExternalStore : _3
rN.exports = oN
var iN = rN.exports
const k3 = a0["useInsertionEffect"],
  N3 =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  T3 = N3 ? m.useLayoutEffect : m.useEffect,
  M3 = k3 || T3,
  sN = (e) => {
    const t = m.useRef([e, (...n) => t[0](...n)]).current
    return (
      M3(() => {
        t[0] = e
      }),
      t[1]
    )
  },
  O3 = "popstate",
  Q0 = "pushState",
  J0 = "replaceState",
  A3 = "hashchange",
  yw = [O3, Q0, J0, A3],
  R3 = (e) => {
    for (const t of yw) addEventListener(t, e)
    return () => {
      for (const t of yw) removeEventListener(t, e)
    }
  },
  aN = (e, t) => iN.useSyncExternalStore(R3, e, t),
  I3 = () => location.search,
  D3 = ({ ssrSearch: e = "" } = {}) => aN(I3, () => e),
  bw = () => location.pathname,
  L3 = ({ ssrPath: e } = {}) => aN(bw, e ? () => e : bw),
  P3 = (e, { replace: t = !1, state: n = null } = {}) =>
    history[t ? J0 : Q0](n, "", e),
  $3 = (e = {}) => [L3(e), P3],
  xw = Symbol.for("wouter_v3")
if (typeof history < "u" && typeof window[xw] > "u") {
  for (const e of [Q0, J0]) {
    const t = history[e]
    history[e] = function () {
      const n = t.apply(this, arguments),
        r = new Event(e)
      return (r.arguments = arguments), dispatchEvent(r), n
    }
  }
  Object.defineProperty(window, xw, { value: !0 })
}
const B3 = (e, t) =>
    t.toLowerCase().indexOf(e.toLowerCase())
      ? "~" + t
      : t.slice(e.length) || "/",
  lN = (e = "") => (e === "/" ? "" : e),
  j3 = (e, t) => (e[0] === "~" ? e.slice(1) : lN(t) + e),
  F3 = (e = "", t) => B3(ww(lN(e)), ww(t)),
  ww = (e) => {
    try {
      return decodeURI(e)
    } catch {
      return e
    }
  },
  cN = {
    hook: $3,
    searchHook: D3,
    parser: g3,
    base: "",
    ssrPath: void 0,
    ssrSearch: void 0,
    ssrContext: void 0,
    hrefs: (e) => e,
  },
  uN = m.createContext(cN),
  yh = () => m.useContext(uN),
  dN = {},
  fN = m.createContext(dN),
  z3 = () => m.useContext(fN),
  eb = (e) => {
    const [t, n] = e.hook(e)
    return [F3(e.base, t), sN((r, o) => n(j3(r, e.base), o))]
  },
  bh = () => eb(yh()),
  U3 = (e, t, n, r) => {
    const { pattern: o, keys: i } =
        t instanceof RegExp ? { keys: !1, pattern: t } : e(t || "*", r),
      s = o.exec(n) || [],
      [a, ...l] = s
    return a !== void 0
      ? [
          !0,
          (() => {
            const c =
              i !== !1
                ? Object.fromEntries(i.map((d, f) => [d, l[f]]))
                : s.groups
            let u = { ...l }
            return c && Object.assign(u, c), u
          })(),
          ...(r ? [a] : []),
        ]
      : [!1, null]
  },
  Zv = ({ children: e, ...t }) => {
    var u, d, f, p
    const n = yh(),
      r = t.hook ? cN : n
    let o = r
    const [i, s] =
      (d = (u = t.ssrPath) == null ? void 0 : u.split("?")) != null ? d : []
    s && ((t.ssrSearch = s), (t.ssrPath = i)),
      (t.hrefs =
        (p = t.hrefs) != null ? p : (f = t.hook) == null ? void 0 : f.hrefs)
    let a = m.useRef({}),
      l = a.current,
      c = l
    for (let g in r) {
      const v = g === "base" ? r[g] + (t[g] || "") : t[g] || r[g]
      l === c && v !== c[g] && (a.current = c = { ...c }),
        (c[g] = v),
        v !== r[g] && (o = c)
    }
    return m.createElement(uN.Provider, { value: o, children: e })
  },
  Ew = ({ children: e, component: t }, n) =>
    t ? m.createElement(t, { params: n }) : typeof e == "function" ? e(n) : e,
  V3 = (e) => {
    let t = m.useRef(dN)
    const n = t.current
    return (t.current =
      Object.keys(e).length !== Object.keys(n).length ||
      Object.entries(e).some(([r, o]) => o !== n[r])
        ? e
        : n)
  },
  cd = ({ path: e, nest: t, match: n, ...r }) => {
    const o = yh(),
      [i] = eb(o),
      [s, a, l] = n != null ? n : U3(o.parser, e, i, t),
      c = V3({ ...z3(), ...a })
    if (!s) return null
    const u = l ? m.createElement(Zv, { base: l }, Ew(r, c)) : Ew(r, c)
    return m.createElement(fN.Provider, { value: c, children: u })
  }
m.forwardRef((e, t) => {
  const n = yh(),
    [r, o] = eb(n),
    {
      to: i = "",
      href: s = i,
      onClick: a,
      asChild: l,
      children: c,
      className: u,
      replace: d,
      state: f,
      ...p
    } = e,
    g = sN((b) => {
      b.ctrlKey ||
        b.metaKey ||
        b.altKey ||
        b.shiftKey ||
        b.button !== 0 ||
        (a == null || a(b), b.defaultPrevented || (b.preventDefault(), o(s, e)))
    }),
    v = n.hrefs(s[0] === "~" ? s.slice(1) : n.base + s, n)
  return l && m.isValidElement(c)
    ? m.cloneElement(c, { onClick: g, href: v })
    : m.createElement("a", {
        ...p,
        onClick: g,
        href: v,
        className: u != null && u.call ? u(r === s) : u,
        children: c,
        ref: t,
      })
})
const Vl = { v: [] },
  Cw = () => Vl.v.forEach((e) => e()),
  H3 = (e) => (
    Vl.v.push(e) === 1 && addEventListener("hashchange", Cw),
    () => {
      ;(Vl.v = Vl.v.filter((t) => t !== e)),
        Vl.v.length || removeEventListener("hashchange", Cw)
    }
  ),
  W3 = () => "/" + location.hash.replace(/^#?\/?/, ""),
  K3 = (e, { state: t = null } = {}) => {
    const [n, r] = e.replace(/^#?\/?/, "").split("?")
    history.replaceState(
      t,
      "",
      location.pathname +
        (r ? `?${r}` : location.search) +
        (location.hash = `#/${n}`)
    )
  },
  Yv = ({ ssrPath: e = "/" } = {}) => [
    iN.useSyncExternalStore(H3, W3, () => e),
    K3,
  ]
Yv.hrefs = (e) => "#" + e
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const G3 = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  pN = (...e) =>
    e
      .filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n)
      .join(" ")
      .trim()
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var q3 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
}
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Z3 = m.forwardRef(
  (
    {
      color: e = "currentColor",
      size: t = 24,
      strokeWidth: n = 2,
      absoluteStrokeWidth: r,
      className: o = "",
      children: i,
      iconNode: s,
      ...a
    },
    l
  ) =>
    m.createElement(
      "svg",
      {
        ref: l,
        ...q3,
        width: t,
        height: t,
        stroke: e,
        strokeWidth: r ? (Number(n) * 24) / Number(t) : n,
        className: pN("lucide", o),
        ...a,
      },
      [
        ...s.map(([c, u]) => m.createElement(c, u)),
        ...(Array.isArray(i) ? i : [i]),
      ]
    )
)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const on = (e, t) => {
  const n = m.forwardRef(({ className: r, ...o }, i) =>
    m.createElement(Z3, {
      ref: i,
      iconNode: t,
      className: pN(`lucide-${G3(e)}`, r),
      ...o,
    })
  )
  return (n.displayName = `${e}`), n
}
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Y3 = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]],
  hN = on("Check", Y3)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const X3 = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]],
  Q3 = on("ChevronRight", X3)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const J3 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }],
  ],
  eL = on("CircleAlert", J3)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const tL = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]],
  mN = on("Circle", tL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const nL = [
    [
      "path",
      { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" },
    ],
    [
      "path",
      {
        d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
        key: "1d0kgt",
      },
    ],
  ],
  rL = on("House", nL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const oL = [
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }],
    ["path", { d: "M10.41 10.41a2 2 0 1 1-2.83-2.83", key: "1bzlo9" }],
    ["line", { x1: "13.5", x2: "6", y1: "13.5", y2: "21", key: "1q0aeu" }],
    ["line", { x1: "18", x2: "21", y1: "12", y2: "15", key: "5mozeu" }],
    [
      "path",
      {
        d: "M3.59 3.59A1.99 1.99 0 0 0 3 5v14a2 2 0 0 0 2 2h14c.55 0 1.052-.22 1.41-.59",
        key: "mmje98",
      },
    ],
    ["path", { d: "M21 15V5a2 2 0 0 0-2-2H9", key: "43el77" }],
  ],
  iL = on("ImageOff", oL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const sL = [
    [
      "rect",
      {
        width: "18",
        height: "18",
        x: "3",
        y: "3",
        rx: "2",
        ry: "2",
        key: "1m3agn",
      },
    ],
    ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
    ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }],
  ],
  aL = on("Image", sL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lL = [
    [
      "path",
      {
        d: "M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16",
        key: "tarvll",
      },
    ],
  ],
  cL = on("Laptop", lL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const uL = [
    ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
    ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
    ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }],
  ],
  dL = on("Link2", uL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const fL = [
    [
      "rect",
      { x: "3", y: "5", width: "6", height: "6", rx: "1", key: "1defrl" },
    ],
    ["path", { d: "m3 17 2 2 4-4", key: "1jhpwq" }],
    ["path", { d: "M13 6h8", key: "15sg57" }],
    ["path", { d: "M13 12h8", key: "h98zly" }],
    ["path", { d: "M13 18h8", key: "oe0vm4" }],
  ],
  pL = on("ListTodo", fL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const hL = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]],
  mL = on("LoaderCircle", hL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const gL = [
    ["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z", key: "a7tn18" }],
  ],
  vL = on("Moon", gL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yL = [
    [
      "rect",
      { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" },
    ],
    ["path", { d: "M9 3v18", key: "fh3hqa" }],
  ],
  bL = on("PanelLeft", yL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const xL = [
    ["path", { d: "M5 12h14", key: "1ays0h" }],
    ["path", { d: "M12 5v14", key: "s699le" }],
  ],
  wL = on("Plus", xL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const EL = [
    ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
    ["path", { d: "M12 2v2", key: "tus03m" }],
    ["path", { d: "M12 20v2", key: "1lh1kg" }],
    ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
    ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
    ["path", { d: "M2 12h2", key: "1t8f8n" }],
    ["path", { d: "M20 12h2", key: "1q8mjw" }],
    ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
    ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }],
  ],
  CL = on("Sun", EL)
/**
 * @license lucide-react v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const SL = [
    ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
    ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
  ],
  tb = on("X", SL)
function gN(e) {
  var t,
    n,
    r = ""
  if (typeof e == "string" || typeof e == "number") r += e
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var o = e.length
      for (t = 0; t < o; t++)
        e[t] && (n = gN(e[t])) && (r && (r += " "), (r += n))
    } else for (n in e) e[n] && (r && (r += " "), (r += n))
  return r
}
function vN() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++)
    (e = arguments[n]) && (t = gN(e)) && (r && (r += " "), (r += t))
  return r
}
const Sw = (e) => (typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e),
  _w = vN,
  pl = (e, t) => (n) => {
    var r
    if ((t == null ? void 0 : t.variants) == null)
      return _w(
        e,
        n == null ? void 0 : n.class,
        n == null ? void 0 : n.className
      )
    const { variants: o, defaultVariants: i } = t,
      s = Object.keys(o).map((c) => {
        const u = n == null ? void 0 : n[c],
          d = i == null ? void 0 : i[c]
        if (u === null) return null
        const f = Sw(u) || Sw(d)
        return o[c][f]
      }),
      a =
        n &&
        Object.entries(n).reduce((c, u) => {
          let [d, f] = u
          return f === void 0 || (c[d] = f), c
        }, {}),
      l =
        t == null || (r = t.compoundVariants) === null || r === void 0
          ? void 0
          : r.reduce((c, u) => {
              let { class: d, className: f, ...p } = u
              return Object.entries(p).every((g) => {
                let [v, b] = g
                return Array.isArray(b)
                  ? b.includes({ ...i, ...a }[v])
                  : { ...i, ...a }[v] === b
              })
                ? [...c, d, f]
                : c
            }, [])
    return _w(
      e,
      s,
      l,
      n == null ? void 0 : n.class,
      n == null ? void 0 : n.className
    )
  }
function _L() {
  for (var e = 0, t, n, r = ""; e < arguments.length; )
    (t = arguments[e++]) && (n = yN(t)) && (r && (r += " "), (r += n))
  return r
}
function yN(e) {
  if (typeof e == "string") return e
  for (var t, n = "", r = 0; r < e.length; r++)
    e[r] && (t = yN(e[r])) && (n && (n += " "), (n += t))
  return n
}
var nb = "-"
function kL(e) {
  var t = TL(e),
    n = e.conflictingClassGroups,
    r = e.conflictingClassGroupModifiers,
    o = r === void 0 ? {} : r
  function i(a) {
    var l = a.split(nb)
    return l[0] === "" && l.length !== 1 && l.shift(), bN(l, t) || NL(a)
  }
  function s(a, l) {
    var c = n[a] || []
    return l && o[a] ? [].concat(c, o[a]) : c
  }
  return { getClassGroupId: i, getConflictingClassGroupIds: s }
}
function bN(e, t) {
  var s
  if (e.length === 0) return t.classGroupId
  var n = e[0],
    r = t.nextPart.get(n),
    o = r ? bN(e.slice(1), r) : void 0
  if (o) return o
  if (t.validators.length !== 0) {
    var i = e.join(nb)
    return (s = t.validators.find(function (a) {
      var l = a.validator
      return l(i)
    })) == null
      ? void 0
      : s.classGroupId
  }
}
var kw = /^\[(.+)\]$/
function NL(e) {
  if (kw.test(e)) {
    var t = kw.exec(e)[1],
      n = t == null ? void 0 : t.substring(0, t.indexOf(":"))
    if (n) return "arbitrary.." + n
  }
}
function TL(e) {
  var t = e.theme,
    n = e.prefix,
    r = { nextPart: new Map(), validators: [] },
    o = OL(Object.entries(e.classGroups), n)
  return (
    o.forEach(function (i) {
      var s = i[0],
        a = i[1]
      Xv(a, r, s, t)
    }),
    r
  )
}
function Xv(e, t, n, r) {
  e.forEach(function (o) {
    if (typeof o == "string") {
      var i = o === "" ? t : Nw(t, o)
      i.classGroupId = n
      return
    }
    if (typeof o == "function") {
      if (ML(o)) {
        Xv(o(r), t, n, r)
        return
      }
      t.validators.push({ validator: o, classGroupId: n })
      return
    }
    Object.entries(o).forEach(function (s) {
      var a = s[0],
        l = s[1]
      Xv(l, Nw(t, a), n, r)
    })
  })
}
function Nw(e, t) {
  var n = e
  return (
    t.split(nb).forEach(function (r) {
      n.nextPart.has(r) ||
        n.nextPart.set(r, { nextPart: new Map(), validators: [] }),
        (n = n.nextPart.get(r))
    }),
    n
  )
}
function ML(e) {
  return e.isThemeGetter
}
function OL(e, t) {
  return t
    ? e.map(function (n) {
        var r = n[0],
          o = n[1],
          i = o.map(function (s) {
            return typeof s == "string"
              ? t + s
              : typeof s == "object"
                ? Object.fromEntries(
                    Object.entries(s).map(function (a) {
                      var l = a[0],
                        c = a[1]
                      return [t + l, c]
                    })
                  )
                : s
          })
        return [r, i]
      })
    : e
}
function AL(e) {
  if (e < 1) return { get: function () {}, set: function () {} }
  var t = 0,
    n = new Map(),
    r = new Map()
  function o(i, s) {
    n.set(i, s), t++, t > e && ((t = 0), (r = n), (n = new Map()))
  }
  return {
    get: function (s) {
      var a = n.get(s)
      if (a !== void 0) return a
      if ((a = r.get(s)) !== void 0) return o(s, a), a
    },
    set: function (s, a) {
      n.has(s) ? n.set(s, a) : o(s, a)
    },
  }
}
var xN = "!"
function RL(e) {
  var t = e.separator || ":",
    n = t.length === 1,
    r = t[0],
    o = t.length
  return function (s) {
    for (var a = [], l = 0, c = 0, u, d = 0; d < s.length; d++) {
      var f = s[d]
      if (l === 0) {
        if (f === r && (n || s.slice(d, d + o) === t)) {
          a.push(s.slice(c, d)), (c = d + o)
          continue
        }
        if (f === "/") {
          u = d
          continue
        }
      }
      f === "[" ? l++ : f === "]" && l--
    }
    var p = a.length === 0 ? s : s.substring(c),
      g = p.startsWith(xN),
      v = g ? p.substring(1) : p,
      b = u && u > c ? u - c : void 0
    return {
      modifiers: a,
      hasImportantModifier: g,
      baseClassName: v,
      maybePostfixModifierPosition: b,
    }
  }
}
function IL(e) {
  if (e.length <= 1) return e
  var t = [],
    n = []
  return (
    e.forEach(function (r) {
      var o = r[0] === "["
      o ? (t.push.apply(t, n.sort().concat([r])), (n = [])) : n.push(r)
    }),
    t.push.apply(t, n.sort()),
    t
  )
}
function DL(e) {
  return { cache: AL(e.cacheSize), splitModifiers: RL(e), ...kL(e) }
}
var LL = /\s+/
function PL(e, t) {
  var n = t.splitModifiers,
    r = t.getClassGroupId,
    o = t.getConflictingClassGroupIds,
    i = new Set()
  return e
    .trim()
    .split(LL)
    .map(function (s) {
      var a = n(s),
        l = a.modifiers,
        c = a.hasImportantModifier,
        u = a.baseClassName,
        d = a.maybePostfixModifierPosition,
        f = r(d ? u.substring(0, d) : u),
        p = !!d
      if (!f) {
        if (!d) return { isTailwindClass: !1, originalClassName: s }
        if (((f = r(u)), !f))
          return { isTailwindClass: !1, originalClassName: s }
        p = !1
      }
      var g = IL(l).join(":"),
        v = c ? g + xN : g
      return {
        isTailwindClass: !0,
        modifierId: v,
        classGroupId: f,
        originalClassName: s,
        hasPostfixModifier: p,
      }
    })
    .reverse()
    .filter(function (s) {
      if (!s.isTailwindClass) return !0
      var a = s.modifierId,
        l = s.classGroupId,
        c = s.hasPostfixModifier,
        u = a + l
      return i.has(u)
        ? !1
        : (i.add(u),
          o(l, c).forEach(function (d) {
            return i.add(a + d)
          }),
          !0)
    })
    .reverse()
    .map(function (s) {
      return s.originalClassName
    })
    .join(" ")
}
function $L() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n]
  var r,
    o,
    i,
    s = a
  function a(c) {
    var u = t[0],
      d = t.slice(1),
      f = d.reduce(function (p, g) {
        return g(p)
      }, u())
    return (r = DL(f)), (o = r.cache.get), (i = r.cache.set), (s = l), l(c)
  }
  function l(c) {
    var u = o(c)
    if (u) return u
    var d = PL(c, r)
    return i(c, d), d
  }
  return function () {
    return s(_L.apply(null, arguments))
  }
}
function Ye(e) {
  var t = function (r) {
    return r[e] || []
  }
  return (t.isThemeGetter = !0), t
}
var wN = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  BL = /^\d+\/\d+$/,
  jL = new Set(["px", "full", "screen"]),
  FL = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  zL =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  UL = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
function pr(e) {
  return Zi(e) || jL.has(e) || BL.test(e) || Qv(e)
}
function Qv(e) {
  return Is(e, "length", qL)
}
function VL(e) {
  return Is(e, "size", EN)
}
function HL(e) {
  return Is(e, "position", EN)
}
function WL(e) {
  return Is(e, "url", ZL)
}
function ud(e) {
  return Is(e, "number", Zi)
}
function Zi(e) {
  return !Number.isNaN(Number(e))
}
function KL(e) {
  return e.endsWith("%") && Zi(e.slice(0, -1))
}
function Al(e) {
  return Tw(e) || Is(e, "number", Tw)
}
function De(e) {
  return wN.test(e)
}
function Rl() {
  return !0
}
function Po(e) {
  return FL.test(e)
}
function GL(e) {
  return Is(e, "", YL)
}
function Is(e, t, n) {
  var r = wN.exec(e)
  return r ? (r[1] ? r[1] === t : n(r[2])) : !1
}
function qL(e) {
  return zL.test(e)
}
function EN() {
  return !1
}
function ZL(e) {
  return e.startsWith("url(")
}
function Tw(e) {
  return Number.isInteger(Number(e))
}
function YL(e) {
  return UL.test(e)
}
function XL() {
  var e = Ye("colors"),
    t = Ye("spacing"),
    n = Ye("blur"),
    r = Ye("brightness"),
    o = Ye("borderColor"),
    i = Ye("borderRadius"),
    s = Ye("borderSpacing"),
    a = Ye("borderWidth"),
    l = Ye("contrast"),
    c = Ye("grayscale"),
    u = Ye("hueRotate"),
    d = Ye("invert"),
    f = Ye("gap"),
    p = Ye("gradientColorStops"),
    g = Ye("gradientColorStopPositions"),
    v = Ye("inset"),
    b = Ye("margin"),
    y = Ye("opacity"),
    x = Ye("padding"),
    E = Ye("saturate"),
    w = Ye("scale"),
    C = Ye("sepia"),
    S = Ye("skew"),
    M = Ye("space"),
    N = Ye("translate"),
    R = function () {
      return ["auto", "contain", "none"]
    },
    B = function () {
      return ["auto", "hidden", "clip", "visible", "scroll"]
    },
    V = function () {
      return ["auto", De, t]
    },
    j = function () {
      return [De, t]
    },
    U = function () {
      return ["", pr]
    },
    W = function () {
      return ["auto", Zi, De]
    },
    ee = function () {
      return [
        "bottom",
        "center",
        "left",
        "left-bottom",
        "left-top",
        "right",
        "right-bottom",
        "right-top",
        "top",
      ]
    },
    I = function () {
      return ["solid", "dashed", "dotted", "double", "none"]
    },
    O = function () {
      return [
        "normal",
        "multiply",
        "screen",
        "overlay",
        "darken",
        "lighten",
        "color-dodge",
        "color-burn",
        "hard-light",
        "soft-light",
        "difference",
        "exclusion",
        "hue",
        "saturation",
        "color",
        "luminosity",
        "plus-lighter",
      ]
    },
    _ = function () {
      return [
        "start",
        "end",
        "center",
        "between",
        "around",
        "evenly",
        "stretch",
      ]
    },
    A = function () {
      return ["", "0", De]
    },
    P = function () {
      return [
        "auto",
        "avoid",
        "all",
        "avoid-page",
        "page",
        "left",
        "right",
        "column",
      ]
    },
    H = function () {
      return [Zi, ud]
    },
    X = function () {
      return [Zi, De]
    }
  return {
    cacheSize: 500,
    theme: {
      colors: [Rl],
      spacing: [pr],
      blur: ["none", "", Po, De],
      brightness: H(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Po, De],
      borderSpacing: j(),
      borderWidth: U(),
      contrast: H(),
      grayscale: A(),
      hueRotate: X(),
      invert: A(),
      gap: j(),
      gradientColorStops: [e],
      gradientColorStopPositions: [KL, Qv],
      inset: V(),
      margin: V(),
      opacity: H(),
      padding: j(),
      saturate: H(),
      scale: H(),
      sepia: A(),
      skew: X(),
      space: j(),
      translate: j(),
    },
    classGroups: {
      aspect: [{ aspect: ["auto", "square", "video", De] }],
      container: ["container"],
      columns: [{ columns: [Po] }],
      "break-after": [{ "break-after": P() }],
      "break-before": [{ "break-before": P() }],
      "break-inside": [
        { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] },
      ],
      "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
      box: [{ box: ["border", "content"] }],
      display: [
        "block",
        "inline-block",
        "inline",
        "flex",
        "inline-flex",
        "table",
        "inline-table",
        "table-caption",
        "table-cell",
        "table-column",
        "table-column-group",
        "table-footer-group",
        "table-header-group",
        "table-row-group",
        "table-row",
        "flow-root",
        "grid",
        "inline-grid",
        "contents",
        "list-item",
        "hidden",
      ],
      float: [{ float: ["right", "left", "none"] }],
      clear: [{ clear: ["left", "right", "both", "none"] }],
      isolation: ["isolate", "isolation-auto"],
      "object-fit": [
        { object: ["contain", "cover", "fill", "none", "scale-down"] },
      ],
      "object-position": [{ object: [].concat(ee(), [De]) }],
      overflow: [{ overflow: B() }],
      "overflow-x": [{ "overflow-x": B() }],
      "overflow-y": [{ "overflow-y": B() }],
      overscroll: [{ overscroll: R() }],
      "overscroll-x": [{ "overscroll-x": R() }],
      "overscroll-y": [{ "overscroll-y": R() }],
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      inset: [{ inset: [v] }],
      "inset-x": [{ "inset-x": [v] }],
      "inset-y": [{ "inset-y": [v] }],
      start: [{ start: [v] }],
      end: [{ end: [v] }],
      top: [{ top: [v] }],
      right: [{ right: [v] }],
      bottom: [{ bottom: [v] }],
      left: [{ left: [v] }],
      visibility: ["visible", "invisible", "collapse"],
      z: [{ z: ["auto", Al] }],
      basis: [{ basis: V() }],
      "flex-direction": [
        { flex: ["row", "row-reverse", "col", "col-reverse"] },
      ],
      "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
      flex: [{ flex: ["1", "auto", "initial", "none", De] }],
      grow: [{ grow: A() }],
      shrink: [{ shrink: A() }],
      order: [{ order: ["first", "last", "none", Al] }],
      "grid-cols": [{ "grid-cols": [Rl] }],
      "col-start-end": [{ col: ["auto", { span: ["full", Al] }, De] }],
      "col-start": [{ "col-start": W() }],
      "col-end": [{ "col-end": W() }],
      "grid-rows": [{ "grid-rows": [Rl] }],
      "row-start-end": [{ row: ["auto", { span: [Al] }, De] }],
      "row-start": [{ "row-start": W() }],
      "row-end": [{ "row-end": W() }],
      "grid-flow": [
        { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] },
      ],
      "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", De] }],
      "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", De] }],
      gap: [{ gap: [f] }],
      "gap-x": [{ "gap-x": [f] }],
      "gap-y": [{ "gap-y": [f] }],
      "justify-content": [{ justify: ["normal"].concat(_()) }],
      "justify-items": [
        { "justify-items": ["start", "end", "center", "stretch"] },
      ],
      "justify-self": [
        { "justify-self": ["auto", "start", "end", "center", "stretch"] },
      ],
      "align-content": [{ content: ["normal"].concat(_(), ["baseline"]) }],
      "align-items": [
        { items: ["start", "end", "center", "baseline", "stretch"] },
      ],
      "align-self": [
        { self: ["auto", "start", "end", "center", "stretch", "baseline"] },
      ],
      "place-content": [{ "place-content": [].concat(_(), ["baseline"]) }],
      "place-items": [
        { "place-items": ["start", "end", "center", "baseline", "stretch"] },
      ],
      "place-self": [
        { "place-self": ["auto", "start", "end", "center", "stretch"] },
      ],
      p: [{ p: [x] }],
      px: [{ px: [x] }],
      py: [{ py: [x] }],
      ps: [{ ps: [x] }],
      pe: [{ pe: [x] }],
      pt: [{ pt: [x] }],
      pr: [{ pr: [x] }],
      pb: [{ pb: [x] }],
      pl: [{ pl: [x] }],
      m: [{ m: [b] }],
      mx: [{ mx: [b] }],
      my: [{ my: [b] }],
      ms: [{ ms: [b] }],
      me: [{ me: [b] }],
      mt: [{ mt: [b] }],
      mr: [{ mr: [b] }],
      mb: [{ mb: [b] }],
      ml: [{ ml: [b] }],
      "space-x": [{ "space-x": [M] }],
      "space-x-reverse": ["space-x-reverse"],
      "space-y": [{ "space-y": [M] }],
      "space-y-reverse": ["space-y-reverse"],
      w: [{ w: ["auto", "min", "max", "fit", De, t] }],
      "min-w": [{ "min-w": ["min", "max", "fit", De, pr] }],
      "max-w": [
        {
          "max-w": [
            "0",
            "none",
            "full",
            "min",
            "max",
            "fit",
            "prose",
            { screen: [Po] },
            Po,
            De,
          ],
        },
      ],
      h: [{ h: [De, t, "auto", "min", "max", "fit"] }],
      "min-h": [{ "min-h": ["min", "max", "fit", De, pr] }],
      "max-h": [{ "max-h": [De, t, "min", "max", "fit"] }],
      "font-size": [{ text: ["base", Po, Qv] }],
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      "font-style": ["italic", "not-italic"],
      "font-weight": [
        {
          font: [
            "thin",
            "extralight",
            "light",
            "normal",
            "medium",
            "semibold",
            "bold",
            "extrabold",
            "black",
            ud,
          ],
        },
      ],
      "font-family": [{ font: [Rl] }],
      "fvn-normal": ["normal-nums"],
      "fvn-ordinal": ["ordinal"],
      "fvn-slashed-zero": ["slashed-zero"],
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      tracking: [
        {
          tracking: [
            "tighter",
            "tight",
            "normal",
            "wide",
            "wider",
            "widest",
            De,
          ],
        },
      ],
      "line-clamp": [{ "line-clamp": ["none", Zi, ud] }],
      leading: [
        {
          leading: [
            "none",
            "tight",
            "snug",
            "normal",
            "relaxed",
            "loose",
            De,
            pr,
          ],
        },
      ],
      "list-image": [{ "list-image": ["none", De] }],
      "list-style-type": [{ list: ["none", "disc", "decimal", De] }],
      "list-style-position": [{ list: ["inside", "outside"] }],
      "placeholder-color": [{ placeholder: [e] }],
      "placeholder-opacity": [{ "placeholder-opacity": [y] }],
      "text-alignment": [
        { text: ["left", "center", "right", "justify", "start", "end"] },
      ],
      "text-color": [{ text: [e] }],
      "text-opacity": [{ "text-opacity": [y] }],
      "text-decoration": [
        "underline",
        "overline",
        "line-through",
        "no-underline",
      ],
      "text-decoration-style": [{ decoration: [].concat(I(), ["wavy"]) }],
      "text-decoration-thickness": [{ decoration: ["auto", "from-font", pr] }],
      "underline-offset": [{ "underline-offset": ["auto", De, pr] }],
      "text-decoration-color": [{ decoration: [e] }],
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      indent: [{ indent: j() }],
      "vertical-align": [
        {
          align: [
            "baseline",
            "top",
            "middle",
            "bottom",
            "text-top",
            "text-bottom",
            "sub",
            "super",
            De,
          ],
        },
      ],
      whitespace: [
        {
          whitespace: [
            "normal",
            "nowrap",
            "pre",
            "pre-line",
            "pre-wrap",
            "break-spaces",
          ],
        },
      ],
      break: [{ break: ["normal", "words", "all", "keep"] }],
      hyphens: [{ hyphens: ["none", "manual", "auto"] }],
      content: [{ content: ["none", De] }],
      "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
      "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
      "bg-opacity": [{ "bg-opacity": [y] }],
      "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
      "bg-position": [{ bg: [].concat(ee(), [HL]) }],
      "bg-repeat": [
        { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] },
      ],
      "bg-size": [{ bg: ["auto", "cover", "contain", VL] }],
      "bg-image": [
        {
          bg: [
            "none",
            { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
            WL,
          ],
        },
      ],
      "bg-color": [{ bg: [e] }],
      "gradient-from-pos": [{ from: [g] }],
      "gradient-via-pos": [{ via: [g] }],
      "gradient-to-pos": [{ to: [g] }],
      "gradient-from": [{ from: [p] }],
      "gradient-via": [{ via: [p] }],
      "gradient-to": [{ to: [p] }],
      rounded: [{ rounded: [i] }],
      "rounded-s": [{ "rounded-s": [i] }],
      "rounded-e": [{ "rounded-e": [i] }],
      "rounded-t": [{ "rounded-t": [i] }],
      "rounded-r": [{ "rounded-r": [i] }],
      "rounded-b": [{ "rounded-b": [i] }],
      "rounded-l": [{ "rounded-l": [i] }],
      "rounded-ss": [{ "rounded-ss": [i] }],
      "rounded-se": [{ "rounded-se": [i] }],
      "rounded-ee": [{ "rounded-ee": [i] }],
      "rounded-es": [{ "rounded-es": [i] }],
      "rounded-tl": [{ "rounded-tl": [i] }],
      "rounded-tr": [{ "rounded-tr": [i] }],
      "rounded-br": [{ "rounded-br": [i] }],
      "rounded-bl": [{ "rounded-bl": [i] }],
      "border-w": [{ border: [a] }],
      "border-w-x": [{ "border-x": [a] }],
      "border-w-y": [{ "border-y": [a] }],
      "border-w-s": [{ "border-s": [a] }],
      "border-w-e": [{ "border-e": [a] }],
      "border-w-t": [{ "border-t": [a] }],
      "border-w-r": [{ "border-r": [a] }],
      "border-w-b": [{ "border-b": [a] }],
      "border-w-l": [{ "border-l": [a] }],
      "border-opacity": [{ "border-opacity": [y] }],
      "border-style": [{ border: [].concat(I(), ["hidden"]) }],
      "divide-x": [{ "divide-x": [a] }],
      "divide-x-reverse": ["divide-x-reverse"],
      "divide-y": [{ "divide-y": [a] }],
      "divide-y-reverse": ["divide-y-reverse"],
      "divide-opacity": [{ "divide-opacity": [y] }],
      "divide-style": [{ divide: I() }],
      "border-color": [{ border: [o] }],
      "border-color-x": [{ "border-x": [o] }],
      "border-color-y": [{ "border-y": [o] }],
      "border-color-t": [{ "border-t": [o] }],
      "border-color-r": [{ "border-r": [o] }],
      "border-color-b": [{ "border-b": [o] }],
      "border-color-l": [{ "border-l": [o] }],
      "divide-color": [{ divide: [o] }],
      "outline-style": [{ outline: [""].concat(I()) }],
      "outline-offset": [{ "outline-offset": [De, pr] }],
      "outline-w": [{ outline: [pr] }],
      "outline-color": [{ outline: [e] }],
      "ring-w": [{ ring: U() }],
      "ring-w-inset": ["ring-inset"],
      "ring-color": [{ ring: [e] }],
      "ring-opacity": [{ "ring-opacity": [y] }],
      "ring-offset-w": [{ "ring-offset": [pr] }],
      "ring-offset-color": [{ "ring-offset": [e] }],
      shadow: [{ shadow: ["", "inner", "none", Po, GL] }],
      "shadow-color": [{ shadow: [Rl] }],
      opacity: [{ opacity: [y] }],
      "mix-blend": [{ "mix-blend": O() }],
      "bg-blend": [{ "bg-blend": O() }],
      filter: [{ filter: ["", "none"] }],
      blur: [{ blur: [n] }],
      brightness: [{ brightness: [r] }],
      contrast: [{ contrast: [l] }],
      "drop-shadow": [{ "drop-shadow": ["", "none", Po, De] }],
      grayscale: [{ grayscale: [c] }],
      "hue-rotate": [{ "hue-rotate": [u] }],
      invert: [{ invert: [d] }],
      saturate: [{ saturate: [E] }],
      sepia: [{ sepia: [C] }],
      "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
      "backdrop-blur": [{ "backdrop-blur": [n] }],
      "backdrop-brightness": [{ "backdrop-brightness": [r] }],
      "backdrop-contrast": [{ "backdrop-contrast": [l] }],
      "backdrop-grayscale": [{ "backdrop-grayscale": [c] }],
      "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [u] }],
      "backdrop-invert": [{ "backdrop-invert": [d] }],
      "backdrop-opacity": [{ "backdrop-opacity": [y] }],
      "backdrop-saturate": [{ "backdrop-saturate": [E] }],
      "backdrop-sepia": [{ "backdrop-sepia": [C] }],
      "border-collapse": [{ border: ["collapse", "separate"] }],
      "border-spacing": [{ "border-spacing": [s] }],
      "border-spacing-x": [{ "border-spacing-x": [s] }],
      "border-spacing-y": [{ "border-spacing-y": [s] }],
      "table-layout": [{ table: ["auto", "fixed"] }],
      caption: [{ caption: ["top", "bottom"] }],
      transition: [
        {
          transition: [
            "none",
            "all",
            "",
            "colors",
            "opacity",
            "shadow",
            "transform",
            De,
          ],
        },
      ],
      duration: [{ duration: X() }],
      ease: [{ ease: ["linear", "in", "out", "in-out", De] }],
      delay: [{ delay: X() }],
      animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", De] }],
      transform: [{ transform: ["", "gpu", "none"] }],
      scale: [{ scale: [w] }],
      "scale-x": [{ "scale-x": [w] }],
      "scale-y": [{ "scale-y": [w] }],
      rotate: [{ rotate: [Al, De] }],
      "translate-x": [{ "translate-x": [N] }],
      "translate-y": [{ "translate-y": [N] }],
      "skew-x": [{ "skew-x": [S] }],
      "skew-y": [{ "skew-y": [S] }],
      "transform-origin": [
        {
          origin: [
            "center",
            "top",
            "top-right",
            "right",
            "bottom-right",
            "bottom",
            "bottom-left",
            "left",
            "top-left",
            De,
          ],
        },
      ],
      accent: [{ accent: ["auto", e] }],
      appearance: ["appearance-none"],
      cursor: [
        {
          cursor: [
            "auto",
            "default",
            "pointer",
            "wait",
            "text",
            "move",
            "help",
            "not-allowed",
            "none",
            "context-menu",
            "progress",
            "cell",
            "crosshair",
            "vertical-text",
            "alias",
            "copy",
            "no-drop",
            "grab",
            "grabbing",
            "all-scroll",
            "col-resize",
            "row-resize",
            "n-resize",
            "e-resize",
            "s-resize",
            "w-resize",
            "ne-resize",
            "nw-resize",
            "se-resize",
            "sw-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "zoom-in",
            "zoom-out",
            De,
          ],
        },
      ],
      "caret-color": [{ caret: [e] }],
      "pointer-events": [{ "pointer-events": ["none", "auto"] }],
      resize: [{ resize: ["none", "y", "x", ""] }],
      "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
      "scroll-m": [{ "scroll-m": j() }],
      "scroll-mx": [{ "scroll-mx": j() }],
      "scroll-my": [{ "scroll-my": j() }],
      "scroll-ms": [{ "scroll-ms": j() }],
      "scroll-me": [{ "scroll-me": j() }],
      "scroll-mt": [{ "scroll-mt": j() }],
      "scroll-mr": [{ "scroll-mr": j() }],
      "scroll-mb": [{ "scroll-mb": j() }],
      "scroll-ml": [{ "scroll-ml": j() }],
      "scroll-p": [{ "scroll-p": j() }],
      "scroll-px": [{ "scroll-px": j() }],
      "scroll-py": [{ "scroll-py": j() }],
      "scroll-ps": [{ "scroll-ps": j() }],
      "scroll-pe": [{ "scroll-pe": j() }],
      "scroll-pt": [{ "scroll-pt": j() }],
      "scroll-pr": [{ "scroll-pr": j() }],
      "scroll-pb": [{ "scroll-pb": j() }],
      "scroll-pl": [{ "scroll-pl": j() }],
      "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
      "snap-stop": [{ snap: ["normal", "always"] }],
      "snap-type": [{ snap: ["none", "x", "y", "both"] }],
      "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
      touch: [
        {
          touch: [
            "auto",
            "none",
            "pinch-zoom",
            "manipulation",
            { pan: ["x", "left", "right", "y", "up", "down"] },
          ],
        },
      ],
      select: [{ select: ["none", "text", "all", "auto"] }],
      "will-change": [
        { "will-change": ["auto", "scroll", "contents", "transform", De] },
      ],
      fill: [{ fill: [e, "none"] }],
      "stroke-w": [{ stroke: [pr, ud] }],
      stroke: [{ stroke: [e, "none"] }],
      sr: ["sr-only", "not-sr-only"],
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: [
        "inset-x",
        "inset-y",
        "start",
        "end",
        "top",
        "right",
        "bottom",
        "left",
      ],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": [
        "fvn-ordinal",
        "fvn-slashed-zero",
        "fvn-figure",
        "fvn-spacing",
        "fvn-fraction",
      ],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: [
        "rounded-s",
        "rounded-e",
        "rounded-t",
        "rounded-r",
        "rounded-b",
        "rounded-l",
        "rounded-ss",
        "rounded-se",
        "rounded-ee",
        "rounded-es",
        "rounded-tl",
        "rounded-tr",
        "rounded-br",
        "rounded-bl",
      ],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": [
        "border-w-s",
        "border-w-e",
        "border-w-t",
        "border-w-r",
        "border-w-b",
        "border-w-l",
      ],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": [
        "border-color-t",
        "border-color-r",
        "border-color-b",
        "border-color-l",
      ],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": [
        "scroll-mx",
        "scroll-my",
        "scroll-ms",
        "scroll-me",
        "scroll-mt",
        "scroll-mr",
        "scroll-mb",
        "scroll-ml",
      ],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": [
        "scroll-px",
        "scroll-py",
        "scroll-ps",
        "scroll-pe",
        "scroll-pt",
        "scroll-pr",
        "scroll-pb",
        "scroll-pl",
      ],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
    },
    conflictingClassGroupModifiers: { "font-size": ["leading"] },
  }
}
var QL = $L(XL)
function q(...e) {
  return QL(vN(e))
}
const JL = pl(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: { variant: "default" },
  }
)
function Pf({ className: e, variant: t, ...n }) {
  return h.jsx("div", { className: q(JL({ variant: t }), e), ...n })
}
function Mw(e, t) {
  if (typeof e == "function") return e(t)
  e != null && (e.current = t)
}
function xh(...e) {
  return (t) => {
    let n = !1
    const r = e.map((o) => {
      const i = Mw(o, t)
      return !n && typeof i == "function" && (n = !0), i
    })
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const i = r[o]
          typeof i == "function" ? i() : Mw(e[o], null)
        }
      }
  }
}
function tt(...e) {
  return m.useCallback(xh(...e), e)
}
var An = m.forwardRef((e, t) => {
  const { children: n, ...r } = e,
    o = m.Children.toArray(n),
    i = o.find(eP)
  if (i) {
    const s = i.props.children,
      a = o.map((l) =>
        l === i
          ? m.Children.count(s) > 1
            ? m.Children.only(null)
            : m.isValidElement(s)
              ? s.props.children
              : null
          : l
      )
    return h.jsx(Jv, {
      ...r,
      ref: t,
      children: m.isValidElement(s) ? m.cloneElement(s, void 0, a) : null,
    })
  }
  return h.jsx(Jv, { ...r, ref: t, children: n })
})
An.displayName = "Slot"
var Jv = m.forwardRef((e, t) => {
  const { children: n, ...r } = e
  if (m.isValidElement(n)) {
    const o = nP(n),
      i = tP(r, n.props)
    return (
      n.type !== m.Fragment && (i.ref = t ? xh(t, o) : o), m.cloneElement(n, i)
    )
  }
  return m.Children.count(n) > 1 ? m.Children.only(null) : null
})
Jv.displayName = "SlotClone"
var CN = ({ children: e }) => h.jsx(h.Fragment, { children: e })
function eP(e) {
  return m.isValidElement(e) && e.type === CN
}
function tP(e, t) {
  const n = { ...t }
  for (const r in t) {
    const o = e[r],
      i = t[r]
    ;/^on[A-Z]/.test(r)
      ? o && i
        ? (n[r] = (...a) => {
            i(...a), o(...a)
          })
        : o && (n[r] = o)
      : r === "style"
        ? (n[r] = { ...o, ...i })
        : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "))
  }
  return { ...e, ...n }
}
function nP(e) {
  var r, o
  let t =
      (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null
        ? void 0
        : r.get,
    n = t && "isReactWarning" in t && t.isReactWarning
  return n
    ? e.ref
    : ((t =
        (o = Object.getOwnPropertyDescriptor(e, "ref")) == null
          ? void 0
          : o.get),
      (n = t && "isReactWarning" in t && t.isReactWarning),
      n ? e.props.ref : e.props.ref || e.ref)
}
const rb = pl(
    "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline:
            "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline",
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    }
  ),
  et = m.forwardRef(
    ({ className: e, variant: t, size: n, asChild: r = !1, ...o }, i) => {
      const s = r ? An : "button"
      return h.jsx(s, {
        className: q(rb({ variant: t, size: n, className: e })),
        ref: i,
        ...o,
      })
    }
  )
et.displayName = "Button"
const Co = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    className: q("rounded-lg border bg-card text-card-foreground shadow-sm", e),
    ...t,
  })
)
Co.displayName = "Card"
const ob = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    className: q("flex flex-col space-y-1.5 p-6", e),
    ...t,
  })
)
ob.displayName = "CardHeader"
const SN = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("h3", {
    ref: n,
    className: q("text-2xl font-semibold leading-none tracking-tight", e),
    ...t,
  })
)
SN.displayName = "CardTitle"
const rP = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("p", { ref: n, className: q("text-sm text-muted-foreground", e), ...t })
)
rP.displayName = "CardDescription"
const So = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", { ref: n, className: q("p-6 pt-0", e), ...t })
)
So.displayName = "CardContent"
const oP = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", { ref: n, className: q(" flex items-center p-6 pt-0", e), ...t })
)
oP.displayName = "CardFooter"
function iP({ recipe: e }) {
  const [, t] = bh()
  return h.jsxs(
    Co,
    {
      className: "rounded-xl shadow-lg",
      children: [
        h.jsx(ob, {
          className: "relative h-40",
          children: h.jsx("img", {
            src: e.title_image,
            alt: e.name,
            className: "h-full w-full rounded-t-xl object-cover",
          }),
        }),
        h.jsxs(So, {
          className: "p-4",
          children: [
            h.jsx(SN, { className: "text-lg font-semibold", children: e.name }),
            h.jsxs("p", {
              className: "mb-3 text-sm text-gray-500",
              children: ["Category: ", e.category],
            }),
            h.jsxs("div", {
              className: "mb-3 flex items-center gap-2",
              children: [
                h.jsx(Pf, {
                  variant: "secondary",
                  children: "".repeat(e.rating + 1),
                }),
                e.favourite
                  ? h.jsx(Pf, { variant: "default", children: " Favorite" })
                  : null,
              ],
            }),
            h.jsxs("p", {
              className: "text-xs text-gray-400",
              children: [
                "Prep: ",
                e.prep_time,
                " mins | Cook: ",
                e.cook_time,
                " mins",
              ],
            }),
            h.jsx(et, {
              className: "mt-4 w-full",
              onClick: () => {
                t("/details/" + e.id)
              },
              children: "View Recipe",
            }),
          ],
        }),
      ],
    },
    e.id
  )
}
async function ib(e, t, n = []) {
  var r
  try {
    return (r = await (e == null ? void 0 : e.execute(t, n))) != null ? r : null
  } catch (o) {
    return console.error("Database error:", o), null
  }
}
async function sb(e, t, n = []) {
  var r
  try {
    return (r = await (e == null ? void 0 : e.select(t, n))) != null ? r : null
  } catch (o) {
    return console.error("Fetch error:", o), null
  }
}
async function _u(e, t, n) {
  const r = Object.keys(n).join(", "),
    o = Object.values(n),
    i = o.map((s, a) => `?${a + 1}`).join(", ")
  return ib(e, `INSERT INTO ${t} (${r}) VALUES (${i})`, o)
}
async function wh(e, t, n) {
  var r
  return (r = await sb(e, `SELECT * FROM ${t} WHERE recipe_id = ?1`, [n])) !=
    null
    ? r
    : []
}
async function _N(e, t, n) {
  const r = Object.keys(n).filter((s) => s !== "id"),
    o = r.map((s) => n[s]),
    i = r.map((s, a) => `${s} = ?${a + 2}`).join(", ")
  return ib(e, `UPDATE ${t} SET ${i} WHERE id = ?1`, [n.id, ...o])
}
async function Eh(e, t, n) {
  return ib(e, `DELETE FROM ${t} WHERE id = ?1`, [n])
}
const sP = (e, t) => _u(e, "Recipe", t),
  aP = (e, t) =>
    sb(e, "SELECT * FROM Recipe WHERE id = ?1 LIMIT 1", [t]).then((n) =>
      n ? n[0] : null
    ),
  lP = (e) => sb(e, "SELECT * FROM Recipe"),
  cP = (e, t) => {
    var n
    _N(e, "Recipe", { ...t, id: (n = t.id) != null ? n : 0 })
  },
  uP = (e, t) => Eh(e, "Recipe", t),
  kN = (e, t) => _u(e, "Ingredients", t),
  NN = (e, t) => wh(e, "Ingredients", t),
  dP = (e, t) => Eh(e, "Ingredients", t),
  TN = (e, t) => _u(e, "Directions", t),
  MN = (e, t) => wh(e, "Directions", t),
  fP = (e, t) => Eh(e, "Directions", t),
  ON = (e, t) => _u(e, "Equipment", t),
  AN = (e, t) => wh(e, "Equipment", t),
  pP = (e, t) => Eh(e, "Equipment", t),
  RN = (e, t) => _u(e, "Nutrition", t),
  IN = (e, t) => wh(e, "Nutrition", t),
  hP = (e, t) => _N(e, "Nutrition", t),
  DN = async (e, t) => {
    if (!e) return null
    try {
      const n = await aP(e, t)
      if (!n) return null
      const [r, o, i, s] = await Promise.all([
        NN(e, t),
        MN(e, t),
        AN(e, t),
        IN(e, t).then((a) => (a.length ? a[0] : null)),
      ])
      return {
        recipe: n,
        ingredients: r,
        directions: o,
        equipment: i,
        nutrition:
          s != null
            ? s
            : {
                id: 0,
                recipe_id: t,
                calories: 0,
                fat: 0,
                carbs: 0,
                protein: 0,
              },
      }
    } catch (n) {
      return console.error("Error fetching full recipe:", n), null
    }
  },
  mP = async (e, t, n = !1) => {
    const r = {
        name: t.name,
        category: t.category,
        title_image: t.title_image,
        rating: t.rating,
        favourite: 0,
        prep_time: Number(t.prep_time),
        cook_time: Number(t.cook_time),
        servings: t.servings,
      },
      o = await sP(e, r)
    if (!(o != null && o.lastInsertId))
      return console.error("Failed to insert recipe"), null
    const i = o.lastInsertId
    await Promise.all(
      t.instructions.map((u) =>
        TN(e, { recipe_id: i, title: "", description: u })
      )
    ),
      await Promise.all(
        t.ingredients.map((u) => kN(e, { ...u, recipe_id: i }))
      ),
      await Promise.all(
        t.equipment.map((u) => ON(e, { equipment: u, recipe_id: i }))
      )
    let { calories: s, fat: a, protein: l, carbs: c } = t.nutrition
    return (
      t.isPerServing || (s /= t.servings),
      await RN(e, { recipe_id: i, calories: s, fat: a, protein: l, carbs: c }),
      i
    )
  },
  gP = async (e, t, n) => {
    if (!e) return !1
    try {
      const r = {
        id: t,
        name: n.name,
        category: n.category,
        title_image: n.title_image,
        rating: n.rating,
        favourite: 0,
        prep_time: n.prep_time,
        cook_time: n.cook_time,
        servings: n.servings,
      }
      cP(e, r)
      const o = await MN(e, t)
      await Promise.all([
        n.instructions.map((f) =>
          TN(e, { recipe_id: t, title: "", description: f })
        ),
        o.map((f) => fP(e, f.id)),
      ])
      const i = await NN(e, t)
      await Promise.all([
        n.ingredients.map((f) =>
          kN(e, {
            recipe_id: t,
            ingredient: f.ingredient,
            quantity: f.quantity,
            unit: f.unit,
          })
        ),
        i.map((f) => dP(e, f.id)),
      ])
      const s = await AN(e, t)
      await Promise.all([
        n.equipment.map((f) => ON(e, { recipe_id: t, equipment: f.equipment })),
        s.map((f) => pP(e, f.id)),
      ])
      let { calories: a, fat: l, protein: c, carbs: u } = n.nutrition
      n.isPerServing || (a /= n.servings)
      const d = await IN(e, t)
      return (
        d.length > 0
          ? await hP(e, {
              id: d[0].id,
              recipe_id: t,
              calories: a,
              fat: l,
              protein: c,
              carbs: u,
            })
          : await RN(e, {
              recipe_id: t,
              calories: a,
              fat: l,
              protein: c,
              carbs: u,
            }),
        !0
      )
    } catch (r) {
      return console.error("Error editing recipe:", r), !1
    }
  }
async function dd(e, t = {}, n) {
  return window.__TAURI_INTERNALS__.invoke(e, t, n)
}
class $f {
  constructor(t) {
    this.path = t
  }
  static async load(t) {
    const n = await dd("plugin:sql|load", { db: t })
    return new $f(n)
  }
  static get(t) {
    return new $f(t)
  }
  async execute(t, n) {
    const [r, o] = await dd("plugin:sql|execute", {
      db: this.path,
      query: t,
      values: n != null ? n : [],
    })
    return { lastInsertId: o, rowsAffected: r }
  }
  async select(t, n) {
    return await dd("plugin:sql|select", {
      db: this.path,
      query: t,
      values: n != null ? n : [],
    })
  }
  async close(t) {
    return await dd("plugin:sql|close", { db: t })
  }
}
let Xm = null
async function vP() {
  if (!Xm)
    try {
      Xm = await $f.load("sqlite:capsaicin.db")
    } catch (e) {
      throw (console.error("Failed to load the database:", e), e)
    }
  return Xm
}
const ab = () => {
  const [e, t] = m.useState(null),
    [n, r] = m.useState(!0),
    [o, i] = m.useState(null)
  return (
    m.useEffect(() => {
      ;(async () => {
        r(!0)
        try {
          const a = await vP()
          t(a)
        } catch (a) {
          i(a)
        } finally {
          r(!1)
        }
      })()
    }, []),
    { db: e, loading: n, error: o }
  )
}
function yP() {
  const { db: e } = ab(),
    [t, n] = m.useState([])
  return (
    m.useEffect(() => {
      ;(async () => {
        let o = await lP(e)
        n(o != null ? o : [])
      })()
    }, [e]),
    h.jsx("div", {
      className: "scroll",
      children:
        t.length > 0
          ? h.jsx("div", {
              className:
                "grid grid-cols-1 gap-6 p-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4",
              children: t.map((r) => h.jsx(iP, { recipe: r })),
            })
          : h.jsxs("div", {
              className:
                "flex h-[60vh] flex-col items-center justify-center text-center",
              children: [
                h.jsx(eL, { size: 48, className: "text-gray-400" }),
                h.jsx("h2", {
                  className: "mt-4 text-xl font-semibold",
                  children: "No recipes found",
                }),
                h.jsx("p", {
                  className: "text-gray-500",
                  children: "Try adding a new recipe to get started.",
                }),
                h.jsx("a", {
                  href: "#create",
                  children: h.jsx(et, {
                    className: "mt-4",
                    children: "Add Recipe",
                  }),
                }),
              ],
            }),
    })
  )
}
function ge(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (o) {
    if ((e == null || e(o), n === !1 || !o.defaultPrevented))
      return t == null ? void 0 : t(o)
  }
}
function bP(e, t) {
  const n = m.createContext(t),
    r = (i) => {
      const { children: s, ...a } = i,
        l = m.useMemo(() => a, Object.values(a))
      return h.jsx(n.Provider, { value: l, children: s })
    }
  r.displayName = e + "Provider"
  function o(i) {
    const s = m.useContext(n)
    if (s) return s
    if (t !== void 0) return t
    throw new Error(`\`${i}\` must be used within \`${e}\``)
  }
  return [r, o]
}
function Wn(e, t = []) {
  let n = []
  function r(i, s) {
    const a = m.createContext(s),
      l = n.length
    n = [...n, s]
    const c = (d) => {
      var y
      const { scope: f, children: p, ...g } = d,
        v = ((y = f == null ? void 0 : f[e]) == null ? void 0 : y[l]) || a,
        b = m.useMemo(() => g, Object.values(g))
      return h.jsx(v.Provider, { value: b, children: p })
    }
    c.displayName = i + "Provider"
    function u(d, f) {
      var v
      const p = ((v = f == null ? void 0 : f[e]) == null ? void 0 : v[l]) || a,
        g = m.useContext(p)
      if (g) return g
      if (s !== void 0) return s
      throw new Error(`\`${d}\` must be used within \`${i}\``)
    }
    return [c, u]
  }
  const o = () => {
    const i = n.map((s) => m.createContext(s))
    return function (a) {
      const l = (a == null ? void 0 : a[e]) || i
      return m.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l])
    }
  }
  return (o.scopeName = e), [r, xP(o, ...t)]
}
function xP(...e) {
  const t = e[0]
  if (e.length === 1) return t
  const n = () => {
    const r = e.map((o) => ({ useScope: o(), scopeName: o.scopeName }))
    return function (i) {
      const s = r.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`]
        return { ...a, ...d }
      }, {})
      return m.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s])
    }
  }
  return (n.scopeName = t.scopeName), n
}
var wP = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul",
  ],
  Le = wP.reduce((e, t) => {
    const n = m.forwardRef((r, o) => {
      const { asChild: i, ...s } = r,
        a = i ? An : t
      return (
        typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        h.jsx(a, { ...s, ref: o })
      )
    })
    return (n.displayName = `Primitive.${t}`), { ...e, [t]: n }
  }, {})
function LN(e, t) {
  e && Rs.flushSync(() => e.dispatchEvent(t))
}
function Nr(e) {
  const t = m.useRef(e)
  return (
    m.useEffect(() => {
      t.current = e
    }),
    m.useMemo(
      () =>
        (...n) => {
          var r
          return (r = t.current) == null ? void 0 : r.call(t, ...n)
        },
      []
    )
  )
}
function EP(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Nr(e)
  m.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o)
    }
    return (
      t.addEventListener("keydown", r, { capture: !0 }),
      () => t.removeEventListener("keydown", r, { capture: !0 })
    )
  }, [n, t])
}
var CP = "DismissableLayer",
  ey = "dismissableLayer.update",
  SP = "dismissableLayer.pointerDownOutside",
  _P = "dismissableLayer.focusOutside",
  Ow,
  PN = m.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  ku = m.forwardRef((e, t) => {
    var M
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: i,
        onInteractOutside: s,
        onDismiss: a,
        ...l
      } = e,
      c = m.useContext(PN),
      [u, d] = m.useState(null),
      f =
        (M = u == null ? void 0 : u.ownerDocument) != null
          ? M
          : globalThis == null
            ? void 0
            : globalThis.document,
      [, p] = m.useState({}),
      g = tt(t, (N) => d(N)),
      v = Array.from(c.layers),
      [b] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
      y = v.indexOf(b),
      x = u ? v.indexOf(u) : -1,
      E = c.layersWithOutsidePointerEventsDisabled.size > 0,
      w = x >= y,
      C = TP((N) => {
        const R = N.target,
          B = [...c.branches].some((V) => V.contains(R))
        !w ||
          B ||
          (o == null || o(N),
          s == null || s(N),
          N.defaultPrevented || a == null || a())
      }, f),
      S = MP((N) => {
        const R = N.target
        ;[...c.branches].some((V) => V.contains(R)) ||
          (i == null || i(N),
          s == null || s(N),
          N.defaultPrevented || a == null || a())
      }, f)
    return (
      EP((N) => {
        x === c.layers.size - 1 &&
          (r == null || r(N),
          !N.defaultPrevented && a && (N.preventDefault(), a()))
      }, f),
      m.useEffect(() => {
        if (u)
          return (
            n &&
              (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((Ow = f.body.style.pointerEvents),
                (f.body.style.pointerEvents = "none")),
              c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            Aw(),
            () => {
              n &&
                c.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (f.body.style.pointerEvents = Ow)
            }
          )
      }, [u, f, n, c]),
      m.useEffect(
        () => () => {
          u &&
            (c.layers.delete(u),
            c.layersWithOutsidePointerEventsDisabled.delete(u),
            Aw())
        },
        [u, c]
      ),
      m.useEffect(() => {
        const N = () => p({})
        return (
          document.addEventListener(ey, N),
          () => document.removeEventListener(ey, N)
        )
      }, []),
      h.jsx(Le.div, {
        ...l,
        ref: g,
        style: {
          pointerEvents: E ? (w ? "auto" : "none") : void 0,
          ...e.style,
        },
        onFocusCapture: ge(e.onFocusCapture, S.onFocusCapture),
        onBlurCapture: ge(e.onBlurCapture, S.onBlurCapture),
        onPointerDownCapture: ge(
          e.onPointerDownCapture,
          C.onPointerDownCapture
        ),
      })
    )
  })
ku.displayName = CP
var kP = "DismissableLayerBranch",
  NP = m.forwardRef((e, t) => {
    const n = m.useContext(PN),
      r = m.useRef(null),
      o = tt(t, r)
    return (
      m.useEffect(() => {
        const i = r.current
        if (i)
          return (
            n.branches.add(i),
            () => {
              n.branches.delete(i)
            }
          )
      }, [n.branches]),
      h.jsx(Le.div, { ...e, ref: o })
    )
  })
NP.displayName = kP
function TP(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Nr(e),
    r = m.useRef(!1),
    o = m.useRef(() => {})
  return (
    m.useEffect(() => {
      const i = (a) => {
          if (a.target && !r.current) {
            let l = function () {
              $N(SP, n, c, { discrete: !0 })
            }
            const c = { originalEvent: a }
            a.pointerType === "touch"
              ? (t.removeEventListener("click", o.current),
                (o.current = l),
                t.addEventListener("click", o.current, { once: !0 }))
              : l()
          } else t.removeEventListener("click", o.current)
          r.current = !1
        },
        s = window.setTimeout(() => {
          t.addEventListener("pointerdown", i)
        }, 0)
      return () => {
        window.clearTimeout(s),
          t.removeEventListener("pointerdown", i),
          t.removeEventListener("click", o.current)
      }
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  )
}
function MP(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Nr(e),
    r = m.useRef(!1)
  return (
    m.useEffect(() => {
      const o = (i) => {
        i.target &&
          !r.current &&
          $N(_P, n, { originalEvent: i }, { discrete: !1 })
      }
      return (
        t.addEventListener("focusin", o),
        () => t.removeEventListener("focusin", o)
      )
    }, [t, n]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1),
    }
  )
}
function Aw() {
  const e = new CustomEvent(ey)
  document.dispatchEvent(e)
}
function $N(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target,
    i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n })
  t && o.addEventListener(e, t, { once: !0 }), r ? LN(o, i) : o.dispatchEvent(i)
}
var ys =
    globalThis != null && globalThis.document ? m.useLayoutEffect : () => {},
  OP = a0["useId".toString()] || (() => {}),
  AP = 0
function fi(e) {
  const [t, n] = m.useState(OP())
  return (
    ys(() => {
      e || n((r) => (r != null ? r : String(AP++)))
    }, [e]),
    e || (t ? `radix-${t}` : "")
  )
}
const RP = ["top", "right", "bottom", "left"],
  Ei = Math.min,
  Ln = Math.max,
  Bf = Math.round,
  fd = Math.floor,
  Gr = (e) => ({ x: e, y: e }),
  IP = { left: "right", right: "left", bottom: "top", top: "bottom" },
  DP = { start: "end", end: "start" }
function ty(e, t, n) {
  return Ln(e, Ei(t, n))
}
function Oo(e, t) {
  return typeof e == "function" ? e(t) : e
}
function Ao(e) {
  return e.split("-")[0]
}
function hl(e) {
  return e.split("-")[1]
}
function lb(e) {
  return e === "x" ? "y" : "x"
}
function cb(e) {
  return e === "y" ? "height" : "width"
}
function Ci(e) {
  return ["top", "bottom"].includes(Ao(e)) ? "y" : "x"
}
function ub(e) {
  return lb(Ci(e))
}
function LP(e, t, n) {
  n === void 0 && (n = !1)
  const r = hl(e),
    o = ub(e),
    i = cb(o)
  let s =
    o === "x"
      ? r === (n ? "end" : "start")
        ? "right"
        : "left"
      : r === "start"
        ? "bottom"
        : "top"
  return t.reference[i] > t.floating[i] && (s = jf(s)), [s, jf(s)]
}
function PP(e) {
  const t = jf(e)
  return [ny(e), t, ny(t)]
}
function ny(e) {
  return e.replace(/start|end/g, (t) => DP[t])
}
function $P(e, t, n) {
  const r = ["left", "right"],
    o = ["right", "left"],
    i = ["top", "bottom"],
    s = ["bottom", "top"]
  switch (e) {
    case "top":
    case "bottom":
      return n ? (t ? o : r) : t ? r : o
    case "left":
    case "right":
      return t ? i : s
    default:
      return []
  }
}
function BP(e, t, n, r) {
  const o = hl(e)
  let i = $P(Ao(e), n === "start", r)
  return (
    o && ((i = i.map((s) => s + "-" + o)), t && (i = i.concat(i.map(ny)))), i
  )
}
function jf(e) {
  return e.replace(/left|right|bottom|top/g, (t) => IP[t])
}
function jP(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e }
}
function BN(e) {
  return typeof e != "number" ? jP(e) : { top: e, right: e, bottom: e, left: e }
}
function Ff(e) {
  const { x: t, y: n, width: r, height: o } = e
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n,
  }
}
function Rw(e, t, n) {
  let { reference: r, floating: o } = e
  const i = Ci(t),
    s = ub(t),
    a = cb(s),
    l = Ao(t),
    c = i === "y",
    u = r.x + r.width / 2 - o.width / 2,
    d = r.y + r.height / 2 - o.height / 2,
    f = r[a] / 2 - o[a] / 2
  let p
  switch (l) {
    case "top":
      p = { x: u, y: r.y - o.height }
      break
    case "bottom":
      p = { x: u, y: r.y + r.height }
      break
    case "right":
      p = { x: r.x + r.width, y: d }
      break
    case "left":
      p = { x: r.x - o.width, y: d }
      break
    default:
      p = { x: r.x, y: r.y }
  }
  switch (hl(t)) {
    case "start":
      p[s] -= f * (n && c ? -1 : 1)
      break
    case "end":
      p[s] += f * (n && c ? -1 : 1)
      break
  }
  return p
}
const FP = async (e, t, n) => {
  const {
      placement: r = "bottom",
      strategy: o = "absolute",
      middleware: i = [],
      platform: s,
    } = n,
    a = i.filter(Boolean),
    l = await (s.isRTL == null ? void 0 : s.isRTL(t))
  let c = await s.getElementRects({ reference: e, floating: t, strategy: o }),
    { x: u, y: d } = Rw(c, r, l),
    f = r,
    p = {},
    g = 0
  for (let v = 0; v < a.length; v++) {
    const { name: b, fn: y } = a[v],
      {
        x,
        y: E,
        data: w,
        reset: C,
      } = await y({
        x: u,
        y: d,
        initialPlacement: r,
        placement: f,
        strategy: o,
        middlewareData: p,
        rects: c,
        platform: s,
        elements: { reference: e, floating: t },
      })
    ;(u = x != null ? x : u),
      (d = E != null ? E : d),
      (p = { ...p, [b]: { ...p[b], ...w } }),
      C &&
        g <= 50 &&
        (g++,
        typeof C == "object" &&
          (C.placement && (f = C.placement),
          C.rects &&
            (c =
              C.rects === !0
                ? await s.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: o,
                  })
                : C.rects),
          ({ x: u, y: d } = Rw(c, f, l))),
        (v = -1))
  }
  return { x: u, y: d, placement: f, strategy: o, middlewareData: p }
}
async function Fc(e, t) {
  var n
  t === void 0 && (t = {})
  const { x: r, y: o, platform: i, rects: s, elements: a, strategy: l } = e,
    {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: d = "floating",
      altBoundary: f = !1,
      padding: p = 0,
    } = Oo(t, e),
    g = BN(p),
    b = a[f ? (d === "floating" ? "reference" : "floating") : d],
    y = Ff(
      await i.getClippingRect({
        element:
          (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null ||
          n
            ? b
            : b.contextElement ||
              (await (i.getDocumentElement == null
                ? void 0
                : i.getDocumentElement(a.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      })
    ),
    x =
      d === "floating"
        ? { x: r, y: o, width: s.floating.width, height: s.floating.height }
        : s.reference,
    E = await (i.getOffsetParent == null
      ? void 0
      : i.getOffsetParent(a.floating)),
    w = (await (i.isElement == null ? void 0 : i.isElement(E)))
      ? (await (i.getScale == null ? void 0 : i.getScale(E))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    C = Ff(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: x,
            offsetParent: E,
            strategy: l,
          })
        : x
    )
  return {
    top: (y.top - C.top + g.top) / w.y,
    bottom: (C.bottom - y.bottom + g.bottom) / w.y,
    left: (y.left - C.left + g.left) / w.x,
    right: (C.right - y.right + g.right) / w.x,
  }
}
const zP = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
          x: n,
          y: r,
          placement: o,
          rects: i,
          platform: s,
          elements: a,
          middlewareData: l,
        } = t,
        { element: c, padding: u = 0 } = Oo(e, t) || {}
      if (c == null) return {}
      const d = BN(u),
        f = { x: n, y: r },
        p = ub(o),
        g = cb(p),
        v = await s.getDimensions(c),
        b = p === "y",
        y = b ? "top" : "left",
        x = b ? "bottom" : "right",
        E = b ? "clientHeight" : "clientWidth",
        w = i.reference[g] + i.reference[p] - f[p] - i.floating[g],
        C = f[p] - i.reference[p],
        S = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c))
      let M = S ? S[E] : 0
      ;(!M || !(await (s.isElement == null ? void 0 : s.isElement(S)))) &&
        (M = a.floating[E] || i.floating[g])
      const N = w / 2 - C / 2,
        R = M / 2 - v[g] / 2 - 1,
        B = Ei(d[y], R),
        V = Ei(d[x], R),
        j = B,
        U = M - v[g] - V,
        W = M / 2 - v[g] / 2 + N,
        ee = ty(j, W, U),
        I =
          !l.arrow &&
          hl(o) != null &&
          W !== ee &&
          i.reference[g] / 2 - (W < j ? B : V) - v[g] / 2 < 0,
        O = I ? (W < j ? W - j : W - U) : 0
      return {
        [p]: f[p] + O,
        data: {
          [p]: ee,
          centerOffset: W - ee - O,
          ...(I && { alignmentOffset: O }),
        },
        reset: I,
      }
    },
  }),
  UP = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "flip",
        options: e,
        async fn(t) {
          var n, r
          const {
              placement: o,
              middlewareData: i,
              rects: s,
              initialPlacement: a,
              platform: l,
              elements: c,
            } = t,
            {
              mainAxis: u = !0,
              crossAxis: d = !0,
              fallbackPlacements: f,
              fallbackStrategy: p = "bestFit",
              fallbackAxisSideDirection: g = "none",
              flipAlignment: v = !0,
              ...b
            } = Oo(e, t)
          if ((n = i.arrow) != null && n.alignmentOffset) return {}
          const y = Ao(o),
            x = Ci(a),
            E = Ao(a) === a,
            w = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
            C = f || (E || !v ? [jf(a)] : PP(a)),
            S = g !== "none"
          !f && S && C.push(...BP(a, v, g, w))
          const M = [a, ...C],
            N = await Fc(t, b),
            R = []
          let B = ((r = i.flip) == null ? void 0 : r.overflows) || []
          if ((u && R.push(N[y]), d)) {
            const W = LP(o, s, w)
            R.push(N[W[0]], N[W[1]])
          }
          if (
            ((B = [...B, { placement: o, overflows: R }]),
            !R.every((W) => W <= 0))
          ) {
            var V, j
            const W = (((V = i.flip) == null ? void 0 : V.index) || 0) + 1,
              ee = M[W]
            if (ee)
              return {
                data: { index: W, overflows: B },
                reset: { placement: ee },
              }
            let I =
              (j = B.filter((O) => O.overflows[0] <= 0).sort(
                (O, _) => O.overflows[1] - _.overflows[1]
              )[0]) == null
                ? void 0
                : j.placement
            if (!I)
              switch (p) {
                case "bestFit": {
                  var U
                  const O =
                    (U = B.filter((_) => {
                      if (S) {
                        const A = Ci(_.placement)
                        return A === x || A === "y"
                      }
                      return !0
                    })
                      .map((_) => [
                        _.placement,
                        _.overflows
                          .filter((A) => A > 0)
                          .reduce((A, P) => A + P, 0),
                      ])
                      .sort((_, A) => _[1] - A[1])[0]) == null
                      ? void 0
                      : U[0]
                  O && (I = O)
                  break
                }
                case "initialPlacement":
                  I = a
                  break
              }
            if (o !== I) return { reset: { placement: I } }
          }
          return {}
        },
      }
    )
  }
function Iw(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width,
  }
}
function Dw(e) {
  return RP.some((t) => e[t] >= 0)
}
const VP = function (e) {
  return (
    e === void 0 && (e = {}),
    {
      name: "hide",
      options: e,
      async fn(t) {
        const { rects: n } = t,
          { strategy: r = "referenceHidden", ...o } = Oo(e, t)
        switch (r) {
          case "referenceHidden": {
            const i = await Fc(t, { ...o, elementContext: "reference" }),
              s = Iw(i, n.reference)
            return {
              data: { referenceHiddenOffsets: s, referenceHidden: Dw(s) },
            }
          }
          case "escaped": {
            const i = await Fc(t, { ...o, altBoundary: !0 }),
              s = Iw(i, n.floating)
            return { data: { escapedOffsets: s, escaped: Dw(s) } }
          }
          default:
            return {}
        }
      },
    }
  )
}
async function HP(e, t) {
  const { placement: n, platform: r, elements: o } = e,
    i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)),
    s = Ao(n),
    a = hl(n),
    l = Ci(n) === "y",
    c = ["left", "top"].includes(s) ? -1 : 1,
    u = i && l ? -1 : 1,
    d = Oo(t, e)
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: g,
  } = typeof d == "number"
    ? { mainAxis: d, crossAxis: 0, alignmentAxis: null }
    : {
        mainAxis: d.mainAxis || 0,
        crossAxis: d.crossAxis || 0,
        alignmentAxis: d.alignmentAxis,
      }
  return (
    a && typeof g == "number" && (p = a === "end" ? g * -1 : g),
    l ? { x: p * u, y: f * c } : { x: f * c, y: p * u }
  )
}
const WP = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: "offset",
        options: e,
        async fn(t) {
          var n, r
          const { x: o, y: i, placement: s, middlewareData: a } = t,
            l = await HP(t, e)
          return s === ((n = a.offset) == null ? void 0 : n.placement) &&
            (r = a.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: o + l.x, y: i + l.y, data: { ...l, placement: s } }
        },
      }
    )
  },
  KP = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "shift",
        options: e,
        async fn(t) {
          const { x: n, y: r, placement: o } = t,
            {
              mainAxis: i = !0,
              crossAxis: s = !1,
              limiter: a = {
                fn: (b) => {
                  let { x: y, y: x } = b
                  return { x: y, y: x }
                },
              },
              ...l
            } = Oo(e, t),
            c = { x: n, y: r },
            u = await Fc(t, l),
            d = Ci(Ao(o)),
            f = lb(d)
          let p = c[f],
            g = c[d]
          if (i) {
            const b = f === "y" ? "top" : "left",
              y = f === "y" ? "bottom" : "right",
              x = p + u[b],
              E = p - u[y]
            p = ty(x, p, E)
          }
          if (s) {
            const b = d === "y" ? "top" : "left",
              y = d === "y" ? "bottom" : "right",
              x = g + u[b],
              E = g - u[y]
            g = ty(x, g, E)
          }
          const v = a.fn({ ...t, [f]: p, [d]: g })
          return {
            ...v,
            data: { x: v.x - n, y: v.y - r, enabled: { [f]: i, [d]: s } },
          }
        },
      }
    )
  },
  GP = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        options: e,
        fn(t) {
          const { x: n, y: r, placement: o, rects: i, middlewareData: s } = t,
            { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = Oo(e, t),
            u = { x: n, y: r },
            d = Ci(o),
            f = lb(d)
          let p = u[f],
            g = u[d]
          const v = Oo(a, t),
            b =
              typeof v == "number"
                ? { mainAxis: v, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...v }
          if (l) {
            const E = f === "y" ? "height" : "width",
              w = i.reference[f] - i.floating[E] + b.mainAxis,
              C = i.reference[f] + i.reference[E] - b.mainAxis
            p < w ? (p = w) : p > C && (p = C)
          }
          if (c) {
            var y, x
            const E = f === "y" ? "width" : "height",
              w = ["top", "left"].includes(Ao(o)),
              C =
                i.reference[d] -
                i.floating[E] +
                ((w && ((y = s.offset) == null ? void 0 : y[d])) || 0) +
                (w ? 0 : b.crossAxis),
              S =
                i.reference[d] +
                i.reference[E] +
                (w ? 0 : ((x = s.offset) == null ? void 0 : x[d]) || 0) -
                (w ? b.crossAxis : 0)
            g < C ? (g = C) : g > S && (g = S)
          }
          return { [f]: p, [d]: g }
        },
      }
    )
  },
  qP = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "size",
        options: e,
        async fn(t) {
          var n, r
          const { placement: o, rects: i, platform: s, elements: a } = t,
            { apply: l = () => {}, ...c } = Oo(e, t),
            u = await Fc(t, c),
            d = Ao(o),
            f = hl(o),
            p = Ci(o) === "y",
            { width: g, height: v } = i.floating
          let b, y
          d === "top" || d === "bottom"
            ? ((b = d),
              (y =
                f ===
                ((await (s.isRTL == null ? void 0 : s.isRTL(a.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((y = d), (b = f === "end" ? "top" : "bottom"))
          const x = v - u.top - u.bottom,
            E = g - u.left - u.right,
            w = Ei(v - u[b], x),
            C = Ei(g - u[y], E),
            S = !t.middlewareData.shift
          let M = w,
            N = C
          if (
            ((n = t.middlewareData.shift) != null && n.enabled.x && (N = E),
            (r = t.middlewareData.shift) != null && r.enabled.y && (M = x),
            S && !f)
          ) {
            const B = Ln(u.left, 0),
              V = Ln(u.right, 0),
              j = Ln(u.top, 0),
              U = Ln(u.bottom, 0)
            p
              ? (N = g - 2 * (B !== 0 || V !== 0 ? B + V : Ln(u.left, u.right)))
              : (M = v - 2 * (j !== 0 || U !== 0 ? j + U : Ln(u.top, u.bottom)))
          }
          await l({ ...t, availableWidth: N, availableHeight: M })
          const R = await s.getDimensions(a.floating)
          return g !== R.width || v !== R.height ? { reset: { rects: !0 } } : {}
        },
      }
    )
  }
function Ch() {
  return typeof window < "u"
}
function ml(e) {
  return jN(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function jn(e) {
  var t
  return (
    (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) ||
    window
  )
}
function no(e) {
  var t
  return (t = (jN(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement
}
function jN(e) {
  return Ch() ? e instanceof Node || e instanceof jn(e).Node : !1
}
function Tr(e) {
  return Ch() ? e instanceof Element || e instanceof jn(e).Element : !1
}
function Yr(e) {
  return Ch() ? e instanceof HTMLElement || e instanceof jn(e).HTMLElement : !1
}
function Lw(e) {
  return !Ch() || typeof ShadowRoot > "u"
    ? !1
    : e instanceof ShadowRoot || e instanceof jn(e).ShadowRoot
}
function Nu(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: o } = Mr(e)
  return (
    /auto|scroll|overlay|hidden|clip/.test(t + r + n) &&
    !["inline", "contents"].includes(o)
  )
}
function ZP(e) {
  return ["table", "td", "th"].includes(ml(e))
}
function Sh(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t)
    } catch {
      return !1
    }
  })
}
function db(e) {
  const t = fb(),
    n = Tr(e) ? Mr(e) : e
  return (
    ["transform", "translate", "scale", "rotate", "perspective"].some((r) =>
      n[r] ? n[r] !== "none" : !1
    ) ||
    (n.containerType ? n.containerType !== "normal" : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
    (!t && (n.filter ? n.filter !== "none" : !1)) ||
    ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(
      (r) => (n.willChange || "").includes(r)
    ) ||
    ["paint", "layout", "strict", "content"].some((r) =>
      (n.contain || "").includes(r)
    )
  )
}
function YP(e) {
  let t = Si(e)
  for (; Yr(t) && !Va(t); ) {
    if (db(t)) return t
    if (Sh(t)) return null
    t = Si(t)
  }
  return null
}
function fb() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none")
}
function Va(e) {
  return ["html", "body", "#document"].includes(ml(e))
}
function Mr(e) {
  return jn(e).getComputedStyle(e)
}
function _h(e) {
  return Tr(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.scrollX, scrollTop: e.scrollY }
}
function Si(e) {
  if (ml(e) === "html") return e
  const t = e.assignedSlot || e.parentNode || (Lw(e) && e.host) || no(e)
  return Lw(t) ? t.host : t
}
function FN(e) {
  const t = Si(e)
  return Va(t)
    ? e.ownerDocument
      ? e.ownerDocument.body
      : e.body
    : Yr(t) && Nu(t)
      ? t
      : FN(t)
}
function zc(e, t, n) {
  var r
  t === void 0 && (t = []), n === void 0 && (n = !0)
  const o = FN(e),
    i = o === ((r = e.ownerDocument) == null ? void 0 : r.body),
    s = jn(o)
  if (i) {
    const a = ry(s)
    return t.concat(
      s,
      s.visualViewport || [],
      Nu(o) ? o : [],
      a && n ? zc(a) : []
    )
  }
  return t.concat(o, zc(o, [], n))
}
function ry(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function zN(e) {
  const t = Mr(e)
  let n = parseFloat(t.width) || 0,
    r = parseFloat(t.height) || 0
  const o = Yr(e),
    i = o ? e.offsetWidth : n,
    s = o ? e.offsetHeight : r,
    a = Bf(n) !== i || Bf(r) !== s
  return a && ((n = i), (r = s)), { width: n, height: r, $: a }
}
function pb(e) {
  return Tr(e) ? e : e.contextElement
}
function Ta(e) {
  const t = pb(e)
  if (!Yr(t)) return Gr(1)
  const n = t.getBoundingClientRect(),
    { width: r, height: o, $: i } = zN(t)
  let s = (i ? Bf(n.width) : n.width) / r,
    a = (i ? Bf(n.height) : n.height) / o
  return (
    (!s || !Number.isFinite(s)) && (s = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    { x: s, y: a }
  )
}
const XP = Gr(0)
function UN(e) {
  const t = jn(e)
  return !fb() || !t.visualViewport
    ? XP
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
}
function QP(e, t, n) {
  return t === void 0 && (t = !1), !n || (t && n !== jn(e)) ? !1 : t
}
function bs(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1)
  const o = e.getBoundingClientRect(),
    i = pb(e)
  let s = Gr(1)
  t && (r ? Tr(r) && (s = Ta(r)) : (s = Ta(e)))
  const a = QP(i, n, r) ? UN(i) : Gr(0)
  let l = (o.left + a.x) / s.x,
    c = (o.top + a.y) / s.y,
    u = o.width / s.x,
    d = o.height / s.y
  if (i) {
    const f = jn(i),
      p = r && Tr(r) ? jn(r) : r
    let g = f,
      v = ry(g)
    for (; v && r && p !== g; ) {
      const b = Ta(v),
        y = v.getBoundingClientRect(),
        x = Mr(v),
        E = y.left + (v.clientLeft + parseFloat(x.paddingLeft)) * b.x,
        w = y.top + (v.clientTop + parseFloat(x.paddingTop)) * b.y
      ;(l *= b.x),
        (c *= b.y),
        (u *= b.x),
        (d *= b.y),
        (l += E),
        (c += w),
        (g = jn(v)),
        (v = ry(g))
    }
  }
  return Ff({ width: u, height: d, x: l, y: c })
}
function hb(e, t) {
  const n = _h(e).scrollLeft
  return t ? t.left + n : bs(no(e)).left + n
}
function VN(e, t, n) {
  n === void 0 && (n = !1)
  const r = e.getBoundingClientRect(),
    o = r.left + t.scrollLeft - (n ? 0 : hb(e, r)),
    i = r.top + t.scrollTop
  return { x: o, y: i }
}
function JP(e) {
  let { elements: t, rect: n, offsetParent: r, strategy: o } = e
  const i = o === "fixed",
    s = no(r),
    a = t ? Sh(t.floating) : !1
  if (r === s || (a && i)) return n
  let l = { scrollLeft: 0, scrollTop: 0 },
    c = Gr(1)
  const u = Gr(0),
    d = Yr(r)
  if (
    (d || (!d && !i)) &&
    ((ml(r) !== "body" || Nu(s)) && (l = _h(r)), Yr(r))
  ) {
    const p = bs(r)
    ;(c = Ta(r)), (u.x = p.x + r.clientLeft), (u.y = p.y + r.clientTop)
  }
  const f = s && !d && !i ? VN(s, l, !0) : Gr(0)
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y,
  }
}
function e9(e) {
  return Array.from(e.getClientRects())
}
function t9(e) {
  const t = no(e),
    n = _h(e),
    r = e.ownerDocument.body,
    o = Ln(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
    i = Ln(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight)
  let s = -n.scrollLeft + hb(e)
  const a = -n.scrollTop
  return (
    Mr(r).direction === "rtl" && (s += Ln(t.clientWidth, r.clientWidth) - o),
    { width: o, height: i, x: s, y: a }
  )
}
function n9(e, t) {
  const n = jn(e),
    r = no(e),
    o = n.visualViewport
  let i = r.clientWidth,
    s = r.clientHeight,
    a = 0,
    l = 0
  if (o) {
    ;(i = o.width), (s = o.height)
    const c = fb()
    ;(!c || (c && t === "fixed")) && ((a = o.offsetLeft), (l = o.offsetTop))
  }
  return { width: i, height: s, x: a, y: l }
}
function r9(e, t) {
  const n = bs(e, !0, t === "fixed"),
    r = n.top + e.clientTop,
    o = n.left + e.clientLeft,
    i = Yr(e) ? Ta(e) : Gr(1),
    s = e.clientWidth * i.x,
    a = e.clientHeight * i.y,
    l = o * i.x,
    c = r * i.y
  return { width: s, height: a, x: l, y: c }
}
function Pw(e, t, n) {
  let r
  if (t === "viewport") r = n9(e, n)
  else if (t === "document") r = t9(no(e))
  else if (Tr(t)) r = r9(t, n)
  else {
    const o = UN(e)
    r = { x: t.x - o.x, y: t.y - o.y, width: t.width, height: t.height }
  }
  return Ff(r)
}
function HN(e, t) {
  const n = Si(e)
  return n === t || !Tr(n) || Va(n)
    ? !1
    : Mr(n).position === "fixed" || HN(n, t)
}
function o9(e, t) {
  const n = t.get(e)
  if (n) return n
  let r = zc(e, [], !1).filter((a) => Tr(a) && ml(a) !== "body"),
    o = null
  const i = Mr(e).position === "fixed"
  let s = i ? Si(e) : e
  for (; Tr(s) && !Va(s); ) {
    const a = Mr(s),
      l = db(s)
    !l && a.position === "fixed" && (o = null),
      (
        i
          ? !l && !o
          : (!l &&
              a.position === "static" &&
              !!o &&
              ["absolute", "fixed"].includes(o.position)) ||
            (Nu(s) && !l && HN(e, s))
      )
        ? (r = r.filter((u) => u !== s))
        : (o = a),
      (s = Si(s))
  }
  return t.set(e, r), r
}
function i9(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: o } = e
  const s = [
      ...(n === "clippingAncestors"
        ? Sh(t)
          ? []
          : o9(t, this._c)
        : [].concat(n)),
      r,
    ],
    a = s[0],
    l = s.reduce(
      (c, u) => {
        const d = Pw(t, u, o)
        return (
          (c.top = Ln(d.top, c.top)),
          (c.right = Ei(d.right, c.right)),
          (c.bottom = Ei(d.bottom, c.bottom)),
          (c.left = Ln(d.left, c.left)),
          c
        )
      },
      Pw(t, a, o)
    )
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top,
  }
}
function s9(e) {
  const { width: t, height: n } = zN(e)
  return { width: t, height: n }
}
function a9(e, t, n) {
  const r = Yr(t),
    o = no(t),
    i = n === "fixed",
    s = bs(e, !0, i, t)
  let a = { scrollLeft: 0, scrollTop: 0 }
  const l = Gr(0)
  if (r || (!r && !i))
    if (((ml(t) !== "body" || Nu(o)) && (a = _h(t)), r)) {
      const f = bs(t, !0, i, t)
      ;(l.x = f.x + t.clientLeft), (l.y = f.y + t.clientTop)
    } else o && (l.x = hb(o))
  const c = o && !r && !i ? VN(o, a) : Gr(0),
    u = s.left + a.scrollLeft - l.x - c.x,
    d = s.top + a.scrollTop - l.y - c.y
  return { x: u, y: d, width: s.width, height: s.height }
}
function Qm(e) {
  return Mr(e).position === "static"
}
function $w(e, t) {
  if (!Yr(e) || Mr(e).position === "fixed") return null
  if (t) return t(e)
  let n = e.offsetParent
  return no(e) === n && (n = n.ownerDocument.body), n
}
function WN(e, t) {
  const n = jn(e)
  if (Sh(e)) return n
  if (!Yr(e)) {
    let o = Si(e)
    for (; o && !Va(o); ) {
      if (Tr(o) && !Qm(o)) return o
      o = Si(o)
    }
    return n
  }
  let r = $w(e, t)
  for (; r && ZP(r) && Qm(r); ) r = $w(r, t)
  return r && Va(r) && Qm(r) && !db(r) ? n : r || YP(e) || n
}
const l9 = async function (e) {
  const t = this.getOffsetParent || WN,
    n = this.getDimensions,
    r = await n(e.floating)
  return {
    reference: a9(e.reference, await t(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  }
}
function c9(e) {
  return Mr(e).direction === "rtl"
}
const u9 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: JP,
  getDocumentElement: no,
  getClippingRect: i9,
  getOffsetParent: WN,
  getElementRects: l9,
  getClientRects: e9,
  getDimensions: s9,
  getScale: Ta,
  isElement: Tr,
  isRTL: c9,
}
function KN(e, t) {
  return (
    e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
  )
}
function d9(e, t) {
  let n = null,
    r
  const o = no(e)
  function i() {
    var a
    clearTimeout(r), (a = n) == null || a.disconnect(), (n = null)
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i()
    const c = e.getBoundingClientRect(),
      { left: u, top: d, width: f, height: p } = c
    if ((a || t(), !f || !p)) return
    const g = fd(d),
      v = fd(o.clientWidth - (u + f)),
      b = fd(o.clientHeight - (d + p)),
      y = fd(u),
      E = {
        rootMargin: -g + "px " + -v + "px " + -b + "px " + -y + "px",
        threshold: Ln(0, Ei(1, l)) || 1,
      }
    let w = !0
    function C(S) {
      const M = S[0].intersectionRatio
      if (M !== l) {
        if (!w) return s()
        M
          ? s(!1, M)
          : (r = setTimeout(() => {
              s(!1, 1e-7)
            }, 1e3))
      }
      M === 1 && !KN(c, e.getBoundingClientRect()) && s(), (w = !1)
    }
    try {
      n = new IntersectionObserver(C, { ...E, root: o.ownerDocument })
    } catch {
      n = new IntersectionObserver(C, E)
    }
    n.observe(e)
  }
  return s(!0), i
}
function f9(e, t, n, r) {
  r === void 0 && (r = {})
  const {
      ancestorScroll: o = !0,
      ancestorResize: i = !0,
      elementResize: s = typeof ResizeObserver == "function",
      layoutShift: a = typeof IntersectionObserver == "function",
      animationFrame: l = !1,
    } = r,
    c = pb(e),
    u = o || i ? [...(c ? zc(c) : []), ...zc(t)] : []
  u.forEach((y) => {
    o && y.addEventListener("scroll", n, { passive: !0 }),
      i && y.addEventListener("resize", n)
  })
  const d = c && a ? d9(c, n) : null
  let f = -1,
    p = null
  s &&
    ((p = new ResizeObserver((y) => {
      let [x] = y
      x &&
        x.target === c &&
        p &&
        (p.unobserve(t),
        cancelAnimationFrame(f),
        (f = requestAnimationFrame(() => {
          var E
          ;(E = p) == null || E.observe(t)
        }))),
        n()
    })),
    c && !l && p.observe(c),
    p.observe(t))
  let g,
    v = l ? bs(e) : null
  l && b()
  function b() {
    const y = bs(e)
    v && !KN(v, y) && n(), (v = y), (g = requestAnimationFrame(b))
  }
  return (
    n(),
    () => {
      var y
      u.forEach((x) => {
        o && x.removeEventListener("scroll", n),
          i && x.removeEventListener("resize", n)
      }),
        d == null || d(),
        (y = p) == null || y.disconnect(),
        (p = null),
        l && cancelAnimationFrame(g)
    }
  )
}
const p9 = WP,
  h9 = KP,
  m9 = UP,
  g9 = qP,
  v9 = VP,
  Bw = zP,
  y9 = GP,
  b9 = (e, t, n) => {
    const r = new Map(),
      o = { platform: u9, ...n },
      i = { ...o.platform, _c: r }
    return FP(e, t, { ...o, platform: i })
  }
var tf = typeof document < "u" ? m.useLayoutEffect : m.useEffect
function zf(e, t) {
  if (e === t) return !0
  if (typeof e != typeof t) return !1
  if (typeof e == "function" && e.toString() === t.toString()) return !0
  let n, r, o
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1
      for (r = n; r-- !== 0; ) if (!zf(e[r], t[r])) return !1
      return !0
    }
    if (((o = Object.keys(e)), (n = o.length), n !== Object.keys(t).length))
      return !1
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, o[r])) return !1
    for (r = n; r-- !== 0; ) {
      const i = o[r]
      if (!(i === "_owner" && e.$$typeof) && !zf(e[i], t[i])) return !1
    }
    return !0
  }
  return e !== e && t !== t
}
function GN(e) {
  return typeof window > "u"
    ? 1
    : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function jw(e, t) {
  const n = GN(e)
  return Math.round(t * n) / n
}
function Jm(e) {
  const t = m.useRef(e)
  return (
    tf(() => {
      t.current = e
    }),
    t
  )
}
function x9(e) {
  e === void 0 && (e = {})
  const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: o,
      elements: { reference: i, floating: s } = {},
      transform: a = !0,
      whileElementsMounted: l,
      open: c,
    } = e,
    [u, d] = m.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1,
    }),
    [f, p] = m.useState(r)
  zf(f, r) || p(r)
  const [g, v] = m.useState(null),
    [b, y] = m.useState(null),
    x = m.useCallback((_) => {
      _ !== S.current && ((S.current = _), v(_))
    }, []),
    E = m.useCallback((_) => {
      _ !== M.current && ((M.current = _), y(_))
    }, []),
    w = i || g,
    C = s || b,
    S = m.useRef(null),
    M = m.useRef(null),
    N = m.useRef(u),
    R = l != null,
    B = Jm(l),
    V = Jm(o),
    j = Jm(c),
    U = m.useCallback(() => {
      if (!S.current || !M.current) return
      const _ = { placement: t, strategy: n, middleware: f }
      V.current && (_.platform = V.current),
        b9(S.current, M.current, _).then((A) => {
          const P = { ...A, isPositioned: j.current !== !1 }
          W.current &&
            !zf(N.current, P) &&
            ((N.current = P),
            Rs.flushSync(() => {
              d(P)
            }))
        })
    }, [f, t, n, V, j])
  tf(() => {
    c === !1 &&
      N.current.isPositioned &&
      ((N.current.isPositioned = !1), d((_) => ({ ..._, isPositioned: !1 })))
  }, [c])
  const W = m.useRef(!1)
  tf(
    () => (
      (W.current = !0),
      () => {
        W.current = !1
      }
    ),
    []
  ),
    tf(() => {
      if ((w && (S.current = w), C && (M.current = C), w && C)) {
        if (B.current) return B.current(w, C, U)
        U()
      }
    }, [w, C, U, B, R])
  const ee = m.useMemo(
      () => ({ reference: S, floating: M, setReference: x, setFloating: E }),
      [x, E]
    ),
    I = m.useMemo(() => ({ reference: w, floating: C }), [w, C]),
    O = m.useMemo(() => {
      const _ = { position: n, left: 0, top: 0 }
      if (!I.floating) return _
      const A = jw(I.floating, u.x),
        P = jw(I.floating, u.y)
      return a
        ? {
            ..._,
            transform: "translate(" + A + "px, " + P + "px)",
            ...(GN(I.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: n, left: A, top: P }
    }, [n, a, I.floating, u.x, u.y])
  return m.useMemo(
    () => ({ ...u, update: U, refs: ee, elements: I, floatingStyles: O }),
    [u, U, ee, I, O]
  )
}
const w9 = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current")
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const { element: r, padding: o } = typeof e == "function" ? e(n) : e
        return r && t(r)
          ? r.current != null
            ? Bw({ element: r.current, padding: o }).fn(n)
            : {}
          : r
            ? Bw({ element: r, padding: o }).fn(n)
            : {}
      },
    }
  },
  E9 = (e, t) => ({ ...p9(e), options: [e, t] }),
  C9 = (e, t) => ({ ...h9(e), options: [e, t] }),
  S9 = (e, t) => ({ ...y9(e), options: [e, t] }),
  _9 = (e, t) => ({ ...m9(e), options: [e, t] }),
  k9 = (e, t) => ({ ...g9(e), options: [e, t] }),
  N9 = (e, t) => ({ ...v9(e), options: [e, t] }),
  T9 = (e, t) => ({ ...w9(e), options: [e, t] })
var M9 = "Arrow",
  qN = m.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: o = 5, ...i } = e
    return h.jsx(Le.svg, {
      ...i,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : h.jsx("polygon", { points: "0,0 30,0 15,10" }),
    })
  })
qN.displayName = M9
var O9 = qN
function kh(e) {
  const [t, n] = m.useState(void 0)
  return (
    ys(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight })
        const r = new ResizeObserver((o) => {
          if (!Array.isArray(o) || !o.length) return
          const i = o[0]
          let s, a
          if ("borderBoxSize" in i) {
            const l = i.borderBoxSize,
              c = Array.isArray(l) ? l[0] : l
            ;(s = c.inlineSize), (a = c.blockSize)
          } else (s = e.offsetWidth), (a = e.offsetHeight)
          n({ width: s, height: a })
        })
        return r.observe(e, { box: "border-box" }), () => r.unobserve(e)
      } else n(void 0)
    }, [e]),
    t
  )
}
var mb = "Popper",
  [ZN, gl] = Wn(mb),
  [A9, YN] = ZN(mb),
  XN = (e) => {
    const { __scopePopper: t, children: n } = e,
      [r, o] = m.useState(null)
    return h.jsx(A9, { scope: t, anchor: r, onAnchorChange: o, children: n })
  }
XN.displayName = mb
var QN = "PopperAnchor",
  JN = m.forwardRef((e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e,
      i = YN(QN, n),
      s = m.useRef(null),
      a = tt(t, s)
    return (
      m.useEffect(() => {
        i.onAnchorChange((r == null ? void 0 : r.current) || s.current)
      }),
      r ? null : h.jsx(Le.div, { ...o, ref: a })
    )
  })
JN.displayName = QN
var gb = "PopperContent",
  [R9, I9] = ZN(gb),
  eT = m.forwardRef((e, t) => {
    var Ae, je, Fe, Ze, dt, kt, ft, Et
    const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: o = 0,
        align: i = "center",
        alignOffset: s = 0,
        arrowPadding: a = 0,
        avoidCollisions: l = !0,
        collisionBoundary: c = [],
        collisionPadding: u = 0,
        sticky: d = "partial",
        hideWhenDetached: f = !1,
        updatePositionStrategy: p = "optimized",
        onPlaced: g,
        ...v
      } = e,
      b = YN(gb, n),
      [y, x] = m.useState(null),
      E = tt(t, (He) => x(He)),
      [w, C] = m.useState(null),
      S = kh(w),
      M = (Ae = S == null ? void 0 : S.width) != null ? Ae : 0,
      N = (je = S == null ? void 0 : S.height) != null ? je : 0,
      R = r + (i !== "center" ? "-" + i : ""),
      B =
        typeof u == "number"
          ? u
          : { top: 0, right: 0, bottom: 0, left: 0, ...u },
      V = Array.isArray(c) ? c : [c],
      j = V.length > 0,
      U = { padding: B, boundary: V.filter(L9), altBoundary: j },
      {
        refs: W,
        floatingStyles: ee,
        placement: I,
        isPositioned: O,
        middlewareData: _,
      } = x9({
        strategy: "fixed",
        placement: R,
        whileElementsMounted: (...He) =>
          f9(...He, { animationFrame: p === "always" }),
        elements: { reference: b.anchor },
        middleware: [
          E9({ mainAxis: o + N, alignmentAxis: s }),
          l &&
            C9({
              mainAxis: !0,
              crossAxis: !1,
              limiter: d === "partial" ? S9() : void 0,
              ...U,
            }),
          l && _9({ ...U }),
          k9({
            ...U,
            apply: ({
              elements: He,
              rects: be,
              availableWidth: yt,
              availableHeight: ue,
            }) => {
              const { width: me, height: $e } = be.reference,
                fe = He.floating.style
              fe.setProperty("--radix-popper-available-width", `${yt}px`),
                fe.setProperty("--radix-popper-available-height", `${ue}px`),
                fe.setProperty("--radix-popper-anchor-width", `${me}px`),
                fe.setProperty("--radix-popper-anchor-height", `${$e}px`)
            },
          }),
          w && T9({ element: w, padding: a }),
          P9({ arrowWidth: M, arrowHeight: N }),
          f && N9({ strategy: "referenceHidden", ...U }),
        ],
      }),
      [A, P] = rT(I),
      H = Nr(g)
    ys(() => {
      O && (H == null || H())
    }, [O, H])
    const X = (Fe = _.arrow) == null ? void 0 : Fe.x,
      ae = (Ze = _.arrow) == null ? void 0 : Ze.y,
      ve = ((dt = _.arrow) == null ? void 0 : dt.centerOffset) !== 0,
      [he, xe] = m.useState()
    return (
      ys(() => {
        y && xe(window.getComputedStyle(y).zIndex)
      }, [y]),
      h.jsx("div", {
        ref: W.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...ee,
          transform: O ? ee.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: he,
          "--radix-popper-transform-origin": [
            (kt = _.transformOrigin) == null ? void 0 : kt.x,
            (ft = _.transformOrigin) == null ? void 0 : ft.y,
          ].join(" "),
          ...(((Et = _.hide) == null ? void 0 : Et.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none",
          }),
        },
        dir: e.dir,
        children: h.jsx(R9, {
          scope: n,
          placedSide: A,
          onArrowChange: C,
          arrowX: X,
          arrowY: ae,
          shouldHideArrow: ve,
          children: h.jsx(Le.div, {
            "data-side": A,
            "data-align": P,
            ...v,
            ref: E,
            style: { ...v.style, animation: O ? void 0 : "none" },
          }),
        }),
      })
    )
  })
eT.displayName = gb
var tT = "PopperArrow",
  D9 = { top: "bottom", right: "left", bottom: "top", left: "right" },
  nT = m.forwardRef(function (t, n) {
    const { __scopePopper: r, ...o } = t,
      i = I9(tT, r),
      s = D9[i.placedSide]
    return h.jsx("span", {
      ref: i.onArrowChange,
      style: {
        position: "absolute",
        left: i.arrowX,
        top: i.arrowY,
        [s]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0",
        }[i.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[i.placedSide],
        visibility: i.shouldHideArrow ? "hidden" : void 0,
      },
      children: h.jsx(O9, {
        ...o,
        ref: n,
        style: { ...o.style, display: "block" },
      }),
    })
  })
nT.displayName = tT
function L9(e) {
  return e !== null
}
var P9 = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var b, y, x, E, w
    const { placement: n, rects: r, middlewareData: o } = t,
      s = ((b = o.arrow) == null ? void 0 : b.centerOffset) !== 0,
      a = s ? 0 : e.arrowWidth,
      l = s ? 0 : e.arrowHeight,
      [c, u] = rT(n),
      d = { start: "0%", center: "50%", end: "100%" }[u],
      f = ((x = (y = o.arrow) == null ? void 0 : y.x) != null ? x : 0) + a / 2,
      p = ((w = (E = o.arrow) == null ? void 0 : E.y) != null ? w : 0) + l / 2
    let g = "",
      v = ""
    return (
      c === "bottom"
        ? ((g = s ? d : `${f}px`), (v = `${-l}px`))
        : c === "top"
          ? ((g = s ? d : `${f}px`), (v = `${r.floating.height + l}px`))
          : c === "right"
            ? ((g = `${-l}px`), (v = s ? d : `${p}px`))
            : c === "left" &&
              ((g = `${r.floating.width + l}px`), (v = s ? d : `${p}px`)),
      { data: { x: g, y: v } }
    )
  },
})
function rT(e) {
  const [t, n = "center"] = e.split("-")
  return [t, n]
}
var vb = XN,
  Nh = JN,
  yb = eT,
  bb = nT,
  $9 = "Portal",
  Th = m.forwardRef((e, t) => {
    var a
    const { container: n, ...r } = e,
      [o, i] = m.useState(!1)
    ys(() => i(!0), [])
    const s =
      n ||
      (o &&
        ((a = globalThis == null ? void 0 : globalThis.document) == null
          ? void 0
          : a.body))
    return s ? vh.createPortal(h.jsx(Le.div, { ...r, ref: t }), s) : null
  })
Th.displayName = $9
function B9(e, t) {
  return m.useReducer((n, r) => {
    const o = t[n][r]
    return o != null ? o : n
  }, e)
}
var Kn = (e) => {
  const { present: t, children: n } = e,
    r = j9(t),
    o =
      typeof n == "function" ? n({ present: r.isPresent }) : m.Children.only(n),
    i = tt(r.ref, F9(o))
  return typeof n == "function" || r.isPresent
    ? m.cloneElement(o, { ref: i })
    : null
}
Kn.displayName = "Presence"
function j9(e) {
  const [t, n] = m.useState(),
    r = m.useRef({}),
    o = m.useRef(e),
    i = m.useRef("none"),
    s = e ? "mounted" : "unmounted",
    [a, l] = B9(s, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    })
  return (
    m.useEffect(() => {
      const c = pd(r.current)
      i.current = a === "mounted" ? c : "none"
    }, [a]),
    ys(() => {
      const c = r.current,
        u = o.current
      if (u !== e) {
        const f = i.current,
          p = pd(c)
        e
          ? l("MOUNT")
          : p === "none" || (c == null ? void 0 : c.display) === "none"
            ? l("UNMOUNT")
            : l(u && f !== p ? "ANIMATION_OUT" : "UNMOUNT"),
          (o.current = e)
      }
    }, [e, l]),
    ys(() => {
      var c
      if (t) {
        let u
        const d = (c = t.ownerDocument.defaultView) != null ? c : window,
          f = (g) => {
            const b = pd(r.current).includes(g.animationName)
            if (g.target === t && b && (l("ANIMATION_END"), !o.current)) {
              const y = t.style.animationFillMode
              ;(t.style.animationFillMode = "forwards"),
                (u = d.setTimeout(() => {
                  t.style.animationFillMode === "forwards" &&
                    (t.style.animationFillMode = y)
                }))
            }
          },
          p = (g) => {
            g.target === t && (i.current = pd(r.current))
          }
        return (
          t.addEventListener("animationstart", p),
          t.addEventListener("animationcancel", f),
          t.addEventListener("animationend", f),
          () => {
            d.clearTimeout(u),
              t.removeEventListener("animationstart", p),
              t.removeEventListener("animationcancel", f),
              t.removeEventListener("animationend", f)
          }
        )
      } else l("ANIMATION_END")
    }, [t, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(a),
      ref: m.useCallback((c) => {
        c && (r.current = getComputedStyle(c)), n(c)
      }, []),
    }
  )
}
function pd(e) {
  return (e == null ? void 0 : e.animationName) || "none"
}
function F9(e) {
  var r, o
  let t =
      (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null
        ? void 0
        : r.get,
    n = t && "isReactWarning" in t && t.isReactWarning
  return n
    ? e.ref
    : ((t =
        (o = Object.getOwnPropertyDescriptor(e, "ref")) == null
          ? void 0
          : o.get),
      (n = t && "isReactWarning" in t && t.isReactWarning),
      n ? e.props.ref : e.props.ref || e.ref)
}
function Ir({ prop: e, defaultProp: t, onChange: n = () => {} }) {
  const [r, o] = z9({ defaultProp: t, onChange: n }),
    i = e !== void 0,
    s = i ? e : r,
    a = Nr(n),
    l = m.useCallback(
      (c) => {
        if (i) {
          const d = typeof c == "function" ? c(e) : c
          d !== e && a(d)
        } else o(c)
      },
      [i, e, o, a]
    )
  return [s, l]
}
function z9({ defaultProp: e, onChange: t }) {
  const n = m.useState(e),
    [r] = n,
    o = m.useRef(r),
    i = Nr(t)
  return (
    m.useEffect(() => {
      o.current !== r && (i(r), (o.current = r))
    }, [r, o, i]),
    n
  )
}
var U9 = "VisuallyHidden",
  oT = m.forwardRef((e, t) =>
    h.jsx(Le.span, {
      ...e,
      ref: t,
      style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style,
      },
    })
  )
oT.displayName = U9
var V9 = oT,
  [Mh, Kte] = Wn("Tooltip", [gl]),
  Oh = gl(),
  iT = "TooltipProvider",
  H9 = 700,
  oy = "tooltip.open",
  [W9, xb] = Mh(iT),
  sT = (e) => {
    const {
        __scopeTooltip: t,
        delayDuration: n = H9,
        skipDelayDuration: r = 300,
        disableHoverableContent: o = !1,
        children: i,
      } = e,
      [s, a] = m.useState(!0),
      l = m.useRef(!1),
      c = m.useRef(0)
    return (
      m.useEffect(() => {
        const u = c.current
        return () => window.clearTimeout(u)
      }, []),
      h.jsx(W9, {
        scope: t,
        isOpenDelayed: s,
        delayDuration: n,
        onOpen: m.useCallback(() => {
          window.clearTimeout(c.current), a(!1)
        }, []),
        onClose: m.useCallback(() => {
          window.clearTimeout(c.current),
            (c.current = window.setTimeout(() => a(!0), r))
        }, [r]),
        isPointerInTransitRef: l,
        onPointerInTransitChange: m.useCallback((u) => {
          l.current = u
        }, []),
        disableHoverableContent: o,
        children: i,
      })
    )
  }
sT.displayName = iT
var Ah = "Tooltip",
  [K9, Rh] = Mh(Ah),
  aT = (e) => {
    const {
        __scopeTooltip: t,
        children: n,
        open: r,
        defaultOpen: o = !1,
        onOpenChange: i,
        disableHoverableContent: s,
        delayDuration: a,
      } = e,
      l = xb(Ah, e.__scopeTooltip),
      c = Oh(t),
      [u, d] = m.useState(null),
      f = fi(),
      p = m.useRef(0),
      g = s != null ? s : l.disableHoverableContent,
      v = a != null ? a : l.delayDuration,
      b = m.useRef(!1),
      [y = !1, x] = Ir({
        prop: r,
        defaultProp: o,
        onChange: (M) => {
          M
            ? (l.onOpen(), document.dispatchEvent(new CustomEvent(oy)))
            : l.onClose(),
            i == null || i(M)
        },
      }),
      E = m.useMemo(
        () => (y ? (b.current ? "delayed-open" : "instant-open") : "closed"),
        [y]
      ),
      w = m.useCallback(() => {
        window.clearTimeout(p.current), (p.current = 0), (b.current = !1), x(!0)
      }, [x]),
      C = m.useCallback(() => {
        window.clearTimeout(p.current), (p.current = 0), x(!1)
      }, [x]),
      S = m.useCallback(() => {
        window.clearTimeout(p.current),
          (p.current = window.setTimeout(() => {
            ;(b.current = !0), x(!0), (p.current = 0)
          }, v))
      }, [v, x])
    return (
      m.useEffect(
        () => () => {
          p.current && (window.clearTimeout(p.current), (p.current = 0))
        },
        []
      ),
      h.jsx(vb, {
        ...c,
        children: h.jsx(K9, {
          scope: t,
          contentId: f,
          open: y,
          stateAttribute: E,
          trigger: u,
          onTriggerChange: d,
          onTriggerEnter: m.useCallback(() => {
            l.isOpenDelayed ? S() : w()
          }, [l.isOpenDelayed, S, w]),
          onTriggerLeave: m.useCallback(() => {
            g ? C() : (window.clearTimeout(p.current), (p.current = 0))
          }, [C, g]),
          onOpen: w,
          onClose: C,
          disableHoverableContent: g,
          children: n,
        }),
      })
    )
  }
aT.displayName = Ah
var iy = "TooltipTrigger",
  lT = m.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e,
      o = Rh(iy, n),
      i = xb(iy, n),
      s = Oh(n),
      a = m.useRef(null),
      l = tt(t, a, o.onTriggerChange),
      c = m.useRef(!1),
      u = m.useRef(!1),
      d = m.useCallback(() => (c.current = !1), [])
    return (
      m.useEffect(
        () => () => document.removeEventListener("pointerup", d),
        [d]
      ),
      h.jsx(Nh, {
        asChild: !0,
        ...s,
        children: h.jsx(Le.button, {
          "aria-describedby": o.open ? o.contentId : void 0,
          "data-state": o.stateAttribute,
          ...r,
          ref: l,
          onPointerMove: ge(e.onPointerMove, (f) => {
            f.pointerType !== "touch" &&
              !u.current &&
              !i.isPointerInTransitRef.current &&
              (o.onTriggerEnter(), (u.current = !0))
          }),
          onPointerLeave: ge(e.onPointerLeave, () => {
            o.onTriggerLeave(), (u.current = !1)
          }),
          onPointerDown: ge(e.onPointerDown, () => {
            ;(c.current = !0),
              document.addEventListener("pointerup", d, { once: !0 })
          }),
          onFocus: ge(e.onFocus, () => {
            c.current || o.onOpen()
          }),
          onBlur: ge(e.onBlur, o.onClose),
          onClick: ge(e.onClick, o.onClose),
        }),
      })
    )
  })
lT.displayName = iy
var G9 = "TooltipPortal",
  [Gte, q9] = Mh(G9, { forceMount: void 0 }),
  Ha = "TooltipContent",
  cT = m.forwardRef((e, t) => {
    const n = q9(Ha, e.__scopeTooltip),
      { forceMount: r = n.forceMount, side: o = "top", ...i } = e,
      s = Rh(Ha, e.__scopeTooltip)
    return h.jsx(Kn, {
      present: r || s.open,
      children: s.disableHoverableContent
        ? h.jsx(uT, { side: o, ...i, ref: t })
        : h.jsx(Z9, { side: o, ...i, ref: t }),
    })
  }),
  Z9 = m.forwardRef((e, t) => {
    const n = Rh(Ha, e.__scopeTooltip),
      r = xb(Ha, e.__scopeTooltip),
      o = m.useRef(null),
      i = tt(t, o),
      [s, a] = m.useState(null),
      { trigger: l, onClose: c } = n,
      u = o.current,
      { onPointerInTransitChange: d } = r,
      f = m.useCallback(() => {
        a(null), d(!1)
      }, [d]),
      p = m.useCallback(
        (g, v) => {
          const b = g.currentTarget,
            y = { x: g.clientX, y: g.clientY },
            x = J9(y, b.getBoundingClientRect()),
            E = e6(y, x),
            w = t6(v.getBoundingClientRect()),
            C = r6([...E, ...w])
          a(C), d(!0)
        },
        [d]
      )
    return (
      m.useEffect(() => () => f(), [f]),
      m.useEffect(() => {
        if (l && u) {
          const g = (b) => p(b, u),
            v = (b) => p(b, l)
          return (
            l.addEventListener("pointerleave", g),
            u.addEventListener("pointerleave", v),
            () => {
              l.removeEventListener("pointerleave", g),
                u.removeEventListener("pointerleave", v)
            }
          )
        }
      }, [l, u, p, f]),
      m.useEffect(() => {
        if (s) {
          const g = (v) => {
            const b = v.target,
              y = { x: v.clientX, y: v.clientY },
              x =
                (l == null ? void 0 : l.contains(b)) ||
                (u == null ? void 0 : u.contains(b)),
              E = !n6(y, s)
            x ? f() : E && (f(), c())
          }
          return (
            document.addEventListener("pointermove", g),
            () => document.removeEventListener("pointermove", g)
          )
        }
      }, [l, u, s, c, f]),
      h.jsx(uT, { ...e, ref: i })
    )
  }),
  [Y9, X9] = Mh(Ah, { isInside: !1 }),
  uT = m.forwardRef((e, t) => {
    const {
        __scopeTooltip: n,
        children: r,
        "aria-label": o,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        ...a
      } = e,
      l = Rh(Ha, n),
      c = Oh(n),
      { onClose: u } = l
    return (
      m.useEffect(
        () => (
          document.addEventListener(oy, u),
          () => document.removeEventListener(oy, u)
        ),
        [u]
      ),
      m.useEffect(() => {
        if (l.trigger) {
          const d = (f) => {
            const p = f.target
            p != null && p.contains(l.trigger) && u()
          }
          return (
            window.addEventListener("scroll", d, { capture: !0 }),
            () => window.removeEventListener("scroll", d, { capture: !0 })
          )
        }
      }, [l.trigger, u]),
      h.jsx(ku, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: u,
        children: h.jsxs(yb, {
          "data-state": l.stateAttribute,
          ...c,
          ...a,
          ref: t,
          style: {
            ...a.style,
            "--radix-tooltip-content-transform-origin":
              "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width":
              "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height":
              "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height":
              "var(--radix-popper-anchor-height)",
          },
          children: [
            h.jsx(CN, { children: r }),
            h.jsx(Y9, {
              scope: n,
              isInside: !0,
              children: h.jsx(V9, {
                id: l.contentId,
                role: "tooltip",
                children: o || r,
              }),
            }),
          ],
        }),
      })
    )
  })
cT.displayName = Ha
var dT = "TooltipArrow",
  Q9 = m.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e,
      o = Oh(n)
    return X9(dT, n).isInside ? null : h.jsx(bb, { ...o, ...r, ref: t })
  })
Q9.displayName = dT
function J9(e, t) {
  const n = Math.abs(t.top - e.y),
    r = Math.abs(t.bottom - e.y),
    o = Math.abs(t.right - e.x),
    i = Math.abs(t.left - e.x)
  switch (Math.min(n, r, o, i)) {
    case i:
      return "left"
    case o:
      return "right"
    case n:
      return "top"
    case r:
      return "bottom"
    default:
      throw new Error("unreachable")
  }
}
function e6(e, t, n = 5) {
  const r = []
  switch (t) {
    case "top":
      r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n })
      break
    case "bottom":
      r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n })
      break
    case "left":
      r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n })
      break
    case "right":
      r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n })
      break
  }
  return r
}
function t6(e) {
  const { top: t, right: n, bottom: r, left: o } = e
  return [
    { x: o, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: o, y: r },
  ]
}
function n6(e, t) {
  const { x: n, y: r } = e
  let o = !1
  for (let i = 0, s = t.length - 1; i < t.length; s = i++) {
    const a = t[i].x,
      l = t[i].y,
      c = t[s].x,
      u = t[s].y
    l > r != u > r && n < ((c - a) * (r - l)) / (u - l) + a && (o = !o)
  }
  return o
}
function r6(e) {
  const t = e.slice()
  return (
    t.sort((n, r) =>
      n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0
    ),
    o6(t)
  )
}
function o6(e) {
  if (e.length <= 1) return e.slice()
  const t = []
  for (let r = 0; r < e.length; r++) {
    const o = e[r]
    for (; t.length >= 2; ) {
      const i = t[t.length - 1],
        s = t[t.length - 2]
      if ((i.x - s.x) * (o.y - s.y) >= (i.y - s.y) * (o.x - s.x)) t.pop()
      else break
    }
    t.push(o)
  }
  t.pop()
  const n = []
  for (let r = e.length - 1; r >= 0; r--) {
    const o = e[r]
    for (; n.length >= 2; ) {
      const i = n[n.length - 1],
        s = n[n.length - 2]
      if ((i.x - s.x) * (o.y - s.y) >= (i.y - s.y) * (o.x - s.x)) n.pop()
      else break
    }
    n.push(o)
  }
  return (
    n.pop(),
    t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y
      ? t
      : t.concat(n)
  )
}
var i6 = sT,
  s6 = aT,
  a6 = lT,
  fT = cT
const pT = i6,
  Ih = s6,
  Dh = a6,
  Tu = m.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) =>
    h.jsx(fT, {
      ref: r,
      sideOffset: t,
      className: q(
        "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...n,
    })
  )
Tu.displayName = fT.displayName
const eg = 768
function l6() {
  const [e, t] = m.useState(void 0)
  return (
    m.useEffect(() => {
      const n = window.matchMedia(`(max-width: ${eg - 1}px)`),
        r = () => {
          t(window.innerWidth < eg)
        }
      return (
        n.addEventListener("change", r),
        t(window.innerWidth < eg),
        () => n.removeEventListener("change", r)
      )
    }, []),
    !!e
  )
}
const St = m.forwardRef(({ className: e, type: t, ...n }, r) =>
  h.jsx("input", {
    type: t,
    className: q(
      "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      e
    ),
    ref: r,
    ...n,
  })
)
St.displayName = "Input"
var c6 = "Separator",
  Fw = "horizontal",
  u6 = ["horizontal", "vertical"],
  hT = m.forwardRef((e, t) => {
    const { decorative: n, orientation: r = Fw, ...o } = e,
      i = d6(r) ? r : Fw,
      a = n
        ? { role: "none" }
        : {
            "aria-orientation": i === "vertical" ? i : void 0,
            role: "separator",
          }
    return h.jsx(Le.div, { "data-orientation": i, ...a, ...o, ref: t })
  })
hT.displayName = c6
function d6(e) {
  return u6.includes(e)
}
var mT = hT
const bo = m.forwardRef(
  (
    { className: e, orientation: t = "horizontal", decorative: n = !0, ...r },
    o
  ) =>
    h.jsx(mT, {
      ref: o,
      decorative: n,
      orientation: t,
      className: q(
        "shrink-0 bg-border",
        t === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        e
      ),
      ...r,
    })
)
bo.displayName = mT.displayName
var tg = "focusScope.autoFocusOnMount",
  ng = "focusScope.autoFocusOnUnmount",
  zw = { bubbles: !1, cancelable: !0 },
  f6 = "FocusScope",
  Lh = m.forwardRef((e, t) => {
    const {
        loop: n = !1,
        trapped: r = !1,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        ...s
      } = e,
      [a, l] = m.useState(null),
      c = Nr(o),
      u = Nr(i),
      d = m.useRef(null),
      f = tt(t, (v) => l(v)),
      p = m.useRef({
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        },
      }).current
    m.useEffect(() => {
      if (r) {
        let v = function (E) {
            if (p.paused || !a) return
            const w = E.target
            a.contains(w) ? (d.current = w) : Bo(d.current, { select: !0 })
          },
          b = function (E) {
            if (p.paused || !a) return
            const w = E.relatedTarget
            w !== null && (a.contains(w) || Bo(d.current, { select: !0 }))
          },
          y = function (E) {
            if (document.activeElement === document.body)
              for (const C of E) C.removedNodes.length > 0 && Bo(a)
          }
        document.addEventListener("focusin", v),
          document.addEventListener("focusout", b)
        const x = new MutationObserver(y)
        return (
          a && x.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", v),
              document.removeEventListener("focusout", b),
              x.disconnect()
          }
        )
      }
    }, [r, a, p.paused]),
      m.useEffect(() => {
        if (a) {
          Vw.add(p)
          const v = document.activeElement
          if (!a.contains(v)) {
            const y = new CustomEvent(tg, zw)
            a.addEventListener(tg, c),
              a.dispatchEvent(y),
              y.defaultPrevented ||
                (p6(y6(gT(a)), { select: !0 }),
                document.activeElement === v && Bo(a))
          }
          return () => {
            a.removeEventListener(tg, c),
              setTimeout(() => {
                const y = new CustomEvent(ng, zw)
                a.addEventListener(ng, u),
                  a.dispatchEvent(y),
                  y.defaultPrevented ||
                    Bo(v != null ? v : document.body, { select: !0 }),
                  a.removeEventListener(ng, u),
                  Vw.remove(p)
              }, 0)
          }
        }
      }, [a, c, u, p])
    const g = m.useCallback(
      (v) => {
        if ((!n && !r) || p.paused) return
        const b = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey,
          y = document.activeElement
        if (b && y) {
          const x = v.currentTarget,
            [E, w] = h6(x)
          E && w
            ? !v.shiftKey && y === w
              ? (v.preventDefault(), n && Bo(E, { select: !0 }))
              : v.shiftKey &&
                y === E &&
                (v.preventDefault(), n && Bo(w, { select: !0 }))
            : y === x && v.preventDefault()
        }
      },
      [n, r, p.paused]
    )
    return h.jsx(Le.div, { tabIndex: -1, ...s, ref: f, onKeyDown: g })
  })
Lh.displayName = f6
function p6(e, { select: t = !1 } = {}) {
  const n = document.activeElement
  for (const r of e)
    if ((Bo(r, { select: t }), document.activeElement !== n)) return
}
function h6(e) {
  const t = gT(e),
    n = Uw(t, e),
    r = Uw(t.reverse(), e)
  return [n, r]
}
function gT(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden"
        return r.disabled || r.hidden || o
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP
      },
    })
  for (; n.nextNode(); ) t.push(n.currentNode)
  return t
}
function Uw(e, t) {
  for (const n of e) if (!m6(n, { upTo: t })) return n
}
function m6(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0
  for (; e; ) {
    if (t !== void 0 && e === t) return !1
    if (getComputedStyle(e).display === "none") return !0
    e = e.parentElement
  }
  return !1
}
function g6(e) {
  return e instanceof HTMLInputElement && "select" in e
}
function Bo(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement
    e.focus({ preventScroll: !0 }), e !== n && g6(e) && t && e.select()
  }
}
var Vw = v6()
function v6() {
  let e = []
  return {
    add(t) {
      const n = e[0]
      t !== n && (n == null || n.pause()), (e = Hw(e, t)), e.unshift(t)
    },
    remove(t) {
      var n
      ;(e = Hw(e, t)), (n = e[0]) == null || n.resume()
    },
  }
}
function Hw(e, t) {
  const n = [...e],
    r = n.indexOf(t)
  return r !== -1 && n.splice(r, 1), n
}
function y6(e) {
  return e.filter((t) => t.tagName !== "A")
}
var rg = 0
function wb() {
  m.useEffect(() => {
    var t, n
    const e = document.querySelectorAll("[data-radix-focus-guard]")
    return (
      document.body.insertAdjacentElement(
        "afterbegin",
        (t = e[0]) != null ? t : Ww()
      ),
      document.body.insertAdjacentElement(
        "beforeend",
        (n = e[1]) != null ? n : Ww()
      ),
      rg++,
      () => {
        rg === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((r) => r.remove()),
          rg--
      }
    )
  }, [])
}
function Ww() {
  const e = document.createElement("span")
  return (
    e.setAttribute("data-radix-focus-guard", ""),
    (e.tabIndex = 0),
    (e.style.outline = "none"),
    (e.style.opacity = "0"),
    (e.style.position = "fixed"),
    (e.style.pointerEvents = "none"),
    e
  )
}
var en = function () {
  return (
    (en =
      Object.assign ||
      function (t) {
        for (var n, r = 1, o = arguments.length; r < o; r++) {
          n = arguments[r]
          for (var i in n)
            Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
        }
        return t
      }),
    en.apply(this, arguments)
  )
}
function Eb(e, t) {
  var n = {}
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
        (n[r[o]] = e[r[o]])
  return n
}
function vT(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, o = t.length, i; r < o; r++)
      (i || !(r in t)) &&
        (i || (i = Array.prototype.slice.call(t, 0, r)), (i[r] = t[r]))
  return e.concat(i || Array.prototype.slice.call(t))
}
var sc = "right-scroll-bar-position",
  ac = "width-before-scroll-bar",
  b6 = "with-scroll-bars-hidden",
  x6 = "--removed-body-scroll-bar-size"
function og(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e
}
function w6(e, t) {
  var n = m.useState(function () {
    return {
      value: e,
      callback: t,
      facade: {
        get current() {
          return n.value
        },
        set current(r) {
          var o = n.value
          o !== r && ((n.value = r), n.callback(r, o))
        },
      },
    }
  })[0]
  return (n.callback = t), n.facade
}
var E6 = typeof window < "u" ? m.useLayoutEffect : m.useEffect,
  Kw = new WeakMap()
function yT(e, t) {
  var n = w6(t || null, function (r) {
    return e.forEach(function (o) {
      return og(o, r)
    })
  })
  return (
    E6(
      function () {
        var r = Kw.get(n)
        if (r) {
          var o = new Set(r),
            i = new Set(e),
            s = n.current
          o.forEach(function (a) {
            i.has(a) || og(a, null)
          }),
            i.forEach(function (a) {
              o.has(a) || og(a, s)
            })
        }
        Kw.set(n, e)
      },
      [e]
    ),
    n
  )
}
function C6(e) {
  return e
}
function S6(e, t) {
  t === void 0 && (t = C6)
  var n = [],
    r = !1,
    o = {
      read: function () {
        if (r)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
          )
        return n.length ? n[n.length - 1] : e
      },
      useMedium: function (i) {
        var s = t(i, r)
        return (
          n.push(s),
          function () {
            n = n.filter(function (a) {
              return a !== s
            })
          }
        )
      },
      assignSyncMedium: function (i) {
        for (r = !0; n.length; ) {
          var s = n
          ;(n = []), s.forEach(i)
        }
        n = {
          push: function (a) {
            return i(a)
          },
          filter: function () {
            return n
          },
        }
      },
      assignMedium: function (i) {
        r = !0
        var s = []
        if (n.length) {
          var a = n
          ;(n = []), a.forEach(i), (s = n)
        }
        var l = function () {
            var u = s
            ;(s = []), u.forEach(i)
          },
          c = function () {
            return Promise.resolve().then(l)
          }
        c(),
          (n = {
            push: function (u) {
              s.push(u), c()
            },
            filter: function (u) {
              return (s = s.filter(u)), n
            },
          })
      },
    }
  return o
}
function bT(e) {
  e === void 0 && (e = {})
  var t = S6(null)
  return (t.options = en({ async: !0, ssr: !1 }, e)), t
}
var xT = function (e) {
  var t = e.sideCar,
    n = Eb(e, ["sideCar"])
  if (!t)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car"
    )
  var r = t.read()
  if (!r) throw new Error("Sidecar medium not found")
  return m.createElement(r, en({}, n))
}
xT.isSideCarExport = !0
function wT(e, t) {
  return e.useMedium(t), xT
}
var ET = bT(),
  ig = function () {},
  Ph = m.forwardRef(function (e, t) {
    var n = m.useRef(null),
      r = m.useState({
        onScrollCapture: ig,
        onWheelCapture: ig,
        onTouchMoveCapture: ig,
      }),
      o = r[0],
      i = r[1],
      s = e.forwardProps,
      a = e.children,
      l = e.className,
      c = e.removeScrollBar,
      u = e.enabled,
      d = e.shards,
      f = e.sideCar,
      p = e.noIsolation,
      g = e.inert,
      v = e.allowPinchZoom,
      b = e.as,
      y = b === void 0 ? "div" : b,
      x = e.gapMode,
      E = Eb(e, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      w = f,
      C = yT([n, t]),
      S = en(en({}, E), o)
    return m.createElement(
      m.Fragment,
      null,
      u &&
        m.createElement(w, {
          sideCar: ET,
          removeScrollBar: c,
          shards: d,
          noIsolation: p,
          inert: g,
          setCallbacks: i,
          allowPinchZoom: !!v,
          lockRef: n,
          gapMode: x,
        }),
      s
        ? m.cloneElement(m.Children.only(a), en(en({}, S), { ref: C }))
        : m.createElement(y, en({}, S, { className: l, ref: C }), a)
    )
  })
Ph.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }
Ph.classNames = { fullWidth: ac, zeroRight: sc }
var Gw,
  _6 = function () {
    if (Gw) return Gw
    if (typeof __webpack_nonce__ < "u") return __webpack_nonce__
  }
function k6() {
  if (!document) return null
  var e = document.createElement("style")
  e.type = "text/css"
  var t = _6()
  return t && e.setAttribute("nonce", t), e
}
function N6(e, t) {
  e.styleSheet
    ? (e.styleSheet.cssText = t)
    : e.appendChild(document.createTextNode(t))
}
function T6(e) {
  var t = document.head || document.getElementsByTagName("head")[0]
  t.appendChild(e)
}
var M6 = function () {
    var e = 0,
      t = null
    return {
      add: function (n) {
        e == 0 && (t = k6()) && (N6(t, n), T6(t)), e++
      },
      remove: function () {
        e--,
          !e && t && (t.parentNode && t.parentNode.removeChild(t), (t = null))
      },
    }
  },
  O6 = function () {
    var e = M6()
    return function (t, n) {
      m.useEffect(
        function () {
          return (
            e.add(t),
            function () {
              e.remove()
            }
          )
        },
        [t && n]
      )
    }
  },
  Cb = function () {
    var e = O6(),
      t = function (n) {
        var r = n.styles,
          o = n.dynamic
        return e(r, o), null
      }
    return t
  },
  A6 = { left: 0, top: 0, right: 0, gap: 0 },
  sg = function (e) {
    return parseInt(e || "", 10) || 0
  },
  R6 = function (e) {
    var t = window.getComputedStyle(document.body),
      n = t[e === "padding" ? "paddingLeft" : "marginLeft"],
      r = t[e === "padding" ? "paddingTop" : "marginTop"],
      o = t[e === "padding" ? "paddingRight" : "marginRight"]
    return [sg(n), sg(r), sg(o)]
  },
  I6 = function (e) {
    if ((e === void 0 && (e = "margin"), typeof window > "u")) return A6
    var t = R6(e),
      n = document.documentElement.clientWidth,
      r = window.innerWidth
    return {
      left: t[0],
      top: t[1],
      right: t[2],
      gap: Math.max(0, r - n + t[2] - t[0]),
    }
  },
  D6 = Cb(),
  Ma = "data-scroll-locked",
  L6 = function (e, t, n, r) {
    var o = e.left,
      i = e.top,
      s = e.right,
      a = e.gap
    return (
      n === void 0 && (n = "margin"),
      `
  .`
        .concat(
          b6,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  body[`
        )
        .concat(
          Ma,
          `] {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            t && "position: relative ".concat(r, ";"),
            n === "margin" &&
              `
    padding-left: `
                .concat(
                  o,
                  `px;
    padding-top: `
                )
                .concat(
                  i,
                  `px;
    padding-right: `
                )
                .concat(
                  s,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(a, "px ")
                .concat(
                  r,
                  `;
    `
                ),
            n === "padding" &&
              "padding-right: ".concat(a, "px ").concat(r, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`
        )
        .concat(
          sc,
          ` {
    right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          ac,
          ` {
    margin-right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(sc, " .")
        .concat(
          sc,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(ac, " .")
        .concat(
          ac,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body[`
        )
        .concat(
          Ma,
          `] {
    `
        )
        .concat(x6, ": ")
        .concat(
          a,
          `px;
  }
`
        )
    )
  },
  qw = function () {
    var e = parseInt(document.body.getAttribute(Ma) || "0", 10)
    return isFinite(e) ? e : 0
  },
  P6 = function () {
    m.useEffect(function () {
      return (
        document.body.setAttribute(Ma, (qw() + 1).toString()),
        function () {
          var e = qw() - 1
          e <= 0
            ? document.body.removeAttribute(Ma)
            : document.body.setAttribute(Ma, e.toString())
        }
      )
    }, [])
  },
  CT = function (e) {
    var t = e.noRelative,
      n = e.noImportant,
      r = e.gapMode,
      o = r === void 0 ? "margin" : r
    P6()
    var i = m.useMemo(
      function () {
        return I6(o)
      },
      [o]
    )
    return m.createElement(D6, { styles: L6(i, !t, o, n ? "" : "!important") })
  },
  sy = !1
if (typeof window < "u")
  try {
    var hd = Object.defineProperty({}, "passive", {
      get: function () {
        return (sy = !0), !0
      },
    })
    window.addEventListener("test", hd, hd),
      window.removeEventListener("test", hd, hd)
  } catch {
    sy = !1
  }
var Hs = sy ? { passive: !1 } : !1,
  $6 = function (e) {
    return e.tagName === "TEXTAREA"
  },
  ST = function (e, t) {
    if (!(e instanceof Element)) return !1
    var n = window.getComputedStyle(e)
    return (
      n[t] !== "hidden" &&
      !(n.overflowY === n.overflowX && !$6(e) && n[t] === "visible")
    )
  },
  B6 = function (e) {
    return ST(e, "overflowY")
  },
  j6 = function (e) {
    return ST(e, "overflowX")
  },
  Zw = function (e, t) {
    var n = t.ownerDocument,
      r = t
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host)
      var o = _T(e, r)
      if (o) {
        var i = kT(e, r),
          s = i[1],
          a = i[2]
        if (s > a) return !0
      }
      r = r.parentNode
    } while (r && r !== n.body)
    return !1
  },
  F6 = function (e) {
    var t = e.scrollTop,
      n = e.scrollHeight,
      r = e.clientHeight
    return [t, n, r]
  },
  z6 = function (e) {
    var t = e.scrollLeft,
      n = e.scrollWidth,
      r = e.clientWidth
    return [t, n, r]
  },
  _T = function (e, t) {
    return e === "v" ? B6(t) : j6(t)
  },
  kT = function (e, t) {
    return e === "v" ? F6(t) : z6(t)
  },
  U6 = function (e, t) {
    return e === "h" && t === "rtl" ? -1 : 1
  },
  V6 = function (e, t, n, r, o) {
    var i = U6(e, window.getComputedStyle(t).direction),
      s = i * r,
      a = n.target,
      l = t.contains(a),
      c = !1,
      u = s > 0,
      d = 0,
      f = 0
    do {
      var p = kT(e, a),
        g = p[0],
        v = p[1],
        b = p[2],
        y = v - b - i * g
      ;(g || y) && _T(e, a) && ((d += y), (f += g)),
        a instanceof ShadowRoot ? (a = a.host) : (a = a.parentNode)
    } while ((!l && a !== document.body) || (l && (t.contains(a) || t === a)))
    return (
      ((u && ((o && Math.abs(d) < 1) || (!o && s > d))) ||
        (!u && ((o && Math.abs(f) < 1) || (!o && -s > f)))) &&
        (c = !0),
      c
    )
  },
  md = function (e) {
    return "changedTouches" in e
      ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY]
      : [0, 0]
  },
  Yw = function (e) {
    return [e.deltaX, e.deltaY]
  },
  Xw = function (e) {
    return e && "current" in e ? e.current : e
  },
  H6 = function (e, t) {
    return e[0] === t[0] && e[1] === t[1]
  },
  W6 = function (e) {
    return `
  .block-interactivity-`
      .concat(
        e,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        e,
        ` {pointer-events: all;}
`
      )
  },
  K6 = 0,
  Ws = []
function G6(e) {
  var t = m.useRef([]),
    n = m.useRef([0, 0]),
    r = m.useRef(),
    o = m.useState(K6++)[0],
    i = m.useState(Cb)[0],
    s = m.useRef(e)
  m.useEffect(
    function () {
      s.current = e
    },
    [e]
  ),
    m.useEffect(
      function () {
        if (e.inert) {
          document.body.classList.add("block-interactivity-".concat(o))
          var v = vT([e.lockRef.current], (e.shards || []).map(Xw), !0).filter(
            Boolean
          )
          return (
            v.forEach(function (b) {
              return b.classList.add("allow-interactivity-".concat(o))
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(o)),
                v.forEach(function (b) {
                  return b.classList.remove("allow-interactivity-".concat(o))
                })
            }
          )
        }
      },
      [e.inert, e.lockRef.current, e.shards]
    )
  var a = m.useCallback(function (v, b) {
      if (
        ("touches" in v && v.touches.length === 2) ||
        (v.type === "wheel" && v.ctrlKey)
      )
        return !s.current.allowPinchZoom
      var y = md(v),
        x = n.current,
        E = "deltaX" in v ? v.deltaX : x[0] - y[0],
        w = "deltaY" in v ? v.deltaY : x[1] - y[1],
        C,
        S = v.target,
        M = Math.abs(E) > Math.abs(w) ? "h" : "v"
      if ("touches" in v && M === "h" && S.type === "range") return !1
      var N = Zw(M, S)
      if (!N) return !0
      if ((N ? (C = M) : ((C = M === "v" ? "h" : "v"), (N = Zw(M, S))), !N))
        return !1
      if (
        (!r.current && "changedTouches" in v && (E || w) && (r.current = C), !C)
      )
        return !0
      var R = r.current || C
      return V6(R, b, v, R === "h" ? E : w, !0)
    }, []),
    l = m.useCallback(function (v) {
      var b = v
      if (!(!Ws.length || Ws[Ws.length - 1] !== i)) {
        var y = "deltaY" in b ? Yw(b) : md(b),
          x = t.current.filter(function (C) {
            return (
              C.name === b.type &&
              (C.target === b.target || b.target === C.shadowParent) &&
              H6(C.delta, y)
            )
          })[0]
        if (x && x.should) {
          b.cancelable && b.preventDefault()
          return
        }
        if (!x) {
          var E = (s.current.shards || [])
              .map(Xw)
              .filter(Boolean)
              .filter(function (C) {
                return C.contains(b.target)
              }),
            w = E.length > 0 ? a(b, E[0]) : !s.current.noIsolation
          w && b.cancelable && b.preventDefault()
        }
      }
    }, []),
    c = m.useCallback(function (v, b, y, x) {
      var E = { name: v, delta: b, target: y, should: x, shadowParent: q6(y) }
      t.current.push(E),
        setTimeout(function () {
          t.current = t.current.filter(function (w) {
            return w !== E
          })
        }, 1)
    }, []),
    u = m.useCallback(function (v) {
      ;(n.current = md(v)), (r.current = void 0)
    }, []),
    d = m.useCallback(function (v) {
      c(v.type, Yw(v), v.target, a(v, e.lockRef.current))
    }, []),
    f = m.useCallback(function (v) {
      c(v.type, md(v), v.target, a(v, e.lockRef.current))
    }, [])
  m.useEffect(function () {
    return (
      Ws.push(i),
      e.setCallbacks({
        onScrollCapture: d,
        onWheelCapture: d,
        onTouchMoveCapture: f,
      }),
      document.addEventListener("wheel", l, Hs),
      document.addEventListener("touchmove", l, Hs),
      document.addEventListener("touchstart", u, Hs),
      function () {
        ;(Ws = Ws.filter(function (v) {
          return v !== i
        })),
          document.removeEventListener("wheel", l, Hs),
          document.removeEventListener("touchmove", l, Hs),
          document.removeEventListener("touchstart", u, Hs)
      }
    )
  }, [])
  var p = e.removeScrollBar,
    g = e.inert
  return m.createElement(
    m.Fragment,
    null,
    g ? m.createElement(i, { styles: W6(o) }) : null,
    p ? m.createElement(CT, { gapMode: e.gapMode }) : null
  )
}
function q6(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && ((t = e.host), (e = e.host)), (e = e.parentNode)
  return t
}
const Z6 = wT(ET, G6)
var NT = m.forwardRef(function (e, t) {
  return m.createElement(Ph, en({}, e, { ref: t, sideCar: Z6 }))
})
NT.classNames = Ph.classNames
const Sb = NT
var Y6 = function (e) {
    if (typeof document > "u") return null
    var t = Array.isArray(e) ? e[0] : e
    return t.ownerDocument.body
  },
  Ks = new WeakMap(),
  gd = new WeakMap(),
  vd = {},
  ag = 0,
  TT = function (e) {
    return e && (e.host || TT(e.parentNode))
  },
  X6 = function (e, t) {
    return t
      .map(function (n) {
        if (e.contains(n)) return n
        var r = TT(n)
        return r && e.contains(r)
          ? r
          : (console.error(
              "aria-hidden",
              n,
              "in not contained inside",
              e,
              ". Doing nothing"
            ),
            null)
      })
      .filter(function (n) {
        return !!n
      })
  },
  Q6 = function (e, t, n, r) {
    var o = X6(t, Array.isArray(e) ? e : [e])
    vd[n] || (vd[n] = new WeakMap())
    var i = vd[n],
      s = [],
      a = new Set(),
      l = new Set(o),
      c = function (d) {
        !d || a.has(d) || (a.add(d), c(d.parentNode))
      }
    o.forEach(c)
    var u = function (d) {
      !d ||
        l.has(d) ||
        Array.prototype.forEach.call(d.children, function (f) {
          if (a.has(f)) u(f)
          else
            try {
              var p = f.getAttribute(r),
                g = p !== null && p !== "false",
                v = (Ks.get(f) || 0) + 1,
                b = (i.get(f) || 0) + 1
              Ks.set(f, v),
                i.set(f, b),
                s.push(f),
                v === 1 && g && gd.set(f, !0),
                b === 1 && f.setAttribute(n, "true"),
                g || f.setAttribute(r, "true")
            } catch (y) {
              console.error("aria-hidden: cannot operate on ", f, y)
            }
        })
    }
    return (
      u(t),
      a.clear(),
      ag++,
      function () {
        s.forEach(function (d) {
          var f = Ks.get(d) - 1,
            p = i.get(d) - 1
          Ks.set(d, f),
            i.set(d, p),
            f || (gd.has(d) || d.removeAttribute(r), gd.delete(d)),
            p || d.removeAttribute(n)
        }),
          ag--,
          ag ||
            ((Ks = new WeakMap()),
            (Ks = new WeakMap()),
            (gd = new WeakMap()),
            (vd = {}))
      }
    )
  },
  $h = function (e, t, n) {
    n === void 0 && (n = "data-aria-hidden")
    var r = Array.from(Array.isArray(e) ? e : [e]),
      o = t || Y6(e)
    return o
      ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))),
        Q6(r, o, n, "aria-hidden"))
      : function () {
          return null
        }
  },
  _b = "Dialog",
  [MT, qte] = Wn(_b),
  [J6, Dr] = MT(_b),
  OT = (e) => {
    const {
        __scopeDialog: t,
        children: n,
        open: r,
        defaultOpen: o,
        onOpenChange: i,
        modal: s = !0,
      } = e,
      a = m.useRef(null),
      l = m.useRef(null),
      [c = !1, u] = Ir({ prop: r, defaultProp: o, onChange: i })
    return h.jsx(J6, {
      scope: t,
      triggerRef: a,
      contentRef: l,
      contentId: fi(),
      titleId: fi(),
      descriptionId: fi(),
      open: c,
      onOpenChange: u,
      onOpenToggle: m.useCallback(() => u((d) => !d), [u]),
      modal: s,
      children: n,
    })
  }
OT.displayName = _b
var AT = "DialogTrigger",
  RT = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = Dr(AT, n),
      i = tt(t, o.triggerRef)
    return h.jsx(Le.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": o.open,
      "aria-controls": o.contentId,
      "data-state": Tb(o.open),
      ...r,
      ref: i,
      onClick: ge(e.onClick, o.onOpenToggle),
    })
  })
RT.displayName = AT
var kb = "DialogPortal",
  [e7, IT] = MT(kb, { forceMount: void 0 }),
  DT = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: o } = e,
      i = Dr(kb, t)
    return h.jsx(e7, {
      scope: t,
      forceMount: n,
      children: m.Children.map(r, (s) =>
        h.jsx(Kn, {
          present: n || i.open,
          children: h.jsx(Th, { asChild: !0, container: o, children: s }),
        })
      ),
    })
  }
DT.displayName = kb
var Uf = "DialogOverlay",
  LT = m.forwardRef((e, t) => {
    const n = IT(Uf, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = e,
      i = Dr(Uf, e.__scopeDialog)
    return i.modal
      ? h.jsx(Kn, {
          present: r || i.open,
          children: h.jsx(t7, { ...o, ref: t }),
        })
      : null
  })
LT.displayName = Uf
var t7 = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = Dr(Uf, n)
    return h.jsx(Sb, {
      as: An,
      allowPinchZoom: !0,
      shards: [o.contentRef],
      children: h.jsx(Le.div, {
        "data-state": Tb(o.open),
        ...r,
        ref: t,
        style: { pointerEvents: "auto", ...r.style },
      }),
    })
  }),
  xs = "DialogContent",
  PT = m.forwardRef((e, t) => {
    const n = IT(xs, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = e,
      i = Dr(xs, e.__scopeDialog)
    return h.jsx(Kn, {
      present: r || i.open,
      children: i.modal
        ? h.jsx(n7, { ...o, ref: t })
        : h.jsx(r7, { ...o, ref: t }),
    })
  })
PT.displayName = xs
var n7 = m.forwardRef((e, t) => {
    const n = Dr(xs, e.__scopeDialog),
      r = m.useRef(null),
      o = tt(t, n.contentRef, r)
    return (
      m.useEffect(() => {
        const i = r.current
        if (i) return $h(i)
      }, []),
      h.jsx($T, {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: ge(e.onCloseAutoFocus, (i) => {
          var s
          i.preventDefault(), (s = n.triggerRef.current) == null || s.focus()
        }),
        onPointerDownOutside: ge(e.onPointerDownOutside, (i) => {
          const s = i.detail.originalEvent,
            a = s.button === 0 && s.ctrlKey === !0
          ;(s.button === 2 || a) && i.preventDefault()
        }),
        onFocusOutside: ge(e.onFocusOutside, (i) => i.preventDefault()),
      })
    )
  }),
  r7 = m.forwardRef((e, t) => {
    const n = Dr(xs, e.__scopeDialog),
      r = m.useRef(!1),
      o = m.useRef(!1)
    return h.jsx($T, {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (i) => {
        var s, a
        ;(s = e.onCloseAutoFocus) == null || s.call(e, i),
          i.defaultPrevented ||
            (r.current || (a = n.triggerRef.current) == null || a.focus(),
            i.preventDefault()),
          (r.current = !1),
          (o.current = !1)
      },
      onInteractOutside: (i) => {
        var l, c
        ;(l = e.onInteractOutside) == null || l.call(e, i),
          i.defaultPrevented ||
            ((r.current = !0),
            i.detail.originalEvent.type === "pointerdown" && (o.current = !0))
        const s = i.target
        ;((c = n.triggerRef.current) == null ? void 0 : c.contains(s)) &&
          i.preventDefault(),
          i.detail.originalEvent.type === "focusin" &&
            o.current &&
            i.preventDefault()
      },
    })
  }),
  $T = m.forwardRef((e, t) => {
    const {
        __scopeDialog: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        ...s
      } = e,
      a = Dr(xs, n),
      l = m.useRef(null),
      c = tt(t, l)
    return (
      wb(),
      h.jsxs(h.Fragment, {
        children: [
          h.jsx(Lh, {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: i,
            children: h.jsx(ku, {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": Tb(a.open),
              ...s,
              ref: c,
              onDismiss: () => a.onOpenChange(!1),
            }),
          }),
          h.jsxs(h.Fragment, {
            children: [
              h.jsx(o7, { titleId: a.titleId }),
              h.jsx(s7, { contentRef: l, descriptionId: a.descriptionId }),
            ],
          }),
        ],
      })
    )
  }),
  Nb = "DialogTitle",
  BT = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = Dr(Nb, n)
    return h.jsx(Le.h2, { id: o.titleId, ...r, ref: t })
  })
BT.displayName = Nb
var jT = "DialogDescription",
  FT = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = Dr(jT, n)
    return h.jsx(Le.p, { id: o.descriptionId, ...r, ref: t })
  })
FT.displayName = jT
var zT = "DialogClose",
  UT = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = Dr(zT, n)
    return h.jsx(Le.button, {
      type: "button",
      ...r,
      ref: t,
      onClick: ge(e.onClick, () => o.onOpenChange(!1)),
    })
  })
UT.displayName = zT
function Tb(e) {
  return e ? "open" : "closed"
}
var VT = "DialogTitleWarning",
  [Zte, HT] = bP(VT, { contentName: xs, titleName: Nb, docsSlug: "dialog" }),
  o7 = ({ titleId: e }) => {
    const t = HT(VT),
      n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`
    return (
      m.useEffect(() => {
        e && (document.getElementById(e) || console.error(n))
      }, [n, e]),
      null
    )
  },
  i7 = "DialogDescriptionWarning",
  s7 = ({ contentRef: e, descriptionId: t }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${HT(i7).contentName}}.`
    return (
      m.useEffect(() => {
        var i
        const o =
          (i = e.current) == null ? void 0 : i.getAttribute("aria-describedby")
        t && o && (document.getElementById(t) || console.warn(r))
      }, [r, e, t]),
      null
    )
  },
  WT = OT,
  a7 = RT,
  Bh = DT,
  jh = LT,
  Fh = PT,
  zh = BT,
  Uh = FT,
  KT = UT
const l7 = WT,
  GT = ({ className: e, ...t }) => h.jsx(Bh, { className: q(e), ...t })
GT.displayName = Bh.displayName
const qT = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(jh, {
    className: q(
      "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      e
    ),
    ...t,
    ref: n,
  })
)
qT.displayName = jh.displayName
const c7 = pl(
    "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
    {
      variants: {
        side: {
          top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
          bottom:
            "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
          left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
          right:
            "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
        },
      },
      defaultVariants: { side: "right" },
    }
  ),
  ZT = m.forwardRef(
    ({ side: e = "right", className: t, children: n, ...r }, o) =>
      h.jsxs(GT, {
        children: [
          h.jsx(qT, {}),
          h.jsxs(Fh, {
            ref: o,
            className: q(c7({ side: e }), t),
            ...r,
            children: [
              n,
              h.jsxs(KT, {
                className:
                  "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-secondary hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none",
                children: [
                  h.jsx(tb, { className: "h-4 w-4" }),
                  h.jsx("span", { className: "sr-only", children: "Close" }),
                ],
              }),
            ],
          }),
        ],
      })
  )
ZT.displayName = Fh.displayName
const YT = ({ className: e, ...t }) =>
  h.jsx("div", {
    className: q("flex flex-col space-y-2 text-center sm:text-left", e),
    ...t,
  })
YT.displayName = "SheetHeader"
const XT = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(zh, {
    ref: n,
    className: q("text-lg font-semibold text-foreground", e),
    ...t,
  })
)
XT.displayName = zh.displayName
const QT = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(Uh, { ref: n, className: q("text-sm text-muted-foreground", e), ...t })
)
QT.displayName = Uh.displayName
function Qw({ className: e, ...t }) {
  return h.jsx("div", {
    className: q("animate-pulse rounded-md bg-muted", e),
    ...t,
  })
}
const u7 = "sidebar_state",
  d7 = 60 * 60 * 24 * 7,
  f7 = "16rem",
  p7 = "18rem",
  h7 = "3rem",
  m7 = "b",
  JT = m.createContext(null)
function Vh() {
  const e = m.useContext(JT)
  if (!e) throw new Error("useSidebar must be used within a SidebarProvider.")
  return e
}
const e2 = m.forwardRef(
  (
    {
      defaultOpen: e = !0,
      open: t,
      onOpenChange: n,
      className: r,
      style: o,
      children: i,
      ...s
    },
    a
  ) => {
    const l = l6(),
      [c, u] = m.useState(!1),
      [d, f] = m.useState(e),
      p = t != null ? t : d,
      g = m.useCallback(
        (x) => {
          const E = typeof x == "function" ? x(p) : x
          n ? n(E) : f(E),
            (document.cookie = `${u7}=${E}; path=/; max-age=${d7}`)
        },
        [n, p]
      ),
      v = m.useCallback(() => (l ? u((x) => !x) : g((x) => !x)), [l, g, u])
    m.useEffect(() => {
      const x = (E) => {
        E.key === m7 && (E.metaKey || E.ctrlKey) && (E.preventDefault(), v())
      }
      return (
        window.addEventListener("keydown", x),
        () => window.removeEventListener("keydown", x)
      )
    }, [v])
    const b = p ? "expanded" : "collapsed",
      y = m.useMemo(
        () => ({
          state: b,
          open: p,
          setOpen: g,
          isMobile: l,
          openMobile: c,
          setOpenMobile: u,
          toggleSidebar: v,
        }),
        [b, p, g, l, c, u, v]
      )
    return h.jsx(JT.Provider, {
      value: y,
      children: h.jsx(pT, {
        delayDuration: 0,
        children: h.jsx("div", {
          style: { "--sidebar-width": f7, "--sidebar-width-icon": h7, ...o },
          className: q(
            "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
            r
          ),
          ref: a,
          ...s,
          children: i,
        }),
      }),
    })
  }
)
e2.displayName = "SidebarProvider"
const t2 = m.forwardRef(
  (
    {
      side: e = "left",
      variant: t = "sidebar",
      collapsible: n = "offcanvas",
      className: r,
      children: o,
      ...i
    },
    s
  ) => {
    const { isMobile: a, state: l, openMobile: c, setOpenMobile: u } = Vh()
    return n === "none"
      ? h.jsx("div", {
          className: q(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            r
          ),
          ref: s,
          ...i,
          children: o,
        })
      : a
        ? h.jsx(l7, {
            open: c,
            onOpenChange: u,
            ...i,
            children: h.jsxs(ZT, {
              "data-sidebar": "sidebar",
              "data-mobile": "true",
              className:
                "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
              style: { "--sidebar-width": p7 },
              side: e,
              children: [
                h.jsxs(YT, {
                  className: "sr-only",
                  children: [
                    h.jsx(XT, { children: "Sidebar" }),
                    h.jsx(QT, { children: "Displays the mobile sidebar." }),
                  ],
                }),
                h.jsx("div", {
                  className: "flex h-full w-full flex-col",
                  children: o,
                }),
              ],
            }),
          })
        : h.jsxs("div", {
            ref: s,
            className: "group peer hidden text-sidebar-foreground md:block",
            "data-state": l,
            "data-collapsible": l === "collapsed" ? n : "",
            "data-variant": t,
            "data-side": e,
            children: [
              h.jsx("div", {
                className: q(
                  "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
                  "group-data-[collapsible=offcanvas]:w-0",
                  "group-data-[side=right]:rotate-180",
                  t === "floating" || t === "inset"
                    ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
                    : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
                ),
              }),
              h.jsx("div", {
                className: q(
                  "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
                  e === "left"
                    ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
                    : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
                  t === "floating" || t === "inset"
                    ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
                    : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
                  r
                ),
                ...i,
                children: h.jsx("div", {
                  "data-sidebar": "sidebar",
                  className:
                    "flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow",
                  children: o,
                }),
              }),
            ],
          })
  }
)
t2.displayName = "Sidebar"
const g7 = m.forwardRef(({ className: e, onClick: t, ...n }, r) => {
  const { toggleSidebar: o } = Vh()
  return h.jsxs(et, {
    ref: r,
    "data-sidebar": "trigger",
    variant: "ghost",
    size: "icon",
    className: q("h-7 w-7", e),
    onClick: (i) => {
      t == null || t(i), o()
    },
    ...n,
    children: [
      h.jsx(bL, {}),
      h.jsx("span", { className: "sr-only", children: "Toggle Sidebar" }),
    ],
  })
})
g7.displayName = "SidebarTrigger"
const v7 = m.forwardRef(({ className: e, ...t }, n) => {
  const { toggleSidebar: r } = Vh()
  return h.jsx("button", {
    ref: n,
    "data-sidebar": "rail",
    "aria-label": "Toggle Sidebar",
    tabIndex: -1,
    onClick: r,
    title: "Toggle Sidebar",
    className: q(
      "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
      "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
      "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
      "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
      "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
      "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
      e
    ),
    ...t,
  })
})
v7.displayName = "SidebarRail"
const y7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("main", {
    ref: n,
    className: q(
      "relative flex w-full flex-1 flex-col bg-background",
      "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
      e
    ),
    ...t,
  })
)
y7.displayName = "SidebarInset"
const b7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(St, {
    ref: n,
    "data-sidebar": "input",
    className: q(
      "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
      e
    ),
    ...t,
  })
)
b7.displayName = "SidebarInput"
const x7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    "data-sidebar": "header",
    className: q("flex flex-col gap-2 p-2", e),
    ...t,
  })
)
x7.displayName = "SidebarHeader"
const w7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    "data-sidebar": "footer",
    className: q("flex flex-col gap-2 p-2", e),
    ...t,
  })
)
w7.displayName = "SidebarFooter"
const E7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(bo, {
    ref: n,
    "data-sidebar": "separator",
    className: q("mx-2 w-auto bg-sidebar-border", e),
    ...t,
  })
)
E7.displayName = "SidebarSeparator"
const n2 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    "data-sidebar": "content",
    className: q(
      "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
      e
    ),
    ...t,
  })
)
n2.displayName = "SidebarContent"
const Mb = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    "data-sidebar": "group",
    className: q("relative flex w-full min-w-0 flex-col p-2", e),
    ...t,
  })
)
Mb.displayName = "SidebarGroup"
const Ob = m.forwardRef(({ className: e, asChild: t = !1, ...n }, r) => {
  const o = t ? An : "div"
  return h.jsx(o, {
    ref: r,
    "data-sidebar": "group-label",
    className: q(
      "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
      "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
      e
    ),
    ...n,
  })
})
Ob.displayName = "SidebarGroupLabel"
const C7 = m.forwardRef(({ className: e, asChild: t = !1, ...n }, r) => {
  const o = t ? An : "button"
  return h.jsx(o, {
    ref: r,
    "data-sidebar": "group-action",
    className: q(
      "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
      "after:absolute after:-inset-2 after:md:hidden",
      "group-data-[collapsible=icon]:hidden",
      e
    ),
    ...n,
  })
})
C7.displayName = "SidebarGroupAction"
const Ab = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    "data-sidebar": "group-content",
    className: q("w-full text-sm", e),
    ...t,
  })
)
Ab.displayName = "SidebarGroupContent"
const r2 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("ul", {
    ref: n,
    "data-sidebar": "menu",
    className: q("flex w-full min-w-0 flex-col gap-1", e),
    ...t,
  })
)
r2.displayName = "SidebarMenu"
const o2 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("li", {
    ref: n,
    "data-sidebar": "menu-item",
    className: q("group/menu-item relative", e),
    ...t,
  })
)
o2.displayName = "SidebarMenuItem"
const S7 = pl(
    "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
    {
      variants: {
        variant: {
          default:
            "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
          outline:
            "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
        },
        size: {
          default: "h-8 text-sm",
          sm: "h-7 text-xs",
          lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    }
  ),
  i2 = m.forwardRef(
    (
      {
        asChild: e = !1,
        isActive: t = !1,
        variant: n = "default",
        size: r = "default",
        tooltip: o,
        className: i,
        ...s
      },
      a
    ) => {
      const l = e ? An : "button",
        { isMobile: c, state: u } = Vh(),
        d = h.jsx(l, {
          ref: a,
          "data-sidebar": "menu-button",
          "data-size": r,
          "data-active": t,
          className: q(S7({ variant: n, size: r }), i),
          ...s,
        })
      return o
        ? (typeof o == "string" && (o = { children: o }),
          h.jsxs(Ih, {
            children: [
              h.jsx(Dh, { asChild: !0, children: d }),
              h.jsx(Tu, {
                side: "right",
                align: "center",
                hidden: u !== "collapsed" || c,
                ...o,
              }),
            ],
          }))
        : d
    }
  )
i2.displayName = "SidebarMenuButton"
const _7 = m.forwardRef(
  ({ className: e, asChild: t = !1, showOnHover: n = !1, ...r }, o) => {
    const i = t ? An : "button"
    return h.jsx(i, {
      ref: o,
      "data-sidebar": "menu-action",
      className: q(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        n &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        e
      ),
      ...r,
    })
  }
)
_7.displayName = "SidebarMenuAction"
const k7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("div", {
    ref: n,
    "data-sidebar": "menu-badge",
    className: q(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      e
    ),
    ...t,
  })
)
k7.displayName = "SidebarMenuBadge"
const N7 = m.forwardRef(({ className: e, showIcon: t = !1, ...n }, r) => {
  const o = m.useMemo(() => `${Math.floor(Math.random() * 40) + 50}%`, [])
  return h.jsxs("div", {
    ref: r,
    "data-sidebar": "menu-skeleton",
    className: q("flex h-8 items-center gap-2 rounded-md px-2", e),
    ...n,
    children: [
      t &&
        h.jsx(Qw, {
          className: "size-4 rounded-md",
          "data-sidebar": "menu-skeleton-icon",
        }),
      h.jsx(Qw, {
        className: "h-4 max-w-[--skeleton-width] flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: { "--skeleton-width": o },
      }),
    ],
  })
})
N7.displayName = "SidebarMenuSkeleton"
const T7 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx("ul", {
    ref: n,
    "data-sidebar": "menu-sub",
    className: q(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      e
    ),
    ...t,
  })
)
T7.displayName = "SidebarMenuSub"
const M7 = m.forwardRef(({ ...e }, t) => h.jsx("li", { ref: t, ...e }))
M7.displayName = "SidebarMenuSubItem"
const O7 = m.forwardRef(
  ({ asChild: e = !1, size: t = "md", isActive: n, className: r, ...o }, i) => {
    const s = e ? An : "a"
    return h.jsx(s, {
      ref: i,
      "data-sidebar": "menu-sub-button",
      "data-size": t,
      "data-active": n,
      className: q(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        t === "sm" && "text-xs",
        t === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        r
      ),
      ...o,
    })
  }
)
O7.displayName = "SidebarMenuSubButton"
var A7 = (e, t, n, r, o, i, s, a) => {
    let l = document.documentElement,
      c = ["light", "dark"]
    function u(p) {
      ;(Array.isArray(e) ? e : [e]).forEach((g) => {
        let v = g === "class",
          b = v && i ? o.map((y) => i[y] || y) : o
        v
          ? (l.classList.remove(...b), l.classList.add(i && i[p] ? i[p] : p))
          : l.setAttribute(g, p)
      }),
        d(p)
    }
    function d(p) {
      a && c.includes(p) && (l.style.colorScheme = p)
    }
    function f() {
      return window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light"
    }
    if (r) u(r)
    else
      try {
        let p = localStorage.getItem(t) || n,
          g = s && p === "system" ? f() : p
        u(g)
      } catch {}
  },
  Jw = ["light", "dark"],
  s2 = "(prefers-color-scheme: dark)",
  R7 = typeof window > "u",
  Rb = m.createContext(void 0),
  I7 = { setTheme: (e) => {}, themes: [] },
  D7 = () => {
    var e
    return (e = m.useContext(Rb)) != null ? e : I7
  },
  L7 = (e) =>
    m.useContext(Rb)
      ? m.createElement(m.Fragment, null, e.children)
      : m.createElement($7, { ...e }),
  P7 = ["light", "dark"],
  $7 = ({
    forcedTheme: e,
    disableTransitionOnChange: t = !1,
    enableSystem: n = !0,
    enableColorScheme: r = !0,
    storageKey: o = "theme",
    themes: i = P7,
    defaultTheme: s = n ? "system" : "light",
    attribute: a = "data-theme",
    value: l,
    children: c,
    nonce: u,
    scriptProps: d,
  }) => {
    let [f, p] = m.useState(() => j7(o, s)),
      [g, v] = m.useState(() => (f === "system" ? lg() : f)),
      b = l ? Object.values(l) : i,
      y = m.useCallback(
        (C) => {
          let S = C
          if (!S) return
          C === "system" && n && (S = lg())
          let M = l ? l[S] : S,
            N = t ? F7(u) : null,
            R = document.documentElement,
            B = (V) => {
              V === "class"
                ? (R.classList.remove(...b), M && R.classList.add(M))
                : V.startsWith("data-") &&
                  (M ? R.setAttribute(V, M) : R.removeAttribute(V))
            }
          if ((Array.isArray(a) ? a.forEach(B) : B(a), r)) {
            let V = Jw.includes(s) ? s : null,
              j = Jw.includes(S) ? S : V
            R.style.colorScheme = j
          }
          N == null || N()
        },
        [u]
      ),
      x = m.useCallback(
        (C) => {
          let S = typeof C == "function" ? C(f) : C
          p(S)
          try {
            localStorage.setItem(o, S)
          } catch {}
        },
        [f]
      ),
      E = m.useCallback(
        (C) => {
          let S = lg(C)
          v(S), f === "system" && n && !e && y("system")
        },
        [f, e]
      )
    m.useEffect(() => {
      let C = window.matchMedia(s2)
      return C.addListener(E), E(C), () => C.removeListener(E)
    }, [E]),
      m.useEffect(() => {
        let C = (S) => {
          S.key === o && (S.newValue ? p(S.newValue) : x(s))
        }
        return (
          window.addEventListener("storage", C),
          () => window.removeEventListener("storage", C)
        )
      }, [x]),
      m.useEffect(() => {
        y(e != null ? e : f)
      }, [e, f])
    let w = m.useMemo(
      () => ({
        theme: f,
        setTheme: x,
        forcedTheme: e,
        resolvedTheme: f === "system" ? g : f,
        themes: n ? [...i, "system"] : i,
        systemTheme: n ? g : void 0,
      }),
      [f, x, e, g, n, i]
    )
    return m.createElement(
      Rb.Provider,
      { value: w },
      m.createElement(B7, {
        forcedTheme: e,
        storageKey: o,
        attribute: a,
        enableSystem: n,
        enableColorScheme: r,
        defaultTheme: s,
        value: l,
        themes: i,
        nonce: u,
        scriptProps: d,
      }),
      c
    )
  },
  B7 = m.memo(
    ({
      forcedTheme: e,
      storageKey: t,
      attribute: n,
      enableSystem: r,
      enableColorScheme: o,
      defaultTheme: i,
      value: s,
      themes: a,
      nonce: l,
      scriptProps: c,
    }) => {
      let u = JSON.stringify([n, t, i, e, a, s, r, o]).slice(1, -1)
      return m.createElement("script", {
        ...c,
        suppressHydrationWarning: !0,
        nonce: typeof window > "u" ? l : "",
        dangerouslySetInnerHTML: { __html: `(${A7.toString()})(${u})` },
      })
    }
  ),
  j7 = (e, t) => {
    if (R7) return
    let n
    try {
      n = localStorage.getItem(e) || void 0
    } catch {}
    return n || t
  },
  F7 = (e) => {
    let t = document.createElement("style")
    return (
      e && t.setAttribute("nonce", e),
      t.appendChild(
        document.createTextNode(
          "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"
        )
      ),
      document.head.appendChild(t),
      () => {
        window.getComputedStyle(document.body),
          setTimeout(() => {
            document.head.removeChild(t)
          }, 1)
      }
    )
  },
  lg = (e) => (e || (e = window.matchMedia(s2)), e.matches ? "dark" : "light")
function a2(e) {
  const t = e + "CollectionProvider",
    [n, r] = Wn(t),
    [o, i] = n(t, { collectionRef: { current: null }, itemMap: new Map() }),
    s = (p) => {
      const { scope: g, children: v } = p,
        b = G.useRef(null),
        y = G.useRef(new Map()).current
      return h.jsx(o, { scope: g, itemMap: y, collectionRef: b, children: v })
    }
  s.displayName = t
  const a = e + "CollectionSlot",
    l = G.forwardRef((p, g) => {
      const { scope: v, children: b } = p,
        y = i(a, v),
        x = tt(g, y.collectionRef)
      return h.jsx(An, { ref: x, children: b })
    })
  l.displayName = a
  const c = e + "CollectionItemSlot",
    u = "data-radix-collection-item",
    d = G.forwardRef((p, g) => {
      const { scope: v, children: b, ...y } = p,
        x = G.useRef(null),
        E = tt(g, x),
        w = i(c, v)
      return (
        G.useEffect(
          () => (
            w.itemMap.set(x, { ref: x, ...y }), () => void w.itemMap.delete(x)
          )
        ),
        h.jsx(An, { [u]: "", ref: E, children: b })
      )
    })
  d.displayName = c
  function f(p) {
    const g = i(e + "CollectionConsumer", p)
    return G.useCallback(() => {
      const b = g.collectionRef.current
      if (!b) return []
      const y = Array.from(b.querySelectorAll(`[${u}]`))
      return Array.from(g.itemMap.values()).sort(
        (w, C) => y.indexOf(w.ref.current) - y.indexOf(C.ref.current)
      )
    }, [g.collectionRef, g.itemMap])
  }
  return [{ Provider: s, Slot: l, ItemSlot: d }, f, r]
}
var z7 = m.createContext(void 0)
function Hh(e) {
  const t = m.useContext(z7)
  return e || t || "ltr"
}
var cg = "rovingFocusGroup.onEntryFocus",
  U7 = { bubbles: !1, cancelable: !0 },
  Wh = "RovingFocusGroup",
  [ay, l2, V7] = a2(Wh),
  [H7, vl] = Wn(Wh, [V7]),
  [W7, K7] = H7(Wh),
  c2 = m.forwardRef((e, t) =>
    h.jsx(ay.Provider, {
      scope: e.__scopeRovingFocusGroup,
      children: h.jsx(ay.Slot, {
        scope: e.__scopeRovingFocusGroup,
        children: h.jsx(G7, { ...e, ref: t }),
      }),
    })
  )
c2.displayName = Wh
var G7 = m.forwardRef((e, t) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: o = !1,
        dir: i,
        currentTabStopId: s,
        defaultCurrentTabStopId: a,
        onCurrentTabStopIdChange: l,
        onEntryFocus: c,
        preventScrollOnEntryFocus: u = !1,
        ...d
      } = e,
      f = m.useRef(null),
      p = tt(t, f),
      g = Hh(i),
      [v = null, b] = Ir({ prop: s, defaultProp: a, onChange: l }),
      [y, x] = m.useState(!1),
      E = Nr(c),
      w = l2(n),
      C = m.useRef(!1),
      [S, M] = m.useState(0)
    return (
      m.useEffect(() => {
        const N = f.current
        if (N)
          return N.addEventListener(cg, E), () => N.removeEventListener(cg, E)
      }, [E]),
      h.jsx(W7, {
        scope: n,
        orientation: r,
        dir: g,
        loop: o,
        currentTabStopId: v,
        onItemFocus: m.useCallback((N) => b(N), [b]),
        onItemShiftTab: m.useCallback(() => x(!0), []),
        onFocusableItemAdd: m.useCallback(() => M((N) => N + 1), []),
        onFocusableItemRemove: m.useCallback(() => M((N) => N - 1), []),
        children: h.jsx(Le.div, {
          tabIndex: y || S === 0 ? -1 : 0,
          "data-orientation": r,
          ...d,
          ref: p,
          style: { outline: "none", ...e.style },
          onMouseDown: ge(e.onMouseDown, () => {
            C.current = !0
          }),
          onFocus: ge(e.onFocus, (N) => {
            const R = !C.current
            if (N.target === N.currentTarget && R && !y) {
              const B = new CustomEvent(cg, U7)
              if ((N.currentTarget.dispatchEvent(B), !B.defaultPrevented)) {
                const V = w().filter((I) => I.focusable),
                  j = V.find((I) => I.active),
                  U = V.find((I) => I.id === v),
                  ee = [j, U, ...V].filter(Boolean).map((I) => I.ref.current)
                f2(ee, u)
              }
            }
            C.current = !1
          }),
          onBlur: ge(e.onBlur, () => x(!1)),
        }),
      })
    )
  }),
  u2 = "RovingFocusGroupItem",
  d2 = m.forwardRef((e, t) => {
    const {
        __scopeRovingFocusGroup: n,
        focusable: r = !0,
        active: o = !1,
        tabStopId: i,
        ...s
      } = e,
      a = fi(),
      l = i || a,
      c = K7(u2, n),
      u = c.currentTabStopId === l,
      d = l2(n),
      { onFocusableItemAdd: f, onFocusableItemRemove: p } = c
    return (
      m.useEffect(() => {
        if (r) return f(), () => p()
      }, [r, f, p]),
      h.jsx(ay.ItemSlot, {
        scope: n,
        id: l,
        focusable: r,
        active: o,
        children: h.jsx(Le.span, {
          tabIndex: u ? 0 : -1,
          "data-orientation": c.orientation,
          ...s,
          ref: t,
          onMouseDown: ge(e.onMouseDown, (g) => {
            r ? c.onItemFocus(l) : g.preventDefault()
          }),
          onFocus: ge(e.onFocus, () => c.onItemFocus(l)),
          onKeyDown: ge(e.onKeyDown, (g) => {
            if (g.key === "Tab" && g.shiftKey) {
              c.onItemShiftTab()
              return
            }
            if (g.target !== g.currentTarget) return
            const v = Y7(g, c.orientation, c.dir)
            if (v !== void 0) {
              if (g.metaKey || g.ctrlKey || g.altKey || g.shiftKey) return
              g.preventDefault()
              let y = d()
                .filter((x) => x.focusable)
                .map((x) => x.ref.current)
              if (v === "last") y.reverse()
              else if (v === "prev" || v === "next") {
                v === "prev" && y.reverse()
                const x = y.indexOf(g.currentTarget)
                y = c.loop ? X7(y, x + 1) : y.slice(x + 1)
              }
              setTimeout(() => f2(y))
            }
          }),
        }),
      })
    )
  })
d2.displayName = u2
var q7 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
}
function Z7(e, t) {
  return t !== "rtl"
    ? e
    : e === "ArrowLeft"
      ? "ArrowRight"
      : e === "ArrowRight"
        ? "ArrowLeft"
        : e
}
function Y7(e, t, n) {
  const r = Z7(e.key, n)
  if (
    !(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) &&
    !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))
  )
    return q7[r]
}
function f2(e, t = !1) {
  const n = document.activeElement
  for (const r of e)
    if (
      r === n ||
      (r.focus({ preventScroll: t }), document.activeElement !== n)
    )
      return
}
function X7(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}
var Ib = c2,
  Db = d2
function Lb(e) {
  const t = m.useRef({ value: e, previous: e })
  return m.useMemo(
    () => (
      t.current.value !== e &&
        ((t.current.previous = t.current.value), (t.current.value = e)),
      t.current.previous
    ),
    [e]
  )
}
var Pb = "Radio",
  [Q7, p2] = Wn(Pb),
  [J7, e$] = Q7(Pb),
  h2 = m.forwardRef((e, t) => {
    const {
        __scopeRadio: n,
        name: r,
        checked: o = !1,
        required: i,
        disabled: s,
        value: a = "on",
        onCheck: l,
        form: c,
        ...u
      } = e,
      [d, f] = m.useState(null),
      p = tt(t, (b) => f(b)),
      g = m.useRef(!1),
      v = d ? c || !!d.closest("form") : !0
    return h.jsxs(J7, {
      scope: n,
      checked: o,
      disabled: s,
      children: [
        h.jsx(Le.button, {
          type: "button",
          role: "radio",
          "aria-checked": o,
          "data-state": v2(o),
          "data-disabled": s ? "" : void 0,
          disabled: s,
          value: a,
          ...u,
          ref: p,
          onClick: ge(e.onClick, (b) => {
            o || l == null || l(),
              v &&
                ((g.current = b.isPropagationStopped()),
                g.current || b.stopPropagation())
          }),
        }),
        v &&
          h.jsx(t$, {
            control: d,
            bubbles: !g.current,
            name: r,
            value: a,
            checked: o,
            required: i,
            disabled: s,
            form: c,
            style: { transform: "translateX(-100%)" },
          }),
      ],
    })
  })
h2.displayName = Pb
var m2 = "RadioIndicator",
  g2 = m.forwardRef((e, t) => {
    const { __scopeRadio: n, forceMount: r, ...o } = e,
      i = e$(m2, n)
    return h.jsx(Kn, {
      present: r || i.checked,
      children: h.jsx(Le.span, {
        "data-state": v2(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...o,
        ref: t,
      }),
    })
  })
g2.displayName = m2
var t$ = (e) => {
  const { control: t, checked: n, bubbles: r = !0, ...o } = e,
    i = m.useRef(null),
    s = Lb(n),
    a = kh(t)
  return (
    m.useEffect(() => {
      const l = i.current,
        c = window.HTMLInputElement.prototype,
        d = Object.getOwnPropertyDescriptor(c, "checked").set
      if (s !== n && d) {
        const f = new Event("click", { bubbles: r })
        d.call(l, n), l.dispatchEvent(f)
      }
    }, [s, n, r]),
    h.jsx("input", {
      type: "radio",
      "aria-hidden": !0,
      defaultChecked: n,
      ...o,
      tabIndex: -1,
      ref: i,
      style: {
        ...e.style,
        ...a,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0,
      },
    })
  )
}
function v2(e) {
  return e ? "checked" : "unchecked"
}
var n$ = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"],
  $b = "RadioGroup",
  [r$, Yte] = Wn($b, [vl, p2]),
  y2 = vl(),
  b2 = p2(),
  [o$, i$] = r$($b),
  x2 = m.forwardRef((e, t) => {
    const {
        __scopeRadioGroup: n,
        name: r,
        defaultValue: o,
        value: i,
        required: s = !1,
        disabled: a = !1,
        orientation: l,
        dir: c,
        loop: u = !0,
        onValueChange: d,
        ...f
      } = e,
      p = y2(n),
      g = Hh(c),
      [v, b] = Ir({ prop: i, defaultProp: o, onChange: d })
    return h.jsx(o$, {
      scope: n,
      name: r,
      required: s,
      disabled: a,
      value: v,
      onValueChange: b,
      children: h.jsx(Ib, {
        asChild: !0,
        ...p,
        orientation: l,
        dir: g,
        loop: u,
        children: h.jsx(Le.div, {
          role: "radiogroup",
          "aria-required": s,
          "aria-orientation": l,
          "data-disabled": a ? "" : void 0,
          dir: g,
          ...f,
          ref: t,
        }),
      }),
    })
  })
x2.displayName = $b
var w2 = "RadioGroupItem",
  E2 = m.forwardRef((e, t) => {
    const { __scopeRadioGroup: n, disabled: r, ...o } = e,
      i = i$(w2, n),
      s = i.disabled || r,
      a = y2(n),
      l = b2(n),
      c = m.useRef(null),
      u = tt(t, c),
      d = i.value === o.value,
      f = m.useRef(!1)
    return (
      m.useEffect(() => {
        const p = (v) => {
            n$.includes(v.key) && (f.current = !0)
          },
          g = () => (f.current = !1)
        return (
          document.addEventListener("keydown", p),
          document.addEventListener("keyup", g),
          () => {
            document.removeEventListener("keydown", p),
              document.removeEventListener("keyup", g)
          }
        )
      }, []),
      h.jsx(Db, {
        asChild: !0,
        ...a,
        focusable: !s,
        active: d,
        children: h.jsx(h2, {
          disabled: s,
          required: i.required,
          checked: d,
          ...l,
          ...o,
          name: i.name,
          ref: u,
          onCheck: () => i.onValueChange(o.value),
          onKeyDown: ge((p) => {
            p.key === "Enter" && p.preventDefault()
          }),
          onFocus: ge(o.onFocus, () => {
            var p
            f.current && ((p = c.current) == null || p.click())
          }),
        }),
      })
    )
  })
E2.displayName = w2
var s$ = "RadioGroupIndicator",
  C2 = m.forwardRef((e, t) => {
    const { __scopeRadioGroup: n, ...r } = e,
      o = b2(n)
    return h.jsx(g2, { ...o, ...r, ref: t })
  })
C2.displayName = s$
var S2 = x2,
  _2 = E2,
  a$ = C2
const k2 = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(S2, { className: q("grid gap-2", e), ...t, ref: n })
)
k2.displayName = S2.displayName
const nf = m.forwardRef(({ className: e, children: t, ...n }, r) =>
  h.jsx(_2, {
    ref: r,
    className: q(
      "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      e
    ),
    ...n,
    children: h.jsx(a$, {
      className: "flex items-center justify-center",
      children: h.jsx(mN, {
        className: "h-2.5 w-2.5 fill-current text-current",
      }),
    }),
  })
)
nf.displayName = _2.displayName
function l$() {
  const { setTheme: e, theme: t } = D7()
  return h.jsxs(Mb, {
    className: "absolute bottom-0",
    children: [
      h.jsx(Ob, { children: "Theme" }),
      h.jsx(Ab, {
        children: h.jsxs(k2, {
          value: t,
          children: [
            h.jsxs("label", {
              className:
                "flex cursor-pointer items-center gap-2 rounded-md p-2 hover:bg-gray-100 dark:hover:bg-gray-800",
              children: [
                h.jsx(nf, {
                  id: "light",
                  value: "light",
                  onClick: () => e("light"),
                }),
                h.jsx(CL, { className: "h-4 w-4" }),
                h.jsx("span", { children: "Light" }),
              ],
            }),
            h.jsxs("label", {
              className:
                "flex cursor-pointer items-center gap-2 rounded-md p-2 hover:bg-gray-100 dark:hover:bg-gray-800",
              children: [
                h.jsx(nf, {
                  id: "dark",
                  value: "dark",
                  onClick: () => e("dark"),
                }),
                h.jsx(vL, { className: "h-4 w-4" }),
                h.jsx("span", { children: "Dark" }),
              ],
            }),
            h.jsxs("label", {
              className:
                "flex cursor-pointer items-center gap-2 rounded-md p-2 hover:bg-gray-100 dark:hover:bg-gray-800",
              children: [
                h.jsx(nf, {
                  id: "system",
                  value: "system",
                  onClick: () => e("system"),
                }),
                h.jsx(cL, { className: "h-4 w-4" }),
                h.jsx("span", { children: "System" }),
              ],
            }),
          ],
        }),
      }),
    ],
  })
}
const c$ = [
  { title: "Home", url: "#", icon: rL },
  { title: "Create", url: "#create", icon: wL },
]
function u$() {
  return null
}
function d$() {
  return h.jsx(t2, {
    children: h.jsxs(n2, {
      children: [
        h.jsxs(Mb, {
          children: [
            h.jsx(Ob, { children: "Test" }),
            h.jsxs(Ab, {
              children: [
                h.jsx(r2, {
                  children: c$.map((e) =>
                    h.jsx(
                      o2,
                      {
                        children: h.jsx(i2, {
                          asChild: !0,
                          children: h.jsxs("a", {
                            href: e.url,
                            children: [
                              h.jsx(e.icon, {}),
                              h.jsx("span", { children: e.title }),
                            ],
                          }),
                        }),
                      },
                      e.title
                    )
                  ),
                }),
                h.jsx(u$, {}),
              ],
            }),
          ],
        }),
        h.jsx(l$, {}),
      ],
    }),
  })
}
function f$({ children: e, ...t }) {
  return h.jsx(L7, { ...t, children: e })
}
function yd({ children: e }) {
  return h.jsx(f$, {
    attribute: "class",
    defaultTheme: "system",
    enableSystem: !0,
    children: h.jsx(pT, {
      delayDuration: 0,
      children: h.jsx(e2, {
        children: h.jsxs("div", {
          className: "flex h-full w-full justify-center",
          children: [
            h.jsx(d$, {}),
            h.jsx("div", { className: "flex-1", children: e }),
          ],
        }),
      }),
    }),
  })
}
var Mu = (e) => e.type === "checkbox",
  Yi = (e) => e instanceof Date,
  fn = (e) => e == null
const N2 = (e) => typeof e == "object"
var wt = (e) => !fn(e) && !Array.isArray(e) && N2(e) && !Yi(e),
  T2 = (e) =>
    wt(e) && e.target ? (Mu(e.target) ? e.target.checked : e.target.value) : e,
  p$ = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e,
  M2 = (e, t) => e.has(p$(t)),
  h$ = (e) => {
    const t = e.constructor && e.constructor.prototype
    return wt(t) && t.hasOwnProperty("isPrototypeOf")
  },
  Bb =
    typeof window < "u" &&
    typeof window.HTMLElement < "u" &&
    typeof document < "u"
function zt(e) {
  let t
  const n = Array.isArray(e),
    r = typeof FileList < "u" ? e instanceof FileList : !1
  if (e instanceof Date) t = new Date(e)
  else if (e instanceof Set) t = new Set(e)
  else if (!(Bb && (e instanceof Blob || r)) && (n || wt(e)))
    if (((t = n ? [] : {}), !n && !h$(e))) t = e
    else for (const o in e) e.hasOwnProperty(o) && (t[o] = zt(e[o]))
  else return e
  return t
}
var Kh = (e) => (Array.isArray(e) ? e.filter(Boolean) : []),
  bt = (e) => e === void 0,
  ne = (e, t, n) => {
    if (!t || !wt(e)) return n
    const r = Kh(t.split(/[,[\].]+?/)).reduce((o, i) => (fn(o) ? o : o[i]), e)
    return bt(r) || r === e ? (bt(e[t]) ? n : e[t]) : r
  },
  Dn = (e) => typeof e == "boolean",
  jb = (e) => /^\w*$/.test(e),
  O2 = (e) => Kh(e.replace(/["|']|\]/g, "").split(/\.|\[/)),
  Ue = (e, t, n) => {
    let r = -1
    const o = jb(t) ? [t] : O2(t),
      i = o.length,
      s = i - 1
    for (; ++r < i; ) {
      const a = o[r]
      let l = n
      if (r !== s) {
        const c = e[a]
        l = wt(c) || Array.isArray(c) ? c : isNaN(+o[r + 1]) ? {} : []
      }
      if (a === "__proto__" || a === "constructor" || a === "prototype") return
      ;(e[a] = l), (e = e[a])
    }
  }
const Vf = { BLUR: "blur", FOCUS_OUT: "focusout", CHANGE: "change" },
  vr = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all",
  },
  io = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate",
  },
  A2 = G.createContext(null),
  Gh = () => G.useContext(A2),
  m$ = (e) => {
    const { children: t, ...n } = e
    return G.createElement(A2.Provider, { value: n }, t)
  }
var R2 = (e, t, n, r = !0) => {
  const o = { defaultValues: t._defaultValues }
  for (const i in e)
    Object.defineProperty(o, i, {
      get: () => {
        const s = i
        return (
          t._proxyFormState[s] !== vr.all &&
            (t._proxyFormState[s] = !r || vr.all),
          n && (n[s] = !0),
          e[s]
        )
      },
    })
  return o
}
function g$(e) {
  const t = Gh(),
    { control: n = t.control, disabled: r, name: o, exact: i } = e || {},
    [s, a] = G.useState(n._formState),
    l = G.useRef({
      isDirty: !1,
      isLoading: !1,
      dirtyFields: !1,
      touchedFields: !1,
      validatingFields: !1,
      isValidating: !1,
      isValid: !1,
      errors: !1,
    }),
    c = G.useRef(o)
  return (
    (c.current = o),
    G.useEffect(
      () =>
        n._subscribe({
          name: c.current,
          formState: l.current,
          exact: i,
          callback: (u) => {
            !r && a({ ...n._formState, ...u })
          },
        }),
      [n, r, i]
    ),
    G.useEffect(() => {
      l.current.isValid && n._setValid(!0)
    }, [n]),
    G.useMemo(() => R2(s, n, l.current, !1), [s, n])
  )
}
var Vr = (e) => typeof e == "string",
  I2 = (e, t, n, r, o) =>
    Vr(e)
      ? (r && t.watch.add(e), ne(n, e, o))
      : Array.isArray(e)
        ? e.map((i) => (r && t.watch.add(i), ne(n, i)))
        : (r && (t.watchAll = !0), n)
function v$(e) {
  const t = Gh(),
    {
      control: n = t.control,
      name: r,
      defaultValue: o,
      disabled: i,
      exact: s,
    } = e || {},
    a = G.useRef(r),
    l = G.useRef(o)
  ;(a.current = r),
    G.useEffect(
      () =>
        n._subscribe({
          name: a.current,
          formState: { values: !0 },
          exact: s,
          callback: (d) =>
            !i &&
            u(
              I2(a.current, n._names, d.values || n._formValues, !1, l.current)
            ),
        }),
      [n, i, s]
    )
  const [c, u] = G.useState(n._getWatch(r, o))
  return G.useEffect(() => n._removeUnmounted()), c
}
function y$(e) {
  const t = Gh(),
    { name: n, disabled: r, control: o = t.control, shouldUnregister: i } = e,
    s = M2(o._names.array, n),
    a = v$({
      control: o,
      name: n,
      defaultValue: ne(
        o._formValues,
        n,
        ne(o._defaultValues, n, e.defaultValue)
      ),
      exact: !0,
    }),
    l = g$({ control: o, name: n, exact: !0 }),
    c = G.useRef(e),
    u = G.useRef(
      o.register(n, {
        ...e.rules,
        value: a,
        ...(Dn(e.disabled) ? { disabled: e.disabled } : {}),
      })
    ),
    d = G.useMemo(
      () =>
        Object.defineProperties(
          {},
          {
            invalid: { enumerable: !0, get: () => !!ne(l.errors, n) },
            isDirty: { enumerable: !0, get: () => !!ne(l.dirtyFields, n) },
            isTouched: { enumerable: !0, get: () => !!ne(l.touchedFields, n) },
            isValidating: {
              enumerable: !0,
              get: () => !!ne(l.validatingFields, n),
            },
            error: { enumerable: !0, get: () => ne(l.errors, n) },
          }
        ),
      [l, n]
    ),
    f = G.useCallback(
      (b) =>
        u.current.onChange({
          target: { value: T2(b), name: n },
          type: Vf.CHANGE,
        }),
      [n]
    ),
    p = G.useCallback(
      () =>
        u.current.onBlur({
          target: { value: ne(o._formValues, n), name: n },
          type: Vf.BLUR,
        }),
      [n, o._formValues]
    ),
    g = G.useCallback(
      (b) => {
        const y = ne(o._fields, n)
        y &&
          b &&
          (y._f.ref = {
            focus: () => b.focus(),
            select: () => b.select(),
            setCustomValidity: (x) => b.setCustomValidity(x),
            reportValidity: () => b.reportValidity(),
          })
      },
      [o._fields, n]
    ),
    v = G.useMemo(
      () => ({
        name: n,
        value: a,
        ...(Dn(r) || l.disabled ? { disabled: l.disabled || r } : {}),
        onChange: f,
        onBlur: p,
        ref: g,
      }),
      [n, r, l.disabled, f, p, g, a]
    )
  return (
    G.useEffect(() => {
      const b = o._options.shouldUnregister || i
      o.register(n, {
        ...c.current.rules,
        ...(Dn(c.current.disabled) ? { disabled: c.current.disabled } : {}),
      })
      const y = (x, E) => {
        const w = ne(o._fields, x)
        w && w._f && (w._f.mount = E)
      }
      if ((y(n, !0), b)) {
        const x = zt(ne(o._options.defaultValues, n))
        Ue(o._defaultValues, n, x),
          bt(ne(o._formValues, n)) && Ue(o._formValues, n, x)
      }
      return (
        !s && o.register(n),
        () => {
          ;(s ? b && !o._state.action : b) ? o.unregister(n) : y(n, !1)
        }
      )
    }, [n, o, s, i]),
    G.useEffect(() => {
      o._setDisabledField({ disabled: r, name: n })
    }, [r, n, o]),
    G.useMemo(() => ({ field: v, formState: l, fieldState: d }), [v, l, d])
  )
}
const b$ = (e) => e.render(y$(e))
var D2 = (e, t, n, r, o) =>
    t
      ? {
          ...n[e],
          types: { ...(n[e] && n[e].types ? n[e].types : {}), [r]: o || !0 },
        }
      : {},
  lc = (e) => (Array.isArray(e) ? e : [e]),
  eE = () => {
    let e = []
    return {
      get observers() {
        return e
      },
      next: (o) => {
        for (const i of e) i.next && i.next(o)
      },
      subscribe: (o) => (
        e.push(o),
        {
          unsubscribe: () => {
            e = e.filter((i) => i !== o)
          },
        }
      ),
      unsubscribe: () => {
        e = []
      },
    }
  },
  ly = (e) => fn(e) || !N2(e)
function qo(e, t) {
  if (ly(e) || ly(t)) return e === t
  if (Yi(e) && Yi(t)) return e.getTime() === t.getTime()
  const n = Object.keys(e),
    r = Object.keys(t)
  if (n.length !== r.length) return !1
  for (const o of n) {
    const i = e[o]
    if (!r.includes(o)) return !1
    if (o !== "ref") {
      const s = t[o]
      if (
        (Yi(i) && Yi(s)) ||
        (wt(i) && wt(s)) ||
        (Array.isArray(i) && Array.isArray(s))
          ? !qo(i, s)
          : i !== s
      )
        return !1
    }
  }
  return !0
}
var cn = (e) => wt(e) && !Object.keys(e).length,
  Fb = (e) => e.type === "file",
  yr = (e) => typeof e == "function",
  Hf = (e) => {
    if (!Bb) return !1
    const t = e ? e.ownerDocument : 0
    return (
      e instanceof
      (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement)
    )
  },
  L2 = (e) => e.type === "select-multiple",
  zb = (e) => e.type === "radio",
  x$ = (e) => zb(e) || Mu(e),
  ug = (e) => Hf(e) && e.isConnected
function w$(e, t) {
  const n = t.slice(0, -1).length
  let r = 0
  for (; r < n; ) e = bt(e) ? r++ : e[t[r++]]
  return e
}
function E$(e) {
  for (const t in e) if (e.hasOwnProperty(t) && !bt(e[t])) return !1
  return !0
}
function Nt(e, t) {
  const n = Array.isArray(t) ? t : jb(t) ? [t] : O2(t),
    r = n.length === 1 ? e : w$(e, n),
    o = n.length - 1,
    i = n[o]
  return (
    r && delete r[i],
    o !== 0 &&
      ((wt(r) && cn(r)) || (Array.isArray(r) && E$(r))) &&
      Nt(e, n.slice(0, -1)),
    e
  )
}
var P2 = (e) => {
  for (const t in e) if (yr(e[t])) return !0
  return !1
}
function Wf(e, t = {}) {
  const n = Array.isArray(e)
  if (wt(e) || n)
    for (const r in e)
      Array.isArray(e[r]) || (wt(e[r]) && !P2(e[r]))
        ? ((t[r] = Array.isArray(e[r]) ? [] : {}), Wf(e[r], t[r]))
        : fn(e[r]) || (t[r] = !0)
  return t
}
function $2(e, t, n) {
  const r = Array.isArray(e)
  if (wt(e) || r)
    for (const o in e)
      Array.isArray(e[o]) || (wt(e[o]) && !P2(e[o]))
        ? bt(t) || ly(n[o])
          ? (n[o] = Array.isArray(e[o]) ? Wf(e[o], []) : { ...Wf(e[o]) })
          : $2(e[o], fn(t) ? {} : t[o], n[o])
        : (n[o] = !qo(e[o], t[o]))
  return n
}
var Il = (e, t) => $2(e, t, Wf(t))
const tE = { value: !1, isValid: !1 },
  nE = { value: !0, isValid: !0 }
var B2 = (e) => {
    if (Array.isArray(e)) {
      if (e.length > 1) {
        const t = e
          .filter((n) => n && n.checked && !n.disabled)
          .map((n) => n.value)
        return { value: t, isValid: !!t.length }
      }
      return e[0].checked && !e[0].disabled
        ? e[0].attributes && !bt(e[0].attributes.value)
          ? bt(e[0].value) || e[0].value === ""
            ? nE
            : { value: e[0].value, isValid: !0 }
          : nE
        : tE
    }
    return tE
  },
  j2 = (e, { valueAsNumber: t, valueAsDate: n, setValueAs: r }) =>
    bt(e)
      ? e
      : t
        ? e === ""
          ? NaN
          : e && +e
        : n && Vr(e)
          ? new Date(e)
          : r
            ? r(e)
            : e
const rE = { isValid: !1, value: null }
var F2 = (e) =>
  Array.isArray(e)
    ? e.reduce(
        (t, n) =>
          n && n.checked && !n.disabled ? { isValid: !0, value: n.value } : t,
        rE
      )
    : rE
function oE(e) {
  const t = e.ref
  return Fb(t)
    ? t.files
    : zb(t)
      ? F2(e.refs).value
      : L2(t)
        ? [...t.selectedOptions].map(({ value: n }) => n)
        : Mu(t)
          ? B2(e.refs).value
          : j2(bt(t.value) ? e.ref.value : t.value, e)
}
var C$ = (e, t, n, r) => {
    const o = {}
    for (const i of e) {
      const s = ne(t, i)
      s && Ue(o, i, s._f)
    }
    return {
      criteriaMode: n,
      names: [...e],
      fields: o,
      shouldUseNativeValidation: r,
    }
  },
  Kf = (e) => e instanceof RegExp,
  Dl = (e) =>
    bt(e)
      ? e
      : Kf(e)
        ? e.source
        : wt(e)
          ? Kf(e.value)
            ? e.value.source
            : e.value
          : e,
  iE = (e) => ({
    isOnSubmit: !e || e === vr.onSubmit,
    isOnBlur: e === vr.onBlur,
    isOnChange: e === vr.onChange,
    isOnAll: e === vr.all,
    isOnTouch: e === vr.onTouched,
  })
const sE = "AsyncFunction"
var S$ = (e) =>
    !!e &&
    !!e.validate &&
    !!(
      (yr(e.validate) && e.validate.constructor.name === sE) ||
      (wt(e.validate) &&
        Object.values(e.validate).find((t) => t.constructor.name === sE))
    ),
  _$ = (e) =>
    e.mount &&
    (e.required ||
      e.min ||
      e.max ||
      e.maxLength ||
      e.minLength ||
      e.pattern ||
      e.validate),
  aE = (e, t, n) =>
    !n &&
    (t.watchAll ||
      t.watch.has(e) ||
      [...t.watch].some(
        (r) => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length))
      ))
const cc = (e, t, n, r) => {
  for (const o of n || Object.keys(e)) {
    const i = ne(e, o)
    if (i) {
      const { _f: s, ...a } = i
      if (s) {
        if (s.refs && s.refs[0] && t(s.refs[0], o) && !r) return !0
        if (s.ref && t(s.ref, s.name) && !r) return !0
        if (cc(a, t)) break
      } else if (wt(a) && cc(a, t)) break
    }
  }
}
function lE(e, t, n) {
  const r = ne(e, n)
  if (r || jb(n)) return { error: r, name: n }
  const o = n.split(".")
  for (; o.length; ) {
    const i = o.join("."),
      s = ne(t, i),
      a = ne(e, i)
    if (s && !Array.isArray(s) && n !== i) return { name: n }
    if (a && a.type) return { name: i, error: a }
    o.pop()
  }
  return { name: n }
}
var k$ = (e, t, n, r) => {
    n(e)
    const { name: o, ...i } = e
    return (
      cn(i) ||
      Object.keys(i).length >= Object.keys(t).length ||
      Object.keys(i).find((s) => t[s] === (!r || vr.all))
    )
  },
  N$ = (e, t, n) =>
    !e ||
    !t ||
    e === t ||
    lc(e).some((r) => r && (n ? r === t : r.startsWith(t) || t.startsWith(r))),
  T$ = (e, t, n, r, o) =>
    o.isOnAll
      ? !1
      : !n && o.isOnTouch
        ? !(t || e)
        : (n ? r.isOnBlur : o.isOnBlur)
          ? !e
          : (n ? r.isOnChange : o.isOnChange)
            ? e
            : !0,
  M$ = (e, t) => !Kh(ne(e, t)).length && Nt(e, t),
  O$ = (e, t, n) => {
    const r = lc(ne(e, n))
    return Ue(r, "root", t[n]), Ue(e, n, r), e
  },
  rf = (e) => Vr(e)
function cE(e, t, n = "validate") {
  if (rf(e) || (Array.isArray(e) && e.every(rf)) || (Dn(e) && !e))
    return { type: n, message: rf(e) ? e : "", ref: t }
}
var Gs = (e) => (wt(e) && !Kf(e) ? e : { value: e, message: "" }),
  uE = async (e, t, n, r, o, i) => {
    const {
        ref: s,
        refs: a,
        required: l,
        maxLength: c,
        minLength: u,
        min: d,
        max: f,
        pattern: p,
        validate: g,
        name: v,
        valueAsNumber: b,
        mount: y,
      } = e._f,
      x = ne(n, v)
    if (!y || t.has(v)) return {}
    const E = a ? a[0] : s,
      w = (j) => {
        o &&
          E.reportValidity &&
          (E.setCustomValidity(Dn(j) ? "" : j || ""), E.reportValidity())
      },
      C = {},
      S = zb(s),
      M = Mu(s),
      N = S || M,
      R =
        ((b || Fb(s)) && bt(s.value) && bt(x)) ||
        (Hf(s) && s.value === "") ||
        x === "" ||
        (Array.isArray(x) && !x.length),
      B = D2.bind(null, v, r, C),
      V = (j, U, W, ee = io.maxLength, I = io.minLength) => {
        const O = j ? U : W
        C[v] = { type: j ? ee : I, message: O, ref: s, ...B(j ? ee : I, O) }
      }
    if (
      i
        ? !Array.isArray(x) || !x.length
        : l &&
          ((!N && (R || fn(x))) ||
            (Dn(x) && !x) ||
            (M && !B2(a).isValid) ||
            (S && !F2(a).isValid))
    ) {
      const { value: j, message: U } = rf(l)
        ? { value: !!l, message: l }
        : Gs(l)
      if (
        j &&
        ((C[v] = {
          type: io.required,
          message: U,
          ref: E,
          ...B(io.required, U),
        }),
        !r)
      )
        return w(U), C
    }
    if (!R && (!fn(d) || !fn(f))) {
      let j, U
      const W = Gs(f),
        ee = Gs(d)
      if (!fn(x) && !isNaN(x)) {
        const I = s.valueAsNumber || (x && +x)
        fn(W.value) || (j = I > W.value), fn(ee.value) || (U = I < ee.value)
      } else {
        const I = s.valueAsDate || new Date(x),
          O = (P) => new Date(new Date().toDateString() + " " + P),
          _ = s.type == "time",
          A = s.type == "week"
        Vr(W.value) &&
          x &&
          (j = _ ? O(x) > O(W.value) : A ? x > W.value : I > new Date(W.value)),
          Vr(ee.value) &&
            x &&
            (U = _
              ? O(x) < O(ee.value)
              : A
                ? x < ee.value
                : I < new Date(ee.value))
      }
      if ((j || U) && (V(!!j, W.message, ee.message, io.max, io.min), !r))
        return w(C[v].message), C
    }
    if ((c || u) && !R && (Vr(x) || (i && Array.isArray(x)))) {
      const j = Gs(c),
        U = Gs(u),
        W = !fn(j.value) && x.length > +j.value,
        ee = !fn(U.value) && x.length < +U.value
      if ((W || ee) && (V(W, j.message, U.message), !r))
        return w(C[v].message), C
    }
    if (p && !R && Vr(x)) {
      const { value: j, message: U } = Gs(p)
      if (
        Kf(j) &&
        !x.match(j) &&
        ((C[v] = { type: io.pattern, message: U, ref: s, ...B(io.pattern, U) }),
        !r)
      )
        return w(U), C
    }
    if (g) {
      if (yr(g)) {
        const j = await g(x, n),
          U = cE(j, E)
        if (U && ((C[v] = { ...U, ...B(io.validate, U.message) }), !r))
          return w(U.message), C
      } else if (wt(g)) {
        let j = {}
        for (const U in g) {
          if (!cn(j) && !r) break
          const W = cE(await g[U](x, n), E, U)
          W &&
            ((j = { ...W, ...B(U, W.message) }), w(W.message), r && (C[v] = j))
        }
        if (!cn(j) && ((C[v] = { ref: E, ...j }), !r)) return C
      }
    }
    return w(!0), C
  }
const A$ = {
  mode: vr.onSubmit,
  reValidateMode: vr.onChange,
  shouldFocusError: !0,
}
function R$(e = {}) {
  let t = { ...A$, ...e },
    n = {
      submitCount: 0,
      isDirty: !1,
      isLoading: yr(t.defaultValues),
      isValidating: !1,
      isSubmitted: !1,
      isSubmitting: !1,
      isSubmitSuccessful: !1,
      isValid: !1,
      touchedFields: {},
      dirtyFields: {},
      validatingFields: {},
      errors: t.errors || {},
      disabled: t.disabled || !1,
    }
  const r = {}
  let o =
      wt(t.defaultValues) || wt(t.values)
        ? zt(t.values || t.defaultValues) || {}
        : {},
    i = t.shouldUnregister ? {} : zt(o),
    s = { action: !1, mount: !1, watch: !1 },
    a = {
      mount: new Set(),
      disabled: new Set(),
      unMount: new Set(),
      array: new Set(),
      watch: new Set(),
    },
    l,
    c = 0
  const u = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1,
  }
  let d = { ...u }
  const f = { array: eE(), state: eE() },
    p = iE(t.mode),
    g = iE(t.reValidateMode),
    v = t.criteriaMode === vr.all,
    b = (k) => (D) => {
      clearTimeout(c), (c = setTimeout(k, D))
    },
    y = async (k) => {
      if (!t.disabled && (u.isValid || d.isValid || k)) {
        const D = t.resolver ? cn((await R()).errors) : await V(r, !0)
        D !== n.isValid && f.state.next({ isValid: D })
      }
    },
    x = (k, D) => {
      !t.disabled &&
        (u.isValidating ||
          u.validatingFields ||
          d.isValidating ||
          d.validatingFields) &&
        ((k || Array.from(a.mount)).forEach((F) => {
          F && (D ? Ue(n.validatingFields, F, D) : Nt(n.validatingFields, F))
        }),
        f.state.next({
          validatingFields: n.validatingFields,
          isValidating: !cn(n.validatingFields),
        }))
    },
    E = (k, D = [], F, te, $ = !0, T = !0) => {
      if (te && F && !t.disabled) {
        if (((s.action = !0), T && Array.isArray(ne(r, k)))) {
          const L = F(ne(r, k), te.argA, te.argB)
          $ && Ue(r, k, L)
        }
        if (T && Array.isArray(ne(n.errors, k))) {
          const L = F(ne(n.errors, k), te.argA, te.argB)
          $ && Ue(n.errors, k, L), M$(n.errors, k)
        }
        if (
          (u.touchedFields || d.touchedFields) &&
          T &&
          Array.isArray(ne(n.touchedFields, k))
        ) {
          const L = F(ne(n.touchedFields, k), te.argA, te.argB)
          $ && Ue(n.touchedFields, k, L)
        }
        ;(u.dirtyFields || d.dirtyFields) && (n.dirtyFields = Il(o, i)),
          f.state.next({
            name: k,
            isDirty: U(k, D),
            dirtyFields: n.dirtyFields,
            errors: n.errors,
            isValid: n.isValid,
          })
      } else Ue(i, k, D)
    },
    w = (k, D) => {
      Ue(n.errors, k, D), f.state.next({ errors: n.errors })
    },
    C = (k) => {
      ;(n.errors = k), f.state.next({ errors: n.errors, isValid: !1 })
    },
    S = (k, D, F, te) => {
      const $ = ne(r, k)
      if ($) {
        const T = ne(i, k, bt(F) ? ne(o, k) : F)
        bt(T) || (te && te.defaultChecked) || D
          ? Ue(i, k, D ? T : oE($._f))
          : I(k, T),
          s.mount && y()
      }
    },
    M = (k, D, F, te, $) => {
      let T = !1,
        L = !1
      const K = { name: k }
      if (!t.disabled) {
        if (!F || te) {
          ;(u.isDirty || d.isDirty) &&
            ((L = n.isDirty),
            (n.isDirty = K.isDirty = U()),
            (T = L !== K.isDirty))
          const ie = qo(ne(o, k), D)
          ;(L = !!ne(n.dirtyFields, k)),
            ie ? Nt(n.dirtyFields, k) : Ue(n.dirtyFields, k, !0),
            (K.dirtyFields = n.dirtyFields),
            (T = T || ((u.dirtyFields || d.dirtyFields) && L !== !ie))
        }
        if (F) {
          const ie = ne(n.touchedFields, k)
          ie ||
            (Ue(n.touchedFields, k, F),
            (K.touchedFields = n.touchedFields),
            (T = T || ((u.touchedFields || d.touchedFields) && ie !== F)))
        }
        T && $ && f.state.next(K)
      }
      return T ? K : {}
    },
    N = (k, D, F, te) => {
      const $ = ne(n.errors, k),
        T = (u.isValid || d.isValid) && Dn(D) && n.isValid !== D
      if (
        (t.delayError && F
          ? ((l = b(() => w(k, F))), l(t.delayError))
          : (clearTimeout(c),
            (l = null),
            F ? Ue(n.errors, k, F) : Nt(n.errors, k)),
        (F ? !qo($, F) : $) || !cn(te) || T)
      ) {
        const L = {
          ...te,
          ...(T && Dn(D) ? { isValid: D } : {}),
          errors: n.errors,
          name: k,
        }
        ;(n = { ...n, ...L }), f.state.next(L)
      }
    },
    R = async (k) => {
      x(k, !0)
      const D = await t.resolver(
        i,
        t.context,
        C$(k || a.mount, r, t.criteriaMode, t.shouldUseNativeValidation)
      )
      return x(k), D
    },
    B = async (k) => {
      const { errors: D } = await R(k)
      if (k)
        for (const F of k) {
          const te = ne(D, F)
          te ? Ue(n.errors, F, te) : Nt(n.errors, F)
        }
      else n.errors = D
      return D
    },
    V = async (k, D, F = { valid: !0 }) => {
      for (const te in k) {
        const $ = k[te]
        if ($) {
          const { _f: T, ...L } = $
          if (T) {
            const K = a.array.has(T.name),
              ie = $._f && S$($._f)
            ie && u.validatingFields && x([te], !0)
            const Se = await uE(
              $,
              a.disabled,
              i,
              v,
              t.shouldUseNativeValidation && !D,
              K
            )
            if (
              (ie && u.validatingFields && x([te]),
              Se[T.name] && ((F.valid = !1), D))
            )
              break
            !D &&
              (ne(Se, T.name)
                ? K
                  ? O$(n.errors, Se, T.name)
                  : Ue(n.errors, T.name, Se[T.name])
                : Nt(n.errors, T.name))
          }
          !cn(L) && (await V(L, D, F))
        }
      }
      return F.valid
    },
    j = () => {
      for (const k of a.unMount) {
        const D = ne(r, k)
        D &&
          (D._f.refs ? D._f.refs.every((F) => !ug(F)) : !ug(D._f.ref)) &&
          Fe(k)
      }
      a.unMount = new Set()
    },
    U = (k, D) => !t.disabled && (k && D && Ue(i, k, D), !qo(X(), o)),
    W = (k, D, F) =>
      I2(k, a, { ...(s.mount ? i : bt(D) ? o : Vr(k) ? { [k]: D } : D) }, F, D),
    ee = (k) =>
      Kh(ne(s.mount ? i : o, k, t.shouldUnregister ? ne(o, k, []) : [])),
    I = (k, D, F = {}) => {
      const te = ne(r, k)
      let $ = D
      if (te) {
        const T = te._f
        T &&
          (!T.disabled && Ue(i, k, j2(D, T)),
          ($ = Hf(T.ref) && fn(D) ? "" : D),
          L2(T.ref)
            ? [...T.ref.options].forEach(
                (L) => (L.selected = $.includes(L.value))
              )
            : T.refs
              ? Mu(T.ref)
                ? T.refs.length > 1
                  ? T.refs.forEach(
                      (L) =>
                        (!L.defaultChecked || !L.disabled) &&
                        (L.checked = Array.isArray($)
                          ? !!$.find((K) => K === L.value)
                          : $ === L.value)
                    )
                  : T.refs[0] && (T.refs[0].checked = !!$)
                : T.refs.forEach((L) => (L.checked = L.value === $))
              : Fb(T.ref)
                ? (T.ref.value = "")
                : ((T.ref.value = $),
                  T.ref.type || f.state.next({ name: k, values: zt(i) })))
      }
      ;(F.shouldDirty || F.shouldTouch) &&
        M(k, $, F.shouldTouch, F.shouldDirty, !0),
        F.shouldValidate && H(k)
    },
    O = (k, D, F) => {
      for (const te in D) {
        const $ = D[te],
          T = `${k}.${te}`,
          L = ne(r, T)
        ;(a.array.has(k) || wt($) || (L && !L._f)) && !Yi($)
          ? O(T, $, F)
          : I(T, $, F)
      }
    },
    _ = (k, D, F = {}) => {
      const te = ne(r, k),
        $ = a.array.has(k),
        T = zt(D)
      Ue(i, k, T),
        $
          ? (f.array.next({ name: k, values: zt(i) }),
            (u.isDirty || u.dirtyFields || d.isDirty || d.dirtyFields) &&
              F.shouldDirty &&
              f.state.next({
                name: k,
                dirtyFields: Il(o, i),
                isDirty: U(k, T),
              }))
          : te && !te._f && !fn(T)
            ? O(k, T, F)
            : I(k, T, F),
        aE(k, a) && f.state.next({ ...n }),
        f.state.next({ name: s.mount ? k : void 0, values: zt(i) })
    },
    A = async (k) => {
      s.mount = !0
      const D = k.target
      let F = D.name,
        te = !0
      const $ = ne(r, F),
        T = (L) => {
          te =
            Number.isNaN(L) ||
            (Yi(L) && isNaN(L.getTime())) ||
            qo(L, ne(i, F, L))
        }
      if ($) {
        let L, K
        const ie = D.type ? oE($._f) : T2(k),
          Se = k.type === Vf.BLUR || k.type === Vf.FOCUS_OUT,
          an =
            (!_$($._f) && !t.resolver && !ne(n.errors, F) && !$._f.deps) ||
            T$(Se, ne(n.touchedFields, F), n.isSubmitted, g, p),
          oo = aE(F, a, Se)
        Ue(i, F, ie),
          Se
            ? ($._f.onBlur && $._f.onBlur(k), l && l(0))
            : $._f.onChange && $._f.onChange(k)
        const z = M(F, ie, Se),
          de = !cn(z) || oo
        if ((!Se && f.state.next({ name: F, type: k.type, values: zt(i) }), an))
          return (
            (u.isValid || d.isValid) &&
              (t.mode === "onBlur" ? Se && y() : Se || y()),
            de && f.state.next({ name: F, ...(oo ? {} : z) })
          )
        if ((!Se && oo && f.state.next({ ...n }), t.resolver)) {
          const { errors: we } = await R([F])
          if ((T(ie), te)) {
            const ze = lE(n.errors, r, F),
              Ie = lE(we, r, ze.name || F)
            ;(L = Ie.error), (F = Ie.name), (K = cn(we))
          }
        } else
          x([F], !0),
            (L = (await uE($, a.disabled, i, v, t.shouldUseNativeValidation))[
              F
            ]),
            x([F]),
            T(ie),
            te &&
              (L ? (K = !1) : (u.isValid || d.isValid) && (K = await V(r, !0)))
        te && ($._f.deps && H($._f.deps), N(F, K, L, z))
      }
    },
    P = (k, D) => {
      if (ne(n.errors, D) && k.focus) return k.focus(), 1
    },
    H = async (k, D = {}) => {
      let F, te
      const $ = lc(k)
      if (t.resolver) {
        const T = await B(bt(k) ? k : $)
        ;(F = cn(T)), (te = k ? !$.some((L) => ne(T, L)) : F)
      } else
        k
          ? ((te = (
              await Promise.all(
                $.map(async (T) => {
                  const L = ne(r, T)
                  return await V(L && L._f ? { [T]: L } : L)
                })
              )
            ).every(Boolean)),
            !(!te && !n.isValid) && y())
          : (te = F = await V(r))
      return (
        f.state.next({
          ...(!Vr(k) || ((u.isValid || d.isValid) && F !== n.isValid)
            ? {}
            : { name: k }),
          ...(t.resolver || !k ? { isValid: F } : {}),
          errors: n.errors,
        }),
        D.shouldFocus && !te && cc(r, P, k ? $ : a.mount),
        te
      )
    },
    X = (k) => {
      const D = { ...(s.mount ? i : o) }
      return bt(k) ? D : Vr(k) ? ne(D, k) : k.map((F) => ne(D, F))
    },
    ae = (k, D) => ({
      invalid: !!ne((D || n).errors, k),
      isDirty: !!ne((D || n).dirtyFields, k),
      error: ne((D || n).errors, k),
      isValidating: !!ne(n.validatingFields, k),
      isTouched: !!ne((D || n).touchedFields, k),
    }),
    ve = (k) => {
      k && lc(k).forEach((D) => Nt(n.errors, D)),
        f.state.next({ errors: k ? n.errors : {} })
    },
    he = (k, D, F) => {
      const te = (ne(r, k, { _f: {} })._f || {}).ref,
        $ = ne(n.errors, k) || {},
        { ref: T, message: L, type: K, ...ie } = $
      Ue(n.errors, k, { ...ie, ...D, ref: te }),
        f.state.next({ name: k, errors: n.errors, isValid: !1 }),
        F && F.shouldFocus && te && te.focus && te.focus()
    },
    xe = (k, D) =>
      yr(k)
        ? f.state.subscribe({ next: (F) => k(W(void 0, D), F) })
        : W(k, D, !0),
    Ae = (k) =>
      f.state.subscribe({
        next: (D) => {
          N$(k.name, D.name, k.exact) &&
            k$(D, k.formState || u, me, k.reRenderRoot) &&
            k.callback({ values: { ...i }, ...n, ...D })
        },
      }).unsubscribe,
    je = (k) => (
      (s.mount = !0), (d = { ...d, ...k.formState }), Ae({ ...k, formState: d })
    ),
    Fe = (k, D = {}) => {
      for (const F of k ? lc(k) : a.mount)
        a.mount.delete(F),
          a.array.delete(F),
          D.keepValue || (Nt(r, F), Nt(i, F)),
          !D.keepError && Nt(n.errors, F),
          !D.keepDirty && Nt(n.dirtyFields, F),
          !D.keepTouched && Nt(n.touchedFields, F),
          !D.keepIsValidating && Nt(n.validatingFields, F),
          !t.shouldUnregister && !D.keepDefaultValue && Nt(o, F)
      f.state.next({ values: zt(i) }),
        f.state.next({ ...n, ...(D.keepDirty ? { isDirty: U() } : {}) }),
        !D.keepIsValid && y()
    },
    Ze = ({ disabled: k, name: D }) => {
      ;((Dn(k) && s.mount) || k || a.disabled.has(D)) &&
        (k ? a.disabled.add(D) : a.disabled.delete(D))
    },
    dt = (k, D = {}) => {
      let F = ne(r, k)
      const te = Dn(D.disabled) || Dn(t.disabled)
      return (
        Ue(r, k, {
          ...(F || {}),
          _f: {
            ...(F && F._f ? F._f : { ref: { name: k } }),
            name: k,
            mount: !0,
            ...D,
          },
        }),
        a.mount.add(k),
        F
          ? Ze({ disabled: Dn(D.disabled) ? D.disabled : t.disabled, name: k })
          : S(k, !0, D.value),
        {
          ...(te ? { disabled: D.disabled || t.disabled } : {}),
          ...(t.progressive
            ? {
                required: !!D.required,
                min: Dl(D.min),
                max: Dl(D.max),
                minLength: Dl(D.minLength),
                maxLength: Dl(D.maxLength),
                pattern: Dl(D.pattern),
              }
            : {}),
          name: k,
          onChange: A,
          onBlur: A,
          ref: ($) => {
            if ($) {
              dt(k, D), (F = ne(r, k))
              const T =
                  (bt($.value) &&
                    $.querySelectorAll &&
                    $.querySelectorAll("input,select,textarea")[0]) ||
                  $,
                L = x$(T),
                K = F._f.refs || []
              if (L ? K.find((ie) => ie === T) : T === F._f.ref) return
              Ue(r, k, {
                _f: {
                  ...F._f,
                  ...(L
                    ? {
                        refs: [
                          ...K.filter(ug),
                          T,
                          ...(Array.isArray(ne(o, k)) ? [{}] : []),
                        ],
                        ref: { type: T.type, name: k },
                      }
                    : { ref: T }),
                },
              }),
                S(k, !1, void 0, T)
            } else
              (F = ne(r, k, {})),
                F._f && (F._f.mount = !1),
                (t.shouldUnregister || D.shouldUnregister) &&
                  !(M2(a.array, k) && s.action) &&
                  a.unMount.add(k)
          },
        }
      )
    },
    kt = () => t.shouldFocusError && cc(r, P, a.mount),
    ft = (k) => {
      Dn(k) &&
        (f.state.next({ disabled: k }),
        cc(
          r,
          (D, F) => {
            const te = ne(r, F)
            te &&
              ((D.disabled = te._f.disabled || k),
              Array.isArray(te._f.refs) &&
                te._f.refs.forEach(($) => {
                  $.disabled = te._f.disabled || k
                }))
          },
          0,
          !1
        ))
    },
    Et = (k, D) => async (F) => {
      let te
      F && (F.preventDefault && F.preventDefault(), F.persist && F.persist())
      let $ = zt(i)
      if ((f.state.next({ isSubmitting: !0 }), t.resolver)) {
        const { errors: T, values: L } = await R()
        ;(n.errors = T), ($ = L)
      } else await V(r)
      if (a.disabled.size) for (const T of a.disabled) Ue($, T, void 0)
      if ((Nt(n.errors, "root"), cn(n.errors))) {
        f.state.next({ errors: {} })
        try {
          await k($, F)
        } catch (T) {
          te = T
        }
      } else D && (await D({ ...n.errors }, F)), kt(), setTimeout(kt)
      if (
        (f.state.next({
          isSubmitted: !0,
          isSubmitting: !1,
          isSubmitSuccessful: cn(n.errors) && !te,
          submitCount: n.submitCount + 1,
          errors: n.errors,
        }),
        te)
      )
        throw te
    },
    He = (k, D = {}) => {
      ne(r, k) &&
        (bt(D.defaultValue)
          ? _(k, zt(ne(o, k)))
          : (_(k, D.defaultValue), Ue(o, k, zt(D.defaultValue))),
        D.keepTouched || Nt(n.touchedFields, k),
        D.keepDirty ||
          (Nt(n.dirtyFields, k),
          (n.isDirty = D.defaultValue ? U(k, zt(ne(o, k))) : U())),
        D.keepError || (Nt(n.errors, k), u.isValid && y()),
        f.state.next({ ...n }))
    },
    be = (k, D = {}) => {
      const F = k ? zt(k) : o,
        te = zt(F),
        $ = cn(k),
        T = $ ? o : te
      if ((D.keepDefaultValues || (o = F), !D.keepValues)) {
        if (D.keepDirtyValues) {
          const L = new Set([...a.mount, ...Object.keys(Il(o, i))])
          for (const K of Array.from(L))
            ne(n.dirtyFields, K) ? Ue(T, K, ne(i, K)) : _(K, ne(T, K))
        } else {
          if (Bb && bt(k))
            for (const L of a.mount) {
              const K = ne(r, L)
              if (K && K._f) {
                const ie = Array.isArray(K._f.refs) ? K._f.refs[0] : K._f.ref
                if (Hf(ie)) {
                  const Se = ie.closest("form")
                  if (Se) {
                    Se.reset()
                    break
                  }
                }
              }
            }
          for (const L of a.mount) _(L, ne(T, L))
        }
        ;(i = zt(T)),
          f.array.next({ values: { ...T } }),
          f.state.next({ values: { ...T } })
      }
      ;(a = {
        mount: D.keepDirtyValues ? a.mount : new Set(),
        unMount: new Set(),
        array: new Set(),
        disabled: new Set(),
        watch: new Set(),
        watchAll: !1,
        focus: "",
      }),
        (s.mount = !u.isValid || !!D.keepIsValid || !!D.keepDirtyValues),
        (s.watch = !!t.shouldUnregister),
        f.state.next({
          submitCount: D.keepSubmitCount ? n.submitCount : 0,
          isDirty: $
            ? !1
            : D.keepDirty
              ? n.isDirty
              : !!(D.keepDefaultValues && !qo(k, o)),
          isSubmitted: D.keepIsSubmitted ? n.isSubmitted : !1,
          dirtyFields: $
            ? {}
            : D.keepDirtyValues
              ? D.keepDefaultValues && i
                ? Il(o, i)
                : n.dirtyFields
              : D.keepDefaultValues && k
                ? Il(o, k)
                : D.keepDirty
                  ? n.dirtyFields
                  : {},
          touchedFields: D.keepTouched ? n.touchedFields : {},
          errors: D.keepErrors ? n.errors : {},
          isSubmitSuccessful: D.keepIsSubmitSuccessful
            ? n.isSubmitSuccessful
            : !1,
          isSubmitting: !1,
        })
    },
    yt = (k, D) => be(yr(k) ? k(i) : k, D),
    ue = (k, D = {}) => {
      const F = ne(r, k),
        te = F && F._f
      if (te) {
        const $ = te.refs ? te.refs[0] : te.ref
        $.focus && ($.focus(), D.shouldSelect && yr($.select) && $.select())
      }
    },
    me = (k) => {
      n = { ...n, ...k }
    },
    fe = {
      control: {
        register: dt,
        unregister: Fe,
        getFieldState: ae,
        handleSubmit: Et,
        setError: he,
        _subscribe: Ae,
        _runSchema: R,
        _getWatch: W,
        _getDirty: U,
        _setValid: y,
        _setFieldArray: E,
        _setDisabledField: Ze,
        _setErrors: C,
        _getFieldArray: ee,
        _reset: be,
        _resetDefaultValues: () =>
          yr(t.defaultValues) &&
          t.defaultValues().then((k) => {
            yt(k, t.resetOptions), f.state.next({ isLoading: !1 })
          }),
        _removeUnmounted: j,
        _disableForm: ft,
        _subjects: f,
        _proxyFormState: u,
        get _fields() {
          return r
        },
        get _formValues() {
          return i
        },
        get _state() {
          return s
        },
        set _state(k) {
          s = k
        },
        get _defaultValues() {
          return o
        },
        get _names() {
          return a
        },
        set _names(k) {
          a = k
        },
        get _formState() {
          return n
        },
        get _options() {
          return t
        },
        set _options(k) {
          t = { ...t, ...k }
        },
      },
      subscribe: je,
      trigger: H,
      register: dt,
      handleSubmit: Et,
      watch: xe,
      setValue: _,
      getValues: X,
      reset: yt,
      resetField: He,
      clearErrors: ve,
      unregister: Fe,
      setError: he,
      setFocus: ue,
      getFieldState: ae,
    }
  return { ...fe, formControl: fe }
}
function I$(e = {}) {
  const t = G.useRef(void 0),
    n = G.useRef(void 0),
    [r, o] = G.useState({
      isDirty: !1,
      isValidating: !1,
      isLoading: yr(e.defaultValues),
      isSubmitted: !1,
      isSubmitting: !1,
      isSubmitSuccessful: !1,
      isValid: !1,
      submitCount: 0,
      dirtyFields: {},
      touchedFields: {},
      validatingFields: {},
      errors: e.errors || {},
      disabled: e.disabled || !1,
      defaultValues: yr(e.defaultValues) ? void 0 : e.defaultValues,
    })
  t.current ||
    ((t.current = { ...(e.formControl ? e.formControl : R$(e)), formState: r }),
    e.formControl &&
      e.defaultValues &&
      !yr(e.defaultValues) &&
      e.formControl.reset(e.defaultValues, e.resetOptions))
  const i = t.current.control
  return (
    (i._options = e),
    G.useLayoutEffect(
      () =>
        i._subscribe({
          formState: i._proxyFormState,
          callback: () => o({ ...i._formState }),
          reRenderRoot: !0,
        }),
      [i]
    ),
    G.useEffect(() => i._disableForm(e.disabled), [i, e.disabled]),
    G.useEffect(() => {
      if (i._proxyFormState.isDirty) {
        const s = i._getDirty()
        s !== r.isDirty && i._subjects.state.next({ isDirty: s })
      }
    }, [i, r.isDirty]),
    G.useEffect(() => {
      e.values && !qo(e.values, n.current)
        ? (i._reset(e.values, i._options.resetOptions),
          (n.current = e.values),
          o((s) => ({ ...s })))
        : i._resetDefaultValues()
    }, [e.values, i]),
    G.useEffect(() => {
      e.errors && !cn(e.errors) && i._setErrors(e.errors)
    }, [e.errors, i]),
    G.useEffect(() => {
      i._state.mount || (i._setValid(), (i._state.mount = !0)),
        i._state.watch &&
          ((i._state.watch = !1), i._subjects.state.next({ ...i._formState })),
        i._removeUnmounted()
    }),
    G.useEffect(() => {
      e.shouldUnregister && i._subjects.state.next({ values: i._getWatch() })
    }, [e.shouldUnregister, i]),
    (t.current.formState = R2(r, i)),
    t.current
  )
}
const dE = (e, t, n) => {
    if (e && "reportValidity" in e) {
      const r = ne(n, t)
      e.setCustomValidity((r && r.message) || ""), e.reportValidity()
    }
  },
  z2 = (e, t) => {
    for (const n in t.fields) {
      const r = t.fields[n]
      r && r.ref && "reportValidity" in r.ref
        ? dE(r.ref, n, e)
        : r && r.refs && r.refs.forEach((o) => dE(o, n, e))
    }
  },
  D$ = (e, t) => {
    t.shouldUseNativeValidation && z2(e, t)
    const n = {}
    for (const r in e) {
      const o = ne(t.fields, r),
        i = Object.assign(e[r] || {}, { ref: o && o.ref })
      if (L$(t.names || Object.keys(e), r)) {
        const s = Object.assign({}, ne(n, r))
        Ue(s, "root", i), Ue(n, r, s)
      } else Ue(n, r, i)
    }
    return n
  },
  L$ = (e, t) => {
    const n = fE(t)
    return e.some((r) => fE(r).match(`^${n}\\.\\d+`))
  }
function fE(e) {
  return e.replace(/\]|\[/g, "")
}
function P$(e, t) {
  for (var n = {}; e.length; ) {
    var r = e[0],
      o = r.code,
      i = r.message,
      s = r.path.join(".")
    if (!n[s])
      if ("unionErrors" in r) {
        var a = r.unionErrors[0].errors[0]
        n[s] = { message: a.message, type: a.code }
      } else n[s] = { message: i, type: o }
    if (
      ("unionErrors" in r &&
        r.unionErrors.forEach(function (u) {
          return u.errors.forEach(function (d) {
            return e.push(d)
          })
        }),
      t)
    ) {
      var l = n[s].types,
        c = l && l[r.code]
      n[s] = D2(s, t, n, o, c ? [].concat(c, r.message) : r.message)
    }
    e.shift()
  }
  return n
}
function $$(e, t, n) {
  return (
    n === void 0 && (n = {}),
    function (r, o, i) {
      try {
        return Promise.resolve(
          (function (s, a) {
            try {
              var l = Promise.resolve(
                e[n.mode === "sync" ? "parse" : "parseAsync"](r, t)
              ).then(function (c) {
                return (
                  i.shouldUseNativeValidation && z2({}, i),
                  { errors: {}, values: n.raw ? Object.assign({}, r) : c }
                )
              })
            } catch (c) {
              return a(c)
            }
            return l && l.then ? l.then(void 0, a) : l
          })(0, function (s) {
            if (
              (function (a) {
                return Array.isArray(a == null ? void 0 : a.errors)
              })(s)
            )
              return {
                values: {},
                errors: D$(
                  P$(
                    s.errors,
                    !i.shouldUseNativeValidation && i.criteriaMode === "all"
                  ),
                  i
                ),
              }
            throw s
          })
        )
      } catch (s) {
        return Promise.reject(s)
      }
    }
  )
}
var Pe
;(function (e) {
  e.assertEqual = (o) => o
  function t(o) {}
  e.assertIs = t
  function n(o) {
    throw new Error()
  }
  ;(e.assertNever = n),
    (e.arrayToEnum = (o) => {
      const i = {}
      for (const s of o) i[s] = s
      return i
    }),
    (e.getValidEnumValues = (o) => {
      const i = e.objectKeys(o).filter((a) => typeof o[o[a]] != "number"),
        s = {}
      for (const a of i) s[a] = o[a]
      return e.objectValues(s)
    }),
    (e.objectValues = (o) =>
      e.objectKeys(o).map(function (i) {
        return o[i]
      })),
    (e.objectKeys =
      typeof Object.keys == "function"
        ? (o) => Object.keys(o)
        : (o) => {
            const i = []
            for (const s in o)
              Object.prototype.hasOwnProperty.call(o, s) && i.push(s)
            return i
          }),
    (e.find = (o, i) => {
      for (const s of o) if (i(s)) return s
    }),
    (e.isInteger =
      typeof Number.isInteger == "function"
        ? (o) => Number.isInteger(o)
        : (o) => typeof o == "number" && isFinite(o) && Math.floor(o) === o)
  function r(o, i = " | ") {
    return o.map((s) => (typeof s == "string" ? `'${s}'` : s)).join(i)
  }
  ;(e.joinValues = r),
    (e.jsonStringifyReplacer = (o, i) =>
      typeof i == "bigint" ? i.toString() : i)
})(Pe || (Pe = {}))
var cy
;(function (e) {
  e.mergeShapes = (t, n) => ({ ...t, ...n })
})(cy || (cy = {}))
const se = Pe.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  go = (e) => {
    switch (typeof e) {
      case "undefined":
        return se.undefined
      case "string":
        return se.string
      case "number":
        return isNaN(e) ? se.nan : se.number
      case "boolean":
        return se.boolean
      case "function":
        return se.function
      case "bigint":
        return se.bigint
      case "symbol":
        return se.symbol
      case "object":
        return Array.isArray(e)
          ? se.array
          : e === null
            ? se.null
            : e.then &&
                typeof e.then == "function" &&
                e.catch &&
                typeof e.catch == "function"
              ? se.promise
              : typeof Map < "u" && e instanceof Map
                ? se.map
                : typeof Set < "u" && e instanceof Set
                  ? se.set
                  : typeof Date < "u" && e instanceof Date
                    ? se.date
                    : se.object
      default:
        return se.unknown
    }
  },
  Y = Pe.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  B$ = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:")
class Fn extends Error {
  get errors() {
    return this.issues
  }
  constructor(t) {
    super(),
      (this.issues = []),
      (this.addIssue = (r) => {
        this.issues = [...this.issues, r]
      }),
      (this.addIssues = (r = []) => {
        this.issues = [...this.issues, ...r]
      })
    const n = new.target.prototype
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, n)
      : (this.__proto__ = n),
      (this.name = "ZodError"),
      (this.issues = t)
  }
  format(t) {
    const n =
        t ||
        function (i) {
          return i.message
        },
      r = { _errors: [] },
      o = (i) => {
        for (const s of i.issues)
          if (s.code === "invalid_union") s.unionErrors.map(o)
          else if (s.code === "invalid_return_type") o(s.returnTypeError)
          else if (s.code === "invalid_arguments") o(s.argumentsError)
          else if (s.path.length === 0) r._errors.push(n(s))
          else {
            let a = r,
              l = 0
            for (; l < s.path.length; ) {
              const c = s.path[l]
              l === s.path.length - 1
                ? ((a[c] = a[c] || { _errors: [] }), a[c]._errors.push(n(s)))
                : (a[c] = a[c] || { _errors: [] }),
                (a = a[c]),
                l++
            }
          }
      }
    return o(this), r
  }
  static assert(t) {
    if (!(t instanceof Fn)) throw new Error(`Not a ZodError: ${t}`)
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, Pe.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(t = (n) => n.message) {
    const n = {},
      r = []
    for (const o of this.issues)
      o.path.length > 0
        ? ((n[o.path[0]] = n[o.path[0]] || []), n[o.path[0]].push(t(o)))
        : r.push(t(o))
    return { formErrors: r, fieldErrors: n }
  }
  get formErrors() {
    return this.flatten()
  }
}
Fn.create = (e) => new Fn(e)
const Wa = (e, t) => {
  let n
  switch (e.code) {
    case Y.invalid_type:
      e.received === se.undefined
        ? (n = "Required")
        : (n = `Expected ${e.expected}, received ${e.received}`)
      break
    case Y.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, Pe.jsonStringifyReplacer)}`
      break
    case Y.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Pe.joinValues(e.keys, ", ")}`
      break
    case Y.invalid_union:
      n = "Invalid input"
      break
    case Y.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Pe.joinValues(e.options)}`
      break
    case Y.invalid_enum_value:
      n = `Invalid enum value. Expected ${Pe.joinValues(e.options)}, received '${e.received}'`
      break
    case Y.invalid_arguments:
      n = "Invalid function arguments"
      break
    case Y.invalid_return_type:
      n = "Invalid function return type"
      break
    case Y.invalid_date:
      n = "Invalid date"
      break
    case Y.invalid_string:
      typeof e.validation == "object"
        ? "includes" in e.validation
          ? ((n = `Invalid input: must include "${e.validation.includes}"`),
            typeof e.validation.position == "number" &&
              (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`))
          : "startsWith" in e.validation
            ? (n = `Invalid input: must start with "${e.validation.startsWith}"`)
            : "endsWith" in e.validation
              ? (n = `Invalid input: must end with "${e.validation.endsWith}"`)
              : Pe.assertNever(e.validation)
        : e.validation !== "regex"
          ? (n = `Invalid ${e.validation}`)
          : (n = "Invalid")
      break
    case Y.too_small:
      e.type === "array"
        ? (n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)`)
        : e.type === "string"
          ? (n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)`)
          : e.type === "number"
            ? (n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}`)
            : e.type === "date"
              ? (n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}`)
              : (n = "Invalid input")
      break
    case Y.too_big:
      e.type === "array"
        ? (n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)`)
        : e.type === "string"
          ? (n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)`)
          : e.type === "number"
            ? (n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`)
            : e.type === "bigint"
              ? (n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`)
              : e.type === "date"
                ? (n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}`)
                : (n = "Invalid input")
      break
    case Y.custom:
      n = "Invalid input"
      break
    case Y.invalid_intersection_types:
      n = "Intersection results could not be merged"
      break
    case Y.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`
      break
    case Y.not_finite:
      n = "Number must be finite"
      break
    default:
      ;(n = t.defaultError), Pe.assertNever(e)
  }
  return { message: n }
}
let U2 = Wa
function j$(e) {
  U2 = e
}
function Gf() {
  return U2
}
const qf = (e) => {
    const { data: t, path: n, errorMaps: r, issueData: o } = e,
      i = [...n, ...(o.path || [])],
      s = { ...o, path: i }
    if (o.message !== void 0) return { ...o, path: i, message: o.message }
    let a = ""
    const l = r
      .filter((c) => !!c)
      .slice()
      .reverse()
    for (const c of l) a = c(s, { data: t, defaultError: a }).message
    return { ...o, path: i, message: a }
  },
  F$ = []
function re(e, t) {
  const n = Gf(),
    r = qf({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [
        e.common.contextualErrorMap,
        e.schemaErrorMap,
        n,
        n === Wa ? void 0 : Wa,
      ].filter((o) => !!o),
    })
  e.common.issues.push(r)
}
class rn {
  constructor() {
    this.value = "valid"
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty")
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted")
  }
  static mergeArray(t, n) {
    const r = []
    for (const o of n) {
      if (o.status === "aborted") return Ce
      o.status === "dirty" && t.dirty(), r.push(o.value)
    }
    return { status: t.value, value: r }
  }
  static async mergeObjectAsync(t, n) {
    const r = []
    for (const o of n) {
      const i = await o.key,
        s = await o.value
      r.push({ key: i, value: s })
    }
    return rn.mergeObjectSync(t, r)
  }
  static mergeObjectSync(t, n) {
    const r = {}
    for (const o of n) {
      const { key: i, value: s } = o
      if (i.status === "aborted" || s.status === "aborted") return Ce
      i.status === "dirty" && t.dirty(),
        s.status === "dirty" && t.dirty(),
        i.value !== "__proto__" &&
          (typeof s.value < "u" || o.alwaysSet) &&
          (r[i.value] = s.value)
    }
    return { status: t.value, value: r }
  }
}
const Ce = Object.freeze({ status: "aborted" }),
  ba = (e) => ({ status: "dirty", value: e }),
  mn = (e) => ({ status: "valid", value: e }),
  uy = (e) => e.status === "aborted",
  dy = (e) => e.status === "dirty",
  ws = (e) => e.status === "valid",
  Uc = (e) => typeof Promise < "u" && e instanceof Promise
function Zf(e, t, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter")
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    )
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e)
}
function V2(e, t, n, r, o) {
  if (r === "m") throw new TypeError("Private method is not writable")
  if (r === "a" && !o)
    throw new TypeError("Private accessor was defined without a setter")
  if (typeof t == "function" ? e !== t || !o : !t.has(e))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    )
  return r === "a" ? o.call(e, n) : o ? (o.value = n) : t.set(e, n), n
}
var pe
;(function (e) {
  ;(e.errToObj = (t) => (typeof t == "string" ? { message: t } : t || {})),
    (e.toString = (t) =>
      typeof t == "string" ? t : t == null ? void 0 : t.message)
})(pe || (pe = {}))
var Hl, Wl
class Xr {
  constructor(t, n, r, o) {
    ;(this._cachedPath = []),
      (this.parent = t),
      (this.data = n),
      (this._path = r),
      (this._key = o)
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    )
  }
}
const pE = (e, t) => {
  if (ws(t)) return { success: !0, data: t.value }
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.")
  return {
    success: !1,
    get error() {
      if (this._error) return this._error
      const n = new Fn(e.common.issues)
      return (this._error = n), this._error
    },
  }
}
function ke(e) {
  if (!e) return {}
  const {
    errorMap: t,
    invalid_type_error: n,
    required_error: r,
    description: o,
  } = e
  if (t && (n || r))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    )
  return t
    ? { errorMap: t, description: o }
    : {
        errorMap: (s, a) => {
          var l, c
          const { message: u } = e
          return s.code === "invalid_enum_value"
            ? { message: u != null ? u : a.defaultError }
            : typeof a.data > "u"
              ? {
                  message:
                    (l = u != null ? u : r) !== null && l !== void 0
                      ? l
                      : a.defaultError,
                }
              : s.code !== "invalid_type"
                ? { message: a.defaultError }
                : {
                    message:
                      (c = u != null ? u : n) !== null && c !== void 0
                        ? c
                        : a.defaultError,
                  }
        },
        description: o,
      }
}
class Me {
  get description() {
    return this._def.description
  }
  _getType(t) {
    return go(t.data)
  }
  _getOrReturnCtx(t, n) {
    return (
      n || {
        common: t.parent.common,
        data: t.data,
        parsedType: go(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent,
      }
    )
  }
  _processInputParams(t) {
    return {
      status: new rn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: go(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent,
      },
    }
  }
  _parseSync(t) {
    const n = this._parse(t)
    if (Uc(n)) throw new Error("Synchronous parse encountered promise.")
    return n
  }
  _parseAsync(t) {
    const n = this._parse(t)
    return Promise.resolve(n)
  }
  parse(t, n) {
    const r = this.safeParse(t, n)
    if (r.success) return r.data
    throw r.error
  }
  safeParse(t, n) {
    var r
    const o = {
        common: {
          issues: [],
          async:
            (r = n == null ? void 0 : n.async) !== null && r !== void 0
              ? r
              : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: go(t),
      },
      i = this._parseSync({ data: t, path: o.path, parent: o })
    return pE(o, i)
  }
  "~validate"(t) {
    var n, r
    const o = {
      common: { issues: [], async: !!this["~standard"].async },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: go(t),
    }
    if (!this["~standard"].async)
      try {
        const i = this._parseSync({ data: t, path: [], parent: o })
        return ws(i) ? { value: i.value } : { issues: o.common.issues }
      } catch (i) {
        !(
          (r =
            (n = i == null ? void 0 : i.message) === null || n === void 0
              ? void 0
              : n.toLowerCase()) === null || r === void 0
        ) &&
          r.includes("encountered") &&
          (this["~standard"].async = !0),
          (o.common = { issues: [], async: !0 })
      }
    return this._parseAsync({ data: t, path: [], parent: o }).then((i) =>
      ws(i) ? { value: i.value } : { issues: o.common.issues }
    )
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n)
    if (r.success) return r.data
    throw r.error
  }
  async safeParseAsync(t, n) {
    const r = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: go(t),
      },
      o = this._parse({ data: t, path: r.path, parent: r }),
      i = await (Uc(o) ? o : Promise.resolve(o))
    return pE(r, i)
  }
  refine(t, n) {
    const r = (o) =>
      typeof n == "string" || typeof n > "u"
        ? { message: n }
        : typeof n == "function"
          ? n(o)
          : n
    return this._refinement((o, i) => {
      const s = t(o),
        a = () => i.addIssue({ code: Y.custom, ...r(o) })
      return typeof Promise < "u" && s instanceof Promise
        ? s.then((l) => (l ? !0 : (a(), !1)))
        : s
          ? !0
          : (a(), !1)
    })
  }
  refinement(t, n) {
    return this._refinement((r, o) =>
      t(r) ? !0 : (o.addIssue(typeof n == "function" ? n(r, o) : n), !1)
    )
  }
  _refinement(t) {
    return new Or({
      schema: this,
      typeName: Ee.ZodEffects,
      effect: { type: "refinement", refinement: t },
    })
  }
  superRefine(t) {
    return this._refinement(t)
  }
  constructor(t) {
    ;(this.spa = this.safeParseAsync),
      (this._def = t),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this)),
      (this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (n) => this["~validate"](n),
      })
  }
  optional() {
    return qr.create(this, this._def)
  }
  nullable() {
    return Ti.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return _r.create(this)
  }
  promise() {
    return Ga.create(this, this._def)
  }
  or(t) {
    return Kc.create([this, t], this._def)
  }
  and(t) {
    return Gc.create(this, t, this._def)
  }
  transform(t) {
    return new Or({
      ...ke(this._def),
      schema: this,
      typeName: Ee.ZodEffects,
      effect: { type: "transform", transform: t },
    })
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t
    return new Qc({
      ...ke(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Ee.ZodDefault,
    })
  }
  brand() {
    return new Ub({ typeName: Ee.ZodBranded, type: this, ...ke(this._def) })
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t
    return new Jc({
      ...ke(this._def),
      innerType: this,
      catchValue: n,
      typeName: Ee.ZodCatch,
    })
  }
  describe(t) {
    const n = this.constructor
    return new n({ ...this._def, description: t })
  }
  pipe(t) {
    return Ou.create(this, t)
  }
  readonly() {
    return eu.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const z$ = /^c[^\s-]{8,}$/i,
  U$ = /^[0-9a-z]+$/,
  V$ = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  H$ =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  W$ = /^[a-z0-9_-]{21}$/i,
  K$ = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  G$ =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  q$ =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Z$ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$"
let dg
const Y$ =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  X$ =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  Q$ =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  J$ =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  e8 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  t8 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  H2 =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  n8 = new RegExp(`^${H2}$`)
function W2(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"
  return (
    e.precision
      ? (t = `${t}\\.\\d{${e.precision}}`)
      : e.precision == null && (t = `${t}(\\.\\d+)?`),
    t
  )
}
function r8(e) {
  return new RegExp(`^${W2(e)}$`)
}
function K2(e) {
  let t = `${H2}T${W2(e)}`
  const n = []
  return (
    n.push(e.local ? "Z?" : "Z"),
    e.offset && n.push("([+-]\\d{2}:?\\d{2})"),
    (t = `${t}(${n.join("|")})`),
    new RegExp(`^${t}$`)
  )
}
function o8(e, t) {
  return !!(
    ((t === "v4" || !t) && Y$.test(e)) ||
    ((t === "v6" || !t) && Q$.test(e))
  )
}
function i8(e, t) {
  if (!K$.test(e)) return !1
  try {
    const [n] = e.split("."),
      r = n
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(n.length + ((4 - (n.length % 4)) % 4), "="),
      o = JSON.parse(atob(r))
    return !(
      typeof o != "object" ||
      o === null ||
      !o.typ ||
      !o.alg ||
      (t && o.alg !== t)
    )
  } catch {
    return !1
  }
}
function s8(e, t) {
  return !!(
    ((t === "v4" || !t) && X$.test(e)) ||
    ((t === "v6" || !t) && J$.test(e))
  )
}
class xr extends Me {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = String(t.data)),
      this._getType(t) !== se.string)
    ) {
      const i = this._getOrReturnCtx(t)
      return (
        re(i, {
          code: Y.invalid_type,
          expected: se.string,
          received: i.parsedType,
        }),
        Ce
      )
    }
    const r = new rn()
    let o
    for (const i of this._def.checks)
      if (i.kind === "min")
        t.data.length < i.value &&
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            code: Y.too_small,
            minimum: i.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "max")
        t.data.length > i.value &&
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            code: Y.too_big,
            maximum: i.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "length") {
        const s = t.data.length > i.value,
          a = t.data.length < i.value
        ;(s || a) &&
          ((o = this._getOrReturnCtx(t, o)),
          s
            ? re(o, {
                code: Y.too_big,
                maximum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message,
              })
            : a &&
              re(o, {
                code: Y.too_small,
                minimum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message,
              }),
          r.dirty())
      } else if (i.kind === "email")
        q$.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            validation: "email",
            code: Y.invalid_string,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "emoji")
        dg || (dg = new RegExp(Z$, "u")),
          dg.test(t.data) ||
            ((o = this._getOrReturnCtx(t, o)),
            re(o, {
              validation: "emoji",
              code: Y.invalid_string,
              message: i.message,
            }),
            r.dirty())
      else if (i.kind === "uuid")
        H$.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            validation: "uuid",
            code: Y.invalid_string,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "nanoid")
        W$.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            validation: "nanoid",
            code: Y.invalid_string,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "cuid")
        z$.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            validation: "cuid",
            code: Y.invalid_string,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "cuid2")
        U$.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            validation: "cuid2",
            code: Y.invalid_string,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "ulid")
        V$.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            validation: "ulid",
            code: Y.invalid_string,
            message: i.message,
          }),
          r.dirty())
      else if (i.kind === "url")
        try {
          new URL(t.data)
        } catch {
          ;(o = this._getOrReturnCtx(t, o)),
            re(o, {
              validation: "url",
              code: Y.invalid_string,
              message: i.message,
            }),
            r.dirty()
        }
      else
        i.kind === "regex"
          ? ((i.regex.lastIndex = 0),
            i.regex.test(t.data) ||
              ((o = this._getOrReturnCtx(t, o)),
              re(o, {
                validation: "regex",
                code: Y.invalid_string,
                message: i.message,
              }),
              r.dirty()))
          : i.kind === "trim"
            ? (t.data = t.data.trim())
            : i.kind === "includes"
              ? t.data.includes(i.value, i.position) ||
                ((o = this._getOrReturnCtx(t, o)),
                re(o, {
                  code: Y.invalid_string,
                  validation: { includes: i.value, position: i.position },
                  message: i.message,
                }),
                r.dirty())
              : i.kind === "toLowerCase"
                ? (t.data = t.data.toLowerCase())
                : i.kind === "toUpperCase"
                  ? (t.data = t.data.toUpperCase())
                  : i.kind === "startsWith"
                    ? t.data.startsWith(i.value) ||
                      ((o = this._getOrReturnCtx(t, o)),
                      re(o, {
                        code: Y.invalid_string,
                        validation: { startsWith: i.value },
                        message: i.message,
                      }),
                      r.dirty())
                    : i.kind === "endsWith"
                      ? t.data.endsWith(i.value) ||
                        ((o = this._getOrReturnCtx(t, o)),
                        re(o, {
                          code: Y.invalid_string,
                          validation: { endsWith: i.value },
                          message: i.message,
                        }),
                        r.dirty())
                      : i.kind === "datetime"
                        ? K2(i).test(t.data) ||
                          ((o = this._getOrReturnCtx(t, o)),
                          re(o, {
                            code: Y.invalid_string,
                            validation: "datetime",
                            message: i.message,
                          }),
                          r.dirty())
                        : i.kind === "date"
                          ? n8.test(t.data) ||
                            ((o = this._getOrReturnCtx(t, o)),
                            re(o, {
                              code: Y.invalid_string,
                              validation: "date",
                              message: i.message,
                            }),
                            r.dirty())
                          : i.kind === "time"
                            ? r8(i).test(t.data) ||
                              ((o = this._getOrReturnCtx(t, o)),
                              re(o, {
                                code: Y.invalid_string,
                                validation: "time",
                                message: i.message,
                              }),
                              r.dirty())
                            : i.kind === "duration"
                              ? G$.test(t.data) ||
                                ((o = this._getOrReturnCtx(t, o)),
                                re(o, {
                                  validation: "duration",
                                  code: Y.invalid_string,
                                  message: i.message,
                                }),
                                r.dirty())
                              : i.kind === "ip"
                                ? o8(t.data, i.version) ||
                                  ((o = this._getOrReturnCtx(t, o)),
                                  re(o, {
                                    validation: "ip",
                                    code: Y.invalid_string,
                                    message: i.message,
                                  }),
                                  r.dirty())
                                : i.kind === "jwt"
                                  ? i8(t.data, i.alg) ||
                                    ((o = this._getOrReturnCtx(t, o)),
                                    re(o, {
                                      validation: "jwt",
                                      code: Y.invalid_string,
                                      message: i.message,
                                    }),
                                    r.dirty())
                                  : i.kind === "cidr"
                                    ? s8(t.data, i.version) ||
                                      ((o = this._getOrReturnCtx(t, o)),
                                      re(o, {
                                        validation: "cidr",
                                        code: Y.invalid_string,
                                        message: i.message,
                                      }),
                                      r.dirty())
                                    : i.kind === "base64"
                                      ? e8.test(t.data) ||
                                        ((o = this._getOrReturnCtx(t, o)),
                                        re(o, {
                                          validation: "base64",
                                          code: Y.invalid_string,
                                          message: i.message,
                                        }),
                                        r.dirty())
                                      : i.kind === "base64url"
                                        ? t8.test(t.data) ||
                                          ((o = this._getOrReturnCtx(t, o)),
                                          re(o, {
                                            validation: "base64url",
                                            code: Y.invalid_string,
                                            message: i.message,
                                          }),
                                          r.dirty())
                                        : Pe.assertNever(i)
    return { status: r.value, value: t.data }
  }
  _regex(t, n, r) {
    return this.refinement((o) => t.test(o), {
      validation: n,
      code: Y.invalid_string,
      ...pe.errToObj(r),
    })
  }
  _addCheck(t) {
    return new xr({ ...this._def, checks: [...this._def.checks, t] })
  }
  email(t) {
    return this._addCheck({ kind: "email", ...pe.errToObj(t) })
  }
  url(t) {
    return this._addCheck({ kind: "url", ...pe.errToObj(t) })
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...pe.errToObj(t) })
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...pe.errToObj(t) })
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...pe.errToObj(t) })
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...pe.errToObj(t) })
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...pe.errToObj(t) })
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...pe.errToObj(t) })
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...pe.errToObj(t) })
  }
  base64url(t) {
    return this._addCheck({ kind: "base64url", ...pe.errToObj(t) })
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...pe.errToObj(t) })
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...pe.errToObj(t) })
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...pe.errToObj(t) })
  }
  datetime(t) {
    var n, r
    return typeof t == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          local: !1,
          message: t,
        })
      : this._addCheck({
          kind: "datetime",
          precision:
            typeof (t == null ? void 0 : t.precision) > "u"
              ? null
              : t == null
                ? void 0
                : t.precision,
          offset:
            (n = t == null ? void 0 : t.offset) !== null && n !== void 0
              ? n
              : !1,
          local:
            (r = t == null ? void 0 : t.local) !== null && r !== void 0
              ? r
              : !1,
          ...pe.errToObj(t == null ? void 0 : t.message),
        })
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t })
  }
  time(t) {
    return typeof t == "string"
      ? this._addCheck({ kind: "time", precision: null, message: t })
      : this._addCheck({
          kind: "time",
          precision:
            typeof (t == null ? void 0 : t.precision) > "u"
              ? null
              : t == null
                ? void 0
                : t.precision,
          ...pe.errToObj(t == null ? void 0 : t.message),
        })
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...pe.errToObj(t) })
  }
  regex(t, n) {
    return this._addCheck({ kind: "regex", regex: t, ...pe.errToObj(n) })
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...pe.errToObj(n == null ? void 0 : n.message),
    })
  }
  startsWith(t, n) {
    return this._addCheck({ kind: "startsWith", value: t, ...pe.errToObj(n) })
  }
  endsWith(t, n) {
    return this._addCheck({ kind: "endsWith", value: t, ...pe.errToObj(n) })
  }
  min(t, n) {
    return this._addCheck({ kind: "min", value: t, ...pe.errToObj(n) })
  }
  max(t, n) {
    return this._addCheck({ kind: "max", value: t, ...pe.errToObj(n) })
  }
  length(t, n) {
    return this._addCheck({ kind: "length", value: t, ...pe.errToObj(n) })
  }
  nonempty(t) {
    return this.min(1, pe.errToObj(t))
  }
  trim() {
    return new xr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    })
  }
  toLowerCase() {
    return new xr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    })
  }
  toUpperCase() {
    return new xr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    })
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime")
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date")
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time")
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration")
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email")
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url")
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji")
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid")
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid")
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid")
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2")
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid")
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip")
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr")
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64")
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url")
  }
  get minLength() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value)
    return t
  }
  get maxLength() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value)
    return t
  }
}
xr.create = (e) => {
  var t
  return new xr({
    checks: [],
    typeName: Ee.ZodString,
    coerce:
      (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ke(e),
  })
}
function a8(e, t) {
  const n = (e.toString().split(".")[1] || "").length,
    r = (t.toString().split(".")[1] || "").length,
    o = n > r ? n : r,
    i = parseInt(e.toFixed(o).replace(".", "")),
    s = parseInt(t.toFixed(o).replace(".", ""))
  return (i % s) / Math.pow(10, o)
}
class _i extends Me {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf)
  }
  _parse(t) {
    if (
      (this._def.coerce && (t.data = Number(t.data)),
      this._getType(t) !== se.number)
    ) {
      const i = this._getOrReturnCtx(t)
      return (
        re(i, {
          code: Y.invalid_type,
          expected: se.number,
          received: i.parsedType,
        }),
        Ce
      )
    }
    let r
    const o = new rn()
    for (const i of this._def.checks)
      i.kind === "int"
        ? Pe.isInteger(t.data) ||
          ((r = this._getOrReturnCtx(t, r)),
          re(r, {
            code: Y.invalid_type,
            expected: "integer",
            received: "float",
            message: i.message,
          }),
          o.dirty())
        : i.kind === "min"
          ? (i.inclusive ? t.data < i.value : t.data <= i.value) &&
            ((r = this._getOrReturnCtx(t, r)),
            re(r, {
              code: Y.too_small,
              minimum: i.value,
              type: "number",
              inclusive: i.inclusive,
              exact: !1,
              message: i.message,
            }),
            o.dirty())
          : i.kind === "max"
            ? (i.inclusive ? t.data > i.value : t.data >= i.value) &&
              ((r = this._getOrReturnCtx(t, r)),
              re(r, {
                code: Y.too_big,
                maximum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message,
              }),
              o.dirty())
            : i.kind === "multipleOf"
              ? a8(t.data, i.value) !== 0 &&
                ((r = this._getOrReturnCtx(t, r)),
                re(r, {
                  code: Y.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                o.dirty())
              : i.kind === "finite"
                ? Number.isFinite(t.data) ||
                  ((r = this._getOrReturnCtx(t, r)),
                  re(r, { code: Y.not_finite, message: i.message }),
                  o.dirty())
                : Pe.assertNever(i)
    return { status: o.value, value: t.data }
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, pe.toString(n))
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, pe.toString(n))
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, pe.toString(n))
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, pe.toString(n))
  }
  setLimit(t, n, r, o) {
    return new _i({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: t, value: n, inclusive: r, message: pe.toString(o) },
      ],
    })
  }
  _addCheck(t) {
    return new _i({ ...this._def, checks: [...this._def.checks, t] })
  }
  int(t) {
    return this._addCheck({ kind: "int", message: pe.toString(t) })
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: pe.toString(t),
    })
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: pe.toString(t),
    })
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: pe.toString(t),
    })
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: pe.toString(t),
    })
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: pe.toString(n),
    })
  }
  finite(t) {
    return this._addCheck({ kind: "finite", message: pe.toString(t) })
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: pe.toString(t),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: pe.toString(t),
    })
  }
  get minValue() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value)
    return t
  }
  get maxValue() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value)
    return t
  }
  get isInt() {
    return !!this._def.checks.find(
      (t) =>
        t.kind === "int" || (t.kind === "multipleOf" && Pe.isInteger(t.value))
    )
  }
  get isFinite() {
    let t = null,
      n = null
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0
      r.kind === "min"
        ? (n === null || r.value > n) && (n = r.value)
        : r.kind === "max" && (t === null || r.value < t) && (t = r.value)
    }
    return Number.isFinite(n) && Number.isFinite(t)
  }
}
_i.create = (e) =>
  new _i({
    checks: [],
    typeName: Ee.ZodNumber,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...ke(e),
  })
class ki extends Me {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte)
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data)
      } catch {
        return this._getInvalidInput(t)
      }
    if (this._getType(t) !== se.bigint) return this._getInvalidInput(t)
    let r
    const o = new rn()
    for (const i of this._def.checks)
      i.kind === "min"
        ? (i.inclusive ? t.data < i.value : t.data <= i.value) &&
          ((r = this._getOrReturnCtx(t, r)),
          re(r, {
            code: Y.too_small,
            type: "bigint",
            minimum: i.value,
            inclusive: i.inclusive,
            message: i.message,
          }),
          o.dirty())
        : i.kind === "max"
          ? (i.inclusive ? t.data > i.value : t.data >= i.value) &&
            ((r = this._getOrReturnCtx(t, r)),
            re(r, {
              code: Y.too_big,
              type: "bigint",
              maximum: i.value,
              inclusive: i.inclusive,
              message: i.message,
            }),
            o.dirty())
          : i.kind === "multipleOf"
            ? t.data % i.value !== BigInt(0) &&
              ((r = this._getOrReturnCtx(t, r)),
              re(r, {
                code: Y.not_multiple_of,
                multipleOf: i.value,
                message: i.message,
              }),
              o.dirty())
            : Pe.assertNever(i)
    return { status: o.value, value: t.data }
  }
  _getInvalidInput(t) {
    const n = this._getOrReturnCtx(t)
    return (
      re(n, {
        code: Y.invalid_type,
        expected: se.bigint,
        received: n.parsedType,
      }),
      Ce
    )
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, pe.toString(n))
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, pe.toString(n))
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, pe.toString(n))
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, pe.toString(n))
  }
  setLimit(t, n, r, o) {
    return new ki({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: t, value: n, inclusive: r, message: pe.toString(o) },
      ],
    })
  }
  _addCheck(t) {
    return new ki({ ...this._def, checks: [...this._def.checks, t] })
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: pe.toString(t),
    })
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: pe.toString(t),
    })
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: pe.toString(t),
    })
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: pe.toString(t),
    })
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: pe.toString(n),
    })
  }
  get minValue() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value)
    return t
  }
  get maxValue() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value)
    return t
  }
}
ki.create = (e) => {
  var t
  return new ki({
    checks: [],
    typeName: Ee.ZodBigInt,
    coerce:
      (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ke(e),
  })
}
class Vc extends Me {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = !!t.data), this._getType(t) !== se.boolean)
    ) {
      const r = this._getOrReturnCtx(t)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.boolean,
          received: r.parsedType,
        }),
        Ce
      )
    }
    return mn(t.data)
  }
}
Vc.create = (e) =>
  new Vc({
    typeName: Ee.ZodBoolean,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...ke(e),
  })
class Es extends Me {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = new Date(t.data)),
      this._getType(t) !== se.date)
    ) {
      const i = this._getOrReturnCtx(t)
      return (
        re(i, {
          code: Y.invalid_type,
          expected: se.date,
          received: i.parsedType,
        }),
        Ce
      )
    }
    if (isNaN(t.data.getTime())) {
      const i = this._getOrReturnCtx(t)
      return re(i, { code: Y.invalid_date }), Ce
    }
    const r = new rn()
    let o
    for (const i of this._def.checks)
      i.kind === "min"
        ? t.data.getTime() < i.value &&
          ((o = this._getOrReturnCtx(t, o)),
          re(o, {
            code: Y.too_small,
            message: i.message,
            inclusive: !0,
            exact: !1,
            minimum: i.value,
            type: "date",
          }),
          r.dirty())
        : i.kind === "max"
          ? t.data.getTime() > i.value &&
            ((o = this._getOrReturnCtx(t, o)),
            re(o, {
              code: Y.too_big,
              message: i.message,
              inclusive: !0,
              exact: !1,
              maximum: i.value,
              type: "date",
            }),
            r.dirty())
          : Pe.assertNever(i)
    return { status: r.value, value: new Date(t.data.getTime()) }
  }
  _addCheck(t) {
    return new Es({ ...this._def, checks: [...this._def.checks, t] })
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: pe.toString(n),
    })
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: pe.toString(n),
    })
  }
  get minDate() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value)
    return t != null ? new Date(t) : null
  }
  get maxDate() {
    let t = null
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value)
    return t != null ? new Date(t) : null
  }
}
Es.create = (e) =>
  new Es({
    checks: [],
    coerce: (e == null ? void 0 : e.coerce) || !1,
    typeName: Ee.ZodDate,
    ...ke(e),
  })
class Yf extends Me {
  _parse(t) {
    if (this._getType(t) !== se.symbol) {
      const r = this._getOrReturnCtx(t)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.symbol,
          received: r.parsedType,
        }),
        Ce
      )
    }
    return mn(t.data)
  }
}
Yf.create = (e) => new Yf({ typeName: Ee.ZodSymbol, ...ke(e) })
class Hc extends Me {
  _parse(t) {
    if (this._getType(t) !== se.undefined) {
      const r = this._getOrReturnCtx(t)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.undefined,
          received: r.parsedType,
        }),
        Ce
      )
    }
    return mn(t.data)
  }
}
Hc.create = (e) => new Hc({ typeName: Ee.ZodUndefined, ...ke(e) })
class Wc extends Me {
  _parse(t) {
    if (this._getType(t) !== se.null) {
      const r = this._getOrReturnCtx(t)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.null,
          received: r.parsedType,
        }),
        Ce
      )
    }
    return mn(t.data)
  }
}
Wc.create = (e) => new Wc({ typeName: Ee.ZodNull, ...ke(e) })
class Ka extends Me {
  constructor() {
    super(...arguments), (this._any = !0)
  }
  _parse(t) {
    return mn(t.data)
  }
}
Ka.create = (e) => new Ka({ typeName: Ee.ZodAny, ...ke(e) })
class ns extends Me {
  constructor() {
    super(...arguments), (this._unknown = !0)
  }
  _parse(t) {
    return mn(t.data)
  }
}
ns.create = (e) => new ns({ typeName: Ee.ZodUnknown, ...ke(e) })
class Ro extends Me {
  _parse(t) {
    const n = this._getOrReturnCtx(t)
    return (
      re(n, {
        code: Y.invalid_type,
        expected: se.never,
        received: n.parsedType,
      }),
      Ce
    )
  }
}
Ro.create = (e) => new Ro({ typeName: Ee.ZodNever, ...ke(e) })
class Xf extends Me {
  _parse(t) {
    if (this._getType(t) !== se.undefined) {
      const r = this._getOrReturnCtx(t)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.void,
          received: r.parsedType,
        }),
        Ce
      )
    }
    return mn(t.data)
  }
}
Xf.create = (e) => new Xf({ typeName: Ee.ZodVoid, ...ke(e) })
class _r extends Me {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t),
      o = this._def
    if (n.parsedType !== se.array)
      return (
        re(n, {
          code: Y.invalid_type,
          expected: se.array,
          received: n.parsedType,
        }),
        Ce
      )
    if (o.exactLength !== null) {
      const s = n.data.length > o.exactLength.value,
        a = n.data.length < o.exactLength.value
      ;(s || a) &&
        (re(n, {
          code: s ? Y.too_big : Y.too_small,
          minimum: a ? o.exactLength.value : void 0,
          maximum: s ? o.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: o.exactLength.message,
        }),
        r.dirty())
    }
    if (
      (o.minLength !== null &&
        n.data.length < o.minLength.value &&
        (re(n, {
          code: Y.too_small,
          minimum: o.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: o.minLength.message,
        }),
        r.dirty()),
      o.maxLength !== null &&
        n.data.length > o.maxLength.value &&
        (re(n, {
          code: Y.too_big,
          maximum: o.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: o.maxLength.message,
        }),
        r.dirty()),
      n.common.async)
    )
      return Promise.all(
        [...n.data].map((s, a) => o.type._parseAsync(new Xr(n, s, n.path, a)))
      ).then((s) => rn.mergeArray(r, s))
    const i = [...n.data].map((s, a) =>
      o.type._parseSync(new Xr(n, s, n.path, a))
    )
    return rn.mergeArray(r, i)
  }
  get element() {
    return this._def.type
  }
  min(t, n) {
    return new _r({
      ...this._def,
      minLength: { value: t, message: pe.toString(n) },
    })
  }
  max(t, n) {
    return new _r({
      ...this._def,
      maxLength: { value: t, message: pe.toString(n) },
    })
  }
  length(t, n) {
    return new _r({
      ...this._def,
      exactLength: { value: t, message: pe.toString(n) },
    })
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
_r.create = (e, t) =>
  new _r({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Ee.ZodArray,
    ...ke(t),
  })
function ea(e) {
  if (e instanceof ot) {
    const t = {}
    for (const n in e.shape) {
      const r = e.shape[n]
      t[n] = qr.create(ea(r))
    }
    return new ot({ ...e._def, shape: () => t })
  } else
    return e instanceof _r
      ? new _r({ ...e._def, type: ea(e.element) })
      : e instanceof qr
        ? qr.create(ea(e.unwrap()))
        : e instanceof Ti
          ? Ti.create(ea(e.unwrap()))
          : e instanceof Qr
            ? Qr.create(e.items.map((t) => ea(t)))
            : e
}
class ot extends Me {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend)
  }
  _getCached() {
    if (this._cached !== null) return this._cached
    const t = this._def.shape(),
      n = Pe.objectKeys(t)
    return (this._cached = { shape: t, keys: n })
  }
  _parse(t) {
    if (this._getType(t) !== se.object) {
      const c = this._getOrReturnCtx(t)
      return (
        re(c, {
          code: Y.invalid_type,
          expected: se.object,
          received: c.parsedType,
        }),
        Ce
      )
    }
    const { status: r, ctx: o } = this._processInputParams(t),
      { shape: i, keys: s } = this._getCached(),
      a = []
    if (
      !(this._def.catchall instanceof Ro && this._def.unknownKeys === "strip")
    )
      for (const c in o.data) s.includes(c) || a.push(c)
    const l = []
    for (const c of s) {
      const u = i[c],
        d = o.data[c]
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new Xr(o, d, o.path, c)),
        alwaysSet: c in o.data,
      })
    }
    if (this._def.catchall instanceof Ro) {
      const c = this._def.unknownKeys
      if (c === "passthrough")
        for (const u of a)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: o.data[u] },
          })
      else if (c === "strict")
        a.length > 0 &&
          (re(o, { code: Y.unrecognized_keys, keys: a }), r.dirty())
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.")
    } else {
      const c = this._def.catchall
      for (const u of a) {
        const d = o.data[u]
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(new Xr(o, d, o.path, u)),
          alwaysSet: u in o.data,
        })
      }
    }
    return o.common.async
      ? Promise.resolve()
          .then(async () => {
            const c = []
            for (const u of l) {
              const d = await u.key,
                f = await u.value
              c.push({ key: d, value: f, alwaysSet: u.alwaysSet })
            }
            return c
          })
          .then((c) => rn.mergeObjectSync(r, c))
      : rn.mergeObjectSync(r, l)
  }
  get shape() {
    return this._def.shape()
  }
  strict(t) {
    return (
      pe.errToObj,
      new ot({
        ...this._def,
        unknownKeys: "strict",
        ...(t !== void 0
          ? {
              errorMap: (n, r) => {
                var o, i, s, a
                const l =
                  (s =
                    (i = (o = this._def).errorMap) === null || i === void 0
                      ? void 0
                      : i.call(o, n, r).message) !== null && s !== void 0
                    ? s
                    : r.defaultError
                return n.code === "unrecognized_keys"
                  ? {
                      message:
                        (a = pe.errToObj(t).message) !== null && a !== void 0
                          ? a
                          : l,
                    }
                  : { message: l }
              },
            }
          : {}),
      })
    )
  }
  strip() {
    return new ot({ ...this._def, unknownKeys: "strip" })
  }
  passthrough() {
    return new ot({ ...this._def, unknownKeys: "passthrough" })
  }
  extend(t) {
    return new ot({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...t }),
    })
  }
  merge(t) {
    return new ot({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
      typeName: Ee.ZodObject,
    })
  }
  setKey(t, n) {
    return this.augment({ [t]: n })
  }
  catchall(t) {
    return new ot({ ...this._def, catchall: t })
  }
  pick(t) {
    const n = {}
    return (
      Pe.objectKeys(t).forEach((r) => {
        t[r] && this.shape[r] && (n[r] = this.shape[r])
      }),
      new ot({ ...this._def, shape: () => n })
    )
  }
  omit(t) {
    const n = {}
    return (
      Pe.objectKeys(this.shape).forEach((r) => {
        t[r] || (n[r] = this.shape[r])
      }),
      new ot({ ...this._def, shape: () => n })
    )
  }
  deepPartial() {
    return ea(this)
  }
  partial(t) {
    const n = {}
    return (
      Pe.objectKeys(this.shape).forEach((r) => {
        const o = this.shape[r]
        t && !t[r] ? (n[r] = o) : (n[r] = o.optional())
      }),
      new ot({ ...this._def, shape: () => n })
    )
  }
  required(t) {
    const n = {}
    return (
      Pe.objectKeys(this.shape).forEach((r) => {
        if (t && !t[r]) n[r] = this.shape[r]
        else {
          let i = this.shape[r]
          for (; i instanceof qr; ) i = i._def.innerType
          n[r] = i
        }
      }),
      new ot({ ...this._def, shape: () => n })
    )
  }
  keyof() {
    return G2(Pe.objectKeys(this.shape))
  }
}
ot.create = (e, t) =>
  new ot({
    shape: () => e,
    unknownKeys: "strip",
    catchall: Ro.create(),
    typeName: Ee.ZodObject,
    ...ke(t),
  })
ot.strictCreate = (e, t) =>
  new ot({
    shape: () => e,
    unknownKeys: "strict",
    catchall: Ro.create(),
    typeName: Ee.ZodObject,
    ...ke(t),
  })
ot.lazycreate = (e, t) =>
  new ot({
    shape: e,
    unknownKeys: "strip",
    catchall: Ro.create(),
    typeName: Ee.ZodObject,
    ...ke(t),
  })
class Kc extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t),
      r = this._def.options
    function o(i) {
      for (const a of i) if (a.result.status === "valid") return a.result
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result
      const s = i.map((a) => new Fn(a.ctx.common.issues))
      return re(n, { code: Y.invalid_union, unionErrors: s }), Ce
    }
    if (n.common.async)
      return Promise.all(
        r.map(async (i) => {
          const s = { ...n, common: { ...n.common, issues: [] }, parent: null }
          return {
            result: await i._parseAsync({
              data: n.data,
              path: n.path,
              parent: s,
            }),
            ctx: s,
          }
        })
      ).then(o)
    {
      let i
      const s = []
      for (const l of r) {
        const c = { ...n, common: { ...n.common, issues: [] }, parent: null },
          u = l._parseSync({ data: n.data, path: n.path, parent: c })
        if (u.status === "valid") return u
        u.status === "dirty" && !i && (i = { result: u, ctx: c }),
          c.common.issues.length && s.push(c.common.issues)
      }
      if (i) return n.common.issues.push(...i.ctx.common.issues), i.result
      const a = s.map((l) => new Fn(l))
      return re(n, { code: Y.invalid_union, unionErrors: a }), Ce
    }
  }
  get options() {
    return this._def.options
  }
}
Kc.create = (e, t) => new Kc({ options: e, typeName: Ee.ZodUnion, ...ke(t) })
const uo = (e) =>
  e instanceof Zc
    ? uo(e.schema)
    : e instanceof Or
      ? uo(e.innerType())
      : e instanceof Yc
        ? [e.value]
        : e instanceof Ni
          ? e.options
          : e instanceof Xc
            ? Pe.objectValues(e.enum)
            : e instanceof Qc
              ? uo(e._def.innerType)
              : e instanceof Hc
                ? [void 0]
                : e instanceof Wc
                  ? [null]
                  : e instanceof qr
                    ? [void 0, ...uo(e.unwrap())]
                    : e instanceof Ti
                      ? [null, ...uo(e.unwrap())]
                      : e instanceof Ub || e instanceof eu
                        ? uo(e.unwrap())
                        : e instanceof Jc
                          ? uo(e._def.innerType)
                          : []
class qh extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t)
    if (n.parsedType !== se.object)
      return (
        re(n, {
          code: Y.invalid_type,
          expected: se.object,
          received: n.parsedType,
        }),
        Ce
      )
    const r = this.discriminator,
      o = n.data[r],
      i = this.optionsMap.get(o)
    return i
      ? n.common.async
        ? i._parseAsync({ data: n.data, path: n.path, parent: n })
        : i._parseSync({ data: n.data, path: n.path, parent: n })
      : (re(n, {
          code: Y.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [r],
        }),
        Ce)
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  static create(t, n, r) {
    const o = new Map()
    for (const i of n) {
      const s = uo(i.shape[t])
      if (!s.length)
        throw new Error(
          `A discriminator value for key \`${t}\` could not be extracted from all schema options`
        )
      for (const a of s) {
        if (o.has(a))
          throw new Error(
            `Discriminator property ${String(t)} has duplicate value ${String(a)}`
          )
        o.set(a, i)
      }
    }
    return new qh({
      typeName: Ee.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: o,
      ...ke(r),
    })
  }
}
function fy(e, t) {
  const n = go(e),
    r = go(t)
  if (e === t) return { valid: !0, data: e }
  if (n === se.object && r === se.object) {
    const o = Pe.objectKeys(t),
      i = Pe.objectKeys(e).filter((a) => o.indexOf(a) !== -1),
      s = { ...e, ...t }
    for (const a of i) {
      const l = fy(e[a], t[a])
      if (!l.valid) return { valid: !1 }
      s[a] = l.data
    }
    return { valid: !0, data: s }
  } else if (n === se.array && r === se.array) {
    if (e.length !== t.length) return { valid: !1 }
    const o = []
    for (let i = 0; i < e.length; i++) {
      const s = e[i],
        a = t[i],
        l = fy(s, a)
      if (!l.valid) return { valid: !1 }
      o.push(l.data)
    }
    return { valid: !0, data: o }
  } else
    return n === se.date && r === se.date && +e == +t
      ? { valid: !0, data: e }
      : { valid: !1 }
}
class Gc extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t),
      o = (i, s) => {
        if (uy(i) || uy(s)) return Ce
        const a = fy(i.value, s.value)
        return a.valid
          ? ((dy(i) || dy(s)) && n.dirty(), { status: n.value, value: a.data })
          : (re(r, { code: Y.invalid_intersection_types }), Ce)
      }
    return r.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r,
          }),
        ]).then(([i, s]) => o(i, s))
      : o(
          this._def.left._parseSync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseSync({ data: r.data, path: r.path, parent: r })
        )
  }
}
Gc.create = (e, t, n) =>
  new Gc({ left: e, right: t, typeName: Ee.ZodIntersection, ...ke(n) })
class Qr extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t)
    if (r.parsedType !== se.array)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.array,
          received: r.parsedType,
        }),
        Ce
      )
    if (r.data.length < this._def.items.length)
      return (
        re(r, {
          code: Y.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        Ce
      )
    !this._def.rest &&
      r.data.length > this._def.items.length &&
      (re(r, {
        code: Y.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      n.dirty())
    const i = [...r.data]
      .map((s, a) => {
        const l = this._def.items[a] || this._def.rest
        return l ? l._parse(new Xr(r, s, r.path, a)) : null
      })
      .filter((s) => !!s)
    return r.common.async
      ? Promise.all(i).then((s) => rn.mergeArray(n, s))
      : rn.mergeArray(n, i)
  }
  get items() {
    return this._def.items
  }
  rest(t) {
    return new Qr({ ...this._def, rest: t })
  }
}
Qr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])")
  return new Qr({ items: e, typeName: Ee.ZodTuple, rest: null, ...ke(t) })
}
class qc extends Me {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t)
    if (r.parsedType !== se.object)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.object,
          received: r.parsedType,
        }),
        Ce
      )
    const o = [],
      i = this._def.keyType,
      s = this._def.valueType
    for (const a in r.data)
      o.push({
        key: i._parse(new Xr(r, a, r.path, a)),
        value: s._parse(new Xr(r, r.data[a], r.path, a)),
        alwaysSet: a in r.data,
      })
    return r.common.async ? rn.mergeObjectAsync(n, o) : rn.mergeObjectSync(n, o)
  }
  get element() {
    return this._def.valueType
  }
  static create(t, n, r) {
    return n instanceof Me
      ? new qc({ keyType: t, valueType: n, typeName: Ee.ZodRecord, ...ke(r) })
      : new qc({
          keyType: xr.create(),
          valueType: t,
          typeName: Ee.ZodRecord,
          ...ke(n),
        })
  }
}
class Qf extends Me {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t)
    if (r.parsedType !== se.map)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.map,
          received: r.parsedType,
        }),
        Ce
      )
    const o = this._def.keyType,
      i = this._def.valueType,
      s = [...r.data.entries()].map(([a, l], c) => ({
        key: o._parse(new Xr(r, a, r.path, [c, "key"])),
        value: i._parse(new Xr(r, l, r.path, [c, "value"])),
      }))
    if (r.common.async) {
      const a = new Map()
      return Promise.resolve().then(async () => {
        for (const l of s) {
          const c = await l.key,
            u = await l.value
          if (c.status === "aborted" || u.status === "aborted") return Ce
          ;(c.status === "dirty" || u.status === "dirty") && n.dirty(),
            a.set(c.value, u.value)
        }
        return { status: n.value, value: a }
      })
    } else {
      const a = new Map()
      for (const l of s) {
        const c = l.key,
          u = l.value
        if (c.status === "aborted" || u.status === "aborted") return Ce
        ;(c.status === "dirty" || u.status === "dirty") && n.dirty(),
          a.set(c.value, u.value)
      }
      return { status: n.value, value: a }
    }
  }
}
Qf.create = (e, t, n) =>
  new Qf({ valueType: t, keyType: e, typeName: Ee.ZodMap, ...ke(n) })
class Cs extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t)
    if (r.parsedType !== se.set)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.set,
          received: r.parsedType,
        }),
        Ce
      )
    const o = this._def
    o.minSize !== null &&
      r.data.size < o.minSize.value &&
      (re(r, {
        code: Y.too_small,
        minimum: o.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: o.minSize.message,
      }),
      n.dirty()),
      o.maxSize !== null &&
        r.data.size > o.maxSize.value &&
        (re(r, {
          code: Y.too_big,
          maximum: o.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: o.maxSize.message,
        }),
        n.dirty())
    const i = this._def.valueType
    function s(l) {
      const c = new Set()
      for (const u of l) {
        if (u.status === "aborted") return Ce
        u.status === "dirty" && n.dirty(), c.add(u.value)
      }
      return { status: n.value, value: c }
    }
    const a = [...r.data.values()].map((l, c) =>
      i._parse(new Xr(r, l, r.path, c))
    )
    return r.common.async ? Promise.all(a).then((l) => s(l)) : s(a)
  }
  min(t, n) {
    return new Cs({
      ...this._def,
      minSize: { value: t, message: pe.toString(n) },
    })
  }
  max(t, n) {
    return new Cs({
      ...this._def,
      maxSize: { value: t, message: pe.toString(n) },
    })
  }
  size(t, n) {
    return this.min(t, n).max(t, n)
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
Cs.create = (e, t) =>
  new Cs({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: Ee.ZodSet,
    ...ke(t),
  })
class Oa extends Me {
  constructor() {
    super(...arguments), (this.validate = this.implement)
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t)
    if (n.parsedType !== se.function)
      return (
        re(n, {
          code: Y.invalid_type,
          expected: se.function,
          received: n.parsedType,
        }),
        Ce
      )
    function r(a, l) {
      return qf({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Gf(),
          Wa,
        ].filter((c) => !!c),
        issueData: { code: Y.invalid_arguments, argumentsError: l },
      })
    }
    function o(a, l) {
      return qf({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Gf(),
          Wa,
        ].filter((c) => !!c),
        issueData: { code: Y.invalid_return_type, returnTypeError: l },
      })
    }
    const i = { errorMap: n.common.contextualErrorMap },
      s = n.data
    if (this._def.returns instanceof Ga) {
      const a = this
      return mn(async function (...l) {
        const c = new Fn([]),
          u = await a._def.args.parseAsync(l, i).catch((p) => {
            throw (c.addIssue(r(l, p)), c)
          }),
          d = await Reflect.apply(s, this, u)
        return await a._def.returns._def.type.parseAsync(d, i).catch((p) => {
          throw (c.addIssue(o(d, p)), c)
        })
      })
    } else {
      const a = this
      return mn(function (...l) {
        const c = a._def.args.safeParse(l, i)
        if (!c.success) throw new Fn([r(l, c.error)])
        const u = Reflect.apply(s, this, c.data),
          d = a._def.returns.safeParse(u, i)
        if (!d.success) throw new Fn([o(u, d.error)])
        return d.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...t) {
    return new Oa({ ...this._def, args: Qr.create(t).rest(ns.create()) })
  }
  returns(t) {
    return new Oa({ ...this._def, returns: t })
  }
  implement(t) {
    return this.parse(t)
  }
  strictImplement(t) {
    return this.parse(t)
  }
  static create(t, n, r) {
    return new Oa({
      args: t || Qr.create([]).rest(ns.create()),
      returns: n || ns.create(),
      typeName: Ee.ZodFunction,
      ...ke(r),
    })
  }
}
class Zc extends Me {
  get schema() {
    return this._def.getter()
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t)
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n })
  }
}
Zc.create = (e, t) => new Zc({ getter: e, typeName: Ee.ZodLazy, ...ke(t) })
class Yc extends Me {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t)
      return (
        re(n, {
          received: n.data,
          code: Y.invalid_literal,
          expected: this._def.value,
        }),
        Ce
      )
    }
    return { status: "valid", value: t.data }
  }
  get value() {
    return this._def.value
  }
}
Yc.create = (e, t) => new Yc({ value: e, typeName: Ee.ZodLiteral, ...ke(t) })
function G2(e, t) {
  return new Ni({ values: e, typeName: Ee.ZodEnum, ...ke(t) })
}
class Ni extends Me {
  constructor() {
    super(...arguments), Hl.set(this, void 0)
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t),
        r = this._def.values
      return (
        re(n, {
          expected: Pe.joinValues(r),
          received: n.parsedType,
          code: Y.invalid_type,
        }),
        Ce
      )
    }
    if (
      (Zf(this, Hl, "f") || V2(this, Hl, new Set(this._def.values), "f"),
      !Zf(this, Hl, "f").has(t.data))
    ) {
      const n = this._getOrReturnCtx(t),
        r = this._def.values
      return (
        re(n, { received: n.data, code: Y.invalid_enum_value, options: r }), Ce
      )
    }
    return mn(t.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const t = {}
    for (const n of this._def.values) t[n] = n
    return t
  }
  get Values() {
    const t = {}
    for (const n of this._def.values) t[n] = n
    return t
  }
  get Enum() {
    const t = {}
    for (const n of this._def.values) t[n] = n
    return t
  }
  extract(t, n = this._def) {
    return Ni.create(t, { ...this._def, ...n })
  }
  exclude(t, n = this._def) {
    return Ni.create(
      this.options.filter((r) => !t.includes(r)),
      { ...this._def, ...n }
    )
  }
}
Hl = new WeakMap()
Ni.create = G2
class Xc extends Me {
  constructor() {
    super(...arguments), Wl.set(this, void 0)
  }
  _parse(t) {
    const n = Pe.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(t)
    if (r.parsedType !== se.string && r.parsedType !== se.number) {
      const o = Pe.objectValues(n)
      return (
        re(r, {
          expected: Pe.joinValues(o),
          received: r.parsedType,
          code: Y.invalid_type,
        }),
        Ce
      )
    }
    if (
      (Zf(this, Wl, "f") ||
        V2(this, Wl, new Set(Pe.getValidEnumValues(this._def.values)), "f"),
      !Zf(this, Wl, "f").has(t.data))
    ) {
      const o = Pe.objectValues(n)
      return (
        re(r, { received: r.data, code: Y.invalid_enum_value, options: o }), Ce
      )
    }
    return mn(t.data)
  }
  get enum() {
    return this._def.values
  }
}
Wl = new WeakMap()
Xc.create = (e, t) =>
  new Xc({ values: e, typeName: Ee.ZodNativeEnum, ...ke(t) })
class Ga extends Me {
  unwrap() {
    return this._def.type
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t)
    if (n.parsedType !== se.promise && n.common.async === !1)
      return (
        re(n, {
          code: Y.invalid_type,
          expected: se.promise,
          received: n.parsedType,
        }),
        Ce
      )
    const r = n.parsedType === se.promise ? n.data : Promise.resolve(n.data)
    return mn(
      r.then((o) =>
        this._def.type.parseAsync(o, {
          path: n.path,
          errorMap: n.common.contextualErrorMap,
        })
      )
    )
  }
}
Ga.create = (e, t) => new Ga({ type: e, typeName: Ee.ZodPromise, ...ke(t) })
class Or extends Me {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === Ee.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t),
      o = this._def.effect || null,
      i = {
        addIssue: (s) => {
          re(r, s), s.fatal ? n.abort() : n.dirty()
        },
        get path() {
          return r.path
        },
      }
    if (((i.addIssue = i.addIssue.bind(i)), o.type === "preprocess")) {
      const s = o.transform(r.data, i)
      if (r.common.async)
        return Promise.resolve(s).then(async (a) => {
          if (n.value === "aborted") return Ce
          const l = await this._def.schema._parseAsync({
            data: a,
            path: r.path,
            parent: r,
          })
          return l.status === "aborted"
            ? Ce
            : l.status === "dirty" || n.value === "dirty"
              ? ba(l.value)
              : l
        })
      {
        if (n.value === "aborted") return Ce
        const a = this._def.schema._parseSync({
          data: s,
          path: r.path,
          parent: r,
        })
        return a.status === "aborted"
          ? Ce
          : a.status === "dirty" || n.value === "dirty"
            ? ba(a.value)
            : a
      }
    }
    if (o.type === "refinement") {
      const s = (a) => {
        const l = o.refinement(a, i)
        if (r.common.async) return Promise.resolve(l)
        if (l instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          )
        return a
      }
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r,
        })
        return a.status === "aborted"
          ? Ce
          : (a.status === "dirty" && n.dirty(),
            s(a.value),
            { status: n.value, value: a.value })
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then((a) =>
            a.status === "aborted"
              ? Ce
              : (a.status === "dirty" && n.dirty(),
                s(a.value).then(() => ({ status: n.value, value: a.value })))
          )
    }
    if (o.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r,
        })
        if (!ws(s)) return s
        const a = o.transform(s.value, i)
        if (a instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          )
        return { status: n.value, value: a }
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then((s) =>
            ws(s)
              ? Promise.resolve(o.transform(s.value, i)).then((a) => ({
                  status: n.value,
                  value: a,
                }))
              : s
          )
    Pe.assertNever(o)
  }
}
Or.create = (e, t, n) =>
  new Or({ schema: e, typeName: Ee.ZodEffects, effect: t, ...ke(n) })
Or.createWithPreprocess = (e, t, n) =>
  new Or({
    schema: t,
    effect: { type: "preprocess", transform: e },
    typeName: Ee.ZodEffects,
    ...ke(n),
  })
class qr extends Me {
  _parse(t) {
    return this._getType(t) === se.undefined
      ? mn(void 0)
      : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
qr.create = (e, t) =>
  new qr({ innerType: e, typeName: Ee.ZodOptional, ...ke(t) })
class Ti extends Me {
  _parse(t) {
    return this._getType(t) === se.null
      ? mn(null)
      : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
Ti.create = (e, t) =>
  new Ti({ innerType: e, typeName: Ee.ZodNullable, ...ke(t) })
class Qc extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t)
    let r = n.data
    return (
      n.parsedType === se.undefined && (r = this._def.defaultValue()),
      this._def.innerType._parse({ data: r, path: n.path, parent: n })
    )
  }
  removeDefault() {
    return this._def.innerType
  }
}
Qc.create = (e, t) =>
  new Qc({
    innerType: e,
    typeName: Ee.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...ke(t),
  })
class Jc extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t),
      r = { ...n, common: { ...n.common, issues: [] } },
      o = this._def.innerType._parse({
        data: r.data,
        path: r.path,
        parent: { ...r },
      })
    return Uc(o)
      ? o.then((i) => ({
          status: "valid",
          value:
            i.status === "valid"
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new Fn(r.common.issues)
                  },
                  input: r.data,
                }),
        }))
      : {
          status: "valid",
          value:
            o.status === "valid"
              ? o.value
              : this._def.catchValue({
                  get error() {
                    return new Fn(r.common.issues)
                  },
                  input: r.data,
                }),
        }
  }
  removeCatch() {
    return this._def.innerType
  }
}
Jc.create = (e, t) =>
  new Jc({
    innerType: e,
    typeName: Ee.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...ke(t),
  })
class Jf extends Me {
  _parse(t) {
    if (this._getType(t) !== se.nan) {
      const r = this._getOrReturnCtx(t)
      return (
        re(r, {
          code: Y.invalid_type,
          expected: se.nan,
          received: r.parsedType,
        }),
        Ce
      )
    }
    return { status: "valid", value: t.data }
  }
}
Jf.create = (e) => new Jf({ typeName: Ee.ZodNaN, ...ke(e) })
const l8 = Symbol("zod_brand")
class Ub extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t),
      r = n.data
    return this._def.type._parse({ data: r, path: n.path, parent: n })
  }
  unwrap() {
    return this._def.type
  }
}
class Ou extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t)
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r,
        })
        return i.status === "aborted"
          ? Ce
          : i.status === "dirty"
            ? (n.dirty(), ba(i.value))
            : this._def.out._parseAsync({
                data: i.value,
                path: r.path,
                parent: r,
              })
      })()
    {
      const o = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r,
      })
      return o.status === "aborted"
        ? Ce
        : o.status === "dirty"
          ? (n.dirty(), { status: "dirty", value: o.value })
          : this._def.out._parseSync({ data: o.value, path: r.path, parent: r })
    }
  }
  static create(t, n) {
    return new Ou({ in: t, out: n, typeName: Ee.ZodPipeline })
  }
}
class eu extends Me {
  _parse(t) {
    const n = this._def.innerType._parse(t),
      r = (o) => (ws(o) && (o.value = Object.freeze(o.value)), o)
    return Uc(n) ? n.then((o) => r(o)) : r(n)
  }
  unwrap() {
    return this._def.innerType
  }
}
eu.create = (e, t) =>
  new eu({ innerType: e, typeName: Ee.ZodReadonly, ...ke(t) })
function hE(e, t) {
  const n =
    typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e
  return typeof n == "string" ? { message: n } : n
}
function q2(e, t = {}, n) {
  return e
    ? Ka.create().superRefine((r, o) => {
        var i, s
        const a = e(r)
        if (a instanceof Promise)
          return a.then((l) => {
            var c, u
            if (!l) {
              const d = hE(t, r),
                f =
                  (u = (c = d.fatal) !== null && c !== void 0 ? c : n) !==
                    null && u !== void 0
                    ? u
                    : !0
              o.addIssue({ code: "custom", ...d, fatal: f })
            }
          })
        if (!a) {
          const l = hE(t, r),
            c =
              (s = (i = l.fatal) !== null && i !== void 0 ? i : n) !== null &&
              s !== void 0
                ? s
                : !0
          o.addIssue({ code: "custom", ...l, fatal: c })
        }
      })
    : Ka.create()
}
const c8 = { object: ot.lazycreate }
var Ee
;(function (e) {
  ;(e.ZodString = "ZodString"),
    (e.ZodNumber = "ZodNumber"),
    (e.ZodNaN = "ZodNaN"),
    (e.ZodBigInt = "ZodBigInt"),
    (e.ZodBoolean = "ZodBoolean"),
    (e.ZodDate = "ZodDate"),
    (e.ZodSymbol = "ZodSymbol"),
    (e.ZodUndefined = "ZodUndefined"),
    (e.ZodNull = "ZodNull"),
    (e.ZodAny = "ZodAny"),
    (e.ZodUnknown = "ZodUnknown"),
    (e.ZodNever = "ZodNever"),
    (e.ZodVoid = "ZodVoid"),
    (e.ZodArray = "ZodArray"),
    (e.ZodObject = "ZodObject"),
    (e.ZodUnion = "ZodUnion"),
    (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (e.ZodIntersection = "ZodIntersection"),
    (e.ZodTuple = "ZodTuple"),
    (e.ZodRecord = "ZodRecord"),
    (e.ZodMap = "ZodMap"),
    (e.ZodSet = "ZodSet"),
    (e.ZodFunction = "ZodFunction"),
    (e.ZodLazy = "ZodLazy"),
    (e.ZodLiteral = "ZodLiteral"),
    (e.ZodEnum = "ZodEnum"),
    (e.ZodEffects = "ZodEffects"),
    (e.ZodNativeEnum = "ZodNativeEnum"),
    (e.ZodOptional = "ZodOptional"),
    (e.ZodNullable = "ZodNullable"),
    (e.ZodDefault = "ZodDefault"),
    (e.ZodCatch = "ZodCatch"),
    (e.ZodPromise = "ZodPromise"),
    (e.ZodBranded = "ZodBranded"),
    (e.ZodPipeline = "ZodPipeline"),
    (e.ZodReadonly = "ZodReadonly")
})(Ee || (Ee = {}))
const u8 = (e, t = { message: `Input not instance of ${e.name}` }) =>
    q2((n) => n instanceof e, t),
  Z2 = xr.create,
  Y2 = _i.create,
  d8 = Jf.create,
  f8 = ki.create,
  X2 = Vc.create,
  p8 = Es.create,
  h8 = Yf.create,
  m8 = Hc.create,
  g8 = Wc.create,
  v8 = Ka.create,
  y8 = ns.create,
  b8 = Ro.create,
  x8 = Xf.create,
  w8 = _r.create,
  E8 = ot.create,
  C8 = ot.strictCreate,
  S8 = Kc.create,
  _8 = qh.create,
  k8 = Gc.create,
  N8 = Qr.create,
  T8 = qc.create,
  M8 = Qf.create,
  O8 = Cs.create,
  A8 = Oa.create,
  R8 = Zc.create,
  I8 = Yc.create,
  D8 = Ni.create,
  L8 = Xc.create,
  P8 = Ga.create,
  mE = Or.create,
  $8 = qr.create,
  B8 = Ti.create,
  j8 = Or.createWithPreprocess,
  F8 = Ou.create,
  z8 = () => Z2().optional(),
  U8 = () => Y2().optional(),
  V8 = () => X2().optional(),
  H8 = {
    string: (e) => xr.create({ ...e, coerce: !0 }),
    number: (e) => _i.create({ ...e, coerce: !0 }),
    boolean: (e) => Vc.create({ ...e, coerce: !0 }),
    bigint: (e) => ki.create({ ...e, coerce: !0 }),
    date: (e) => Es.create({ ...e, coerce: !0 }),
  },
  W8 = Ce
var Rt = Object.freeze({
  __proto__: null,
  defaultErrorMap: Wa,
  setErrorMap: j$,
  getErrorMap: Gf,
  makeIssue: qf,
  EMPTY_PATH: F$,
  addIssueToContext: re,
  ParseStatus: rn,
  INVALID: Ce,
  DIRTY: ba,
  OK: mn,
  isAborted: uy,
  isDirty: dy,
  isValid: ws,
  isAsync: Uc,
  get util() {
    return Pe
  },
  get objectUtil() {
    return cy
  },
  ZodParsedType: se,
  getParsedType: go,
  ZodType: Me,
  datetimeRegex: K2,
  ZodString: xr,
  ZodNumber: _i,
  ZodBigInt: ki,
  ZodBoolean: Vc,
  ZodDate: Es,
  ZodSymbol: Yf,
  ZodUndefined: Hc,
  ZodNull: Wc,
  ZodAny: Ka,
  ZodUnknown: ns,
  ZodNever: Ro,
  ZodVoid: Xf,
  ZodArray: _r,
  ZodObject: ot,
  ZodUnion: Kc,
  ZodDiscriminatedUnion: qh,
  ZodIntersection: Gc,
  ZodTuple: Qr,
  ZodRecord: qc,
  ZodMap: Qf,
  ZodSet: Cs,
  ZodFunction: Oa,
  ZodLazy: Zc,
  ZodLiteral: Yc,
  ZodEnum: Ni,
  ZodNativeEnum: Xc,
  ZodPromise: Ga,
  ZodEffects: Or,
  ZodTransformer: Or,
  ZodOptional: qr,
  ZodNullable: Ti,
  ZodDefault: Qc,
  ZodCatch: Jc,
  ZodNaN: Jf,
  BRAND: l8,
  ZodBranded: Ub,
  ZodPipeline: Ou,
  ZodReadonly: eu,
  custom: q2,
  Schema: Me,
  ZodSchema: Me,
  late: c8,
  get ZodFirstPartyTypeKind() {
    return Ee
  },
  coerce: H8,
  any: v8,
  array: w8,
  bigint: f8,
  boolean: X2,
  date: p8,
  discriminatedUnion: _8,
  effect: mE,
  enum: D8,
  function: A8,
  instanceof: u8,
  intersection: k8,
  lazy: R8,
  literal: I8,
  map: M8,
  nan: d8,
  nativeEnum: L8,
  never: b8,
  null: g8,
  nullable: B8,
  number: Y2,
  object: E8,
  oboolean: V8,
  onumber: U8,
  optional: $8,
  ostring: z8,
  pipeline: F8,
  preprocess: j8,
  promise: P8,
  record: T8,
  set: O8,
  strictObject: C8,
  string: Z2,
  symbol: h8,
  transformer: mE,
  tuple: N8,
  undefined: m8,
  union: S8,
  unknown: y8,
  void: x8,
  NEVER: W8,
  ZodIssueCode: Y,
  quotelessJson: B$,
  ZodError: Fn,
})
function qe() {
  return (
    (qe = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    qe.apply(null, arguments)
  )
}
function K8(e, t) {
  const n = m.createContext(t)
  function r(i) {
    const { children: s, ...a } = i,
      l = m.useMemo(() => a, Object.values(a))
    return m.createElement(n.Provider, { value: l }, s)
  }
  function o(i) {
    const s = m.useContext(n)
    if (s) return s
    if (t !== void 0) return t
    throw new Error(`\`${i}\` must be used within \`${e}\``)
  }
  return (r.displayName = e + "Provider"), [r, o]
}
function Q2(e, t = []) {
  let n = []
  function r(i, s) {
    const a = m.createContext(s),
      l = n.length
    n = [...n, s]
    function c(d) {
      const { scope: f, children: p, ...g } = d,
        v = (f == null ? void 0 : f[e][l]) || a,
        b = m.useMemo(() => g, Object.values(g))
      return m.createElement(v.Provider, { value: b }, p)
    }
    function u(d, f) {
      const p = (f == null ? void 0 : f[e][l]) || a,
        g = m.useContext(p)
      if (g) return g
      if (s !== void 0) return s
      throw new Error(`\`${d}\` must be used within \`${i}\``)
    }
    return (c.displayName = i + "Provider"), [c, u]
  }
  const o = () => {
    const i = n.map((s) => m.createContext(s))
    return function (a) {
      const l = (a == null ? void 0 : a[e]) || i
      return m.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l])
    }
  }
  return (o.scopeName = e), [r, G8(o, ...t)]
}
function G8(...e) {
  const t = e[0]
  if (e.length === 1) return t
  const n = () => {
    const r = e.map((o) => ({ useScope: o(), scopeName: o.scopeName }))
    return function (i) {
      const s = r.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`]
        return { ...a, ...d }
      }, {})
      return m.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s])
    }
  }
  return (n.scopeName = t.scopeName), n
}
function q8(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t)
}
function J2(...e) {
  return (t) => e.forEach((n) => q8(n, t))
}
function Ds(...e) {
  return m.useCallback(J2(...e), e)
}
function pi(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (o) {
    if ((e == null || e(o), n === !1 || !o.defaultPrevented))
      return t == null ? void 0 : t(o)
  }
}
const py =
    globalThis != null && globalThis.document ? m.useLayoutEffect : () => {},
  Z8 = a0["useId".toString()] || (() => {})
let Y8 = 0
function fg(e) {
  const [t, n] = m.useState(Z8())
  return (
    py(() => {
      e || n((r) => (r != null ? r : String(Y8++)))
    }, [e]),
    e || (t ? `radix-${t}` : "")
  )
}
function Ss(e) {
  const t = m.useRef(e)
  return (
    m.useEffect(() => {
      t.current = e
    }),
    m.useMemo(
      () =>
        (...n) => {
          var r
          return (r = t.current) === null || r === void 0
            ? void 0
            : r.call(t, ...n)
        },
      []
    )
  )
}
function X8({ prop: e, defaultProp: t, onChange: n = () => {} }) {
  const [r, o] = Q8({ defaultProp: t, onChange: n }),
    i = e !== void 0,
    s = i ? e : r,
    a = Ss(n),
    l = m.useCallback(
      (c) => {
        if (i) {
          const d = typeof c == "function" ? c(e) : c
          d !== e && a(d)
        } else o(c)
      },
      [i, e, o, a]
    )
  return [s, l]
}
function Q8({ defaultProp: e, onChange: t }) {
  const n = m.useState(e),
    [r] = n,
    o = m.useRef(r),
    i = Ss(t)
  return (
    m.useEffect(() => {
      o.current !== r && (i(r), (o.current = r))
    }, [r, o, i]),
    n
  )
}
const Vb = m.forwardRef((e, t) => {
  const { children: n, ...r } = e,
    o = m.Children.toArray(n),
    i = o.find(J8)
  if (i) {
    const s = i.props.children,
      a = o.map((l) =>
        l === i
          ? m.Children.count(s) > 1
            ? m.Children.only(null)
            : m.isValidElement(s)
              ? s.props.children
              : null
          : l
      )
    return m.createElement(
      hy,
      qe({}, r, { ref: t }),
      m.isValidElement(s) ? m.cloneElement(s, void 0, a) : null
    )
  }
  return m.createElement(hy, qe({}, r, { ref: t }), n)
})
Vb.displayName = "Slot"
const hy = m.forwardRef((e, t) => {
  const { children: n, ...r } = e
  return m.isValidElement(n)
    ? m.cloneElement(n, { ...eB(r, n.props), ref: t ? J2(t, n.ref) : n.ref })
    : m.Children.count(n) > 1
      ? m.Children.only(null)
      : null
})
hy.displayName = "SlotClone"
const eM = ({ children: e }) => m.createElement(m.Fragment, null, e)
function J8(e) {
  return m.isValidElement(e) && e.type === eM
}
function eB(e, t) {
  const n = { ...t }
  for (const r in t) {
    const o = e[r],
      i = t[r]
    ;/^on[A-Z]/.test(r)
      ? o && i
        ? (n[r] = (...a) => {
            i(...a), o(...a)
          })
        : o && (n[r] = o)
      : r === "style"
        ? (n[r] = { ...o, ...i })
        : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "))
  }
  return { ...e, ...n }
}
const tB = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul",
  ],
  Ls = tB.reduce((e, t) => {
    const n = m.forwardRef((r, o) => {
      const { asChild: i, ...s } = r,
        a = i ? Vb : t
      return (
        m.useEffect(() => {
          window[Symbol.for("radix-ui")] = !0
        }, []),
        m.createElement(a, qe({}, s, { ref: o }))
      )
    })
    return (n.displayName = `Primitive.${t}`), { ...e, [t]: n }
  }, {})
function nB(e, t) {
  e && Rs.flushSync(() => e.dispatchEvent(t))
}
function rB(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Ss(e)
  m.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o)
    }
    return (
      t.addEventListener("keydown", r),
      () => t.removeEventListener("keydown", r)
    )
  }, [n, t])
}
const my = "dismissableLayer.update",
  oB = "dismissableLayer.pointerDownOutside",
  iB = "dismissableLayer.focusOutside"
let gE
const sB = m.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  aB = m.forwardRef((e, t) => {
    var n
    const {
        disableOutsidePointerEvents: r = !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: i,
        onFocusOutside: s,
        onInteractOutside: a,
        onDismiss: l,
        ...c
      } = e,
      u = m.useContext(sB),
      [d, f] = m.useState(null),
      p =
        (n = d == null ? void 0 : d.ownerDocument) !== null && n !== void 0
          ? n
          : globalThis == null
            ? void 0
            : globalThis.document,
      [, g] = m.useState({}),
      v = Ds(t, (N) => f(N)),
      b = Array.from(u.layers),
      [y] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1),
      x = b.indexOf(y),
      E = d ? b.indexOf(d) : -1,
      w = u.layersWithOutsidePointerEventsDisabled.size > 0,
      C = E >= x,
      S = lB((N) => {
        const R = N.target,
          B = [...u.branches].some((V) => V.contains(R))
        !C ||
          B ||
          (i == null || i(N),
          a == null || a(N),
          N.defaultPrevented || l == null || l())
      }, p),
      M = cB((N) => {
        const R = N.target
        ;[...u.branches].some((V) => V.contains(R)) ||
          (s == null || s(N),
          a == null || a(N),
          N.defaultPrevented || l == null || l())
      }, p)
    return (
      rB((N) => {
        E === u.layers.size - 1 &&
          (o == null || o(N),
          !N.defaultPrevented && l && (N.preventDefault(), l()))
      }, p),
      m.useEffect(() => {
        if (d)
          return (
            r &&
              (u.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((gE = p.body.style.pointerEvents),
                (p.body.style.pointerEvents = "none")),
              u.layersWithOutsidePointerEventsDisabled.add(d)),
            u.layers.add(d),
            vE(),
            () => {
              r &&
                u.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (p.body.style.pointerEvents = gE)
            }
          )
      }, [d, p, r, u]),
      m.useEffect(
        () => () => {
          d &&
            (u.layers.delete(d),
            u.layersWithOutsidePointerEventsDisabled.delete(d),
            vE())
        },
        [d, u]
      ),
      m.useEffect(() => {
        const N = () => g({})
        return (
          document.addEventListener(my, N),
          () => document.removeEventListener(my, N)
        )
      }, []),
      m.createElement(
        Ls.div,
        qe({}, c, {
          ref: v,
          style: {
            pointerEvents: w ? (C ? "auto" : "none") : void 0,
            ...e.style,
          },
          onFocusCapture: pi(e.onFocusCapture, M.onFocusCapture),
          onBlurCapture: pi(e.onBlurCapture, M.onBlurCapture),
          onPointerDownCapture: pi(
            e.onPointerDownCapture,
            S.onPointerDownCapture
          ),
        })
      )
    )
  })
function lB(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Ss(e),
    r = m.useRef(!1),
    o = m.useRef(() => {})
  return (
    m.useEffect(() => {
      const i = (a) => {
          if (a.target && !r.current) {
            let u = function () {
              tM(oB, n, c, { discrete: !0 })
            }
            var l = u
            const c = { originalEvent: a }
            a.pointerType === "touch"
              ? (t.removeEventListener("click", o.current),
                (o.current = u),
                t.addEventListener("click", o.current, { once: !0 }))
              : u()
          }
          r.current = !1
        },
        s = window.setTimeout(() => {
          t.addEventListener("pointerdown", i)
        }, 0)
      return () => {
        window.clearTimeout(s),
          t.removeEventListener("pointerdown", i),
          t.removeEventListener("click", o.current)
      }
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  )
}
function cB(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Ss(e),
    r = m.useRef(!1)
  return (
    m.useEffect(() => {
      const o = (i) => {
        i.target &&
          !r.current &&
          tM(iB, n, { originalEvent: i }, { discrete: !1 })
      }
      return (
        t.addEventListener("focusin", o),
        () => t.removeEventListener("focusin", o)
      )
    }, [t, n]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1),
    }
  )
}
function vE() {
  const e = new CustomEvent(my)
  document.dispatchEvent(e)
}
function tM(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target,
    i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n })
  t && o.addEventListener(e, t, { once: !0 }), r ? nB(o, i) : o.dispatchEvent(i)
}
const pg = "focusScope.autoFocusOnMount",
  hg = "focusScope.autoFocusOnUnmount",
  yE = { bubbles: !1, cancelable: !0 },
  uB = m.forwardRef((e, t) => {
    const {
        loop: n = !1,
        trapped: r = !1,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        ...s
      } = e,
      [a, l] = m.useState(null),
      c = Ss(o),
      u = Ss(i),
      d = m.useRef(null),
      f = Ds(t, (v) => l(v)),
      p = m.useRef({
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        },
      }).current
    m.useEffect(() => {
      if (r) {
        let x = function (S) {
            if (p.paused || !a) return
            const M = S.target
            a.contains(M) ? (d.current = M) : jo(d.current, { select: !0 })
          },
          E = function (S) {
            if (p.paused || !a) return
            const M = S.relatedTarget
            M !== null && (a.contains(M) || jo(d.current, { select: !0 }))
          },
          w = function (S) {
            const M = document.activeElement
            for (const N of S)
              N.removedNodes.length > 0 &&
                ((a != null && a.contains(M)) || jo(a))
          }
        var v = x,
          b = E,
          y = w
        document.addEventListener("focusin", x),
          document.addEventListener("focusout", E)
        const C = new MutationObserver(w)
        return (
          a && C.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", x),
              document.removeEventListener("focusout", E),
              C.disconnect()
          }
        )
      }
    }, [r, a, p.paused]),
      m.useEffect(() => {
        if (a) {
          xE.add(p)
          const v = document.activeElement
          if (!a.contains(v)) {
            const y = new CustomEvent(pg, yE)
            a.addEventListener(pg, c),
              a.dispatchEvent(y),
              y.defaultPrevented ||
                (dB(gB(nM(a)), { select: !0 }),
                document.activeElement === v && jo(a))
          }
          return () => {
            a.removeEventListener(pg, c),
              setTimeout(() => {
                const y = new CustomEvent(hg, yE)
                a.addEventListener(hg, u),
                  a.dispatchEvent(y),
                  y.defaultPrevented ||
                    jo(v != null ? v : document.body, { select: !0 }),
                  a.removeEventListener(hg, u),
                  xE.remove(p)
              }, 0)
          }
        }
      }, [a, c, u, p])
    const g = m.useCallback(
      (v) => {
        if ((!n && !r) || p.paused) return
        const b = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey,
          y = document.activeElement
        if (b && y) {
          const x = v.currentTarget,
            [E, w] = fB(x)
          E && w
            ? !v.shiftKey && y === w
              ? (v.preventDefault(), n && jo(E, { select: !0 }))
              : v.shiftKey &&
                y === E &&
                (v.preventDefault(), n && jo(w, { select: !0 }))
            : y === x && v.preventDefault()
        }
      },
      [n, r, p.paused]
    )
    return m.createElement(
      Ls.div,
      qe({ tabIndex: -1 }, s, { ref: f, onKeyDown: g })
    )
  })
function dB(e, { select: t = !1 } = {}) {
  const n = document.activeElement
  for (const r of e)
    if ((jo(r, { select: t }), document.activeElement !== n)) return
}
function fB(e) {
  const t = nM(e),
    n = bE(t, e),
    r = bE(t.reverse(), e)
  return [n, r]
}
function nM(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden"
        return r.disabled || r.hidden || o
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP
      },
    })
  for (; n.nextNode(); ) t.push(n.currentNode)
  return t
}
function bE(e, t) {
  for (const n of e) if (!pB(n, { upTo: t })) return n
}
function pB(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0
  for (; e; ) {
    if (t !== void 0 && e === t) return !1
    if (getComputedStyle(e).display === "none") return !0
    e = e.parentElement
  }
  return !1
}
function hB(e) {
  return e instanceof HTMLInputElement && "select" in e
}
function jo(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement
    e.focus({ preventScroll: !0 }), e !== n && hB(e) && t && e.select()
  }
}
const xE = mB()
function mB() {
  let e = []
  return {
    add(t) {
      const n = e[0]
      t !== n && (n == null || n.pause()), (e = wE(e, t)), e.unshift(t)
    },
    remove(t) {
      var n
      ;(e = wE(e, t)), (n = e[0]) === null || n === void 0 || n.resume()
    },
  }
}
function wE(e, t) {
  const n = [...e],
    r = n.indexOf(t)
  return r !== -1 && n.splice(r, 1), n
}
function gB(e) {
  return e.filter((t) => t.tagName !== "A")
}
const vB = m.forwardRef((e, t) => {
  var n
  const {
    container: r = globalThis == null ||
    (n = globalThis.document) === null ||
    n === void 0
      ? void 0
      : n.body,
    ...o
  } = e
  return r
    ? vh.createPortal(m.createElement(Ls.div, qe({}, o, { ref: t })), r)
    : null
})
function yB(e, t) {
  return m.useReducer((n, r) => {
    const o = t[n][r]
    return o != null ? o : n
  }, e)
}
const Zh = (e) => {
  const { present: t, children: n } = e,
    r = bB(t),
    o =
      typeof n == "function" ? n({ present: r.isPresent }) : m.Children.only(n),
    i = Ds(r.ref, o.ref)
  return typeof n == "function" || r.isPresent
    ? m.cloneElement(o, { ref: i })
    : null
}
Zh.displayName = "Presence"
function bB(e) {
  const [t, n] = m.useState(),
    r = m.useRef({}),
    o = m.useRef(e),
    i = m.useRef("none"),
    s = e ? "mounted" : "unmounted",
    [a, l] = yB(s, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    })
  return (
    m.useEffect(() => {
      const c = bd(r.current)
      i.current = a === "mounted" ? c : "none"
    }, [a]),
    py(() => {
      const c = r.current,
        u = o.current
      if (u !== e) {
        const f = i.current,
          p = bd(c)
        e
          ? l("MOUNT")
          : p === "none" || (c == null ? void 0 : c.display) === "none"
            ? l("UNMOUNT")
            : l(u && f !== p ? "ANIMATION_OUT" : "UNMOUNT"),
          (o.current = e)
      }
    }, [e, l]),
    py(() => {
      if (t) {
        const c = (d) => {
            const p = bd(r.current).includes(d.animationName)
            d.target === t && p && Rs.flushSync(() => l("ANIMATION_END"))
          },
          u = (d) => {
            d.target === t && (i.current = bd(r.current))
          }
        return (
          t.addEventListener("animationstart", u),
          t.addEventListener("animationcancel", c),
          t.addEventListener("animationend", c),
          () => {
            t.removeEventListener("animationstart", u),
              t.removeEventListener("animationcancel", c),
              t.removeEventListener("animationend", c)
          }
        )
      } else l("ANIMATION_END")
    }, [t, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(a),
      ref: m.useCallback((c) => {
        c && (r.current = getComputedStyle(c)), n(c)
      }, []),
    }
  )
}
function bd(e) {
  return (e == null ? void 0 : e.animationName) || "none"
}
let mg = 0
function xB() {
  m.useEffect(() => {
    var e, t
    const n = document.querySelectorAll("[data-radix-focus-guard]")
    return (
      document.body.insertAdjacentElement(
        "afterbegin",
        (e = n[0]) !== null && e !== void 0 ? e : EE()
      ),
      document.body.insertAdjacentElement(
        "beforeend",
        (t = n[1]) !== null && t !== void 0 ? t : EE()
      ),
      mg++,
      () => {
        mg === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((r) => r.remove()),
          mg--
      }
    )
  }, [])
}
function EE() {
  const e = document.createElement("span")
  return (
    e.setAttribute("data-radix-focus-guard", ""),
    (e.tabIndex = 0),
    (e.style.cssText =
      "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    e
  )
}
var rM = bT(),
  gg = function () {},
  Yh = m.forwardRef(function (e, t) {
    var n = m.useRef(null),
      r = m.useState({
        onScrollCapture: gg,
        onWheelCapture: gg,
        onTouchMoveCapture: gg,
      }),
      o = r[0],
      i = r[1],
      s = e.forwardProps,
      a = e.children,
      l = e.className,
      c = e.removeScrollBar,
      u = e.enabled,
      d = e.shards,
      f = e.sideCar,
      p = e.noIsolation,
      g = e.inert,
      v = e.allowPinchZoom,
      b = e.as,
      y = b === void 0 ? "div" : b,
      x = Eb(e, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
      ]),
      E = f,
      w = yT([n, t]),
      C = en(en({}, x), o)
    return m.createElement(
      m.Fragment,
      null,
      u &&
        m.createElement(E, {
          sideCar: rM,
          removeScrollBar: c,
          shards: d,
          noIsolation: p,
          inert: g,
          setCallbacks: i,
          allowPinchZoom: !!v,
          lockRef: n,
        }),
      s
        ? m.cloneElement(m.Children.only(a), en(en({}, C), { ref: w }))
        : m.createElement(y, en({}, C, { className: l, ref: w }), a)
    )
  })
Yh.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }
Yh.classNames = { fullWidth: ac, zeroRight: sc }
var gy = !1
if (typeof window < "u")
  try {
    var xd = Object.defineProperty({}, "passive", {
      get: function () {
        return (gy = !0), !0
      },
    })
    window.addEventListener("test", xd, xd),
      window.removeEventListener("test", xd, xd)
  } catch {
    gy = !1
  }
var qs = gy ? { passive: !1 } : !1,
  wB = function (e) {
    return e.tagName === "TEXTAREA"
  },
  oM = function (e, t) {
    var n = window.getComputedStyle(e)
    return (
      n[t] !== "hidden" &&
      !(n.overflowY === n.overflowX && !wB(e) && n[t] === "visible")
    )
  },
  EB = function (e) {
    return oM(e, "overflowY")
  },
  CB = function (e) {
    return oM(e, "overflowX")
  },
  CE = function (e, t) {
    var n = t
    do {
      typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host)
      var r = iM(e, n)
      if (r) {
        var o = sM(e, n),
          i = o[1],
          s = o[2]
        if (i > s) return !0
      }
      n = n.parentNode
    } while (n && n !== document.body)
    return !1
  },
  SB = function (e) {
    var t = e.scrollTop,
      n = e.scrollHeight,
      r = e.clientHeight
    return [t, n, r]
  },
  _B = function (e) {
    var t = e.scrollLeft,
      n = e.scrollWidth,
      r = e.clientWidth
    return [t, n, r]
  },
  iM = function (e, t) {
    return e === "v" ? EB(t) : CB(t)
  },
  sM = function (e, t) {
    return e === "v" ? SB(t) : _B(t)
  },
  kB = function (e, t) {
    return e === "h" && t === "rtl" ? -1 : 1
  },
  NB = function (e, t, n, r, o) {
    var i = kB(e, window.getComputedStyle(t).direction),
      s = i * r,
      a = n.target,
      l = t.contains(a),
      c = !1,
      u = s > 0,
      d = 0,
      f = 0
    do {
      var p = sM(e, a),
        g = p[0],
        v = p[1],
        b = p[2],
        y = v - b - i * g
      ;(g || y) && iM(e, a) && ((d += y), (f += g)), (a = a.parentNode)
    } while ((!l && a !== document.body) || (l && (t.contains(a) || t === a)))
    return (
      ((u && ((o && d === 0) || (!o && s > d))) ||
        (!u && ((o && f === 0) || (!o && -s > f)))) &&
        (c = !0),
      c
    )
  },
  wd = function (e) {
    return "changedTouches" in e
      ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY]
      : [0, 0]
  },
  SE = function (e) {
    return [e.deltaX, e.deltaY]
  },
  _E = function (e) {
    return e && "current" in e ? e.current : e
  },
  TB = function (e, t) {
    return e[0] === t[0] && e[1] === t[1]
  },
  MB = function (e) {
    return `
  .block-interactivity-`
      .concat(
        e,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        e,
        ` {pointer-events: all;}
`
      )
  },
  OB = 0,
  Zs = []
function AB(e) {
  var t = m.useRef([]),
    n = m.useRef([0, 0]),
    r = m.useRef(),
    o = m.useState(OB++)[0],
    i = m.useState(function () {
      return Cb()
    })[0],
    s = m.useRef(e)
  m.useEffect(
    function () {
      s.current = e
    },
    [e]
  ),
    m.useEffect(
      function () {
        if (e.inert) {
          document.body.classList.add("block-interactivity-".concat(o))
          var v = vT([e.lockRef.current], (e.shards || []).map(_E), !0).filter(
            Boolean
          )
          return (
            v.forEach(function (b) {
              return b.classList.add("allow-interactivity-".concat(o))
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(o)),
                v.forEach(function (b) {
                  return b.classList.remove("allow-interactivity-".concat(o))
                })
            }
          )
        }
      },
      [e.inert, e.lockRef.current, e.shards]
    )
  var a = m.useCallback(function (v, b) {
      if ("touches" in v && v.touches.length === 2)
        return !s.current.allowPinchZoom
      var y = wd(v),
        x = n.current,
        E = "deltaX" in v ? v.deltaX : x[0] - y[0],
        w = "deltaY" in v ? v.deltaY : x[1] - y[1],
        C,
        S = v.target,
        M = Math.abs(E) > Math.abs(w) ? "h" : "v"
      if ("touches" in v && M === "h" && S.type === "range") return !1
      var N = CE(M, S)
      if (!N) return !0
      if ((N ? (C = M) : ((C = M === "v" ? "h" : "v"), (N = CE(M, S))), !N))
        return !1
      if (
        (!r.current && "changedTouches" in v && (E || w) && (r.current = C), !C)
      )
        return !0
      var R = r.current || C
      return NB(R, b, v, R === "h" ? E : w, !0)
    }, []),
    l = m.useCallback(function (v) {
      var b = v
      if (!(!Zs.length || Zs[Zs.length - 1] !== i)) {
        var y = "deltaY" in b ? SE(b) : wd(b),
          x = t.current.filter(function (C) {
            return C.name === b.type && C.target === b.target && TB(C.delta, y)
          })[0]
        if (x && x.should) {
          b.cancelable && b.preventDefault()
          return
        }
        if (!x) {
          var E = (s.current.shards || [])
              .map(_E)
              .filter(Boolean)
              .filter(function (C) {
                return C.contains(b.target)
              }),
            w = E.length > 0 ? a(b, E[0]) : !s.current.noIsolation
          w && b.cancelable && b.preventDefault()
        }
      }
    }, []),
    c = m.useCallback(function (v, b, y, x) {
      var E = { name: v, delta: b, target: y, should: x }
      t.current.push(E),
        setTimeout(function () {
          t.current = t.current.filter(function (w) {
            return w !== E
          })
        }, 1)
    }, []),
    u = m.useCallback(function (v) {
      ;(n.current = wd(v)), (r.current = void 0)
    }, []),
    d = m.useCallback(function (v) {
      c(v.type, SE(v), v.target, a(v, e.lockRef.current))
    }, []),
    f = m.useCallback(function (v) {
      c(v.type, wd(v), v.target, a(v, e.lockRef.current))
    }, [])
  m.useEffect(function () {
    return (
      Zs.push(i),
      e.setCallbacks({
        onScrollCapture: d,
        onWheelCapture: d,
        onTouchMoveCapture: f,
      }),
      document.addEventListener("wheel", l, qs),
      document.addEventListener("touchmove", l, qs),
      document.addEventListener("touchstart", u, qs),
      function () {
        ;(Zs = Zs.filter(function (v) {
          return v !== i
        })),
          document.removeEventListener("wheel", l, qs),
          document.removeEventListener("touchmove", l, qs),
          document.removeEventListener("touchstart", u, qs)
      }
    )
  }, [])
  var p = e.removeScrollBar,
    g = e.inert
  return m.createElement(
    m.Fragment,
    null,
    g ? m.createElement(i, { styles: MB(o) }) : null,
    p ? m.createElement(CT, { gapMode: "margin" }) : null
  )
}
const RB = wT(rM, AB)
var aM = m.forwardRef(function (e, t) {
  return m.createElement(Yh, en({}, e, { ref: t, sideCar: RB }))
})
aM.classNames = Yh.classNames
const IB = aM,
  lM = "Dialog",
  [cM, uM] = Q2(lM),
  [DB, ro] = cM(lM),
  LB = (e) => {
    const {
        __scopeDialog: t,
        children: n,
        open: r,
        defaultOpen: o,
        onOpenChange: i,
        modal: s = !0,
      } = e,
      a = m.useRef(null),
      l = m.useRef(null),
      [c = !1, u] = X8({ prop: r, defaultProp: o, onChange: i })
    return m.createElement(
      DB,
      {
        scope: t,
        triggerRef: a,
        contentRef: l,
        contentId: fg(),
        titleId: fg(),
        descriptionId: fg(),
        open: c,
        onOpenChange: u,
        onOpenToggle: m.useCallback(() => u((d) => !d), [u]),
        modal: s,
      },
      n
    )
  },
  dM = "DialogPortal",
  [PB, fM] = cM(dM, { forceMount: void 0 }),
  $B = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: o } = e,
      i = ro(dM, t)
    return m.createElement(
      PB,
      { scope: t, forceMount: n },
      m.Children.map(r, (s) =>
        m.createElement(
          Zh,
          { present: n || i.open },
          m.createElement(vB, { asChild: !0, container: o }, s)
        )
      )
    )
  },
  vy = "DialogOverlay",
  BB = m.forwardRef((e, t) => {
    const n = fM(vy, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = e,
      i = ro(vy, e.__scopeDialog)
    return i.modal
      ? m.createElement(
          Zh,
          { present: r || i.open },
          m.createElement(jB, qe({}, o, { ref: t }))
        )
      : null
  }),
  jB = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = ro(vy, n)
    return m.createElement(
      IB,
      { as: Vb, allowPinchZoom: !0, shards: [o.contentRef] },
      m.createElement(
        Ls.div,
        qe({ "data-state": mM(o.open) }, r, {
          ref: t,
          style: { pointerEvents: "auto", ...r.style },
        })
      )
    )
  }),
  qa = "DialogContent",
  FB = m.forwardRef((e, t) => {
    const n = fM(qa, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = e,
      i = ro(qa, e.__scopeDialog)
    return m.createElement(
      Zh,
      { present: r || i.open },
      i.modal
        ? m.createElement(zB, qe({}, o, { ref: t }))
        : m.createElement(UB, qe({}, o, { ref: t }))
    )
  }),
  zB = m.forwardRef((e, t) => {
    const n = ro(qa, e.__scopeDialog),
      r = m.useRef(null),
      o = Ds(t, n.contentRef, r)
    return (
      m.useEffect(() => {
        const i = r.current
        if (i) return $h(i)
      }, []),
      m.createElement(
        pM,
        qe({}, e, {
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: pi(e.onCloseAutoFocus, (i) => {
            var s
            i.preventDefault(),
              (s = n.triggerRef.current) === null || s === void 0 || s.focus()
          }),
          onPointerDownOutside: pi(e.onPointerDownOutside, (i) => {
            const s = i.detail.originalEvent,
              a = s.button === 0 && s.ctrlKey === !0
            ;(s.button === 2 || a) && i.preventDefault()
          }),
          onFocusOutside: pi(e.onFocusOutside, (i) => i.preventDefault()),
        })
      )
    )
  }),
  UB = m.forwardRef((e, t) => {
    const n = ro(qa, e.__scopeDialog),
      r = m.useRef(!1),
      o = m.useRef(!1)
    return m.createElement(
      pM,
      qe({}, e, {
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var s
          if (
            ((s = e.onCloseAutoFocus) === null || s === void 0 || s.call(e, i),
            !i.defaultPrevented)
          ) {
            var a
            r.current ||
              (a = n.triggerRef.current) === null ||
              a === void 0 ||
              a.focus(),
              i.preventDefault()
          }
          ;(r.current = !1), (o.current = !1)
        },
        onInteractOutside: (i) => {
          var s, a
          ;(s = e.onInteractOutside) === null || s === void 0 || s.call(e, i),
            i.defaultPrevented ||
              ((r.current = !0),
              i.detail.originalEvent.type === "pointerdown" && (o.current = !0))
          const l = i.target
          ;((a = n.triggerRef.current) === null || a === void 0
            ? void 0
            : a.contains(l)) && i.preventDefault(),
            i.detail.originalEvent.type === "focusin" &&
              o.current &&
              i.preventDefault()
        },
      })
    )
  }),
  pM = m.forwardRef((e, t) => {
    const {
        __scopeDialog: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        ...s
      } = e,
      a = ro(qa, n),
      l = m.useRef(null),
      c = Ds(t, l)
    return (
      xB(),
      m.createElement(
        m.Fragment,
        null,
        m.createElement(
          uB,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: i,
          },
          m.createElement(
            aB,
            qe(
              {
                role: "dialog",
                id: a.contentId,
                "aria-describedby": a.descriptionId,
                "aria-labelledby": a.titleId,
                "data-state": mM(a.open),
              },
              s,
              { ref: c, onDismiss: () => a.onOpenChange(!1) }
            )
          )
        ),
        !1
      )
    )
  }),
  hM = "DialogTitle",
  VB = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = ro(hM, n)
    return m.createElement(Ls.h2, qe({ id: o.titleId }, r, { ref: t }))
  }),
  HB = "DialogDescription",
  WB = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = ro(HB, n)
    return m.createElement(Ls.p, qe({ id: o.descriptionId }, r, { ref: t }))
  }),
  KB = "DialogClose",
  GB = m.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      o = ro(KB, n)
    return m.createElement(
      Ls.button,
      qe({ type: "button" }, r, {
        ref: t,
        onClick: pi(e.onClick, () => o.onOpenChange(!1)),
      })
    )
  })
function mM(e) {
  return e ? "open" : "closed"
}
const qB = "DialogTitleWarning",
  [ZB, Xte] = K8(qB, { contentName: qa, titleName: hM, docsSlug: "dialog" }),
  YB = LB,
  XB = $B,
  QB = BB,
  JB = FB,
  ej = VB,
  tj = WB,
  gM = GB,
  nj = "AlertDialog",
  [rj, Qte] = Q2(nj, [uM]),
  Ii = uM(),
  oj = (e) => {
    const { __scopeAlertDialog: t, ...n } = e,
      r = Ii(t)
    return m.createElement(YB, qe({}, r, n, { modal: !0 }))
  },
  ij = (e) => {
    const { __scopeAlertDialog: t, ...n } = e,
      r = Ii(t)
    return m.createElement(XB, qe({}, r, n))
  },
  sj = m.forwardRef((e, t) => {
    const { __scopeAlertDialog: n, ...r } = e,
      o = Ii(n)
    return m.createElement(QB, qe({}, o, r, { ref: t }))
  }),
  vM = "AlertDialogContent",
  [aj, lj] = rj(vM),
  cj = m.forwardRef((e, t) => {
    const { __scopeAlertDialog: n, children: r, ...o } = e,
      i = Ii(n),
      s = m.useRef(null),
      a = Ds(t, s),
      l = m.useRef(null)
    return m.createElement(
      ZB,
      { contentName: vM, titleName: uj, docsSlug: "alert-dialog" },
      m.createElement(
        aj,
        { scope: n, cancelRef: l },
        m.createElement(
          JB,
          qe({ role: "alertdialog" }, i, o, {
            ref: a,
            onOpenAutoFocus: pi(o.onOpenAutoFocus, (c) => {
              var u
              c.preventDefault(),
                (u = l.current) === null ||
                  u === void 0 ||
                  u.focus({ preventScroll: !0 })
            }),
            onPointerDownOutside: (c) => c.preventDefault(),
            onInteractOutside: (c) => c.preventDefault(),
          }),
          m.createElement(eM, null, r),
          !1
        )
      )
    )
  }),
  uj = "AlertDialogTitle",
  dj = m.forwardRef((e, t) => {
    const { __scopeAlertDialog: n, ...r } = e,
      o = Ii(n)
    return m.createElement(ej, qe({}, o, r, { ref: t }))
  }),
  fj = m.forwardRef((e, t) => {
    const { __scopeAlertDialog: n, ...r } = e,
      o = Ii(n)
    return m.createElement(tj, qe({}, o, r, { ref: t }))
  }),
  pj = m.forwardRef((e, t) => {
    const { __scopeAlertDialog: n, ...r } = e,
      o = Ii(n)
    return m.createElement(gM, qe({}, o, r, { ref: t }))
  }),
  hj = "AlertDialogCancel",
  mj = m.forwardRef((e, t) => {
    const { __scopeAlertDialog: n, ...r } = e,
      { cancelRef: o } = lj(hj, n),
      i = Ii(n),
      s = Ds(t, o)
    return m.createElement(gM, qe({}, i, r, { ref: s }))
  }),
  gj = oj,
  yM = ij,
  bM = sj,
  xM = cj,
  wM = pj,
  EM = mj,
  CM = dj,
  SM = fj,
  vj = gj,
  _M = ({ className: e, ...t }) => h.jsx(yM, { className: q(e), ...t })
_M.displayName = yM.displayName
const kM = m.forwardRef(({ className: e, children: t, ...n }, r) =>
  h.jsx(bM, {
    className: q(
      "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      e
    ),
    ...n,
    ref: r,
  })
)
kM.displayName = bM.displayName
const NM = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsxs(_M, {
    children: [
      h.jsx(kM, {}),
      h.jsx(xM, {
        ref: n,
        className: q(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full",
          e
        ),
        ...t,
      }),
    ],
  })
)
NM.displayName = xM.displayName
const TM = ({ className: e, ...t }) =>
  h.jsx("div", {
    className: q("flex flex-col space-y-2 text-center sm:text-left", e),
    ...t,
  })
TM.displayName = "AlertDialogHeader"
const MM = ({ className: e, ...t }) =>
  h.jsx("div", {
    className: q(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      e
    ),
    ...t,
  })
MM.displayName = "AlertDialogFooter"
const OM = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(CM, { ref: n, className: q("text-lg font-semibold", e), ...t })
)
OM.displayName = CM.displayName
const AM = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(SM, { ref: n, className: q("text-sm text-muted-foreground", e), ...t })
)
AM.displayName = SM.displayName
const yj = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(wM, { ref: n, className: q(rb(), e), ...t })
)
yj.displayName = wM.displayName
const RM = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(EM, {
    ref: n,
    className: q(rb({ variant: "outline" }), "mt-2 sm:mt-0", e),
    ...t,
  })
)
RM.displayName = EM.displayName
var bj = "Label",
  IM = m.forwardRef((e, t) =>
    h.jsx(Le.label, {
      ...e,
      ref: t,
      onMouseDown: (n) => {
        var o
        n.target.closest("button, input, select, textarea") ||
          ((o = e.onMouseDown) == null || o.call(e, n),
          !n.defaultPrevented && n.detail > 1 && n.preventDefault())
      },
    })
  )
IM.displayName = bj
var DM = IM
const xj = pl(
    "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
  ),
  Aa = m.forwardRef(({ className: e, ...t }, n) =>
    h.jsx(DM, { ref: n, className: q(xj(), e), ...t })
  )
Aa.displayName = DM.displayName
const wj = m$,
  LM = m.createContext({}),
  Ht = ({ ...e }) =>
    h.jsx(LM.Provider, {
      value: { name: e.name },
      children: h.jsx(b$, { ...e }),
    }),
  Xh = () => {
    const e = m.useContext(LM),
      t = m.useContext(PM),
      { getFieldState: n, formState: r } = Gh(),
      o = n(e.name, r)
    if (!e) throw new Error("useFormField should be used within <FormField>")
    const { id: i } = t
    return {
      id: i,
      name: e.name,
      formItemId: `${i}-form-item`,
      formDescriptionId: `${i}-form-item-description`,
      formMessageId: `${i}-form-item-message`,
      ...o,
    }
  },
  PM = m.createContext({}),
  Dt = m.forwardRef(({ className: e, ...t }, n) => {
    const r = m.useId()
    return h.jsx(PM.Provider, {
      value: { id: r },
      children: h.jsx("div", { ref: n, className: q("space-y-2", e), ...t }),
    })
  })
Dt.displayName = "FormItem"
const Wt = m.forwardRef(({ className: e, ...t }, n) => {
  const { error: r, formItemId: o } = Xh()
  return h.jsx(Aa, {
    ref: n,
    className: q(r && "text-destructive", e),
    htmlFor: o,
    ...t,
  })
})
Wt.displayName = "FormLabel"
const Lt = m.forwardRef(({ ...e }, t) => {
  const {
    error: n,
    formItemId: r,
    formDescriptionId: o,
    formMessageId: i,
  } = Xh()
  return h.jsx(An, {
    ref: t,
    id: r,
    "aria-describedby": n ? `${o} ${i}` : `${o}`,
    "aria-invalid": !!n,
    ...e,
  })
})
Lt.displayName = "FormControl"
const Ej = m.forwardRef(({ className: e, ...t }, n) => {
  const { formDescriptionId: r } = Xh()
  return h.jsx("p", {
    ref: n,
    id: r,
    className: q("text-sm text-muted-foreground", e),
    ...t,
  })
})
Ej.displayName = "FormDescription"
const Pt = m.forwardRef(({ className: e, children: t, ...n }, r) => {
  const { error: o, formMessageId: i } = Xh(),
    s = o ? String(o == null ? void 0 : o.message) : t
  return s
    ? h.jsx("p", {
        ref: r,
        id: i,
        className: q("text-sm font-medium text-destructive", e),
        ...n,
        children: s,
      })
    : null
})
Pt.displayName = "FormMessage"
const Cj = ({
  value: e,
  onChange: t,
  placeholder: n = " Add categories...",
}) => {
  const [r, o] = m.useState(""),
    [i, s] = m.useState([])
  m.useEffect(() => {
    s(
      e
        ? e
            .split(",")
            .map((d) => d.trim())
            .filter(Boolean)
        : []
    )
  }, [e]),
    m.useEffect(() => {
      t(i.join(", "))
    }, [i, t])
  const a = (d) => {
      ;["Enter", ","].includes(d.key) && (d.preventDefault(), l())
    },
    l = () => {
      r.trim() && (s([...i, r.trim()]), o(""))
    },
    c = (d) => {
      s(i.filter((f, p) => p !== d))
    },
    u = () => {
      s([]), o("")
    }
  return h.jsxs("div", {
    className: "space-y-2",
    children: [
      h.jsxs("div", {
        className: "flex items-center gap-2",
        children: [
          h.jsx(St, {
            value: r,
            onChange: (d) => o(d.target.value),
            onKeyDown: a,
            onBlur: l,
            placeholder: n,
            className: "flex-1",
          }),
          i.length > 0 &&
            h.jsx(et, {
              type: "button",
              variant: "ghost",
              size: "sm",
              onClick: u,
              className: "text-muted-foreground hover:text-foreground",
              children: "Clear All",
            }),
        ],
      }),
      h.jsx("div", {
        className: "flex flex-wrap gap-2",
        children: i.map((d, f) =>
          h.jsxs(
            "div",
            {
              className:
                "flex items-center gap-1 rounded-full border px-3 py-1 text-sm",
              children: [
                h.jsx("span", { children: d }),
                h.jsx("button", {
                  type: "button",
                  onClick: () => c(f),
                  className: "ml-1 rounded-full p-0.5 hover:bg-gray-200",
                  children: h.jsx(tb, { className: "h-3 w-3" }),
                }),
              ],
            },
            f
          )
        ),
      }),
    ],
  })
}
function Sj({ form: e }) {
  return h.jsxs("div", {
    className: "flex gap-5",
    children: [
      h.jsxs("div", {
        className: "relative flex flex-1 flex-col",
        children: [
          h.jsx("span", {
            className:
              "absolute -top-3 left-4 bg-background px-2 text-sm font-medium text-muted-foreground",
            children: "Name and category",
          }),
          h.jsx(Co, {
            className: "flex h-full flex-col",
            children: h.jsxs(So, {
              className: "flex flex-1 flex-col gap-4 p-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: "name",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Recipe name" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            placeholder: "Recipe name",
                            ...t,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: "category",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Recipe category" }),
                        h.jsx(Lt, {
                          children: h.jsx(Cj, {
                            value: t.value || "",
                            onChange: t.onChange,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
          }),
        ],
      }),
      h.jsxs("div", {
        className: "relative flex flex-1 flex-col",
        children: [
          h.jsx("span", {
            className:
              "absolute -top-3 left-4 bg-background px-2 text-sm font-medium text-muted-foreground",
            children: "Rating and image",
          }),
          h.jsx(Co, {
            className: "flex h-full flex-col",
            children: h.jsxs(So, {
              className: "flex flex-1 flex-col gap-4 p-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: "rating",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Recipe rating (05)" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            min: 0,
                            max: 5,
                            placeholder: "Recipe rating",
                            ...t,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: "title_image",
                  render: ({ field: { value: t, onChange: n, ...r } }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Title image" }),
                        h.jsx(Lt, {
                          children: h.jsxs("div", {
                            className: "space-y-2",
                            children: [
                              t &&
                                typeof t == "string" &&
                                h.jsxs("div", {
                                  className: "relative",
                                  children: [
                                    h.jsx("img", {
                                      src: t,
                                      alt: "Current recipe image",
                                      className:
                                        "h-40 w-full rounded-md object-cover",
                                    }),
                                    h.jsx("span", {
                                      className:
                                        "absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white",
                                      children: "Current Image",
                                    }),
                                  ],
                                }),
                              h.jsx(St, {
                                ...r,
                                type: "file",
                                accept: "image/*",
                                onChange: (o) => {
                                  var s
                                  const i =
                                    (s = o.target.files) == null ? void 0 : s[0]
                                  if (i) {
                                    const a = new FileReader()
                                    ;(a.onload = (l) => {
                                      var c
                                      n(
                                        (c = l.target) == null
                                          ? void 0
                                          : c.result
                                      )
                                    }),
                                      a.readAsDataURL(i)
                                  } else n(null)
                                },
                              }),
                              t &&
                                typeof t != "string" &&
                                h.jsxs("div", {
                                  className: "relative",
                                  children: [
                                    h.jsx("img", {
                                      src: URL.createObjectURL(t),
                                      alt: "New image preview",
                                      className:
                                        "h-40 w-full rounded-md object-cover",
                                    }),
                                    h.jsx("span", {
                                      className:
                                        "absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white",
                                      children: "New Image Preview",
                                    }),
                                  ],
                                }),
                            ],
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
          }),
        ],
      }),
      h.jsxs("div", {
        className: "relative flex flex-1 flex-col",
        children: [
          h.jsx("span", {
            className:
              "absolute -top-3 left-4 bg-background px-2 text-sm font-medium text-muted-foreground",
            children: "Preparation and cooking time",
          }),
          h.jsx(Co, {
            className: "flex h-full flex-col",
            children: h.jsxs(So, {
              className: "flex flex-1 flex-col gap-4 p-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: "prep_time",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Preparation time (minutes)" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            min: 0,
                            placeholder: "Preparation time",
                            ...t,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: "cook_time",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Cooking time (minutes)" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            min: 0,
                            placeholder: "Cooking time",
                            ...t,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
          }),
        ],
      }),
    ],
  })
}
const Au = WT,
  Ru = a7,
  $M = ({ className: e, ...t }) => h.jsx(Bh, { className: q(e), ...t })
$M.displayName = Bh.displayName
const BM = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(jh, {
    ref: n,
    className: q(
      "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      e
    ),
    ...t,
  })
)
BM.displayName = jh.displayName
const yl = m.forwardRef(({ className: e, children: t, ...n }, r) =>
  h.jsxs($M, {
    children: [
      h.jsx(BM, {}),
      h.jsxs(Fh, {
        ref: r,
        className: q(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full",
          e
        ),
        ...n,
        children: [
          t,
          h.jsxs(KT, {
            className:
              "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none",
            children: [
              h.jsx(tb, { className: "h-4 w-4" }),
              h.jsx("span", { className: "sr-only", children: "Close" }),
            ],
          }),
        ],
      }),
    ],
  })
)
yl.displayName = Fh.displayName
const bl = ({ className: e, ...t }) =>
  h.jsx("div", {
    className: q("flex flex-col space-y-1.5 text-center sm:text-left", e),
    ...t,
  })
bl.displayName = "DialogHeader"
const jM = ({ className: e, ...t }) =>
  h.jsx("div", {
    className: q(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      e
    ),
    ...t,
  })
jM.displayName = "DialogFooter"
const xl = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(zh, {
    ref: n,
    className: q("text-lg font-semibold leading-none tracking-tight", e),
    ...t,
  })
)
xl.displayName = zh.displayName
const Hb = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(Uh, { ref: n, className: q("text-sm text-muted-foreground", e), ...t })
)
Hb.displayName = Uh.displayName
function Vt(e) {
  this.content = e
}
Vt.prototype = {
  constructor: Vt,
  find: function (e) {
    for (var t = 0; t < this.content.length; t += 2)
      if (this.content[t] === e) return t
    return -1
  },
  get: function (e) {
    var t = this.find(e)
    return t == -1 ? void 0 : this.content[t + 1]
  },
  update: function (e, t, n) {
    var r = n && n != e ? this.remove(n) : this,
      o = r.find(e),
      i = r.content.slice()
    return (
      o == -1 ? i.push(n || e, t) : ((i[o + 1] = t), n && (i[o] = n)), new Vt(i)
    )
  },
  remove: function (e) {
    var t = this.find(e)
    if (t == -1) return this
    var n = this.content.slice()
    return n.splice(t, 2), new Vt(n)
  },
  addToStart: function (e, t) {
    return new Vt([e, t].concat(this.remove(e).content))
  },
  addToEnd: function (e, t) {
    var n = this.remove(e).content.slice()
    return n.push(e, t), new Vt(n)
  },
  addBefore: function (e, t, n) {
    var r = this.remove(t),
      o = r.content.slice(),
      i = r.find(e)
    return o.splice(i == -1 ? o.length : i, 0, t, n), new Vt(o)
  },
  forEach: function (e) {
    for (var t = 0; t < this.content.length; t += 2)
      e(this.content[t], this.content[t + 1])
  },
  prepend: function (e) {
    return (
      (e = Vt.from(e)),
      e.size ? new Vt(e.content.concat(this.subtract(e).content)) : this
    )
  },
  append: function (e) {
    return (
      (e = Vt.from(e)),
      e.size ? new Vt(this.subtract(e).content.concat(e.content)) : this
    )
  },
  subtract: function (e) {
    var t = this
    e = Vt.from(e)
    for (var n = 0; n < e.content.length; n += 2) t = t.remove(e.content[n])
    return t
  },
  toObject: function () {
    var e = {}
    return (
      this.forEach(function (t, n) {
        e[t] = n
      }),
      e
    )
  },
  get size() {
    return this.content.length >> 1
  },
}
Vt.from = function (e) {
  if (e instanceof Vt) return e
  var t = []
  if (e) for (var n in e) t.push(n, e[n])
  return new Vt(t)
}
function FM(e, t, n) {
  for (let r = 0; ; r++) {
    if (r == e.childCount || r == t.childCount)
      return e.childCount == t.childCount ? null : n
    let o = e.child(r),
      i = t.child(r)
    if (o == i) {
      n += o.nodeSize
      continue
    }
    if (!o.sameMarkup(i)) return n
    if (o.isText && o.text != i.text) {
      for (let s = 0; o.text[s] == i.text[s]; s++) n++
      return n
    }
    if (o.content.size || i.content.size) {
      let s = FM(o.content, i.content, n + 1)
      if (s != null) return s
    }
    n += o.nodeSize
  }
}
function zM(e, t, n, r) {
  for (let o = e.childCount, i = t.childCount; ; ) {
    if (o == 0 || i == 0) return o == i ? null : { a: n, b: r }
    let s = e.child(--o),
      a = t.child(--i),
      l = s.nodeSize
    if (s == a) {
      ;(n -= l), (r -= l)
      continue
    }
    if (!s.sameMarkup(a)) return { a: n, b: r }
    if (s.isText && s.text != a.text) {
      let c = 0,
        u = Math.min(s.text.length, a.text.length)
      for (
        ;
        c < u && s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1];

      )
        c++, n--, r--
      return { a: n, b: r }
    }
    if (s.content.size || a.content.size) {
      let c = zM(s.content, a.content, n - 1, r - 1)
      if (c) return c
    }
    ;(n -= l), (r -= l)
  }
}
class Z {
  constructor(t, n) {
    if (((this.content = t), (this.size = n || 0), n == null))
      for (let r = 0; r < t.length; r++) this.size += t[r].nodeSize
  }
  nodesBetween(t, n, r, o = 0, i) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s],
        c = a + l.nodeSize
      if (c > t && r(l, o + a, i || null, s) !== !1 && l.content.size) {
        let u = a + 1
        l.nodesBetween(
          Math.max(0, t - u),
          Math.min(l.content.size, n - u),
          r,
          o + u
        )
      }
      a = c
    }
  }
  descendants(t) {
    this.nodesBetween(0, this.size, t)
  }
  textBetween(t, n, r, o) {
    let i = "",
      s = !0
    return (
      this.nodesBetween(
        t,
        n,
        (a, l) => {
          let c = a.isText
            ? a.text.slice(Math.max(t, l) - l, n - l)
            : a.isLeaf
              ? o
                ? typeof o == "function"
                  ? o(a)
                  : o
                : a.type.spec.leafText
                  ? a.type.spec.leafText(a)
                  : ""
              : ""
          a.isBlock &&
            ((a.isLeaf && c) || a.isTextblock) &&
            r &&
            (s ? (s = !1) : (i += r)),
            (i += c)
        },
        0
      ),
      i
    )
  }
  append(t) {
    if (!t.size) return this
    if (!this.size) return t
    let n = this.lastChild,
      r = t.firstChild,
      o = this.content.slice(),
      i = 0
    for (
      n.isText &&
      n.sameMarkup(r) &&
      ((o[o.length - 1] = n.withText(n.text + r.text)), (i = 1));
      i < t.content.length;
      i++
    )
      o.push(t.content[i])
    return new Z(o, this.size + t.size)
  }
  cut(t, n = this.size) {
    if (t == 0 && n == this.size) return this
    let r = [],
      o = 0
    if (n > t)
      for (let i = 0, s = 0; s < n; i++) {
        let a = this.content[i],
          l = s + a.nodeSize
        l > t &&
          ((s < t || l > n) &&
            (a.isText
              ? (a = a.cut(Math.max(0, t - s), Math.min(a.text.length, n - s)))
              : (a = a.cut(
                  Math.max(0, t - s - 1),
                  Math.min(a.content.size, n - s - 1)
                ))),
          r.push(a),
          (o += a.nodeSize)),
          (s = l)
      }
    return new Z(r, o)
  }
  cutByIndex(t, n) {
    return t == n
      ? Z.empty
      : t == 0 && n == this.content.length
        ? this
        : new Z(this.content.slice(t, n))
  }
  replaceChild(t, n) {
    let r = this.content[t]
    if (r == n) return this
    let o = this.content.slice(),
      i = this.size + n.nodeSize - r.nodeSize
    return (o[t] = n), new Z(o, i)
  }
  addToStart(t) {
    return new Z([t].concat(this.content), this.size + t.nodeSize)
  }
  addToEnd(t) {
    return new Z(this.content.concat(t), this.size + t.nodeSize)
  }
  eq(t) {
    if (this.content.length != t.content.length) return !1
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(t.content[n])) return !1
    return !0
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null
  }
  get childCount() {
    return this.content.length
  }
  child(t) {
    let n = this.content[t]
    if (!n) throw new RangeError("Index " + t + " out of range for " + this)
    return n
  }
  maybeChild(t) {
    return this.content[t] || null
  }
  forEach(t) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let o = this.content[n]
      t(o, r, n), (r += o.nodeSize)
    }
  }
  findDiffStart(t, n = 0) {
    return FM(this, t, n)
  }
  findDiffEnd(t, n = this.size, r = t.size) {
    return zM(this, t, n, r)
  }
  findIndex(t, n = -1) {
    if (t == 0) return Ed(0, t)
    if (t == this.size) return Ed(this.content.length, t)
    if (t > this.size || t < 0)
      throw new RangeError(`Position ${t} outside of fragment (${this})`)
    for (let r = 0, o = 0; ; r++) {
      let i = this.child(r),
        s = o + i.nodeSize
      if (s >= t) return s == t || n > 0 ? Ed(r + 1, s) : Ed(r, o)
      o = s
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">"
  }
  toStringInner() {
    return this.content.join(", ")
  }
  toJSON() {
    return this.content.length ? this.content.map((t) => t.toJSON()) : null
  }
  static fromJSON(t, n) {
    if (!n) return Z.empty
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON")
    return new Z(n.map(t.nodeFromJSON))
  }
  static fromArray(t) {
    if (!t.length) return Z.empty
    let n,
      r = 0
    for (let o = 0; o < t.length; o++) {
      let i = t[o]
      ;(r += i.nodeSize),
        o && i.isText && t[o - 1].sameMarkup(i)
          ? (n || (n = t.slice(0, o)),
            (n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)))
          : n && n.push(i)
    }
    return new Z(n || t, r)
  }
  static from(t) {
    if (!t) return Z.empty
    if (t instanceof Z) return t
    if (Array.isArray(t)) return this.fromArray(t)
    if (t.attrs) return new Z([t], t.nodeSize)
    throw new RangeError(
      "Can not convert " +
        t +
        " to a Fragment" +
        (t.nodesBetween
          ? " (looks like multiple versions of prosemirror-model were loaded)"
          : "")
    )
  }
}
Z.empty = new Z([], 0)
const vg = { index: 0, offset: 0 }
function Ed(e, t) {
  return (vg.index = e), (vg.offset = t), vg
}
function ep(e, t) {
  if (e === t) return !0
  if (!(e && typeof e == "object") || !(t && typeof t == "object")) return !1
  let n = Array.isArray(e)
  if (Array.isArray(t) != n) return !1
  if (n) {
    if (e.length != t.length) return !1
    for (let r = 0; r < e.length; r++) if (!ep(e[r], t[r])) return !1
  } else {
    for (let r in e) if (!(r in t) || !ep(e[r], t[r])) return !1
    for (let r in t) if (!(r in e)) return !1
  }
  return !0
}
let Ke = class yy {
  constructor(t, n) {
    ;(this.type = t), (this.attrs = n)
  }
  addToSet(t) {
    let n,
      r = !1
    for (let o = 0; o < t.length; o++) {
      let i = t[o]
      if (this.eq(i)) return t
      if (this.type.excludes(i.type)) n || (n = t.slice(0, o))
      else {
        if (i.type.excludes(this.type)) return t
        !r &&
          i.type.rank > this.type.rank &&
          (n || (n = t.slice(0, o)), n.push(this), (r = !0)),
          n && n.push(i)
      }
    }
    return n || (n = t.slice()), r || n.push(this), n
  }
  removeFromSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n])) return t.slice(0, n).concat(t.slice(n + 1))
    return t
  }
  isInSet(t) {
    for (let n = 0; n < t.length; n++) if (this.eq(t[n])) return !0
    return !1
  }
  eq(t) {
    return this == t || (this.type == t.type && ep(this.attrs, t.attrs))
  }
  toJSON() {
    let t = { type: this.type.name }
    for (let n in this.attrs) {
      t.attrs = this.attrs
      break
    }
    return t
  }
  static fromJSON(t, n) {
    if (!n) throw new RangeError("Invalid input for Mark.fromJSON")
    let r = t.marks[n.type]
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`)
    let o = r.create(n.attrs)
    return r.checkAttrs(o.attrs), o
  }
  static sameSet(t, n) {
    if (t == n) return !0
    if (t.length != n.length) return !1
    for (let r = 0; r < t.length; r++) if (!t[r].eq(n[r])) return !1
    return !0
  }
  static setFrom(t) {
    if (!t || (Array.isArray(t) && t.length == 0)) return yy.none
    if (t instanceof yy) return [t]
    let n = t.slice()
    return n.sort((r, o) => r.type.rank - o.type.rank), n
  }
}
Ke.none = []
class tp extends Error {}
class oe {
  constructor(t, n, r) {
    ;(this.content = t), (this.openStart = n), (this.openEnd = r)
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd
  }
  insertAt(t, n) {
    let r = VM(this.content, t + this.openStart, n)
    return r && new oe(r, this.openStart, this.openEnd)
  }
  removeBetween(t, n) {
    return new oe(
      UM(this.content, t + this.openStart, n + this.openStart),
      this.openStart,
      this.openEnd
    )
  }
  eq(t) {
    return (
      this.content.eq(t.content) &&
      this.openStart == t.openStart &&
      this.openEnd == t.openEnd
    )
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")"
  }
  toJSON() {
    if (!this.content.size) return null
    let t = { content: this.content.toJSON() }
    return (
      this.openStart > 0 && (t.openStart = this.openStart),
      this.openEnd > 0 && (t.openEnd = this.openEnd),
      t
    )
  }
  static fromJSON(t, n) {
    if (!n) return oe.empty
    let r = n.openStart || 0,
      o = n.openEnd || 0
    if (typeof r != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON")
    return new oe(Z.fromJSON(t, n.content), r, o)
  }
  static maxOpen(t, n = !0) {
    let r = 0,
      o = 0
    for (
      let i = t.firstChild;
      i && !i.isLeaf && (n || !i.type.spec.isolating);
      i = i.firstChild
    )
      r++
    for (
      let i = t.lastChild;
      i && !i.isLeaf && (n || !i.type.spec.isolating);
      i = i.lastChild
    )
      o++
    return new oe(t, r, o)
  }
}
oe.empty = new oe(Z.empty, 0, 0)
function UM(e, t, n) {
  let { index: r, offset: o } = e.findIndex(t),
    i = e.maybeChild(r),
    { index: s, offset: a } = e.findIndex(n)
  if (o == t || i.isText) {
    if (a != n && !e.child(s).isText)
      throw new RangeError("Removing non-flat range")
    return e.cut(0, t).append(e.cut(n))
  }
  if (r != s) throw new RangeError("Removing non-flat range")
  return e.replaceChild(r, i.copy(UM(i.content, t - o - 1, n - o - 1)))
}
function VM(e, t, n, r) {
  let { index: o, offset: i } = e.findIndex(t),
    s = e.maybeChild(o)
  if (i == t || s.isText)
    return r && !r.canReplace(o, o, n)
      ? null
      : e.cut(0, t).append(n).append(e.cut(t))
  let a = VM(s.content, t - i - 1, n)
  return a && e.replaceChild(o, s.copy(a))
}
function _j(e, t, n) {
  if (n.openStart > e.depth)
    throw new tp("Inserted content deeper than insertion position")
  if (e.depth - n.openStart != t.depth - n.openEnd)
    throw new tp("Inconsistent open depths")
  return HM(e, t, n, 0)
}
function HM(e, t, n, r) {
  let o = e.index(r),
    i = e.node(r)
  if (o == t.index(r) && r < e.depth - n.openStart) {
    let s = HM(e, t, n, r + 1)
    return i.copy(i.content.replaceChild(o, s))
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
      let s = e.parent,
        a = s.content
      return is(
        s,
        a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset))
      )
    } else {
      let { start: s, end: a } = kj(n, e)
      return is(i, KM(e, s, a, t, r))
    }
  else return is(i, np(e, t, r))
}
function WM(e, t) {
  if (!t.type.compatibleContent(e.type))
    throw new tp("Cannot join " + t.type.name + " onto " + e.type.name)
}
function by(e, t, n) {
  let r = e.node(n)
  return WM(r, t.node(n)), r
}
function rs(e, t) {
  let n = t.length - 1
  n >= 0 && e.isText && e.sameMarkup(t[n])
    ? (t[n] = e.withText(t[n].text + e.text))
    : t.push(e)
}
function uc(e, t, n, r) {
  let o = (t || e).node(n),
    i = 0,
    s = t ? t.index(n) : o.childCount
  e &&
    ((i = e.index(n)),
    e.depth > n ? i++ : e.textOffset && (rs(e.nodeAfter, r), i++))
  for (let a = i; a < s; a++) rs(o.child(a), r)
  t && t.depth == n && t.textOffset && rs(t.nodeBefore, r)
}
function is(e, t) {
  return e.type.checkContent(t), e.copy(t)
}
function KM(e, t, n, r, o) {
  let i = e.depth > o && by(e, t, o + 1),
    s = r.depth > o && by(n, r, o + 1),
    a = []
  return (
    uc(null, e, o, a),
    i && s && t.index(o) == n.index(o)
      ? (WM(i, s), rs(is(i, KM(e, t, n, r, o + 1)), a))
      : (i && rs(is(i, np(e, t, o + 1)), a),
        uc(t, n, o, a),
        s && rs(is(s, np(n, r, o + 1)), a)),
    uc(r, null, o, a),
    new Z(a)
  )
}
function np(e, t, n) {
  let r = []
  if ((uc(null, e, n, r), e.depth > n)) {
    let o = by(e, t, n + 1)
    rs(is(o, np(e, t, n + 1)), r)
  }
  return uc(t, null, n, r), new Z(r)
}
function kj(e, t) {
  let n = t.depth - e.openStart,
    o = t.node(n).copy(e.content)
  for (let i = n - 1; i >= 0; i--) o = t.node(i).copy(Z.from(o))
  return {
    start: o.resolveNoCache(e.openStart + n),
    end: o.resolveNoCache(o.content.size - e.openEnd - n),
  }
}
class tu {
  constructor(t, n, r) {
    ;(this.pos = t),
      (this.path = n),
      (this.parentOffset = r),
      (this.depth = n.length / 3 - 1)
  }
  resolveDepth(t) {
    return t == null ? this.depth : t < 0 ? this.depth + t : t
  }
  get parent() {
    return this.node(this.depth)
  }
  get doc() {
    return this.node(0)
  }
  node(t) {
    return this.path[this.resolveDepth(t) * 3]
  }
  index(t) {
    return this.path[this.resolveDepth(t) * 3 + 1]
  }
  indexAfter(t) {
    return (
      (t = this.resolveDepth(t)),
      this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1)
    )
  }
  start(t) {
    return (t = this.resolveDepth(t)), t == 0 ? 0 : this.path[t * 3 - 1] + 1
  }
  end(t) {
    return (t = this.resolveDepth(t)), this.start(t) + this.node(t).content.size
  }
  before(t) {
    if (((t = this.resolveDepth(t)), !t))
      throw new RangeError("There is no position before the top-level node")
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1]
  }
  after(t) {
    if (((t = this.resolveDepth(t)), !t))
      throw new RangeError("There is no position after the top-level node")
    return t == this.depth + 1
      ? this.pos
      : this.path[t * 3 - 1] + this.path[t * 3].nodeSize
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1]
  }
  get nodeAfter() {
    let t = this.parent,
      n = this.index(this.depth)
    if (n == t.childCount) return null
    let r = this.pos - this.path[this.path.length - 1],
      o = t.child(n)
    return r ? t.child(n).cut(r) : o
  }
  get nodeBefore() {
    let t = this.index(this.depth),
      n = this.pos - this.path[this.path.length - 1]
    return n
      ? this.parent.child(t).cut(0, n)
      : t == 0
        ? null
        : this.parent.child(t - 1)
  }
  posAtIndex(t, n) {
    n = this.resolveDepth(n)
    let r = this.path[n * 3],
      o = n == 0 ? 0 : this.path[n * 3 - 1] + 1
    for (let i = 0; i < t; i++) o += r.child(i).nodeSize
    return o
  }
  marks() {
    let t = this.parent,
      n = this.index()
    if (t.content.size == 0) return Ke.none
    if (this.textOffset) return t.child(n).marks
    let r = t.maybeChild(n - 1),
      o = t.maybeChild(n)
    if (!r) {
      let a = r
      ;(r = o), (o = a)
    }
    let i = r.marks
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 &&
        (!o || !i[s].isInSet(o.marks)) &&
        (i = i[s--].removeFromSet(i))
    return i
  }
  marksAcross(t) {
    let n = this.parent.maybeChild(this.index())
    if (!n || !n.isInline) return null
    let r = n.marks,
      o = t.parent.maybeChild(t.index())
    for (var i = 0; i < r.length; i++)
      r[i].type.spec.inclusive === !1 &&
        (!o || !r[i].isInSet(o.marks)) &&
        (r = r[i--].removeFromSet(r))
    return r
  }
  sharedDepth(t) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= t && this.end(n) >= t) return n
    return 0
  }
  blockRange(t = this, n) {
    if (t.pos < this.pos) return t.blockRange(this)
    for (
      let r =
        this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0);
      r >= 0;
      r--
    )
      if (t.pos <= this.end(r) && (!n || n(this.node(r))))
        return new rp(this, t, r)
    return null
  }
  sameParent(t) {
    return this.pos - this.parentOffset == t.pos - t.parentOffset
  }
  max(t) {
    return t.pos > this.pos ? t : this
  }
  min(t) {
    return t.pos < this.pos ? t : this
  }
  toString() {
    let t = ""
    for (let n = 1; n <= this.depth; n++)
      t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1)
    return t + ":" + this.parentOffset
  }
  static resolve(t, n) {
    if (!(n >= 0 && n <= t.content.size))
      throw new RangeError("Position " + n + " out of range")
    let r = [],
      o = 0,
      i = n
    for (let s = t; ; ) {
      let { index: a, offset: l } = s.content.findIndex(i),
        c = i - l
      if ((r.push(s, a, o + l), !c || ((s = s.child(a)), s.isText))) break
      ;(i = c - 1), (o += l + 1)
    }
    return new tu(n, r, i)
  }
  static resolveCached(t, n) {
    let r = kE.get(t)
    if (r)
      for (let i = 0; i < r.elts.length; i++) {
        let s = r.elts[i]
        if (s.pos == n) return s
      }
    else kE.set(t, (r = new Nj()))
    let o = (r.elts[r.i] = tu.resolve(t, n))
    return (r.i = (r.i + 1) % Tj), o
  }
}
class Nj {
  constructor() {
    ;(this.elts = []), (this.i = 0)
  }
}
const Tj = 12,
  kE = new WeakMap()
class rp {
  constructor(t, n, r) {
    ;(this.$from = t), (this.$to = n), (this.depth = r)
  }
  get start() {
    return this.$from.before(this.depth + 1)
  }
  get end() {
    return this.$to.after(this.depth + 1)
  }
  get parent() {
    return this.$from.node(this.depth)
  }
  get startIndex() {
    return this.$from.index(this.depth)
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth)
  }
}
const Mj = Object.create(null)
let hi = class xy {
  constructor(t, n, r, o = Ke.none) {
    ;(this.type = t),
      (this.attrs = n),
      (this.marks = o),
      (this.content = r || Z.empty)
  }
  get children() {
    return this.content.content
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size
  }
  get childCount() {
    return this.content.childCount
  }
  child(t) {
    return this.content.child(t)
  }
  maybeChild(t) {
    return this.content.maybeChild(t)
  }
  forEach(t) {
    this.content.forEach(t)
  }
  nodesBetween(t, n, r, o = 0) {
    this.content.nodesBetween(t, n, r, o, this)
  }
  descendants(t) {
    this.nodesBetween(0, this.content.size, t)
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText
      ? this.type.spec.leafText(this)
      : this.textBetween(0, this.content.size, "")
  }
  textBetween(t, n, r, o) {
    return this.content.textBetween(t, n, r, o)
  }
  get firstChild() {
    return this.content.firstChild
  }
  get lastChild() {
    return this.content.lastChild
  }
  eq(t) {
    return this == t || (this.sameMarkup(t) && this.content.eq(t.content))
  }
  sameMarkup(t) {
    return this.hasMarkup(t.type, t.attrs, t.marks)
  }
  hasMarkup(t, n, r) {
    return (
      this.type == t &&
      ep(this.attrs, n || t.defaultAttrs || Mj) &&
      Ke.sameSet(this.marks, r || Ke.none)
    )
  }
  copy(t = null) {
    return t == this.content
      ? this
      : new xy(this.type, this.attrs, t, this.marks)
  }
  mark(t) {
    return t == this.marks
      ? this
      : new xy(this.type, this.attrs, this.content, t)
  }
  cut(t, n = this.content.size) {
    return t == 0 && n == this.content.size
      ? this
      : this.copy(this.content.cut(t, n))
  }
  slice(t, n = this.content.size, r = !1) {
    if (t == n) return oe.empty
    let o = this.resolve(t),
      i = this.resolve(n),
      s = r ? 0 : o.sharedDepth(n),
      a = o.start(s),
      c = o.node(s).content.cut(o.pos - a, i.pos - a)
    return new oe(c, o.depth - s, i.depth - s)
  }
  replace(t, n, r) {
    return _j(this.resolve(t), this.resolve(n), r)
  }
  nodeAt(t) {
    for (let n = this; ; ) {
      let { index: r, offset: o } = n.content.findIndex(t)
      if (((n = n.maybeChild(r)), !n)) return null
      if (o == t || n.isText) return n
      t -= o + 1
    }
  }
  childAfter(t) {
    let { index: n, offset: r } = this.content.findIndex(t)
    return { node: this.content.maybeChild(n), index: n, offset: r }
  }
  childBefore(t) {
    if (t == 0) return { node: null, index: 0, offset: 0 }
    let { index: n, offset: r } = this.content.findIndex(t)
    if (r < t) return { node: this.content.child(n), index: n, offset: r }
    let o = this.content.child(n - 1)
    return { node: o, index: n - 1, offset: r - o.nodeSize }
  }
  resolve(t) {
    return tu.resolveCached(this, t)
  }
  resolveNoCache(t) {
    return tu.resolve(this, t)
  }
  rangeHasMark(t, n, r) {
    let o = !1
    return (
      n > t &&
        this.nodesBetween(t, n, (i) => (r.isInSet(i.marks) && (o = !0), !o)),
      o
    )
  }
  get isBlock() {
    return this.type.isBlock
  }
  get isTextblock() {
    return this.type.isTextblock
  }
  get inlineContent() {
    return this.type.inlineContent
  }
  get isInline() {
    return this.type.isInline
  }
  get isText() {
    return this.type.isText
  }
  get isLeaf() {
    return this.type.isLeaf
  }
  get isAtom() {
    return this.type.isAtom
  }
  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)
    let t = this.type.name
    return (
      this.content.size && (t += "(" + this.content.toStringInner() + ")"),
      GM(this.marks, t)
    )
  }
  contentMatchAt(t) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, t)
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content")
    return n
  }
  canReplace(t, n, r = Z.empty, o = 0, i = r.childCount) {
    let s = this.contentMatchAt(t).matchFragment(r, o, i),
      a = s && s.matchFragment(this.content, n)
    if (!a || !a.validEnd) return !1
    for (let l = o; l < i; l++)
      if (!this.type.allowsMarks(r.child(l).marks)) return !1
    return !0
  }
  canReplaceWith(t, n, r, o) {
    if (o && !this.type.allowsMarks(o)) return !1
    let i = this.contentMatchAt(t).matchType(r),
      s = i && i.matchFragment(this.content, n)
    return s ? s.validEnd : !1
  }
  canAppend(t) {
    return t.content.size
      ? this.canReplace(this.childCount, this.childCount, t.content)
      : this.type.compatibleContent(t.type)
  }
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs)
    let t = Ke.none
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n]
      r.type.checkAttrs(r.attrs), (t = r.addToSet(t))
    }
    if (!Ke.sameSet(t, this.marks))
      throw new RangeError(
        `Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`
      )
    this.content.forEach((n) => n.check())
  }
  toJSON() {
    let t = { type: this.type.name }
    for (let n in this.attrs) {
      t.attrs = this.attrs
      break
    }
    return (
      this.content.size && (t.content = this.content.toJSON()),
      this.marks.length && (t.marks = this.marks.map((n) => n.toJSON())),
      t
    )
  }
  static fromJSON(t, n) {
    if (!n) throw new RangeError("Invalid input for Node.fromJSON")
    let r
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON")
      r = n.marks.map(t.markFromJSON)
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON")
      return t.text(n.text, r)
    }
    let o = Z.fromJSON(t, n.content),
      i = t.nodeType(n.type).create(n.attrs, o, r)
    return i.type.checkAttrs(i.attrs), i
  }
}
hi.prototype.text = void 0
class op extends hi {
  constructor(t, n, r, o) {
    if ((super(t, n, null, o), !r))
      throw new RangeError("Empty text nodes are not allowed")
    this.text = r
  }
  toString() {
    return this.type.spec.toDebugString
      ? this.type.spec.toDebugString(this)
      : GM(this.marks, JSON.stringify(this.text))
  }
  get textContent() {
    return this.text
  }
  textBetween(t, n) {
    return this.text.slice(t, n)
  }
  get nodeSize() {
    return this.text.length
  }
  mark(t) {
    return t == this.marks ? this : new op(this.type, this.attrs, this.text, t)
  }
  withText(t) {
    return t == this.text ? this : new op(this.type, this.attrs, t, this.marks)
  }
  cut(t = 0, n = this.text.length) {
    return t == 0 && n == this.text.length
      ? this
      : this.withText(this.text.slice(t, n))
  }
  eq(t) {
    return this.sameMarkup(t) && this.text == t.text
  }
  toJSON() {
    let t = super.toJSON()
    return (t.text = this.text), t
  }
}
function GM(e, t) {
  for (let n = e.length - 1; n >= 0; n--) t = e[n].type.name + "(" + t + ")"
  return t
}
class _s {
  constructor(t) {
    ;(this.validEnd = t), (this.next = []), (this.wrapCache = [])
  }
  static parse(t, n) {
    let r = new Oj(t, n)
    if (r.next == null) return _s.empty
    let o = qM(r)
    r.next && r.err("Unexpected trailing text")
    let i = $j(Pj(o))
    return Bj(i, r), i
  }
  matchType(t) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == t) return this.next[n].next
    return null
  }
  matchFragment(t, n = 0, r = t.childCount) {
    let o = this
    for (let i = n; o && i < r; i++) o = o.matchType(t.child(i).type)
    return o
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline
  }
  get defaultType() {
    for (let t = 0; t < this.next.length; t++) {
      let { type: n } = this.next[t]
      if (!(n.isText || n.hasRequiredAttrs())) return n
    }
    return null
  }
  compatible(t) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < t.next.length; r++)
        if (this.next[n].type == t.next[r].type) return !0
    return !1
  }
  fillBefore(t, n = !1, r = 0) {
    let o = [this]
    function i(s, a) {
      let l = s.matchFragment(t, r)
      if (l && (!n || l.validEnd))
        return Z.from(a.map((c) => c.createAndFill()))
      for (let c = 0; c < s.next.length; c++) {
        let { type: u, next: d } = s.next[c]
        if (!(u.isText || u.hasRequiredAttrs()) && o.indexOf(d) == -1) {
          o.push(d)
          let f = i(d, a.concat(u))
          if (f) return f
        }
      }
      return null
    }
    return i(this, [])
  }
  findWrapping(t) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == t) return this.wrapCache[r + 1]
    let n = this.computeWrapping(t)
    return this.wrapCache.push(t, n), n
  }
  computeWrapping(t) {
    let n = Object.create(null),
      r = [{ match: this, type: null, via: null }]
    for (; r.length; ) {
      let o = r.shift(),
        i = o.match
      if (i.matchType(t)) {
        let s = []
        for (let a = o; a.type; a = a.via) s.push(a.type)
        return s.reverse()
      }
      for (let s = 0; s < i.next.length; s++) {
        let { type: a, next: l } = i.next[s]
        !a.isLeaf &&
          !a.hasRequiredAttrs() &&
          !(a.name in n) &&
          (!o.type || l.validEnd) &&
          (r.push({ match: a.contentMatch, type: a, via: o }), (n[a.name] = !0))
      }
    }
    return null
  }
  get edgeCount() {
    return this.next.length
  }
  edge(t) {
    if (t >= this.next.length)
      throw new RangeError(`There's no ${t}th edge in this content match`)
    return this.next[t]
  }
  toString() {
    let t = []
    function n(r) {
      t.push(r)
      for (let o = 0; o < r.next.length; o++)
        t.indexOf(r.next[o].next) == -1 && n(r.next[o].next)
    }
    return (
      n(this),
      t.map((r, o) => {
        let i = o + (r.validEnd ? "*" : " ") + " "
        for (let s = 0; s < r.next.length; s++)
          i +=
            (s ? ", " : "") +
            r.next[s].type.name +
            "->" +
            t.indexOf(r.next[s].next)
        return i
      }).join(`
`)
    )
  }
}
_s.empty = new _s(!0)
class Oj {
  constructor(t, n) {
    ;(this.string = t),
      (this.nodeTypes = n),
      (this.inline = null),
      (this.pos = 0),
      (this.tokens = t.split(/\s*(?=\b|\W|$)/)),
      this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
      this.tokens[0] == "" && this.tokens.shift()
  }
  get next() {
    return this.tokens[this.pos]
  }
  eat(t) {
    return this.next == t && (this.pos++ || !0)
  }
  err(t) {
    throw new SyntaxError(t + " (in content expression '" + this.string + "')")
  }
}
function qM(e) {
  let t = []
  do t.push(Aj(e))
  while (e.eat("|"))
  return t.length == 1 ? t[0] : { type: "choice", exprs: t }
}
function Aj(e) {
  let t = []
  do t.push(Rj(e))
  while (e.next && e.next != ")" && e.next != "|")
  return t.length == 1 ? t[0] : { type: "seq", exprs: t }
}
function Rj(e) {
  let t = Lj(e)
  for (;;)
    if (e.eat("+")) t = { type: "plus", expr: t }
    else if (e.eat("*")) t = { type: "star", expr: t }
    else if (e.eat("?")) t = { type: "opt", expr: t }
    else if (e.eat("{")) t = Ij(e, t)
    else break
  return t
}
function NE(e) {
  ;/\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'")
  let t = Number(e.next)
  return e.pos++, t
}
function Ij(e, t) {
  let n = NE(e),
    r = n
  return (
    e.eat(",") && (e.next != "}" ? (r = NE(e)) : (r = -1)),
    e.eat("}") || e.err("Unclosed braced range"),
    { type: "range", min: n, max: r, expr: t }
  )
}
function Dj(e, t) {
  let n = e.nodeTypes,
    r = n[t]
  if (r) return [r]
  let o = []
  for (let i in n) {
    let s = n[i]
    s.isInGroup(t) && o.push(s)
  }
  return o.length == 0 && e.err("No node type or group '" + t + "' found"), o
}
function Lj(e) {
  if (e.eat("(")) {
    let t = qM(e)
    return e.eat(")") || e.err("Missing closing paren"), t
  } else if (/\W/.test(e.next)) e.err("Unexpected token '" + e.next + "'")
  else {
    let t = Dj(e, e.next).map(
      (n) => (
        e.inline == null
          ? (e.inline = n.isInline)
          : e.inline != n.isInline && e.err("Mixing inline and block content"),
        { type: "name", value: n }
      )
    )
    return e.pos++, t.length == 1 ? t[0] : { type: "choice", exprs: t }
  }
}
function Pj(e) {
  let t = [[]]
  return o(i(e, 0), n()), t
  function n() {
    return t.push([]) - 1
  }
  function r(s, a, l) {
    let c = { term: l, to: a }
    return t[s].push(c), c
  }
  function o(s, a) {
    s.forEach((l) => (l.to = a))
  }
  function i(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, c) => l.concat(i(c, a)), [])
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let c = i(s.exprs[l], a)
        if (l == s.exprs.length - 1) return c
        o(c, (a = n()))
      }
    else if (s.type == "star") {
      let l = n()
      return r(a, l), o(i(s.expr, l), l), [r(l)]
    } else if (s.type == "plus") {
      let l = n()
      return o(i(s.expr, a), l), o(i(s.expr, l), l), [r(l)]
    } else {
      if (s.type == "opt") return [r(a)].concat(i(s.expr, a))
      if (s.type == "range") {
        let l = a
        for (let c = 0; c < s.min; c++) {
          let u = n()
          o(i(s.expr, l), u), (l = u)
        }
        if (s.max == -1) o(i(s.expr, l), l)
        else
          for (let c = s.min; c < s.max; c++) {
            let u = n()
            r(l, u), o(i(s.expr, l), u), (l = u)
          }
        return [r(l)]
      } else {
        if (s.type == "name") return [r(a, void 0, s.value)]
        throw new Error("Unknown expr type")
      }
    }
  }
}
function ZM(e, t) {
  return t - e
}
function TE(e, t) {
  let n = []
  return r(t), n.sort(ZM)
  function r(o) {
    let i = e[o]
    if (i.length == 1 && !i[0].term) return r(i[0].to)
    n.push(o)
    for (let s = 0; s < i.length; s++) {
      let { term: a, to: l } = i[s]
      !a && n.indexOf(l) == -1 && r(l)
    }
  }
}
function $j(e) {
  let t = Object.create(null)
  return n(TE(e, 0))
  function n(r) {
    let o = []
    r.forEach((s) => {
      e[s].forEach(({ term: a, to: l }) => {
        if (!a) return
        let c
        for (let u = 0; u < o.length; u++) o[u][0] == a && (c = o[u][1])
        TE(e, l).forEach((u) => {
          c || o.push([a, (c = [])]), c.indexOf(u) == -1 && c.push(u)
        })
      })
    })
    let i = (t[r.join(",")] = new _s(r.indexOf(e.length - 1) > -1))
    for (let s = 0; s < o.length; s++) {
      let a = o[s][1].sort(ZM)
      i.next.push({ type: o[s][0], next: t[a.join(",")] || n(a) })
    }
    return i
  }
}
function Bj(e, t) {
  for (let n = 0, r = [e]; n < r.length; n++) {
    let o = r[n],
      i = !o.validEnd,
      s = []
    for (let a = 0; a < o.next.length; a++) {
      let { type: l, next: c } = o.next[a]
      s.push(l.name),
        i && !(l.isText || l.hasRequiredAttrs()) && (i = !1),
        r.indexOf(c) == -1 && r.push(c)
    }
    i &&
      t.err(
        "Only non-generatable nodes (" +
          s.join(", ") +
          ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
      )
  }
}
function YM(e) {
  let t = Object.create(null)
  for (let n in e) {
    let r = e[n]
    if (!r.hasDefault) return null
    t[n] = r.default
  }
  return t
}
function XM(e, t) {
  let n = Object.create(null)
  for (let r in e) {
    let o = t && t[r]
    if (o === void 0) {
      let i = e[r]
      if (i.hasDefault) o = i.default
      else throw new RangeError("No value supplied for attribute " + r)
    }
    n[r] = o
  }
  return n
}
function QM(e, t, n, r) {
  for (let o in t)
    if (!(o in e))
      throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`)
  for (let o in e) {
    let i = e[o]
    i.validate && i.validate(t[o])
  }
}
function JM(e, t) {
  let n = Object.create(null)
  if (t) for (let r in t) n[r] = new Fj(e, r, t[r])
  return n
}
let ME = class eO {
  constructor(t, n, r) {
    ;(this.name = t),
      (this.schema = n),
      (this.spec = r),
      (this.markSet = null),
      (this.groups = r.group ? r.group.split(" ") : []),
      (this.attrs = JM(t, r.attrs)),
      (this.defaultAttrs = YM(this.attrs)),
      (this.contentMatch = null),
      (this.inlineContent = null),
      (this.isBlock = !(r.inline || t == "text")),
      (this.isText = t == "text")
  }
  get isInline() {
    return !this.isBlock
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent
  }
  get isLeaf() {
    return this.contentMatch == _s.empty
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom
  }
  isInGroup(t) {
    return this.groups.indexOf(t) > -1
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
  }
  hasRequiredAttrs() {
    for (let t in this.attrs) if (this.attrs[t].isRequired) return !0
    return !1
  }
  compatibleContent(t) {
    return this == t || this.contentMatch.compatible(t.contentMatch)
  }
  computeAttrs(t) {
    return !t && this.defaultAttrs ? this.defaultAttrs : XM(this.attrs, t)
  }
  create(t = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes")
    return new hi(this, this.computeAttrs(t), Z.from(n), Ke.setFrom(r))
  }
  createChecked(t = null, n, r) {
    return (
      (n = Z.from(n)),
      this.checkContent(n),
      new hi(this, this.computeAttrs(t), n, Ke.setFrom(r))
    )
  }
  createAndFill(t = null, n, r) {
    if (((t = this.computeAttrs(t)), (n = Z.from(n)), n.size)) {
      let s = this.contentMatch.fillBefore(n)
      if (!s) return null
      n = s.append(n)
    }
    let o = this.contentMatch.matchFragment(n),
      i = o && o.fillBefore(Z.empty, !0)
    return i ? new hi(this, t, n.append(i), Ke.setFrom(r)) : null
  }
  validContent(t) {
    let n = this.contentMatch.matchFragment(t)
    if (!n || !n.validEnd) return !1
    for (let r = 0; r < t.childCount; r++)
      if (!this.allowsMarks(t.child(r).marks)) return !1
    return !0
  }
  checkContent(t) {
    if (!this.validContent(t))
      throw new RangeError(
        `Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`
      )
  }
  checkAttrs(t) {
    QM(this.attrs, t, "node", this.name)
  }
  allowsMarkType(t) {
    return this.markSet == null || this.markSet.indexOf(t) > -1
  }
  allowsMarks(t) {
    if (this.markSet == null) return !0
    for (let n = 0; n < t.length; n++)
      if (!this.allowsMarkType(t[n].type)) return !1
    return !0
  }
  allowedMarks(t) {
    if (this.markSet == null) return t
    let n
    for (let r = 0; r < t.length; r++)
      this.allowsMarkType(t[r].type)
        ? n && n.push(t[r])
        : n || (n = t.slice(0, r))
    return n ? (n.length ? n : Ke.none) : t
  }
  static compile(t, n) {
    let r = Object.create(null)
    t.forEach((i, s) => (r[i] = new eO(i, n, s)))
    let o = n.spec.topNode || "doc"
    if (!r[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')")
    if (!r.text) throw new RangeError("Every schema needs a 'text' type")
    for (let i in r.text.attrs)
      throw new RangeError("The text node type should not have attributes")
    return r
  }
}
function jj(e, t, n) {
  let r = n.split("|")
  return (o) => {
    let i = o === null ? "null" : typeof o
    if (r.indexOf(i) < 0)
      throw new RangeError(
        `Expected value of type ${r} for attribute ${t} on type ${e}, got ${i}`
      )
  }
}
class Fj {
  constructor(t, n, r) {
    ;(this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default")),
      (this.default = r.default),
      (this.validate =
        typeof r.validate == "string" ? jj(t, n, r.validate) : r.validate)
  }
  get isRequired() {
    return !this.hasDefault
  }
}
class Qh {
  constructor(t, n, r, o) {
    ;(this.name = t),
      (this.rank = n),
      (this.schema = r),
      (this.spec = o),
      (this.attrs = JM(t, o.attrs)),
      (this.excluded = null)
    let i = YM(this.attrs)
    this.instance = i ? new Ke(this, i) : null
  }
  create(t = null) {
    return !t && this.instance ? this.instance : new Ke(this, XM(this.attrs, t))
  }
  static compile(t, n) {
    let r = Object.create(null),
      o = 0
    return t.forEach((i, s) => (r[i] = new Qh(i, o++, n, s))), r
  }
  removeFromSet(t) {
    for (var n = 0; n < t.length; n++)
      t[n].type == this && ((t = t.slice(0, n).concat(t.slice(n + 1))), n--)
    return t
  }
  isInSet(t) {
    for (let n = 0; n < t.length; n++) if (t[n].type == this) return t[n]
  }
  checkAttrs(t) {
    QM(this.attrs, t, "mark", this.name)
  }
  excludes(t) {
    return this.excluded.indexOf(t) > -1
  }
}
class tO {
  constructor(t) {
    ;(this.linebreakReplacement = null), (this.cached = Object.create(null))
    let n = (this.spec = {})
    for (let o in t) n[o] = t[o]
    ;(n.nodes = Vt.from(t.nodes)),
      (n.marks = Vt.from(t.marks || {})),
      (this.nodes = ME.compile(this.spec.nodes, this)),
      (this.marks = Qh.compile(this.spec.marks, this))
    let r = Object.create(null)
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark")
      let i = this.nodes[o],
        s = i.spec.content || "",
        a = i.spec.marks
      if (
        ((i.contentMatch = r[s] || (r[s] = _s.parse(s, this.nodes))),
        (i.inlineContent = i.contentMatch.inlineContent),
        i.spec.linebreakReplacement)
      ) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined")
        if (!i.isInline || !i.isLeaf)
          throw new RangeError(
            "Linebreak replacement nodes must be inline leaf nodes"
          )
        this.linebreakReplacement = i
      }
      i.markSet =
        a == "_"
          ? null
          : a
            ? OE(this, a.split(" "))
            : a == "" || !i.inlineContent
              ? []
              : null
    }
    for (let o in this.marks) {
      let i = this.marks[o],
        s = i.spec.excludes
      i.excluded = s == null ? [i] : s == "" ? [] : OE(this, s.split(" "))
    }
    ;(this.nodeFromJSON = this.nodeFromJSON.bind(this)),
      (this.markFromJSON = this.markFromJSON.bind(this)),
      (this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
      (this.cached.wrappings = Object.create(null))
  }
  node(t, n = null, r, o) {
    if (typeof t == "string") t = this.nodeType(t)
    else if (t instanceof ME) {
      if (t.schema != this)
        throw new RangeError(
          "Node type from different schema used (" + t.name + ")"
        )
    } else throw new RangeError("Invalid node type: " + t)
    return t.createChecked(n, r, o)
  }
  text(t, n) {
    let r = this.nodes.text
    return new op(r, r.defaultAttrs, t, Ke.setFrom(n))
  }
  mark(t, n) {
    return typeof t == "string" && (t = this.marks[t]), t.create(n)
  }
  nodeFromJSON(t) {
    return hi.fromJSON(this, t)
  }
  markFromJSON(t) {
    return Ke.fromJSON(this, t)
  }
  nodeType(t) {
    let n = this.nodes[t]
    if (!n) throw new RangeError("Unknown node type: " + t)
    return n
  }
}
function OE(e, t) {
  let n = []
  for (let r = 0; r < t.length; r++) {
    let o = t[r],
      i = e.marks[o],
      s = i
    if (i) n.push(i)
    else
      for (let a in e.marks) {
        let l = e.marks[a]
        ;(o == "_" ||
          (l.spec.group && l.spec.group.split(" ").indexOf(o) > -1)) &&
          n.push((s = l))
      }
    if (!s) throw new SyntaxError("Unknown mark type: '" + t[r] + "'")
  }
  return n
}
function zj(e) {
  return e.tag != null
}
function Uj(e) {
  return e.style != null
}
class mi {
  constructor(t, n) {
    ;(this.schema = t), (this.rules = n), (this.tags = []), (this.styles = [])
    let r = (this.matchedStyles = [])
    n.forEach((o) => {
      if (zj(o)) this.tags.push(o)
      else if (Uj(o)) {
        let i = /[^=]*/.exec(o.style)[0]
        r.indexOf(i) < 0 && r.push(i), this.styles.push(o)
      }
    }),
      (this.normalizeLists = !this.tags.some((o) => {
        if (!/^(ul|ol)\b/.test(o.tag) || !o.node) return !1
        let i = t.nodes[o.node]
        return i.contentMatch.matchType(i)
      }))
  }
  parse(t, n = {}) {
    let r = new RE(this, n, !1)
    return r.addAll(t, Ke.none, n.from, n.to), r.finish()
  }
  parseSlice(t, n = {}) {
    let r = new RE(this, n, !0)
    return r.addAll(t, Ke.none, n.from, n.to), oe.maxOpen(r.finish())
  }
  matchTag(t, n, r) {
    for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
      let i = this.tags[o]
      if (
        Wj(t, i.tag) &&
        (i.namespace === void 0 || t.namespaceURI == i.namespace) &&
        (!i.context || n.matchesContext(i.context))
      ) {
        if (i.getAttrs) {
          let s = i.getAttrs(t)
          if (s === !1) continue
          i.attrs = s || void 0
        }
        return i
      }
    }
  }
  matchStyle(t, n, r, o) {
    for (
      let i = o ? this.styles.indexOf(o) + 1 : 0;
      i < this.styles.length;
      i++
    ) {
      let s = this.styles[i],
        a = s.style
      if (
        !(
          a.indexOf(t) != 0 ||
          (s.context && !r.matchesContext(s.context)) ||
          (a.length > t.length &&
            (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))
        )
      ) {
        if (s.getAttrs) {
          let l = s.getAttrs(n)
          if (l === !1) continue
          s.attrs = l || void 0
        }
        return s
      }
    }
  }
  static schemaRules(t) {
    let n = []
    function r(o) {
      let i = o.priority == null ? 50 : o.priority,
        s = 0
      for (; s < n.length; s++) {
        let a = n[s]
        if ((a.priority == null ? 50 : a.priority) < i) break
      }
      n.splice(s, 0, o)
    }
    for (let o in t.marks) {
      let i = t.marks[o].spec.parseDOM
      i &&
        i.forEach((s) => {
          r((s = IE(s))), s.mark || s.ignore || s.clearMark || (s.mark = o)
        })
    }
    for (let o in t.nodes) {
      let i = t.nodes[o].spec.parseDOM
      i &&
        i.forEach((s) => {
          r((s = IE(s))), s.node || s.ignore || s.mark || (s.node = o)
        })
    }
    return n
  }
  static fromSchema(t) {
    return (
      t.cached.domParser || (t.cached.domParser = new mi(t, mi.schemaRules(t)))
    )
  }
}
const nO = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0,
  },
  Vj = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 },
  rO = { ol: !0, ul: !0 },
  nu = 1,
  wy = 2,
  dc = 4
function AE(e, t, n) {
  return t != null
    ? (t ? nu : 0) | (t === "full" ? wy : 0)
    : e && e.whitespace == "pre"
      ? nu | wy
      : n & ~dc
}
class Cd {
  constructor(t, n, r, o, i, s) {
    ;(this.type = t),
      (this.attrs = n),
      (this.marks = r),
      (this.solid = o),
      (this.options = s),
      (this.content = []),
      (this.activeMarks = Ke.none),
      (this.match = i || (s & dc ? null : t.contentMatch))
  }
  findWrapping(t) {
    if (!this.match) {
      if (!this.type) return []
      let n = this.type.contentMatch.fillBefore(Z.from(t))
      if (n) this.match = this.type.contentMatch.matchFragment(n)
      else {
        let r = this.type.contentMatch,
          o
        return (o = r.findWrapping(t.type)) ? ((this.match = r), o) : null
      }
    }
    return this.match.findWrapping(t.type)
  }
  finish(t) {
    if (!(this.options & nu)) {
      let r = this.content[this.content.length - 1],
        o
      if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let i = r
        r.text.length == o[0].length
          ? this.content.pop()
          : (this.content[this.content.length - 1] = i.withText(
              i.text.slice(0, i.text.length - o[0].length)
            ))
      }
    }
    let n = Z.from(this.content)
    return (
      !t && this.match && (n = n.append(this.match.fillBefore(Z.empty, !0))),
      this.type ? this.type.create(this.attrs, n, this.marks) : n
    )
  }
  inlineContext(t) {
    return this.type
      ? this.type.inlineContent
      : this.content.length
        ? this.content[0].isInline
        : t.parentNode &&
          !nO.hasOwnProperty(t.parentNode.nodeName.toLowerCase())
  }
}
class RE {
  constructor(t, n, r) {
    ;(this.parser = t),
      (this.options = n),
      (this.isOpen = r),
      (this.open = 0),
      (this.localPreserveWS = !1)
    let o = n.topNode,
      i,
      s = AE(null, n.preserveWhitespace, 0) | (r ? dc : 0)
    o
      ? (i = new Cd(
          o.type,
          o.attrs,
          Ke.none,
          !0,
          n.topMatch || o.type.contentMatch,
          s
        ))
      : r
        ? (i = new Cd(null, null, Ke.none, !0, null, s))
        : (i = new Cd(t.schema.topNodeType, null, Ke.none, !0, null, s)),
      (this.nodes = [i]),
      (this.find = n.findPositions),
      (this.needsBlock = !1)
  }
  get top() {
    return this.nodes[this.open]
  }
  addDOM(t, n) {
    t.nodeType == 3
      ? this.addTextNode(t, n)
      : t.nodeType == 1 && this.addElement(t, n)
  }
  addTextNode(t, n) {
    let r = t.nodeValue,
      o = this.top,
      i = o.options & wy ? "full" : this.localPreserveWS || (o.options & nu) > 0
    if (i === "full" || o.inlineContext(t) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i)
        i !== "full"
          ? (r = r.replace(/\r?\n|\r/g, " "))
          : (r = r.replace(
              /\r\n?/g,
              `
`
            ))
      else if (
        ((r = r.replace(/[ \t\r\n\u000c]+/g, " ")),
        /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1)
      ) {
        let s = o.content[o.content.length - 1],
          a = t.previousSibling
        ;(!s ||
          (a && a.nodeName == "BR") ||
          (s.isText && /[ \t\r\n\u000c]$/.test(s.text))) &&
          (r = r.slice(1))
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(t)
    } else this.findInside(t)
  }
  addElement(t, n, r) {
    let o = this.localPreserveWS,
      i = this.top
    ;(t.tagName == "PRE" || /pre/.test(t.style && t.style.whiteSpace)) &&
      (this.localPreserveWS = !0)
    let s = t.nodeName.toLowerCase(),
      a
    rO.hasOwnProperty(s) && this.parser.normalizeLists && Hj(t)
    let l =
      (this.options.ruleFromNode && this.options.ruleFromNode(t)) ||
      (a = this.parser.matchTag(t, this, r))
    e: if (l ? l.ignore : Vj.hasOwnProperty(s))
      this.findInside(t), this.ignoreFallback(t, n)
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent
        ? (this.open = Math.max(0, this.open - 1))
        : l && l.skip.nodeType && (t = l.skip)
      let c,
        u = this.needsBlock
      if (nO.hasOwnProperty(s))
        i.content.length &&
          i.content[0].isInline &&
          this.open &&
          (this.open--, (i = this.top)),
          (c = !0),
          i.type || (this.needsBlock = !0)
      else if (!t.firstChild) {
        this.leafFallback(t, n)
        break e
      }
      let d = l && l.skip ? n : this.readStyles(t, n)
      d && this.addAll(t, d), c && this.sync(i), (this.needsBlock = u)
    } else {
      let c = this.readStyles(t, n)
      c && this.addElementByRule(t, l, c, l.consuming === !1 ? a : void 0)
    }
    this.localPreserveWS = o
  }
  leafFallback(t, n) {
    t.nodeName == "BR" &&
      this.top.type &&
      this.top.type.inlineContent &&
      this.addTextNode(
        t.ownerDocument.createTextNode(`
`),
        n
      )
  }
  ignoreFallback(t, n) {
    t.nodeName == "BR" &&
      (!this.top.type || !this.top.type.inlineContent) &&
      this.findPlace(this.parser.schema.text("-"), n)
  }
  readStyles(t, n) {
    let r = t.style
    if (r && r.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let i = this.parser.matchedStyles[o],
          s = r.getPropertyValue(i)
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(i, s, this, a)
            if (!l) break
            if (l.ignore) return null
            if (
              (l.clearMark
                ? (n = n.filter((c) => !l.clearMark(c)))
                : (n = n.concat(
                    this.parser.schema.marks[l.mark].create(l.attrs)
                  )),
              l.consuming === !1)
            )
              a = l
            else break
          }
      }
    return n
  }
  addElementByRule(t, n, r, o) {
    let i, s
    if (n.node)
      if (((s = this.parser.schema.nodes[n.node]), s.isLeaf))
        this.insertNode(s.create(n.attrs), r) || this.leafFallback(t, r)
      else {
        let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace)
        l && ((i = !0), (r = l))
      }
    else {
      let l = this.parser.schema.marks[n.mark]
      r = r.concat(l.create(n.attrs))
    }
    let a = this.top
    if (s && s.isLeaf) this.findInside(t)
    else if (o) this.addElement(t, r, o)
    else if (n.getContent)
      this.findInside(t),
        n
          .getContent(t, this.parser.schema)
          .forEach((l) => this.insertNode(l, r))
    else {
      let l = t
      typeof n.contentElement == "string"
        ? (l = t.querySelector(n.contentElement))
        : typeof n.contentElement == "function"
          ? (l = n.contentElement(t))
          : n.contentElement && (l = n.contentElement),
        this.findAround(t, l, !0),
        this.addAll(l, r),
        this.findAround(t, l, !1)
    }
    i && this.sync(a) && this.open--
  }
  addAll(t, n, r, o) {
    let i = r || 0
    for (
      let s = r ? t.childNodes[r] : t.firstChild,
        a = o == null ? null : t.childNodes[o];
      s != a;
      s = s.nextSibling, ++i
    )
      this.findAtPoint(t, i), this.addDOM(s, n)
    this.findAtPoint(t, i)
  }
  findPlace(t, n) {
    let r, o
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i],
        a = s.findWrapping(t)
      if (
        (a && (!r || r.length > a.length) && ((r = a), (o = s), !a.length)) ||
        s.solid
      )
        break
    }
    if (!r) return null
    this.sync(o)
    for (let i = 0; i < r.length; i++) n = this.enterInner(r[i], null, n, !1)
    return n
  }
  insertNode(t, n) {
    if (t.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext()
      o && (n = this.enterInner(o, null, n))
    }
    let r = this.findPlace(t, n)
    if (r) {
      this.closeExtra()
      let o = this.top
      o.match && (o.match = o.match.matchType(t.type))
      let i = Ke.none
      for (let s of r.concat(t.marks))
        (o.type ? o.type.allowsMarkType(s.type) : DE(s.type, t.type)) &&
          (i = s.addToSet(i))
      return o.content.push(t.mark(i)), !0
    }
    return !1
  }
  enter(t, n, r, o) {
    let i = this.findPlace(t.create(n), r)
    return i && (i = this.enterInner(t, n, r, !0, o)), i
  }
  enterInner(t, n, r, o = !1, i) {
    this.closeExtra()
    let s = this.top
    s.match = s.match && s.match.matchType(t)
    let a = AE(t, i, s.options)
    s.options & dc && s.content.length == 0 && (a |= dc)
    let l = Ke.none
    return (
      (r = r.filter((c) =>
        (s.type ? s.type.allowsMarkType(c.type) : DE(c.type, t))
          ? ((l = c.addToSet(l)), !1)
          : !0
      )),
      this.nodes.push(new Cd(t, n, l, o, null, a)),
      this.open++,
      r
    )
  }
  closeExtra(t = !1) {
    let n = this.nodes.length - 1
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(t))
      this.nodes.length = this.open + 1
    }
  }
  finish() {
    return (
      (this.open = 0),
      this.closeExtra(this.isOpen),
      this.nodes[0].finish(!!(this.isOpen || this.options.topOpen))
    )
  }
  sync(t) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == t) return (this.open = n), !0
      this.localPreserveWS && (this.nodes[n].options |= nu)
    }
    return !1
  }
  get currentPos() {
    this.closeExtra()
    let t = 0
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content
      for (let o = r.length - 1; o >= 0; o--) t += r[o].nodeSize
      n && t++
    }
    return t
  }
  findAtPoint(t, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == t &&
          this.find[r].offset == n &&
          (this.find[r].pos = this.currentPos)
  }
  findInside(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null &&
          t.nodeType == 1 &&
          t.contains(this.find[n].node) &&
          (this.find[n].pos = this.currentPos)
  }
  findAround(t, n, r) {
    if (t != n && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null &&
          t.nodeType == 1 &&
          t.contains(this.find[o].node) &&
          n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) &&
          (this.find[o].pos = this.currentPos)
  }
  findInText(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == t &&
          (this.find[n].pos =
            this.currentPos - (t.nodeValue.length - this.find[n].offset))
  }
  matchesContext(t) {
    if (t.indexOf("|") > -1)
      return t.split(/\s*\|\s*/).some(this.matchesContext, this)
    let n = t.split("/"),
      r = this.options.context,
      o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
      i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1),
      s = (a, l) => {
        for (; a >= 0; a--) {
          let c = n[a]
          if (c == "") {
            if (a == n.length - 1 || a == 0) continue
            for (; l >= i; l--) if (s(a - 1, l)) return !0
            return !1
          } else {
            let u =
              l > 0 || (l == 0 && o)
                ? this.nodes[l].type
                : r && l >= i
                  ? r.node(l - i).type
                  : null
            if (!u || (u.name != c && !u.isInGroup(c))) return !1
            l--
          }
        }
        return !0
      }
    return s(n.length - 1, this.open)
  }
  textblockFromContext() {
    let t = this.options.context
    if (t)
      for (let n = t.depth; n >= 0; n--) {
        let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType
        if (r && r.isTextblock && r.defaultAttrs) return r
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n]
      if (r.isTextblock && r.defaultAttrs) return r
    }
  }
}
function Hj(e) {
  for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
    let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null
    r && rO.hasOwnProperty(r) && n
      ? (n.appendChild(t), (t = n))
      : r == "li"
        ? (n = t)
        : r && (n = null)
  }
}
function Wj(e, t) {
  return (
    e.matches ||
    e.msMatchesSelector ||
    e.webkitMatchesSelector ||
    e.mozMatchesSelector
  ).call(e, t)
}
function IE(e) {
  let t = {}
  for (let n in e) t[n] = e[n]
  return t
}
function DE(e, t) {
  let n = t.schema.nodes
  for (let r in n) {
    let o = n[r]
    if (!o.allowsMarkType(e)) continue
    let i = [],
      s = (a) => {
        i.push(a)
        for (let l = 0; l < a.edgeCount; l++) {
          let { type: c, next: u } = a.edge(l)
          if (c == t || (i.indexOf(u) < 0 && s(u))) return !0
        }
      }
    if (s(o.contentMatch)) return !0
  }
}
class Ps {
  constructor(t, n) {
    ;(this.nodes = t), (this.marks = n)
  }
  serializeFragment(t, n = {}, r) {
    r || (r = yg(n).createDocumentFragment())
    let o = r,
      i = []
    return (
      t.forEach((s) => {
        if (i.length || s.marks.length) {
          let a = 0,
            l = 0
          for (; a < i.length && l < s.marks.length; ) {
            let c = s.marks[l]
            if (!this.marks[c.type.name]) {
              l++
              continue
            }
            if (!c.eq(i[a][0]) || c.type.spec.spanning === !1) break
            a++, l++
          }
          for (; a < i.length; ) o = i.pop()[1]
          for (; l < s.marks.length; ) {
            let c = s.marks[l++],
              u = this.serializeMark(c, s.isInline, n)
            u &&
              (i.push([c, o]),
              o.appendChild(u.dom),
              (o = u.contentDOM || u.dom))
          }
        }
        o.appendChild(this.serializeNodeInner(s, n))
      }),
      r
    )
  }
  serializeNodeInner(t, n) {
    let { dom: r, contentDOM: o } = of(
      yg(n),
      this.nodes[t.type.name](t),
      null,
      t.attrs
    )
    if (o) {
      if (t.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec")
      this.serializeFragment(t.content, n, o)
    }
    return r
  }
  serializeNode(t, n = {}) {
    let r = this.serializeNodeInner(t, n)
    for (let o = t.marks.length - 1; o >= 0; o--) {
      let i = this.serializeMark(t.marks[o], t.isInline, n)
      i && ((i.contentDOM || i.dom).appendChild(r), (r = i.dom))
    }
    return r
  }
  serializeMark(t, n, r = {}) {
    let o = this.marks[t.type.name]
    return o && of(yg(r), o(t, n), null, t.attrs)
  }
  static renderSpec(t, n, r = null, o) {
    return of(t, n, r, o)
  }
  static fromSchema(t) {
    return (
      t.cached.domSerializer ||
      (t.cached.domSerializer = new Ps(
        this.nodesFromSchema(t),
        this.marksFromSchema(t)
      ))
    )
  }
  static nodesFromSchema(t) {
    let n = LE(t.nodes)
    return n.text || (n.text = (r) => r.text), n
  }
  static marksFromSchema(t) {
    return LE(t.marks)
  }
}
function LE(e) {
  let t = {}
  for (let n in e) {
    let r = e[n].spec.toDOM
    r && (t[n] = r)
  }
  return t
}
function yg(e) {
  return e.document || window.document
}
const PE = new WeakMap()
function Kj(e) {
  let t = PE.get(e)
  return t === void 0 && PE.set(e, (t = Gj(e))), t
}
function Gj(e) {
  let t = null
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string") t || (t = []), t.push(r)
        else for (let o = 0; o < r.length; o++) n(r[o])
      else for (let o in r) n(r[o])
  }
  return n(e), t
}
function of(e, t, n, r) {
  if (typeof t == "string") return { dom: e.createTextNode(t) }
  if (t.nodeType != null) return { dom: t }
  if (t.dom && t.dom.nodeType != null) return t
  let o = t[0],
    i
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec")
  if (r && (i = Kj(r)) && i.indexOf(t) > -1)
    throw new RangeError(
      "Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."
    )
  let s = o.indexOf(" ")
  s > 0 && ((n = o.slice(0, s)), (o = o.slice(s + 1)))
  let a,
    l = n ? e.createElementNS(n, o) : e.createElement(o),
    c = t[1],
    u = 1
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ")
        f > 0
          ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d])
          : l.setAttribute(d, c[d])
      }
  }
  for (let d = u; d < t.length; d++) {
    let f = t[d]
    if (f === 0) {
      if (d < t.length - 1 || d > u)
        throw new RangeError(
          "Content hole must be the only child of its parent node"
        )
      return { dom: l, contentDOM: l }
    } else {
      let { dom: p, contentDOM: g } = of(e, f, n, r)
      if ((l.appendChild(p), g)) {
        if (a) throw new RangeError("Multiple content holes")
        a = g
      }
    }
  }
  return { dom: l, contentDOM: a }
}
const oO = 65535,
  iO = Math.pow(2, 16)
function qj(e, t) {
  return e + t * iO
}
function $E(e) {
  return e & oO
}
function Zj(e) {
  return (e - (e & oO)) / iO
}
const sO = 1,
  aO = 2,
  sf = 4,
  lO = 8
class Ey {
  constructor(t, n, r) {
    ;(this.pos = t), (this.delInfo = n), (this.recover = r)
  }
  get deleted() {
    return (this.delInfo & lO) > 0
  }
  get deletedBefore() {
    return (this.delInfo & (sO | sf)) > 0
  }
  get deletedAfter() {
    return (this.delInfo & (aO | sf)) > 0
  }
  get deletedAcross() {
    return (this.delInfo & sf) > 0
  }
}
class Pn {
  constructor(t, n = !1) {
    if (((this.ranges = t), (this.inverted = n), !t.length && Pn.empty))
      return Pn.empty
  }
  recover(t) {
    let n = 0,
      r = $E(t)
    if (!this.inverted)
      for (let o = 0; o < r; o++)
        n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1]
    return this.ranges[r * 3] + n + Zj(t)
  }
  mapResult(t, n = 1) {
    return this._map(t, n, !1)
  }
  map(t, n = 1) {
    return this._map(t, n, !0)
  }
  _map(t, n, r) {
    let o = 0,
      i = this.inverted ? 2 : 1,
      s = this.inverted ? 1 : 2
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? o : 0)
      if (l > t) break
      let c = this.ranges[a + i],
        u = this.ranges[a + s],
        d = l + c
      if (t <= d) {
        let f = c ? (t == l ? -1 : t == d ? 1 : n) : n,
          p = l + o + (f < 0 ? 0 : u)
        if (r) return p
        let g = t == (n < 0 ? l : d) ? null : qj(a / 3, t - l),
          v = t == l ? aO : t == d ? sO : sf
        return (n < 0 ? t != l : t != d) && (v |= lO), new Ey(p, v, g)
      }
      o += u - c
    }
    return r ? t + o : new Ey(t + o, 0, null)
  }
  touches(t, n) {
    let r = 0,
      o = $E(n),
      i = this.inverted ? 2 : 1,
      s = this.inverted ? 1 : 2
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0)
      if (l > t) break
      let c = this.ranges[a + i],
        u = l + c
      if (t <= u && a == o * 3) return !0
      r += this.ranges[a + s] - c
    }
    return !1
  }
  forEach(t) {
    let n = this.inverted ? 2 : 1,
      r = this.inverted ? 1 : 2
    for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
      let s = this.ranges[o],
        a = s - (this.inverted ? i : 0),
        l = s + (this.inverted ? 0 : i),
        c = this.ranges[o + n],
        u = this.ranges[o + r]
      t(a, a + c, l, l + u), (i += u - c)
    }
  }
  invert() {
    return new Pn(this.ranges, !this.inverted)
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
  }
  static offset(t) {
    return t == 0 ? Pn.empty : new Pn(t < 0 ? [0, -t, 0] : [0, 0, t])
  }
}
Pn.empty = new Pn([])
class ru {
  constructor(t, n, r = 0, o = t ? t.length : 0) {
    ;(this.mirror = n),
      (this.from = r),
      (this.to = o),
      (this._maps = t || []),
      (this.ownData = !(t || n))
  }
  get maps() {
    return this._maps
  }
  slice(t = 0, n = this.maps.length) {
    return new ru(this._maps, this.mirror, t, n)
  }
  appendMap(t, n) {
    this.ownData ||
      ((this._maps = this._maps.slice()),
      (this.mirror = this.mirror && this.mirror.slice()),
      (this.ownData = !0)),
      (this.to = this._maps.push(t)),
      n != null && this.setMirror(this._maps.length - 1, n)
  }
  appendMapping(t) {
    for (let n = 0, r = this._maps.length; n < t._maps.length; n++) {
      let o = t.getMirror(n)
      this.appendMap(t._maps[n], o != null && o < n ? r + o : void 0)
    }
  }
  getMirror(t) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == t) return this.mirror[n + (n % 2 ? -1 : 1)]
    }
  }
  setMirror(t, n) {
    this.mirror || (this.mirror = []), this.mirror.push(t, n)
  }
  appendMappingInverted(t) {
    for (
      let n = t.maps.length - 1, r = this._maps.length + t._maps.length;
      n >= 0;
      n--
    ) {
      let o = t.getMirror(n)
      this.appendMap(
        t._maps[n].invert(),
        o != null && o > n ? r - o - 1 : void 0
      )
    }
  }
  invert() {
    let t = new ru()
    return t.appendMappingInverted(this), t
  }
  map(t, n = 1) {
    if (this.mirror) return this._map(t, n, !0)
    for (let r = this.from; r < this.to; r++) t = this._maps[r].map(t, n)
    return t
  }
  mapResult(t, n = 1) {
    return this._map(t, n, !1)
  }
  _map(t, n, r) {
    let o = 0
    for (let i = this.from; i < this.to; i++) {
      let s = this._maps[i],
        a = s.mapResult(t, n)
      if (a.recover != null) {
        let l = this.getMirror(i)
        if (l != null && l > i && l < this.to) {
          ;(i = l), (t = this._maps[l].recover(a.recover))
          continue
        }
      }
      ;(o |= a.delInfo), (t = a.pos)
    }
    return r ? t : new Ey(t, o, null)
  }
}
const bg = Object.create(null)
class sn {
  getMap() {
    return Pn.empty
  }
  merge(t) {
    return null
  }
  static fromJSON(t, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON")
    let r = bg[n.stepType]
    if (!r) throw new RangeError(`No step type ${n.stepType} defined`)
    return r.fromJSON(t, n)
  }
  static jsonID(t, n) {
    if (t in bg) throw new RangeError("Duplicate use of step JSON ID " + t)
    return (bg[t] = n), (n.prototype.jsonID = t), n
  }
}
class _t {
  constructor(t, n) {
    ;(this.doc = t), (this.failed = n)
  }
  static ok(t) {
    return new _t(t, null)
  }
  static fail(t) {
    return new _t(null, t)
  }
  static fromReplace(t, n, r, o) {
    try {
      return _t.ok(t.replace(n, r, o))
    } catch (i) {
      if (i instanceof tp) return _t.fail(i.message)
      throw i
    }
  }
}
function Wb(e, t, n) {
  let r = []
  for (let o = 0; o < e.childCount; o++) {
    let i = e.child(o)
    i.content.size && (i = i.copy(Wb(i.content, t, i))),
      i.isInline && (i = t(i, n, o)),
      r.push(i)
  }
  return Z.fromArray(r)
}
class Jo extends sn {
  constructor(t, n, r) {
    super(), (this.from = t), (this.to = n), (this.mark = r)
  }
  apply(t) {
    let n = t.slice(this.from, this.to),
      r = t.resolve(this.from),
      o = r.node(r.sharedDepth(this.to)),
      i = new oe(
        Wb(
          n.content,
          (s, a) =>
            !s.isAtom || !a.type.allowsMarkType(this.mark.type)
              ? s
              : s.mark(this.mark.addToSet(s.marks)),
          o
        ),
        n.openStart,
        n.openEnd
      )
    return _t.fromReplace(t, this.from, this.to, i)
  }
  invert() {
    return new Hr(this.from, this.to, this.mark)
  }
  map(t) {
    let n = t.mapResult(this.from, 1),
      r = t.mapResult(this.to, -1)
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new Jo(n.pos, r.pos, this.mark)
  }
  merge(t) {
    return t instanceof Jo &&
      t.mark.eq(this.mark) &&
      this.from <= t.to &&
      this.to >= t.from
      ? new Jo(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark)
      : null
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to,
    }
  }
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON")
    return new Jo(n.from, n.to, t.markFromJSON(n.mark))
  }
}
sn.jsonID("addMark", Jo)
class Hr extends sn {
  constructor(t, n, r) {
    super(), (this.from = t), (this.to = n), (this.mark = r)
  }
  apply(t) {
    let n = t.slice(this.from, this.to),
      r = new oe(
        Wb(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), t),
        n.openStart,
        n.openEnd
      )
    return _t.fromReplace(t, this.from, this.to, r)
  }
  invert() {
    return new Jo(this.from, this.to, this.mark)
  }
  map(t) {
    let n = t.mapResult(this.from, 1),
      r = t.mapResult(this.to, -1)
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new Hr(n.pos, r.pos, this.mark)
  }
  merge(t) {
    return t instanceof Hr &&
      t.mark.eq(this.mark) &&
      this.from <= t.to &&
      this.to >= t.from
      ? new Hr(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark)
      : null
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to,
    }
  }
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON")
    return new Hr(n.from, n.to, t.markFromJSON(n.mark))
  }
}
sn.jsonID("removeMark", Hr)
class ei extends sn {
  constructor(t, n) {
    super(), (this.pos = t), (this.mark = n)
  }
  apply(t) {
    let n = t.nodeAt(this.pos)
    if (!n) return _t.fail("No node at mark step's position")
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks))
    return _t.fromReplace(
      t,
      this.pos,
      this.pos + 1,
      new oe(Z.from(r), 0, n.isLeaf ? 0 : 1)
    )
  }
  invert(t) {
    let n = t.nodeAt(this.pos)
    if (n) {
      let r = this.mark.addToSet(n.marks)
      if (r.length == n.marks.length) {
        for (let o = 0; o < n.marks.length; o++)
          if (!n.marks[o].isInSet(r)) return new ei(this.pos, n.marks[o])
        return new ei(this.pos, this.mark)
      }
    }
    return new Za(this.pos, this.mark)
  }
  map(t) {
    let n = t.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new ei(n.pos, this.mark)
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() }
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON")
    return new ei(n.pos, t.markFromJSON(n.mark))
  }
}
sn.jsonID("addNodeMark", ei)
class Za extends sn {
  constructor(t, n) {
    super(), (this.pos = t), (this.mark = n)
  }
  apply(t) {
    let n = t.nodeAt(this.pos)
    if (!n) return _t.fail("No node at mark step's position")
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks))
    return _t.fromReplace(
      t,
      this.pos,
      this.pos + 1,
      new oe(Z.from(r), 0, n.isLeaf ? 0 : 1)
    )
  }
  invert(t) {
    let n = t.nodeAt(this.pos)
    return !n || !this.mark.isInSet(n.marks)
      ? this
      : new ei(this.pos, this.mark)
  }
  map(t) {
    let n = t.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new Za(n.pos, this.mark)
  }
  toJSON() {
    return {
      stepType: "removeNodeMark",
      pos: this.pos,
      mark: this.mark.toJSON(),
    }
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON")
    return new Za(n.pos, t.markFromJSON(n.mark))
  }
}
sn.jsonID("removeNodeMark", Za)
class Mt extends sn {
  constructor(t, n, r, o = !1) {
    super(),
      (this.from = t),
      (this.to = n),
      (this.slice = r),
      (this.structure = o)
  }
  apply(t) {
    return this.structure && Cy(t, this.from, this.to)
      ? _t.fail("Structure replace would overwrite content")
      : _t.fromReplace(t, this.from, this.to, this.slice)
  }
  getMap() {
    return new Pn([this.from, this.to - this.from, this.slice.size])
  }
  invert(t) {
    return new Mt(
      this.from,
      this.from + this.slice.size,
      t.slice(this.from, this.to)
    )
  }
  map(t) {
    let n = t.mapResult(this.from, 1),
      r = t.mapResult(this.to, -1)
    return n.deletedAcross && r.deletedAcross
      ? null
      : new Mt(n.pos, Math.max(n.pos, r.pos), this.slice)
  }
  merge(t) {
    if (!(t instanceof Mt) || t.structure || this.structure) return null
    if (
      this.from + this.slice.size == t.from &&
      !this.slice.openEnd &&
      !t.slice.openStart
    ) {
      let n =
        this.slice.size + t.slice.size == 0
          ? oe.empty
          : new oe(
              this.slice.content.append(t.slice.content),
              this.slice.openStart,
              t.slice.openEnd
            )
      return new Mt(this.from, this.to + (t.to - t.from), n, this.structure)
    } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
      let n =
        this.slice.size + t.slice.size == 0
          ? oe.empty
          : new oe(
              t.slice.content.append(this.slice.content),
              t.slice.openStart,
              this.slice.openEnd
            )
      return new Mt(t.from, this.to, n, this.structure)
    } else return null
  }
  toJSON() {
    let t = { stepType: "replace", from: this.from, to: this.to }
    return (
      this.slice.size && (t.slice = this.slice.toJSON()),
      this.structure && (t.structure = !0),
      t
    )
  }
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON")
    return new Mt(n.from, n.to, oe.fromJSON(t, n.slice), !!n.structure)
  }
}
sn.jsonID("replace", Mt)
class Bt extends sn {
  constructor(t, n, r, o, i, s, a = !1) {
    super(),
      (this.from = t),
      (this.to = n),
      (this.gapFrom = r),
      (this.gapTo = o),
      (this.slice = i),
      (this.insert = s),
      (this.structure = a)
  }
  apply(t) {
    if (
      this.structure &&
      (Cy(t, this.from, this.gapFrom) || Cy(t, this.gapTo, this.to))
    )
      return _t.fail("Structure gap-replace would overwrite content")
    let n = t.slice(this.gapFrom, this.gapTo)
    if (n.openStart || n.openEnd) return _t.fail("Gap is not a flat range")
    let r = this.slice.insertAt(this.insert, n.content)
    return r
      ? _t.fromReplace(t, this.from, this.to, r)
      : _t.fail("Content does not fit in gap")
  }
  getMap() {
    return new Pn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert,
    ])
  }
  invert(t) {
    let n = this.gapTo - this.gapFrom
    return new Bt(
      this.from,
      this.from + this.slice.size + n,
      this.from + this.insert,
      this.from + this.insert + n,
      t
        .slice(this.from, this.to)
        .removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
      this.gapFrom - this.from,
      this.structure
    )
  }
  map(t) {
    let n = t.mapResult(this.from, 1),
      r = t.mapResult(this.to, -1),
      o = this.from == this.gapFrom ? n.pos : t.map(this.gapFrom, -1),
      i = this.to == this.gapTo ? r.pos : t.map(this.gapTo, 1)
    return (n.deletedAcross && r.deletedAcross) || o < n.pos || i > r.pos
      ? null
      : new Bt(n.pos, r.pos, o, i, this.slice, this.insert, this.structure)
  }
  toJSON() {
    let t = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert,
    }
    return (
      this.slice.size && (t.slice = this.slice.toJSON()),
      this.structure && (t.structure = !0),
      t
    )
  }
  static fromJSON(t, n) {
    if (
      typeof n.from != "number" ||
      typeof n.to != "number" ||
      typeof n.gapFrom != "number" ||
      typeof n.gapTo != "number" ||
      typeof n.insert != "number"
    )
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON")
    return new Bt(
      n.from,
      n.to,
      n.gapFrom,
      n.gapTo,
      oe.fromJSON(t, n.slice),
      n.insert,
      !!n.structure
    )
  }
}
sn.jsonID("replaceAround", Bt)
function Cy(e, t, n) {
  let r = e.resolve(t),
    o = n - t,
    i = r.depth
  for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; ) i--, o--
  if (o > 0) {
    let s = r.node(i).maybeChild(r.indexAfter(i))
    for (; o > 0; ) {
      if (!s || s.isLeaf) return !0
      ;(s = s.firstChild), o--
    }
  }
  return !1
}
function Yj(e, t, n, r) {
  let o = [],
    i = [],
    s,
    a
  e.doc.nodesBetween(t, n, (l, c, u) => {
    if (!l.isInline) return
    let d = l.marks
    if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, t),
        p = Math.min(c + l.nodeSize, n),
        g = r.addToSet(d)
      for (let v = 0; v < d.length; v++)
        d[v].isInSet(g) ||
          (s && s.to == f && s.mark.eq(d[v])
            ? (s.to = p)
            : o.push((s = new Hr(f, p, d[v]))))
      a && a.to == f ? (a.to = p) : i.push((a = new Jo(f, p, r)))
    }
  }),
    o.forEach((l) => e.step(l)),
    i.forEach((l) => e.step(l))
}
function Xj(e, t, n, r) {
  let o = [],
    i = 0
  e.doc.nodesBetween(t, n, (s, a) => {
    if (!s.isInline) return
    i++
    let l = null
    if (r instanceof Qh) {
      let c = s.marks,
        u
      for (; (u = r.isInSet(c)); )
        (l || (l = [])).push(u), (c = u.removeFromSet(c))
    } else r ? r.isInSet(s.marks) && (l = [r]) : (l = s.marks)
    if (l && l.length) {
      let c = Math.min(a + s.nodeSize, n)
      for (let u = 0; u < l.length; u++) {
        let d = l[u],
          f
        for (let p = 0; p < o.length; p++) {
          let g = o[p]
          g.step == i - 1 && d.eq(o[p].style) && (f = g)
        }
        f
          ? ((f.to = c), (f.step = i))
          : o.push({ style: d, from: Math.max(a, t), to: c, step: i })
      }
    }
  }),
    o.forEach((s) => e.step(new Hr(s.from, s.to, s.style)))
}
function Kb(e, t, n, r = n.contentMatch, o = !0) {
  let i = e.doc.nodeAt(t),
    s = [],
    a = t + 1
  for (let l = 0; l < i.childCount; l++) {
    let c = i.child(l),
      u = a + c.nodeSize,
      d = r.matchType(c.type)
    if (!d) s.push(new Mt(a, u, oe.empty))
    else {
      r = d
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || e.step(new Hr(a, u, c.marks[f]))
      if (o && c.isText && n.whitespace != "pre") {
        let f,
          p = /\r?\n|\r/g,
          g
        for (; (f = p.exec(c.text)); )
          g ||
            (g = new oe(
              Z.from(n.schema.text(" ", n.allowedMarks(c.marks))),
              0,
              0
            )),
            s.push(new Mt(a + f.index, a + f.index + f[0].length, g))
      }
    }
    a = u
  }
  if (!r.validEnd) {
    let l = r.fillBefore(Z.empty, !0)
    e.replace(a, a, new oe(l, 0, 0))
  }
  for (let l = s.length - 1; l >= 0; l--) e.step(s[l])
}
function Qj(e, t, n) {
  return (
    (t == 0 || e.canReplace(t, e.childCount)) &&
    (n == e.childCount || e.canReplace(0, n))
  )
}
function wl(e) {
  let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex)
  for (let r = e.depth; ; --r) {
    let o = e.$from.node(r),
      i = e.$from.index(r),
      s = e.$to.indexAfter(r)
    if (r < e.depth && o.canReplace(i, s, n)) return r
    if (r == 0 || o.type.spec.isolating || !Qj(o, i, s)) break
  }
  return null
}
function Jj(e, t, n) {
  let { $from: r, $to: o, depth: i } = t,
    s = r.before(i + 1),
    a = o.after(i + 1),
    l = s,
    c = a,
    u = Z.empty,
    d = 0
  for (let g = i, v = !1; g > n; g--)
    v || r.index(g) > 0 ? ((v = !0), (u = Z.from(r.node(g).copy(u))), d++) : l--
  let f = Z.empty,
    p = 0
  for (let g = i, v = !1; g > n; g--)
    v || o.after(g + 1) < o.end(g)
      ? ((v = !0), (f = Z.from(o.node(g).copy(f))), p++)
      : c++
  e.step(new Bt(l, c, s, a, new oe(u.append(f), d, p), u.size - d, !0))
}
function Gb(e, t, n = null, r = e) {
  let o = eF(e, t),
    i = o && tF(r, t)
  return i ? o.map(BE).concat({ type: t, attrs: n }).concat(i.map(BE)) : null
}
function BE(e) {
  return { type: e, attrs: null }
}
function eF(e, t) {
  let { parent: n, startIndex: r, endIndex: o } = e,
    i = n.contentMatchAt(r).findWrapping(t)
  if (!i) return null
  let s = i.length ? i[0] : t
  return n.canReplaceWith(r, o, s) ? i : null
}
function tF(e, t) {
  let { parent: n, startIndex: r, endIndex: o } = e,
    i = n.child(r),
    s = t.contentMatch.findWrapping(i.type)
  if (!s) return null
  let l = (s.length ? s[s.length - 1] : t).contentMatch
  for (let c = r; l && c < o; c++) l = l.matchType(n.child(c).type)
  return !l || !l.validEnd ? null : s
}
function nF(e, t, n) {
  let r = Z.empty
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r)
      if (!a || !a.validEnd)
        throw new RangeError(
          "Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
        )
    }
    r = Z.from(n[s].type.create(n[s].attrs, r))
  }
  let o = t.start,
    i = t.end
  e.step(new Bt(o, i, o, i, new oe(r, 0, 0), n.length, !0))
}
function rF(e, t, n, r, o) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock")
  let i = e.steps.length
  e.doc.nodesBetween(t, n, (s, a) => {
    let l = typeof o == "function" ? o(s) : o
    if (
      s.isTextblock &&
      !s.hasMarkup(r, l) &&
      oF(e.doc, e.mapping.slice(i).map(a), r)
    ) {
      let c = null
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre",
          g = !!r.contentMatch.matchType(r.schema.linebreakReplacement)
        p && !g ? (c = !1) : !p && g && (c = !0)
      }
      c === !1 && uO(e, s, a, i),
        Kb(e, e.mapping.slice(i).map(a, 1), r, void 0, c === null)
      let u = e.mapping.slice(i),
        d = u.map(a, 1),
        f = u.map(a + s.nodeSize, 1)
      return (
        e.step(
          new Bt(
            d,
            f,
            d + 1,
            f - 1,
            new oe(Z.from(r.create(l, null, s.marks)), 0, 0),
            1,
            !0
          )
        ),
        c === !0 && cO(e, s, a, i),
        !1
      )
    }
  })
}
function cO(e, t, n, r) {
  t.forEach((o, i) => {
    if (o.isText) {
      let s,
        a = /\r?\n|\r/g
      for (; (s = a.exec(o.text)); ) {
        let l = e.mapping.slice(r).map(n + 1 + i + s.index)
        e.replaceWith(l, l + 1, t.type.schema.linebreakReplacement.create())
      }
    }
  })
}
function uO(e, t, n, r) {
  t.forEach((o, i) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let s = e.mapping.slice(r).map(n + 1 + i)
      e.replaceWith(
        s,
        s + 1,
        t.type.schema.text(`
`)
      )
    }
  })
}
function oF(e, t, n) {
  let r = e.resolve(t),
    o = r.index()
  return r.parent.canReplaceWith(o, o + 1, n)
}
function iF(e, t, n, r, o) {
  let i = e.doc.nodeAt(t)
  if (!i) throw new RangeError("No node at given position")
  n || (n = i.type)
  let s = n.create(r, null, o || i.marks)
  if (i.isLeaf) return e.replaceWith(t, t + i.nodeSize, s)
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name)
  e.step(
    new Bt(
      t,
      t + i.nodeSize,
      t + 1,
      t + i.nodeSize - 1,
      new oe(Z.from(s), 0, 0),
      1,
      !0
    )
  )
}
function Ra(e, t, n = 1, r) {
  let o = e.resolve(t),
    i = o.depth - n,
    s = (r && r[r.length - 1]) || o.parent
  if (
    i < 0 ||
    o.parent.type.spec.isolating ||
    !o.parent.canReplace(o.index(), o.parent.childCount) ||
    !s.type.validContent(
      o.parent.content.cutByIndex(o.index(), o.parent.childCount)
    )
  )
    return !1
  for (let c = o.depth - 1, u = n - 2; c > i; c--, u--) {
    let d = o.node(c),
      f = o.index(c)
    if (d.type.spec.isolating) return !1
    let p = d.content.cutByIndex(f, d.childCount),
      g = r && r[u + 1]
    g && (p = p.replaceChild(0, g.type.create(g.attrs)))
    let v = (r && r[u]) || d
    if (!d.canReplace(f + 1, d.childCount) || !v.type.validContent(p)) return !1
  }
  let a = o.indexAfter(i),
    l = r && r[0]
  return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type)
}
function sF(e, t, n = 1, r) {
  let o = e.doc.resolve(t),
    i = Z.empty,
    s = Z.empty
  for (let a = o.depth, l = o.depth - n, c = n - 1; a > l; a--, c--) {
    i = Z.from(o.node(a).copy(i))
    let u = r && r[c]
    s = Z.from(u ? u.type.create(u.attrs, s) : o.node(a).copy(s))
  }
  e.step(new Mt(t, t, new oe(i.append(s), n, n), !0))
}
function Di(e, t) {
  let n = e.resolve(t),
    r = n.index()
  return dO(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function aF(e, t) {
  t.content.size || e.type.compatibleContent(t.type)
  let n = e.contentMatchAt(e.childCount),
    { linebreakReplacement: r } = e.type.schema
  for (let o = 0; o < t.childCount; o++) {
    let i = t.child(o),
      s = i.type == r ? e.type.schema.nodes.text : i.type
    if (((n = n.matchType(s)), !n || !e.type.allowsMarks(i.marks))) return !1
  }
  return n.validEnd
}
function dO(e, t) {
  return !!(e && t && !e.isLeaf && aF(e, t))
}
function Jh(e, t, n = -1) {
  let r = e.resolve(t)
  for (let o = r.depth; ; o--) {
    let i,
      s,
      a = r.index(o)
    if (
      (o == r.depth
        ? ((i = r.nodeBefore), (s = r.nodeAfter))
        : n > 0
          ? ((i = r.node(o + 1)), a++, (s = r.node(o).maybeChild(a)))
          : ((i = r.node(o).maybeChild(a - 1)), (s = r.node(o + 1))),
      i && !i.isTextblock && dO(i, s) && r.node(o).canReplace(a, a + 1))
    )
      return t
    if (o == 0) break
    t = n < 0 ? r.before(o) : r.after(o)
  }
}
function lF(e, t, n) {
  let r = null,
    { linebreakReplacement: o } = e.doc.type.schema,
    i = e.doc.resolve(t - n),
    s = i.node().type
  if (o && s.inlineContent) {
    let u = s.whitespace == "pre",
      d = !!s.contentMatch.matchType(o)
    u && !d ? (r = !1) : !u && d && (r = !0)
  }
  let a = e.steps.length
  if (r === !1) {
    let u = e.doc.resolve(t + n)
    uO(e, u.node(), u.before(), a)
  }
  s.inlineContent &&
    Kb(e, t + n - 1, s, i.node().contentMatchAt(i.index()), r == null)
  let l = e.mapping.slice(a),
    c = l.map(t - n)
  if ((e.step(new Mt(c, l.map(t + n, -1), oe.empty, !0)), r === !0)) {
    let u = e.doc.resolve(c)
    cO(e, u.node(), u.before(), e.steps.length)
  }
  return e
}
function cF(e, t, n) {
  let r = e.resolve(t)
  if (r.parent.canReplaceWith(r.index(), r.index(), n)) return t
  if (r.parentOffset == 0)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.index(o)
      if (r.node(o).canReplaceWith(i, i, n)) return r.before(o + 1)
      if (i > 0) return null
    }
  if (r.parentOffset == r.parent.content.size)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.indexAfter(o)
      if (r.node(o).canReplaceWith(i, i, n)) return r.after(o + 1)
      if (i < r.node(o).childCount) return null
    }
  return null
}
function fO(e, t, n) {
  let r = e.resolve(t)
  if (!n.content.size) return t
  let o = n.content
  for (let i = 0; i < n.openStart; i++) o = o.firstChild.content
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let s = r.depth; s >= 0; s--) {
      let a =
          s == r.depth
            ? 0
            : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
              ? -1
              : 1,
        l = r.index(s) + (a > 0 ? 1 : 0),
        c = r.node(s),
        u = !1
      if (i == 1) u = c.canReplace(l, l, o)
      else {
        let d = c.contentMatchAt(l).findWrapping(o.firstChild.type)
        u = d && c.canReplaceWith(l, l, d[0])
      }
      if (u) return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1)
    }
  return null
}
function em(e, t, n = t, r = oe.empty) {
  if (t == n && !r.size) return null
  let o = e.resolve(t),
    i = e.resolve(n)
  return pO(o, i, r) ? new Mt(t, n, r) : new uF(o, i, r).fit()
}
function pO(e, t, n) {
  return (
    !n.openStart &&
    !n.openEnd &&
    e.start() == t.start() &&
    e.parent.canReplace(e.index(), t.index(), n.content)
  )
}
class uF {
  constructor(t, n, r) {
    ;(this.$from = t),
      (this.$to = n),
      (this.unplaced = r),
      (this.frontier = []),
      (this.placed = Z.empty)
    for (let o = 0; o <= t.depth; o++) {
      let i = t.node(o)
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(t.indexAfter(o)),
      })
    }
    for (let o = t.depth; o > 0; o--)
      this.placed = Z.from(t.node(o).copy(this.placed))
  }
  get depth() {
    return this.frontier.length - 1
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable()
      c ? this.placeNodes(c) : this.openMore() || this.dropNode()
    }
    let t = this.mustMoveInline(),
      n = this.placed.size - this.depth - this.$from.depth,
      r = this.$from,
      o = this.close(t < 0 ? this.$to : r.doc.resolve(t))
    if (!o) return null
    let i = this.placed,
      s = r.depth,
      a = o.depth
    for (; s && a && i.childCount == 1; ) (i = i.firstChild.content), s--, a--
    let l = new oe(i, s, a)
    return t > -1
      ? new Bt(r.pos, t, this.$to.pos, this.$to.end(), l, n)
      : l.size || r.pos != this.$to.pos
        ? new Mt(r.pos, o.pos, l)
        : null
  }
  findFittable() {
    let t = this.unplaced.openStart
    for (
      let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd;
      r < t;
      r++
    ) {
      let i = n.firstChild
      if ((n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r)) {
        t = r
        break
      }
      n = i.content
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
        let o,
          i = null
        r
          ? ((i = xg(this.unplaced.content, r - 1).firstChild), (o = i.content))
          : (o = this.unplaced.content)
        let s = o.firstChild
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a],
            u,
            d = null
          if (
            n == 1 &&
            (s
              ? c.matchType(s.type) || (d = c.fillBefore(Z.from(s), !1))
              : i && l.compatibleContent(i.type))
          )
            return { sliceDepth: r, frontierDepth: a, parent: i, inject: d }
          if (n == 2 && s && (u = c.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: i, wrap: u }
          if (i && c.matchType(i.type)) break
        }
      }
  }
  openMore() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced,
      o = xg(t, n)
    return !o.childCount || o.firstChild.isLeaf
      ? !1
      : ((this.unplaced = new oe(
          t,
          n + 1,
          Math.max(r, o.size + n >= t.size - r ? n + 1 : 0)
        )),
        !0)
  }
  dropNode() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced,
      o = xg(t, n)
    if (o.childCount <= 1 && n > 0) {
      let i = t.size - n <= n + o.size
      this.unplaced = new oe(Kl(t, n - 1, 1), n - 1, i ? n - 1 : r)
    } else this.unplaced = new oe(Kl(t, n, 1), n, r)
  }
  placeNodes({
    sliceDepth: t,
    frontierDepth: n,
    parent: r,
    inject: o,
    wrap: i,
  }) {
    for (; this.depth > n; ) this.closeFrontierNode()
    if (i) for (let v = 0; v < i.length; v++) this.openFrontierNode(i[v])
    let s = this.unplaced,
      a = r ? r.content : s.content,
      l = s.openStart - t,
      c = 0,
      u = [],
      { match: d, type: f } = this.frontier[n]
    if (o) {
      for (let v = 0; v < o.childCount; v++) u.push(o.child(v))
      d = d.matchFragment(o)
    }
    let p = a.size + t - (s.content.size - s.openEnd)
    for (; c < a.childCount; ) {
      let v = a.child(c),
        b = d.matchType(v.type)
      if (!b) break
      c++,
        (c > 1 || l == 0 || v.content.size) &&
          ((d = b),
          u.push(
            hO(
              v.mark(f.allowedMarks(v.marks)),
              c == 1 ? l : 0,
              c == a.childCount ? p : -1
            )
          ))
    }
    let g = c == a.childCount
    g || (p = -1),
      (this.placed = Gl(this.placed, n, Z.from(u))),
      (this.frontier[n].match = d),
      g &&
        p < 0 &&
        r &&
        r.type == this.frontier[this.depth].type &&
        this.frontier.length > 1 &&
        this.closeFrontierNode()
    for (let v = 0, b = a; v < p; v++) {
      let y = b.lastChild
      this.frontier.push({
        type: y.type,
        match: y.contentMatchAt(y.childCount),
      }),
        (b = y.content)
    }
    this.unplaced = g
      ? t == 0
        ? oe.empty
        : new oe(Kl(s.content, t - 1, 1), t - 1, p < 0 ? s.openEnd : t - 1)
      : new oe(Kl(s.content, t, c), s.openStart, s.openEnd)
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock) return -1
    let t = this.frontier[this.depth],
      n
    if (
      !t.type.isTextblock ||
      !wg(this.$to, this.$to.depth, t.type, t.match, !1) ||
      (this.$to.depth == this.depth &&
        (n = this.findCloseLevel(this.$to)) &&
        n.depth == this.depth)
    )
      return -1
    let { depth: r } = this.$to,
      o = this.$to.after(r)
    for (; r > 1 && o == this.$to.end(--r); ) ++o
    return o
  }
  findCloseLevel(t) {
    e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
      let { match: r, type: o } = this.frontier[n],
        i = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)),
        s = wg(t, n, o, r, i)
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a],
            u = wg(t, a, c, l, !0)
          if (!u || u.childCount) continue e
        }
        return { depth: n, fit: s, move: i ? t.doc.resolve(t.after(n + 1)) : t }
      }
    }
  }
  close(t) {
    let n = this.findCloseLevel(t)
    if (!n) return null
    for (; this.depth > n.depth; ) this.closeFrontierNode()
    n.fit.childCount && (this.placed = Gl(this.placed, n.depth, n.fit)),
      (t = n.move)
    for (let r = n.depth + 1; r <= t.depth; r++) {
      let o = t.node(r),
        i = o.type.contentMatch.fillBefore(o.content, !0, t.index(r))
      this.openFrontierNode(o.type, o.attrs, i)
    }
    return t
  }
  openFrontierNode(t, n = null, r) {
    let o = this.frontier[this.depth]
    ;(o.match = o.match.matchType(t)),
      (this.placed = Gl(this.placed, this.depth, Z.from(t.create(n, r)))),
      this.frontier.push({ type: t, match: t.contentMatch })
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(Z.empty, !0)
    n.childCount && (this.placed = Gl(this.placed, this.frontier.length, n))
  }
}
function Kl(e, t, n) {
  return t == 0
    ? e.cutByIndex(n, e.childCount)
    : e.replaceChild(0, e.firstChild.copy(Kl(e.firstChild.content, t - 1, n)))
}
function Gl(e, t, n) {
  return t == 0
    ? e.append(n)
    : e.replaceChild(
        e.childCount - 1,
        e.lastChild.copy(Gl(e.lastChild.content, t - 1, n))
      )
}
function xg(e, t) {
  for (let n = 0; n < t; n++) e = e.firstChild.content
  return e
}
function hO(e, t, n) {
  if (t <= 0) return e
  let r = e.content
  return (
    t > 1 &&
      (r = r.replaceChild(
        0,
        hO(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0)
      )),
    t > 0 &&
      ((r = e.type.contentMatch.fillBefore(r).append(r)),
      n <= 0 &&
        (r = r.append(
          e.type.contentMatch.matchFragment(r).fillBefore(Z.empty, !0)
        ))),
    e.copy(r)
  )
}
function wg(e, t, n, r, o) {
  let i = e.node(t),
    s = o ? e.indexAfter(t) : e.index(t)
  if (s == i.childCount && !n.compatibleContent(i.type)) return null
  let a = r.fillBefore(i.content, !0, s)
  return a && !dF(n, i.content, s) ? a : null
}
function dF(e, t, n) {
  for (let r = n; r < t.childCount; r++)
    if (!e.allowsMarks(t.child(r).marks)) return !0
  return !1
}
function fF(e) {
  return e.spec.defining || e.spec.definingForContent
}
function pF(e, t, n, r) {
  if (!r.size) return e.deleteRange(t, n)
  let o = e.doc.resolve(t),
    i = e.doc.resolve(n)
  if (pO(o, i, r)) return e.step(new Mt(t, n, r))
  let s = gO(o, e.doc.resolve(n))
  s[s.length - 1] == 0 && s.pop()
  let a = -(o.depth + 1)
  s.unshift(a)
  for (let f = o.depth, p = o.pos - 1; f > 0; f--, p--) {
    let g = o.node(f).type.spec
    if (g.defining || g.definingAsContext || g.isolating) break
    s.indexOf(f) > -1 ? (a = f) : o.before(f) == p && s.splice(1, 0, -f)
  }
  let l = s.indexOf(a),
    c = [],
    u = r.openStart
  for (let f = r.content, p = 0; ; p++) {
    let g = f.firstChild
    if ((c.push(g), p == r.openStart)) break
    f = g.content
  }
  for (let f = u - 1; f >= 0; f--) {
    let p = c[f],
      g = fF(p.type)
    if (g && !p.sameMarkup(o.node(Math.abs(a) - 1))) u = f
    else if (g || !p.type.isTextblock) break
  }
  for (let f = r.openStart; f >= 0; f--) {
    let p = (f + u + 1) % (r.openStart + 1),
      g = c[p]
    if (g)
      for (let v = 0; v < s.length; v++) {
        let b = s[(v + l) % s.length],
          y = !0
        b < 0 && ((y = !1), (b = -b))
        let x = o.node(b - 1),
          E = o.index(b - 1)
        if (x.canReplaceWith(E, E, g.type, g.marks))
          return e.replace(
            o.before(b),
            y ? i.after(b) : n,
            new oe(mO(r.content, 0, r.openStart, p), p, r.openEnd)
          )
      }
  }
  let d = e.steps.length
  for (
    let f = s.length - 1;
    f >= 0 && (e.replace(t, n, r), !(e.steps.length > d));
    f--
  ) {
    let p = s[f]
    p < 0 || ((t = o.before(p)), (n = i.after(p)))
  }
}
function mO(e, t, n, r, o) {
  if (t < n) {
    let i = e.firstChild
    e = e.replaceChild(0, i.copy(mO(i.content, t + 1, n, r, i)))
  }
  if (t > r) {
    let i = o.contentMatchAt(0),
      s = i.fillBefore(e).append(e)
    e = s.append(i.matchFragment(s).fillBefore(Z.empty, !0))
  }
  return e
}
function hF(e, t, n, r) {
  if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
    let o = cF(e.doc, t, r.type)
    o != null && (t = n = o)
  }
  e.replaceRange(t, n, new oe(Z.from(r), 0, 0))
}
function mF(e, t, n) {
  let r = e.doc.resolve(t),
    o = e.doc.resolve(n),
    i = gO(r, o)
  for (let s = 0; s < i.length; s++) {
    let a = i[s],
      l = s == i.length - 1
    if ((l && a == 0) || r.node(a).type.contentMatch.validEnd)
      return e.delete(r.start(a), o.end(a))
    if (
      a > 0 &&
      (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1)))
    )
      return e.delete(r.before(a), o.after(a))
  }
  for (let s = 1; s <= r.depth && s <= o.depth; s++)
    if (
      t - r.start(s) == r.depth - s &&
      n > r.end(s) &&
      o.end(s) - n != o.depth - s &&
      r.start(s - 1) == o.start(s - 1) &&
      r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1))
    )
      return e.delete(r.before(s), n)
  e.delete(t, n)
}
function gO(e, t) {
  let n = [],
    r = Math.min(e.depth, t.depth)
  for (let o = r; o >= 0; o--) {
    let i = e.start(o)
    if (
      i < e.pos - (e.depth - o) ||
      t.end(o) > t.pos + (t.depth - o) ||
      e.node(o).type.spec.isolating ||
      t.node(o).type.spec.isolating
    )
      break
    ;(i == t.start(o) ||
      (o == e.depth &&
        o == t.depth &&
        e.parent.inlineContent &&
        t.parent.inlineContent &&
        o &&
        t.start(o - 1) == i - 1)) &&
      n.push(o)
  }
  return n
}
class Ia extends sn {
  constructor(t, n, r) {
    super(), (this.pos = t), (this.attr = n), (this.value = r)
  }
  apply(t) {
    let n = t.nodeAt(this.pos)
    if (!n) return _t.fail("No node at attribute step's position")
    let r = Object.create(null)
    for (let i in n.attrs) r[i] = n.attrs[i]
    r[this.attr] = this.value
    let o = n.type.create(r, null, n.marks)
    return _t.fromReplace(
      t,
      this.pos,
      this.pos + 1,
      new oe(Z.from(o), 0, n.isLeaf ? 0 : 1)
    )
  }
  getMap() {
    return Pn.empty
  }
  invert(t) {
    return new Ia(this.pos, this.attr, t.nodeAt(this.pos).attrs[this.attr])
  }
  map(t) {
    let n = t.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new Ia(n.pos, this.attr, this.value)
  }
  toJSON() {
    return {
      stepType: "attr",
      pos: this.pos,
      attr: this.attr,
      value: this.value,
    }
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON")
    return new Ia(n.pos, n.attr, n.value)
  }
}
sn.jsonID("attr", Ia)
class ou extends sn {
  constructor(t, n) {
    super(), (this.attr = t), (this.value = n)
  }
  apply(t) {
    let n = Object.create(null)
    for (let o in t.attrs) n[o] = t.attrs[o]
    n[this.attr] = this.value
    let r = t.type.create(n, t.content, t.marks)
    return _t.ok(r)
  }
  getMap() {
    return Pn.empty
  }
  invert(t) {
    return new ou(this.attr, t.attrs[this.attr])
  }
  map(t) {
    return this
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value }
  }
  static fromJSON(t, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON")
    return new ou(n.attr, n.value)
  }
}
sn.jsonID("docAttr", ou)
let Ya = class extends Error {}
Ya = function e(t) {
  let n = Error.call(this, t)
  return (n.__proto__ = e.prototype), n
}
Ya.prototype = Object.create(Error.prototype)
Ya.prototype.constructor = Ya
Ya.prototype.name = "TransformError"
class vO {
  constructor(t) {
    ;(this.doc = t),
      (this.steps = []),
      (this.docs = []),
      (this.mapping = new ru())
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc
  }
  step(t) {
    let n = this.maybeStep(t)
    if (n.failed) throw new Ya(n.failed)
    return this
  }
  maybeStep(t) {
    let n = t.apply(this.doc)
    return n.failed || this.addStep(t, n.doc), n
  }
  get docChanged() {
    return this.steps.length > 0
  }
  addStep(t, n) {
    this.docs.push(this.doc),
      this.steps.push(t),
      this.mapping.appendMap(t.getMap()),
      (this.doc = n)
  }
  replace(t, n = t, r = oe.empty) {
    let o = em(this.doc, t, n, r)
    return o && this.step(o), this
  }
  replaceWith(t, n, r) {
    return this.replace(t, n, new oe(Z.from(r), 0, 0))
  }
  delete(t, n) {
    return this.replace(t, n, oe.empty)
  }
  insert(t, n) {
    return this.replaceWith(t, t, n)
  }
  replaceRange(t, n, r) {
    return pF(this, t, n, r), this
  }
  replaceRangeWith(t, n, r) {
    return hF(this, t, n, r), this
  }
  deleteRange(t, n) {
    return mF(this, t, n), this
  }
  lift(t, n) {
    return Jj(this, t, n), this
  }
  join(t, n = 1) {
    return lF(this, t, n), this
  }
  wrap(t, n) {
    return nF(this, t, n), this
  }
  setBlockType(t, n = t, r, o = null) {
    return rF(this, t, n, r, o), this
  }
  setNodeMarkup(t, n, r = null, o) {
    return iF(this, t, n, r, o), this
  }
  setNodeAttribute(t, n, r) {
    return this.step(new Ia(t, n, r)), this
  }
  setDocAttribute(t, n) {
    return this.step(new ou(t, n)), this
  }
  addNodeMark(t, n) {
    return this.step(new ei(t, n)), this
  }
  removeNodeMark(t, n) {
    if (!(n instanceof Ke)) {
      let r = this.doc.nodeAt(t)
      if (!r) throw new RangeError("No node at position " + t)
      if (((n = n.isInSet(r.marks)), !n)) return this
    }
    return this.step(new Za(t, n)), this
  }
  split(t, n = 1, r) {
    return sF(this, t, n, r), this
  }
  addMark(t, n, r) {
    return Yj(this, t, n, r), this
  }
  removeMark(t, n, r) {
    return Xj(this, t, n, r), this
  }
  clearIncompatible(t, n, r) {
    return Kb(this, t, n, r), this
  }
}
const Eg = Object.create(null)
let Ne = class {
  constructor(t, n, r) {
    ;(this.$anchor = t),
      (this.$head = n),
      (this.ranges = r || [new gF(t.min(n), t.max(n))])
  }
  get anchor() {
    return this.$anchor.pos
  }
  get head() {
    return this.$head.pos
  }
  get from() {
    return this.$from.pos
  }
  get to() {
    return this.$to.pos
  }
  get $from() {
    return this.ranges[0].$from
  }
  get $to() {
    return this.ranges[0].$to
  }
  get empty() {
    let t = this.ranges
    for (let n = 0; n < t.length; n++)
      if (t[n].$from.pos != t[n].$to.pos) return !1
    return !0
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, !0)
  }
  replace(t, n = oe.empty) {
    let r = n.content.lastChild,
      o = null
    for (let a = 0; a < n.openEnd; a++) (o = r), (r = r.lastChild)
    let i = t.steps.length,
      s = this.ranges
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: c } = s[a],
        u = t.mapping.slice(i)
      t.replaceRange(u.map(l.pos), u.map(c.pos), a ? oe.empty : n),
        a == 0 && zE(t, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1)
    }
  }
  replaceWith(t, n) {
    let r = t.steps.length,
      o = this.ranges
    for (let i = 0; i < o.length; i++) {
      let { $from: s, $to: a } = o[i],
        l = t.mapping.slice(r),
        c = l.map(s.pos),
        u = l.map(a.pos)
      i
        ? t.deleteRange(c, u)
        : (t.replaceRangeWith(c, u, n), zE(t, r, n.isInline ? -1 : 1))
    }
  }
  static findFrom(t, n, r = !1) {
    let o = t.parent.inlineContent
      ? new _e(t)
      : ta(t.node(0), t.parent, t.pos, t.index(), n, r)
    if (o) return o
    for (let i = t.depth - 1; i >= 0; i--) {
      let s =
        n < 0
          ? ta(t.node(0), t.node(i), t.before(i + 1), t.index(i), n, r)
          : ta(t.node(0), t.node(i), t.after(i + 1), t.index(i) + 1, n, r)
      if (s) return s
    }
    return null
  }
  static near(t, n = 1) {
    return this.findFrom(t, n) || this.findFrom(t, -n) || new or(t.node(0))
  }
  static atStart(t) {
    return ta(t, t, 0, 0, 1) || new or(t)
  }
  static atEnd(t) {
    return ta(t, t, t.content.size, t.childCount, -1) || new or(t)
  }
  static fromJSON(t, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON")
    let r = Eg[n.type]
    if (!r) throw new RangeError(`No selection type ${n.type} defined`)
    return r.fromJSON(t, n)
  }
  static jsonID(t, n) {
    if (t in Eg) throw new RangeError("Duplicate use of selection JSON ID " + t)
    return (Eg[t] = n), (n.prototype.jsonID = t), n
  }
  getBookmark() {
    return _e.between(this.$anchor, this.$head).getBookmark()
  }
}
Ne.prototype.visible = !0
class gF {
  constructor(t, n) {
    ;(this.$from = t), (this.$to = n)
  }
}
let jE = !1
function FE(e) {
  !jE &&
    !e.parent.inlineContent &&
    ((jE = !0),
    console.warn(
      "TextSelection endpoint not pointing into a node with inline content (" +
        e.parent.type.name +
        ")"
    ))
}
class _e extends Ne {
  constructor(t, n = t) {
    FE(t), FE(n), super(t, n)
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head))
    if (!r.parent.inlineContent) return Ne.near(r)
    let o = t.resolve(n.map(this.anchor))
    return new _e(o.parent.inlineContent ? o : r, r)
  }
  replace(t, n = oe.empty) {
    if ((super.replace(t, n), n == oe.empty)) {
      let r = this.$from.marksAcross(this.$to)
      r && t.ensureMarks(r)
    }
  }
  eq(t) {
    return t instanceof _e && t.anchor == this.anchor && t.head == this.head
  }
  getBookmark() {
    return new tm(this.anchor, this.head)
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head }
  }
  static fromJSON(t, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON")
    return new _e(t.resolve(n.anchor), t.resolve(n.head))
  }
  static create(t, n, r = n) {
    let o = t.resolve(n)
    return new this(o, r == n ? o : t.resolve(r))
  }
  static between(t, n, r) {
    let o = t.pos - n.pos
    if (((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent)) {
      let i = Ne.findFrom(n, r, !0) || Ne.findFrom(n, -r, !0)
      if (i) n = i.$head
      else return Ne.near(n, r)
    }
    return (
      t.parent.inlineContent ||
        (o == 0
          ? (t = n)
          : ((t = (Ne.findFrom(t, -r, !0) || Ne.findFrom(t, r, !0)).$anchor),
            t.pos < n.pos != o < 0 && (t = n))),
      new _e(t, n)
    )
  }
}
Ne.jsonID("text", _e)
class tm {
  constructor(t, n) {
    ;(this.anchor = t), (this.head = n)
  }
  map(t) {
    return new tm(t.map(this.anchor), t.map(this.head))
  }
  resolve(t) {
    return _e.between(t.resolve(this.anchor), t.resolve(this.head))
  }
}
class ye extends Ne {
  constructor(t) {
    let n = t.nodeAfter,
      r = t.node(0).resolve(t.pos + n.nodeSize)
    super(t, r), (this.node = n)
  }
  map(t, n) {
    let { deleted: r, pos: o } = n.mapResult(this.anchor),
      i = t.resolve(o)
    return r ? Ne.near(i) : new ye(i)
  }
  content() {
    return new oe(Z.from(this.node), 0, 0)
  }
  eq(t) {
    return t instanceof ye && t.anchor == this.anchor
  }
  toJSON() {
    return { type: "node", anchor: this.anchor }
  }
  getBookmark() {
    return new qb(this.anchor)
  }
  static fromJSON(t, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON")
    return new ye(t.resolve(n.anchor))
  }
  static create(t, n) {
    return new ye(t.resolve(n))
  }
  static isSelectable(t) {
    return !t.isText && t.type.spec.selectable !== !1
  }
}
ye.prototype.visible = !1
Ne.jsonID("node", ye)
class qb {
  constructor(t) {
    this.anchor = t
  }
  map(t) {
    let { deleted: n, pos: r } = t.mapResult(this.anchor)
    return n ? new tm(r, r) : new qb(r)
  }
  resolve(t) {
    let n = t.resolve(this.anchor),
      r = n.nodeAfter
    return r && ye.isSelectable(r) ? new ye(n) : Ne.near(n)
  }
}
class or extends Ne {
  constructor(t) {
    super(t.resolve(0), t.resolve(t.content.size))
  }
  replace(t, n = oe.empty) {
    if (n == oe.empty) {
      t.delete(0, t.doc.content.size)
      let r = Ne.atStart(t.doc)
      r.eq(t.selection) || t.setSelection(r)
    } else super.replace(t, n)
  }
  toJSON() {
    return { type: "all" }
  }
  static fromJSON(t) {
    return new or(t)
  }
  map(t) {
    return new or(t)
  }
  eq(t) {
    return t instanceof or
  }
  getBookmark() {
    return vF
  }
}
Ne.jsonID("all", or)
const vF = {
  map() {
    return this
  },
  resolve(e) {
    return new or(e)
  },
}
function ta(e, t, n, r, o, i = !1) {
  if (t.inlineContent) return _e.create(e, n)
  for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < t.childCount : s >= 0; s += o) {
    let a = t.child(s)
    if (a.isAtom) {
      if (!i && ye.isSelectable(a))
        return ye.create(e, n - (o < 0 ? a.nodeSize : 0))
    } else {
      let l = ta(e, a, n + o, o < 0 ? a.childCount : 0, o, i)
      if (l) return l
    }
    n += a.nodeSize * o
  }
  return null
}
function zE(e, t, n) {
  let r = e.steps.length - 1
  if (r < t) return
  let o = e.steps[r]
  if (!(o instanceof Mt || o instanceof Bt)) return
  let i = e.mapping.maps[r],
    s
  i.forEach((a, l, c, u) => {
    s == null && (s = u)
  }),
    e.setSelection(Ne.near(e.doc.resolve(s), n))
}
const UE = 1,
  Sd = 2,
  VE = 4
class yF extends vO {
  constructor(t) {
    super(t.doc),
      (this.curSelectionFor = 0),
      (this.updated = 0),
      (this.meta = Object.create(null)),
      (this.time = Date.now()),
      (this.curSelection = t.selection),
      (this.storedMarks = t.storedMarks)
  }
  get selection() {
    return (
      this.curSelectionFor < this.steps.length &&
        ((this.curSelection = this.curSelection.map(
          this.doc,
          this.mapping.slice(this.curSelectionFor)
        )),
        (this.curSelectionFor = this.steps.length)),
      this.curSelection
    )
  }
  setSelection(t) {
    if (t.$from.doc != this.doc)
      throw new RangeError(
        "Selection passed to setSelection must point at the current document"
      )
    return (
      (this.curSelection = t),
      (this.curSelectionFor = this.steps.length),
      (this.updated = (this.updated | UE) & ~Sd),
      (this.storedMarks = null),
      this
    )
  }
  get selectionSet() {
    return (this.updated & UE) > 0
  }
  setStoredMarks(t) {
    return (this.storedMarks = t), (this.updated |= Sd), this
  }
  ensureMarks(t) {
    return (
      Ke.sameSet(this.storedMarks || this.selection.$from.marks(), t) ||
        this.setStoredMarks(t),
      this
    )
  }
  addStoredMark(t) {
    return this.ensureMarks(
      t.addToSet(this.storedMarks || this.selection.$head.marks())
    )
  }
  removeStoredMark(t) {
    return this.ensureMarks(
      t.removeFromSet(this.storedMarks || this.selection.$head.marks())
    )
  }
  get storedMarksSet() {
    return (this.updated & Sd) > 0
  }
  addStep(t, n) {
    super.addStep(t, n),
      (this.updated = this.updated & ~Sd),
      (this.storedMarks = null)
  }
  setTime(t) {
    return (this.time = t), this
  }
  replaceSelection(t) {
    return this.selection.replace(this, t), this
  }
  replaceSelectionWith(t, n = !0) {
    let r = this.selection
    return (
      n &&
        (t = t.mark(
          this.storedMarks ||
            (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Ke.none)
        )),
      r.replaceWith(this, t),
      this
    )
  }
  deleteSelection() {
    return this.selection.replace(this), this
  }
  insertText(t, n, r) {
    let o = this.doc.type.schema
    if (n == null)
      return t
        ? this.replaceSelectionWith(o.text(t), !0)
        : this.deleteSelection()
    {
      if ((r == null && (r = n), (r = r == null ? n : r), !t))
        return this.deleteRange(n, r)
      let i = this.storedMarks
      if (!i) {
        let s = this.doc.resolve(n)
        i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r))
      }
      return (
        this.replaceRangeWith(n, r, o.text(t, i)),
        this.selection.empty || this.setSelection(Ne.near(this.selection.$to)),
        this
      )
    }
  }
  setMeta(t, n) {
    return (this.meta[typeof t == "string" ? t : t.key] = n), this
  }
  getMeta(t) {
    return this.meta[typeof t == "string" ? t : t.key]
  }
  get isGeneric() {
    for (let t in this.meta) return !1
    return !0
  }
  scrollIntoView() {
    return (this.updated |= VE), this
  }
  get scrolledIntoView() {
    return (this.updated & VE) > 0
  }
}
function HE(e, t) {
  return !t || !e ? e : e.bind(t)
}
class ql {
  constructor(t, n, r) {
    ;(this.name = t), (this.init = HE(n.init, r)), (this.apply = HE(n.apply, r))
  }
}
const bF = [
  new ql("doc", {
    init(e) {
      return e.doc || e.schema.topNodeType.createAndFill()
    },
    apply(e) {
      return e.doc
    },
  }),
  new ql("selection", {
    init(e, t) {
      return e.selection || Ne.atStart(t.doc)
    },
    apply(e) {
      return e.selection
    },
  }),
  new ql("storedMarks", {
    init(e) {
      return e.storedMarks || null
    },
    apply(e, t, n, r) {
      return r.selection.$cursor ? e.storedMarks : null
    },
  }),
  new ql("scrollToSelection", {
    init() {
      return 0
    },
    apply(e, t) {
      return e.scrolledIntoView ? t + 1 : t
    },
  }),
]
class Cg {
  constructor(t, n) {
    ;(this.schema = t),
      (this.plugins = []),
      (this.pluginsByKey = Object.create(null)),
      (this.fields = bF.slice()),
      n &&
        n.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError(
              "Adding different instances of a keyed plugin (" + r.key + ")"
            )
          this.plugins.push(r),
            (this.pluginsByKey[r.key] = r),
            r.spec.state && this.fields.push(new ql(r.key, r.spec.state, r))
        })
  }
}
class xa {
  constructor(t) {
    this.config = t
  }
  get schema() {
    return this.config.schema
  }
  get plugins() {
    return this.config.plugins
  }
  apply(t) {
    return this.applyTransaction(t).state
  }
  filterTransaction(t, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let o = this.config.plugins[r]
        if (
          o.spec.filterTransaction &&
          !o.spec.filterTransaction.call(o, t, this)
        )
          return !1
      }
    return !0
  }
  applyTransaction(t) {
    if (!this.filterTransaction(t)) return { state: this, transactions: [] }
    let n = [t],
      r = this.applyInner(t),
      o = null
    for (;;) {
      let i = !1
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s]
        if (a.spec.appendTransaction) {
          let l = o ? o[s].n : 0,
            c = o ? o[s].state : this,
            u =
              l < n.length &&
              a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r)
          if (u && r.filterTransaction(u, s)) {
            if ((u.setMeta("appendedTransaction", t), !o)) {
              o = []
              for (let d = 0; d < this.config.plugins.length; d++)
                o.push(
                  d < s ? { state: r, n: n.length } : { state: this, n: 0 }
                )
            }
            n.push(u), (r = r.applyInner(u)), (i = !0)
          }
          o && (o[s] = { state: r, n: n.length })
        }
      }
      if (!i) return { state: r, transactions: n }
    }
  }
  applyInner(t) {
    if (!t.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction")
    let n = new xa(this.config),
      r = this.config.fields
    for (let o = 0; o < r.length; o++) {
      let i = r[o]
      n[i.name] = i.apply(t, this[i.name], this, n)
    }
    return n
  }
  get tr() {
    return new yF(this)
  }
  static create(t) {
    let n = new Cg(t.doc ? t.doc.type.schema : t.schema, t.plugins),
      r = new xa(n)
    for (let o = 0; o < n.fields.length; o++)
      r[n.fields[o].name] = n.fields[o].init(t, r)
    return r
  }
  reconfigure(t) {
    let n = new Cg(this.schema, t.plugins),
      r = n.fields,
      o = new xa(n)
    for (let i = 0; i < r.length; i++) {
      let s = r[i].name
      o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(t, o)
    }
    return o
  }
  toJSON(t) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }
    if (
      (this.storedMarks &&
        (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
      t && typeof t == "object")
    )
      for (let r in t) {
        if (r == "doc" || r == "selection")
          throw new RangeError(
            "The JSON fields `doc` and `selection` are reserved"
          )
        let o = t[r],
          i = o.spec.state
        i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]))
      }
    return n
  }
  static fromJSON(t, n, r) {
    if (!n) throw new RangeError("Invalid input for EditorState.fromJSON")
    if (!t.schema)
      throw new RangeError("Required config field 'schema' missing")
    let o = new Cg(t.schema, t.plugins),
      i = new xa(o)
    return (
      o.fields.forEach((s) => {
        if (s.name == "doc") i.doc = hi.fromJSON(t.schema, n.doc)
        else if (s.name == "selection")
          i.selection = Ne.fromJSON(i.doc, n.selection)
        else if (s.name == "storedMarks")
          n.storedMarks &&
            (i.storedMarks = n.storedMarks.map(t.schema.markFromJSON))
        else {
          if (r)
            for (let a in r) {
              let l = r[a],
                c = l.spec.state
              if (
                l.key == s.name &&
                c &&
                c.fromJSON &&
                Object.prototype.hasOwnProperty.call(n, a)
              ) {
                i[s.name] = c.fromJSON.call(l, t, n[a], i)
                return
              }
            }
          i[s.name] = s.init(t, i)
        }
      }),
      i
    )
  }
}
function yO(e, t, n) {
  for (let r in e) {
    let o = e[r]
    o instanceof Function
      ? (o = o.bind(t))
      : r == "handleDOMEvents" && (o = yO(o, t, {})),
      (n[r] = o)
  }
  return n
}
class rt {
  constructor(t) {
    ;(this.spec = t),
      (this.props = {}),
      t.props && yO(t.props, this, this.props),
      (this.key = t.key ? t.key.key : bO("plugin"))
  }
  getState(t) {
    return t[this.key]
  }
}
const Sg = Object.create(null)
function bO(e) {
  return e in Sg ? e + "$" + ++Sg[e] : ((Sg[e] = 0), e + "$")
}
class At {
  constructor(t = "key") {
    this.key = bO(t)
  }
  get(t) {
    return t.config.pluginsByKey[this.key]
  }
  getState(t) {
    return t[this.key]
  }
}
const Kt = function (e) {
    for (var t = 0; ; t++) if (((e = e.previousSibling), !e)) return t
  },
  Xa = function (e) {
    let t = e.assignedSlot || e.parentNode
    return t && t.nodeType == 11 ? t.host : t
  }
let Sy = null
const ho = function (e, t, n) {
    let r = Sy || (Sy = document.createRange())
    return (
      r.setEnd(e, n == null ? e.nodeValue.length : n), r.setStart(e, t || 0), r
    )
  },
  xF = function () {
    Sy = null
  },
  ks = function (e, t, n, r) {
    return n && (WE(e, t, n, r, -1) || WE(e, t, n, r, 1))
  },
  wF = /^(img|br|input|textarea|hr)$/i
function WE(e, t, n, r, o) {
  for (;;) {
    if (e == n && t == r) return !0
    if (t == (o < 0 ? 0 : tr(e))) {
      let i = e.parentNode
      if (
        !i ||
        i.nodeType != 1 ||
        Iu(e) ||
        wF.test(e.nodeName) ||
        e.contentEditable == "false"
      )
        return !1
      ;(t = Kt(e) + (o < 0 ? 0 : 1)), (e = i)
    } else if (e.nodeType == 1) {
      if (
        ((e = e.childNodes[t + (o < 0 ? -1 : 0)]), e.contentEditable == "false")
      )
        return !1
      t = o < 0 ? tr(e) : 0
    } else return !1
  }
}
function tr(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function EF(e, t) {
  for (;;) {
    if (e.nodeType == 3 && t) return e
    if (e.nodeType == 1 && t > 0) {
      if (e.contentEditable == "false") return null
      ;(e = e.childNodes[t - 1]), (t = tr(e))
    } else if (e.parentNode && !Iu(e)) (t = Kt(e)), (e = e.parentNode)
    else return null
  }
}
function CF(e, t) {
  for (;;) {
    if (e.nodeType == 3 && t < e.nodeValue.length) return e
    if (e.nodeType == 1 && t < e.childNodes.length) {
      if (e.contentEditable == "false") return null
      ;(e = e.childNodes[t]), (t = 0)
    } else if (e.parentNode && !Iu(e)) (t = Kt(e) + 1), (e = e.parentNode)
    else return null
  }
}
function SF(e, t, n) {
  for (let r = t == 0, o = t == tr(e); r || o; ) {
    if (e == n) return !0
    let i = Kt(e)
    if (((e = e.parentNode), !e)) return !1
    ;(r = r && i == 0), (o = o && i == tr(e))
  }
}
function Iu(e) {
  let t
  for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode);
  return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e)
}
const nm = function (e) {
  return (
    e.focusNode && ks(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
  )
}
function Hi(e, t) {
  let n = document.createEvent("Event")
  return (
    n.initEvent("keydown", !0, !0), (n.keyCode = e), (n.key = n.code = t), n
  )
}
function _F(e) {
  let t = e.activeElement
  for (; t && t.shadowRoot; ) t = t.shadowRoot.activeElement
  return t
}
function kF(e, t, n) {
  if (e.caretPositionFromPoint)
    try {
      let r = e.caretPositionFromPoint(t, n)
      if (r)
        return {
          node: r.offsetNode,
          offset: Math.min(tr(r.offsetNode), r.offset),
        }
    } catch {}
  if (e.caretRangeFromPoint) {
    let r = e.caretRangeFromPoint(t, n)
    if (r)
      return {
        node: r.startContainer,
        offset: Math.min(tr(r.startContainer), r.startOffset),
      }
  }
}
const Jr = typeof navigator < "u" ? navigator : null,
  KE = typeof document < "u" ? document : null,
  Li = (Jr && Jr.userAgent) || "",
  _y = /Edge\/(\d+)/.exec(Li),
  xO = /MSIE \d/.exec(Li),
  ky = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Li),
  Tn = !!(xO || ky || _y),
  gi = xO ? document.documentMode : ky ? +ky[1] : _y ? +_y[1] : 0,
  Ar = !Tn && /gecko\/(\d+)/i.test(Li)
Ar && +(/Firefox\/(\d+)/.exec(Li) || [0, 0])[1]
const Ny = !Tn && /Chrome\/(\d+)/.exec(Li),
  tn = !!Ny,
  wO = Ny ? +Ny[1] : 0,
  gn = !Tn && !!Jr && /Apple Computer/.test(Jr.vendor),
  Qa = gn && (/Mobile\/\w+/.test(Li) || (!!Jr && Jr.maxTouchPoints > 2)),
  Qn = Qa || (Jr ? /Mac/.test(Jr.platform) : !1),
  NF = Jr ? /Win/.test(Jr.platform) : !1,
  xo = /Android \d/.test(Li),
  Du = !!KE && "webkitFontSmoothing" in KE.documentElement.style,
  TF = Du ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0
function MF(e) {
  let t = e.defaultView && e.defaultView.visualViewport
  return t
    ? { left: 0, right: t.width, top: 0, bottom: t.height }
    : {
        left: 0,
        right: e.documentElement.clientWidth,
        top: 0,
        bottom: e.documentElement.clientHeight,
      }
}
function so(e, t) {
  return typeof e == "number" ? e : e[t]
}
function OF(e) {
  let t = e.getBoundingClientRect(),
    n = t.width / e.offsetWidth || 1,
    r = t.height / e.offsetHeight || 1
  return {
    left: t.left,
    right: t.left + e.clientWidth * n,
    top: t.top,
    bottom: t.top + e.clientHeight * r,
  }
}
function GE(e, t, n) {
  let r = e.someProp("scrollThreshold") || 0,
    o = e.someProp("scrollMargin") || 5,
    i = e.dom.ownerDocument
  for (let s = n || e.dom; s; ) {
    if (s.nodeType != 1) {
      s = Xa(s)
      continue
    }
    let a = s,
      l = a == i.body,
      c = l ? MF(i) : OF(a),
      u = 0,
      d = 0
    if (
      (t.top < c.top + so(r, "top")
        ? (d = -(c.top - t.top + so(o, "top")))
        : t.bottom > c.bottom - so(r, "bottom") &&
          (d =
            t.bottom - t.top > c.bottom - c.top
              ? t.top + so(o, "top") - c.top
              : t.bottom - c.bottom + so(o, "bottom")),
      t.left < c.left + so(r, "left")
        ? (u = -(c.left - t.left + so(o, "left")))
        : t.right > c.right - so(r, "right") &&
          (u = t.right - c.right + so(o, "right")),
      u || d)
    )
      if (l) i.defaultView.scrollBy(u, d)
      else {
        let p = a.scrollLeft,
          g = a.scrollTop
        d && (a.scrollTop += d), u && (a.scrollLeft += u)
        let v = a.scrollLeft - p,
          b = a.scrollTop - g
        t = {
          left: t.left - v,
          top: t.top - b,
          right: t.right - v,
          bottom: t.bottom - b,
        }
      }
    let f = l ? "fixed" : getComputedStyle(s).position
    if (/^(fixed|sticky)$/.test(f)) break
    s = f == "absolute" ? s.offsetParent : Xa(s)
  }
}
function AF(e) {
  let t = e.dom.getBoundingClientRect(),
    n = Math.max(0, t.top),
    r,
    o
  for (
    let i = (t.left + t.right) / 2, s = n + 1;
    s < Math.min(innerHeight, t.bottom);
    s += 5
  ) {
    let a = e.root.elementFromPoint(i, s)
    if (!a || a == e.dom || !e.dom.contains(a)) continue
    let l = a.getBoundingClientRect()
    if (l.top >= n - 20) {
      ;(r = a), (o = l.top)
      break
    }
  }
  return { refDOM: r, refTop: o, stack: EO(e.dom) }
}
function EO(e) {
  let t = [],
    n = e.ownerDocument
  for (
    let r = e;
    r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n);
    r = Xa(r)
  );
  return t
}
function RF({ refDOM: e, refTop: t, stack: n }) {
  let r = e ? e.getBoundingClientRect().top : 0
  CO(n, r == 0 ? 0 : r - t)
}
function CO(e, t) {
  for (let n = 0; n < e.length; n++) {
    let { dom: r, top: o, left: i } = e[n]
    r.scrollTop != o + t && (r.scrollTop = o + t),
      r.scrollLeft != i && (r.scrollLeft = i)
  }
}
let Ys = null
function IF(e) {
  if (e.setActive) return e.setActive()
  if (Ys) return e.focus(Ys)
  let t = EO(e)
  e.focus(
    Ys == null
      ? {
          get preventScroll() {
            return (Ys = { preventScroll: !0 }), !0
          },
        }
      : void 0
  ),
    Ys || ((Ys = !1), CO(t, 0))
}
function SO(e, t) {
  let n,
    r = 2e8,
    o,
    i = 0,
    s = t.top,
    a = t.top,
    l,
    c
  for (let u = e.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f
    if (u.nodeType == 1) f = u.getClientRects()
    else if (u.nodeType == 3) f = ho(u).getClientRects()
    else continue
    for (let p = 0; p < f.length; p++) {
      let g = f[p]
      if (g.top <= s && g.bottom >= a) {
        ;(s = Math.max(g.bottom, s)), (a = Math.min(g.top, a))
        let v =
          g.left > t.left
            ? g.left - t.left
            : g.right < t.left
              ? t.left - g.right
              : 0
        if (v < r) {
          ;(n = u),
            (r = v),
            (o =
              v && n.nodeType == 3
                ? { left: g.right < t.left ? g.right : g.left, top: t.top }
                : t),
            u.nodeType == 1 &&
              v &&
              (i = d + (t.left >= (g.left + g.right) / 2 ? 1 : 0))
          continue
        }
      } else
        g.top > t.top &&
          !l &&
          g.left <= t.left &&
          g.right >= t.left &&
          ((l = u),
          (c = {
            left: Math.max(g.left, Math.min(g.right, t.left)),
            top: g.top,
          }))
      !n &&
        ((t.left >= g.right && t.top >= g.top) ||
          (t.left >= g.left && t.top >= g.bottom)) &&
        (i = d + 1)
    }
  }
  return (
    !n && l && ((n = l), (o = c), (r = 0)),
    n && n.nodeType == 3
      ? DF(n, o)
      : !n || (r && n.nodeType == 1)
        ? { node: e, offset: i }
        : SO(n, o)
  )
}
function DF(e, t) {
  let n = e.nodeValue.length,
    r = document.createRange()
  for (let o = 0; o < n; o++) {
    r.setEnd(e, o + 1), r.setStart(e, o)
    let i = Fo(r, 1)
    if (i.top != i.bottom && Zb(t, i))
      return { node: e, offset: o + (t.left >= (i.left + i.right) / 2 ? 1 : 0) }
  }
  return { node: e, offset: 0 }
}
function Zb(e, t) {
  return (
    e.left >= t.left - 1 &&
    e.left <= t.right + 1 &&
    e.top >= t.top - 1 &&
    e.top <= t.bottom + 1
  )
}
function LF(e, t) {
  let n = e.parentNode
  return n &&
    /^li$/i.test(n.nodeName) &&
    t.left < e.getBoundingClientRect().left
    ? n
    : e
}
function PF(e, t, n) {
  let { node: r, offset: o } = SO(t, n),
    i = -1
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect()
    i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1
  }
  return e.docView.posFromDOM(r, o, i)
}
function $F(e, t, n, r) {
  let o = -1
  for (let i = t, s = !1; i != e.dom; ) {
    let a = e.docView.nearestDesc(i, !0),
      l
    if (!a) return null
    if (
      a.dom.nodeType == 1 &&
      ((a.node.isBlock && a.parent) || !a.contentDOM) &&
      ((l = a.dom.getBoundingClientRect()).width || l.height) &&
      (a.node.isBlock &&
        a.parent &&
        ((!s && l.left > r.left) || l.top > r.top
          ? (o = a.posBefore)
          : ((!s && l.right < r.left) || l.bottom < r.top) && (o = a.posAfter),
        (s = !0)),
      !a.contentDOM && o < 0 && !a.node.isText)
    )
      return (
        a.node.isBlock
          ? r.top < (l.top + l.bottom) / 2
          : r.left < (l.left + l.right) / 2
      )
        ? a.posBefore
        : a.posAfter
    i = a.dom.parentNode
  }
  return o > -1 ? o : e.docView.posFromDOM(t, n, -1)
}
function _O(e, t, n) {
  let r = e.childNodes.length
  if (r && n.top < n.bottom)
    for (
      let o = Math.max(
          0,
          Math.min(
            r - 1,
            Math.floor((r * (t.top - n.top)) / (n.bottom - n.top)) - 2
          )
        ),
        i = o;
      ;

    ) {
      let s = e.childNodes[i]
      if (s.nodeType == 1) {
        let a = s.getClientRects()
        for (let l = 0; l < a.length; l++) {
          let c = a[l]
          if (Zb(t, c)) return _O(s, t, c)
        }
      }
      if ((i = (i + 1) % r) == o) break
    }
  return e
}
function BF(e, t) {
  let n = e.dom.ownerDocument,
    r,
    o = 0,
    i = kF(n, t.left, t.top)
  i && ({ node: r, offset: o } = i)
  let s = (e.root.elementFromPoint ? e.root : n).elementFromPoint(
      t.left,
      t.top
    ),
    a
  if (!s || !e.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let c = e.dom.getBoundingClientRect()
    if (!Zb(t, c) || ((s = _O(e.dom, t, c)), !s)) return null
  }
  if (gn) for (let c = s; r && c; c = Xa(c)) c.draggable && (r = void 0)
  if (((s = LF(s, t)), r)) {
    if (
      Ar &&
      r.nodeType == 1 &&
      ((o = Math.min(o, r.childNodes.length)), o < r.childNodes.length)
    ) {
      let u = r.childNodes[o],
        d
      u.nodeName == "IMG" &&
        (d = u.getBoundingClientRect()).right <= t.left &&
        d.bottom > t.top &&
        o++
    }
    let c
    Du &&
      o &&
      r.nodeType == 1 &&
      (c = r.childNodes[o - 1]).nodeType == 1 &&
      c.contentEditable == "false" &&
      c.getBoundingClientRect().top >= t.top &&
      o--,
      r == e.dom &&
      o == r.childNodes.length - 1 &&
      r.lastChild.nodeType == 1 &&
      t.top > r.lastChild.getBoundingClientRect().bottom
        ? (a = e.state.doc.content.size)
        : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") &&
          (a = $F(e, r, o, t))
  }
  a == null && (a = PF(e, s, t))
  let l = e.docView.nearestDesc(s, !0)
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 }
}
function qE(e) {
  return e.top < e.bottom || e.left < e.right
}
function Fo(e, t) {
  let n = e.getClientRects()
  if (n.length) {
    let r = n[t < 0 ? 0 : n.length - 1]
    if (qE(r)) return r
  }
  return Array.prototype.find.call(n, qE) || e.getBoundingClientRect()
}
const jF = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
function kO(e, t, n) {
  let { node: r, offset: o, atom: i } = e.docView.domFromPos(t, n < 0 ? -1 : 1),
    s = Du || Ar
  if (r.nodeType == 3)
    if (s && (jF.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
      let l = Fo(ho(r, o, o), n)
      if (Ar && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
        let c = Fo(ho(r, o - 1, o - 1), -1)
        if (c.top == l.top) {
          let u = Fo(ho(r, o, o + 1), -1)
          if (u.top != l.top) return Ll(u, u.left < c.left)
        }
      }
      return l
    } else {
      let l = o,
        c = o,
        u = n < 0 ? 1 : -1
      return (
        n < 0 && !o
          ? (c++, (u = -1))
          : n >= 0 && o == r.nodeValue.length
            ? (l--, (u = 1))
            : n < 0
              ? l--
              : c++,
        Ll(Fo(ho(r, l, c), u), u < 0)
      )
    }
  if (!e.state.doc.resolve(t - (i || 0)).parent.inlineContent) {
    if (i == null && o && (n < 0 || o == tr(r))) {
      let l = r.childNodes[o - 1]
      if (l.nodeType == 1) return _g(l.getBoundingClientRect(), !1)
    }
    if (i == null && o < tr(r)) {
      let l = r.childNodes[o]
      if (l.nodeType == 1) return _g(l.getBoundingClientRect(), !0)
    }
    return _g(r.getBoundingClientRect(), n >= 0)
  }
  if (i == null && o && (n < 0 || o == tr(r))) {
    let l = r.childNodes[o - 1],
      c =
        l.nodeType == 3
          ? ho(l, tr(l) - (s ? 0 : 1))
          : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling)
            ? l
            : null
    if (c) return Ll(Fo(c, 1), !1)
  }
  if (i == null && o < tr(r)) {
    let l = r.childNodes[o]
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; ) l = l.nextSibling
    let c = l
      ? l.nodeType == 3
        ? ho(l, 0, s ? 0 : 1)
        : l.nodeType == 1
          ? l
          : null
      : null
    if (c) return Ll(Fo(c, -1), !0)
  }
  return Ll(Fo(r.nodeType == 3 ? ho(r) : r, -n), n >= 0)
}
function Ll(e, t) {
  if (e.width == 0) return e
  let n = t ? e.left : e.right
  return { top: e.top, bottom: e.bottom, left: n, right: n }
}
function _g(e, t) {
  if (e.height == 0) return e
  let n = t ? e.top : e.bottom
  return { top: n, bottom: n, left: e.left, right: e.right }
}
function NO(e, t, n) {
  let r = e.state,
    o = e.root.activeElement
  r != t && e.updateState(t), o != e.dom && e.focus()
  try {
    return n()
  } finally {
    r != t && e.updateState(r), o != e.dom && o && o.focus()
  }
}
function FF(e, t, n) {
  let r = t.selection,
    o = n == "up" ? r.$from : r.$to
  return NO(e, t, () => {
    let { node: i } = e.docView.domFromPos(o.pos, n == "up" ? -1 : 1)
    for (;;) {
      let a = e.docView.nearestDesc(i, !0)
      if (!a) break
      if (a.node.isBlock) {
        i = a.contentDOM || a.dom
        break
      }
      i = a.dom.parentNode
    }
    let s = kO(e, o.pos, 1)
    for (let a = i.firstChild; a; a = a.nextSibling) {
      let l
      if (a.nodeType == 1) l = a.getClientRects()
      else if (a.nodeType == 3)
        l = ho(a, 0, a.nodeValue.length).getClientRects()
      else continue
      for (let c = 0; c < l.length; c++) {
        let u = l[c]
        if (
          u.bottom > u.top + 1 &&
          (n == "up"
            ? s.top - u.top > (u.bottom - s.top) * 2
            : u.bottom - s.bottom > (s.bottom - u.top) * 2)
        )
          return !1
      }
    }
    return !0
  })
}
const zF = /[\u0590-\u08ac]/
function UF(e, t, n) {
  let { $head: r } = t.selection
  if (!r.parent.isTextblock) return !1
  let o = r.parentOffset,
    i = !o,
    s = o == r.parent.content.size,
    a = e.domSelection()
  return a
    ? !zF.test(r.parent.textContent) || !a.modify
      ? n == "left" || n == "backward"
        ? i
        : s
      : NO(e, t, () => {
          let {
              focusNode: l,
              focusOffset: c,
              anchorNode: u,
              anchorOffset: d,
            } = e.domSelectionRange(),
            f = a.caretBidiLevel
          a.modify("move", n, "character")
          let p = r.depth ? e.docView.domAfterPos(r.before()) : e.dom,
            { focusNode: g, focusOffset: v } = e.domSelectionRange(),
            b =
              (g && !p.contains(g.nodeType == 1 ? g : g.parentNode)) ||
              (l == g && c == v)
          try {
            a.collapse(u, d),
              l && (l != u || c != d) && a.extend && a.extend(l, c)
          } catch {}
          return f != null && (a.caretBidiLevel = f), b
        })
    : r.pos == r.start() || r.pos == r.end()
}
let ZE = null,
  YE = null,
  XE = !1
function VF(e, t, n) {
  return ZE == t && YE == n
    ? XE
    : ((ZE = t),
      (YE = n),
      (XE = n == "up" || n == "down" ? FF(e, t, n) : UF(e, t, n)))
}
const ir = 0,
  QE = 1,
  Xi = 2,
  eo = 3
class Lu {
  constructor(t, n, r, o) {
    ;(this.parent = t),
      (this.children = n),
      (this.dom = r),
      (this.contentDOM = o),
      (this.dirty = ir),
      (r.pmViewDesc = this)
  }
  matchesWidget(t) {
    return !1
  }
  matchesMark(t) {
    return !1
  }
  matchesNode(t, n, r) {
    return !1
  }
  matchesHack(t) {
    return !1
  }
  parseRule() {
    return null
  }
  stopEvent(t) {
    return !1
  }
  get size() {
    let t = 0
    for (let n = 0; n < this.children.length; n++) t += this.children[n].size
    return t
  }
  get border() {
    return 0
  }
  destroy() {
    ;(this.parent = void 0),
      this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0)
    for (let t = 0; t < this.children.length; t++) this.children[t].destroy()
  }
  posBeforeChild(t) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let o = this.children[n]
      if (o == t) return r
      r += o.size
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this)
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
  }
  get posAfter() {
    return this.posBefore + this.size
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border
  }
  localPosFromDOM(t, n, r) {
    if (
      this.contentDOM &&
      this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode)
    )
      if (r < 0) {
        let i, s
        if (t == this.contentDOM) i = t.childNodes[n - 1]
        else {
          for (; t.parentNode != this.contentDOM; ) t = t.parentNode
          i = t.previousSibling
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.previousSibling
        return i ? this.posBeforeChild(s) + s.size : this.posAtStart
      } else {
        let i, s
        if (t == this.contentDOM) i = t.childNodes[n]
        else {
          for (; t.parentNode != this.contentDOM; ) t = t.parentNode
          i = t.nextSibling
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.nextSibling
        return i ? this.posBeforeChild(s) : this.posAtEnd
      }
    let o
    if (t == this.dom && this.contentDOM) o = n > Kt(this.contentDOM)
    else if (
      this.contentDOM &&
      this.contentDOM != this.dom &&
      this.dom.contains(this.contentDOM)
    )
      o = t.compareDocumentPosition(this.contentDOM) & 2
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = t; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !1
            break
          }
          if (i.previousSibling) break
        }
      if (o == null && n == t.childNodes.length)
        for (let i = t; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !0
            break
          }
          if (i.nextSibling) break
        }
    }
    return (o == null ? r > 0 : o) ? this.posAtEnd : this.posAtStart
  }
  nearestDesc(t, n = !1) {
    for (let r = !0, o = t; o; o = o.parentNode) {
      let i = this.getDesc(o),
        s
      if (i && (!n || i.node))
        if (
          r &&
          (s = i.nodeDOM) &&
          !(s.nodeType == 1
            ? s.contains(t.nodeType == 1 ? t : t.parentNode)
            : s == t)
        )
          r = !1
        else return i
    }
  }
  getDesc(t) {
    let n = t.pmViewDesc
    for (let r = n; r; r = r.parent) if (r == this) return n
  }
  posFromDOM(t, n, r) {
    for (let o = t; o; o = o.parentNode) {
      let i = this.getDesc(o)
      if (i) return i.localPosFromDOM(t, n, r)
    }
    return -1
  }
  descAt(t) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let o = this.children[n],
        i = r + o.size
      if (r == t && i != r) {
        for (; !o.border && o.children.length; )
          for (let s = 0; s < o.children.length; s++) {
            let a = o.children[s]
            if (a.size) {
              o = a
              break
            }
          }
        return o
      }
      if (t < i) return o.descAt(t - r - o.border)
      r = i
    }
  }
  domFromPos(t, n) {
    if (!this.contentDOM) return { node: this.dom, offset: 0, atom: t + 1 }
    let r = 0,
      o = 0
    for (let i = 0; r < this.children.length; r++) {
      let s = this.children[r],
        a = i + s.size
      if (a > t || s instanceof MO) {
        o = t - i
        break
      }
      i = a
    }
    if (o) return this.children[r].domFromPos(o - this.children[r].border, n)
    for (
      let i;
      r && !(i = this.children[r - 1]).size && i instanceof TO && i.side >= 0;
      r--
    );
    if (n <= 0) {
      let i,
        s = !0
      for (
        ;
        (i = r ? this.children[r - 1] : null),
          !(!i || i.dom.parentNode == this.contentDOM);
        r--, s = !1
      );
      return i && n && s && !i.border && !i.domAtom
        ? i.domFromPos(i.size, n)
        : { node: this.contentDOM, offset: i ? Kt(i.dom) + 1 : 0 }
    } else {
      let i,
        s = !0
      for (
        ;
        (i = r < this.children.length ? this.children[r] : null),
          !(!i || i.dom.parentNode == this.contentDOM);
        r++, s = !1
      );
      return i && s && !i.border && !i.domAtom
        ? i.domFromPos(0, n)
        : {
            node: this.contentDOM,
            offset: i ? Kt(i.dom) : this.contentDOM.childNodes.length,
          }
    }
  }
  parseRange(t, n, r = 0) {
    if (this.children.length == 0)
      return {
        node: this.contentDOM,
        from: t,
        to: n,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length,
      }
    let o = -1,
      i = -1
    for (let s = r, a = 0; ; a++) {
      let l = this.children[a],
        c = s + l.size
      if (o == -1 && t <= c) {
        let u = s + l.border
        if (
          t >= u &&
          n <= c - l.border &&
          l.node &&
          l.contentDOM &&
          this.contentDOM.contains(l.contentDOM)
        )
          return l.parseRange(t, n, u)
        t = s
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1]
          if (
            f.size &&
            f.dom.parentNode == this.contentDOM &&
            !f.emptyChildAt(1)
          ) {
            o = Kt(f.dom) + 1
            break
          }
          t -= f.size
        }
        o == -1 && (o = 0)
      }
      if (o > -1 && (c > n || a == this.children.length - 1)) {
        n = c
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u]
          if (
            d.size &&
            d.dom.parentNode == this.contentDOM &&
            !d.emptyChildAt(-1)
          ) {
            i = Kt(d.dom)
            break
          }
          n += d.size
        }
        i == -1 && (i = this.contentDOM.childNodes.length)
        break
      }
      s = c
    }
    return { node: this.contentDOM, from: t, to: n, fromOffset: o, toOffset: i }
  }
  emptyChildAt(t) {
    if (this.border || !this.contentDOM || !this.children.length) return !1
    let n = this.children[t < 0 ? 0 : this.children.length - 1]
    return n.size == 0 || n.emptyChildAt(t)
  }
  domAfterPos(t) {
    let { node: n, offset: r } = this.domFromPos(t, 0)
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + t)
    return n.childNodes[r]
  }
  setSelection(t, n, r, o = !1) {
    let i = Math.min(t, n),
      s = Math.max(t, n)
    for (let p = 0, g = 0; p < this.children.length; p++) {
      let v = this.children[p],
        b = g + v.size
      if (i > g && s < b)
        return v.setSelection(t - g - v.border, n - g - v.border, r, o)
      g = b
    }
    let a = this.domFromPos(t, t ? -1 : 1),
      l = n == t ? a : this.domFromPos(n, n ? -1 : 1),
      c = r.root.getSelection(),
      u = r.domSelectionRange(),
      d = !1
    if ((Ar || gn) && t == n) {
      let { node: p, offset: g } = a
      if (p.nodeType == 3) {
        if (
          ((d = !!(
            g &&
            p.nodeValue[g - 1] ==
              `
`
          )),
          d && g == p.nodeValue.length)
        )
          for (let v = p, b; v; v = v.parentNode) {
            if ((b = v.nextSibling)) {
              b.nodeName == "BR" &&
                (a = l = { node: b.parentNode, offset: Kt(b) + 1 })
              break
            }
            let y = v.pmViewDesc
            if (y && y.node && y.node.isBlock) break
          }
      } else {
        let v = p.childNodes[g - 1]
        d = v && (v.nodeName == "BR" || v.contentEditable == "false")
      }
    }
    if (
      Ar &&
      u.focusNode &&
      u.focusNode != l.node &&
      u.focusNode.nodeType == 1
    ) {
      let p = u.focusNode.childNodes[u.focusOffset]
      p && p.contentEditable == "false" && (o = !0)
    }
    if (
      !(o || (d && gn)) &&
      ks(a.node, a.offset, u.anchorNode, u.anchorOffset) &&
      ks(l.node, l.offset, u.focusNode, u.focusOffset)
    )
      return
    let f = !1
    if ((c.extend || t == n) && !d) {
      c.collapse(a.node, a.offset)
      try {
        t != n && c.extend(l.node, l.offset), (f = !0)
      } catch {}
    }
    if (!f) {
      if (t > n) {
        let g = a
        ;(a = l), (l = g)
      }
      let p = document.createRange()
      p.setEnd(l.node, l.offset),
        p.setStart(a.node, a.offset),
        c.removeAllRanges(),
        c.addRange(p)
    }
  }
  ignoreMutation(t) {
    return !this.contentDOM && t.type != "selection"
  }
  get contentLost() {
    return (
      this.contentDOM &&
      this.contentDOM != this.dom &&
      !this.dom.contains(this.contentDOM)
    )
  }
  markDirty(t, n) {
    for (let r = 0, o = 0; o < this.children.length; o++) {
      let i = this.children[o],
        s = r + i.size
      if (r == s ? t <= s && n >= r : t < s && n > r) {
        let a = r + i.border,
          l = s - i.border
        if (t >= a && n <= l) {
          ;(this.dirty = t == r || n == s ? Xi : QE),
            t == a &&
            n == l &&
            (i.contentLost || i.dom.parentNode != this.contentDOM)
              ? (i.dirty = eo)
              : i.markDirty(t - a, n - a)
          return
        } else
          i.dirty =
            i.dom == i.contentDOM &&
            i.dom.parentNode == this.contentDOM &&
            !i.children.length
              ? Xi
              : eo
      }
      r = s
    }
    this.dirty = Xi
  }
  markParentsDirty() {
    let t = 1
    for (let n = this.parent; n; n = n.parent, t++) {
      let r = t == 1 ? Xi : QE
      n.dirty < r && (n.dirty = r)
    }
  }
  get domAtom() {
    return !1
  }
  get ignoreForCoords() {
    return !1
  }
  isText(t) {
    return !1
  }
}
class TO extends Lu {
  constructor(t, n, r, o) {
    let i,
      s = n.type.toDOM
    if (
      (typeof s == "function" &&
        (s = s(r, () => {
          if (!i) return o
          if (i.parent) return i.parent.posBeforeChild(i)
        })),
      !n.type.spec.raw)
    ) {
      if (s.nodeType != 1) {
        let a = document.createElement("span")
        a.appendChild(s), (s = a)
      }
      ;(s.contentEditable = "false"), s.classList.add("ProseMirror-widget")
    }
    super(t, [], s, null), (this.widget = n), (this.widget = n), (i = this)
  }
  matchesWidget(t) {
    return this.dirty == ir && t.type.eq(this.widget.type)
  }
  parseRule() {
    return { ignore: !0 }
  }
  stopEvent(t) {
    let n = this.widget.spec.stopEvent
    return n ? n(t) : !1
  }
  ignoreMutation(t) {
    return t.type != "selection" || this.widget.spec.ignoreSelection
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy()
  }
  get domAtom() {
    return !0
  }
  get side() {
    return this.widget.type.side
  }
}
class HF extends Lu {
  constructor(t, n, r, o) {
    super(t, [], n, null), (this.textDOM = r), (this.text = o)
  }
  get size() {
    return this.text.length
  }
  localPosFromDOM(t, n) {
    return t != this.textDOM
      ? this.posAtStart + (n ? this.size : 0)
      : this.posAtStart + n
  }
  domFromPos(t) {
    return { node: this.textDOM, offset: t }
  }
  ignoreMutation(t) {
    return t.type === "characterData" && t.target.nodeValue == t.oldValue
  }
}
class Ns extends Lu {
  constructor(t, n, r, o, i) {
    super(t, [], r, o), (this.mark = n), (this.spec = i)
  }
  static create(t, n, r, o) {
    let i = o.nodeViews[n.type.name],
      s = i && i(n, o, r)
    return (
      (!s || !s.dom) &&
        (s = Ps.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
      new Ns(t, n, s.dom, s.contentDOM || s.dom, s)
    )
  }
  parseRule() {
    return this.dirty & eo || this.mark.type.spec.reparseInView
      ? null
      : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM,
        }
  }
  matchesMark(t) {
    return this.dirty != eo && this.mark.eq(t)
  }
  markDirty(t, n) {
    if ((super.markDirty(t, n), this.dirty != ir)) {
      let r = this.parent
      for (; !r.node; ) r = r.parent
      r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = ir)
    }
  }
  slice(t, n, r) {
    let o = Ns.create(this.parent, this.mark, !0, r),
      i = this.children,
      s = this.size
    n < s && (i = My(i, n, s, r)), t > 0 && (i = My(i, 0, t, r))
    for (let a = 0; a < i.length; a++) i[a].parent = o
    return (o.children = i), o
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(t)
      : super.ignoreMutation(t)
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy()
  }
}
class vi extends Lu {
  constructor(t, n, r, o, i, s, a, l, c) {
    super(t, [], i, s),
      (this.node = n),
      (this.outerDeco = r),
      (this.innerDeco = o),
      (this.nodeDOM = a)
  }
  static create(t, n, r, o, i, s) {
    let a = i.nodeViews[n.type.name],
      l,
      c =
        a &&
        a(
          n,
          i,
          () => {
            if (!l) return s
            if (l.parent) return l.parent.posBeforeChild(l)
          },
          r,
          o
        ),
      u = c && c.dom,
      d = c && c.contentDOM
    if (n.isText) {
      if (!u) u = document.createTextNode(n.text)
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node")
    } else
      u ||
        ({ dom: u, contentDOM: d } = Ps.renderSpec(
          document,
          n.type.spec.toDOM(n),
          null,
          n.attrs
        ))
    !d &&
      !n.isText &&
      u.nodeName != "BR" &&
      (u.hasAttribute("contenteditable") || (u.contentEditable = "false"),
      n.type.spec.draggable && (u.draggable = !0))
    let f = u
    return (
      (u = RO(u, r, n)),
      c
        ? (l = new WF(t, n, r, o, u, d || null, f, c, i, s + 1))
        : n.isText
          ? new rm(t, n, r, o, u, f, i)
          : new vi(t, n, r, o, u, d || null, f, i, s + 1)
    )
  }
  parseRule() {
    if (this.node.type.spec.reparseInView) return null
    let t = { node: this.node.type.name, attrs: this.node.attrs }
    if (
      (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"),
      !this.contentDOM)
    )
      t.getContent = () => this.node.content
    else if (!this.contentLost) t.contentElement = this.contentDOM
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n]
        if (this.dom.contains(r.dom.parentNode)) {
          t.contentElement = r.dom.parentNode
          break
        }
      }
      t.contentElement || (t.getContent = () => Z.empty)
    }
    return t
  }
  matchesNode(t, n, r) {
    return (
      this.dirty == ir &&
      t.eq(this.node) &&
      ip(n, this.outerDeco) &&
      r.eq(this.innerDeco)
    )
  }
  get size() {
    return this.node.nodeSize
  }
  get border() {
    return this.node.isLeaf ? 0 : 1
  }
  updateChildren(t, n) {
    let r = this.node.inlineContent,
      o = n,
      i = t.composing ? this.localCompositionInfo(t, n) : null,
      s = i && i.pos > -1 ? i : null,
      a = i && i.pos < 0,
      l = new GF(this, s && s.node, t)
    YF(
      this.node,
      this.innerDeco,
      (c, u, d) => {
        c.spec.marks
          ? l.syncToMarks(c.spec.marks, r, t)
          : c.type.side >= 0 &&
            !d &&
            l.syncToMarks(
              u == this.node.childCount ? Ke.none : this.node.child(u).marks,
              r,
              t
            ),
          l.placeWidget(c, t, o)
      },
      (c, u, d, f) => {
        l.syncToMarks(c.marks, r, t)
        let p
        l.findNodeMatch(c, u, d, f) ||
          (a &&
            t.state.selection.from > o &&
            t.state.selection.to < o + c.nodeSize &&
            (p = l.findIndexWithChild(i.node)) > -1 &&
            l.updateNodeAt(c, u, d, p, t)) ||
          l.updateNextNode(c, u, d, t, f, o) ||
          l.addNode(c, u, d, t, o),
          (o += c.nodeSize)
      }
    ),
      l.syncToMarks([], r, t),
      this.node.isTextblock && l.addTextblockHacks(),
      l.destroyRest(),
      (l.changed || this.dirty == Xi) &&
        (s && this.protectLocalComposition(t, s),
        OO(this.contentDOM, this.children, t),
        Qa && XF(this.dom))
  }
  localCompositionInfo(t, n) {
    let { from: r, to: o } = t.state.selection
    if (
      !(t.state.selection instanceof _e) ||
      r < n ||
      o > n + this.node.content.size
    )
      return null
    let i = t.input.compositionNode
    if (!i || !this.dom.contains(i.parentNode)) return null
    if (this.node.inlineContent) {
      let s = i.nodeValue,
        a = QF(this.node.content, s, r - n, o - n)
      return a < 0 ? null : { node: i, pos: a, text: s }
    } else return { node: i, pos: -1, text: "" }
  }
  protectLocalComposition(t, { node: n, pos: r, text: o }) {
    if (this.getDesc(n)) return
    let i = n
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; ) i.parentNode.removeChild(i.previousSibling)
      for (; i.nextSibling; ) i.parentNode.removeChild(i.nextSibling)
      i.pmViewDesc && (i.pmViewDesc = void 0)
    }
    let s = new HF(this, i, n, o)
    t.input.compositionNodes.push(s),
      (this.children = My(this.children, r, r + o.length, t, s))
  }
  update(t, n, r, o) {
    return this.dirty == eo || !t.sameMarkup(this.node)
      ? !1
      : (this.updateInner(t, n, r, o), !0)
  }
  updateInner(t, n, r, o) {
    this.updateOuterDeco(n),
      (this.node = t),
      (this.innerDeco = r),
      this.contentDOM && this.updateChildren(o, this.posAtStart),
      (this.dirty = ir)
  }
  updateOuterDeco(t) {
    if (ip(t, this.outerDeco)) return
    let n = this.nodeDOM.nodeType != 1,
      r = this.dom
    ;(this.dom = AO(
      this.dom,
      this.nodeDOM,
      Ty(this.outerDeco, this.node, n),
      Ty(t, this.node, n)
    )),
      this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
      (this.outerDeco = t)
  }
  selectNode() {
    this.nodeDOM.nodeType == 1 &&
      this.nodeDOM.classList.add("ProseMirror-selectednode"),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        (this.dom.draggable = !0)
  }
  deselectNode() {
    this.nodeDOM.nodeType == 1 &&
      (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        this.dom.removeAttribute("draggable"))
  }
  get domAtom() {
    return this.node.isAtom
  }
}
function JE(e, t, n, r, o) {
  RO(r, t, e)
  let i = new vi(void 0, e, t, n, r, r, r, o, 0)
  return i.contentDOM && i.updateChildren(o, 0), i
}
class rm extends vi {
  constructor(t, n, r, o, i, s, a) {
    super(t, n, r, o, i, null, s, a, 0)
  }
  parseRule() {
    let t = this.nodeDOM.parentNode
    for (; t && t != this.dom && !t.pmIsDeco; ) t = t.parentNode
    return { skip: t || !0 }
  }
  update(t, n, r, o) {
    return this.dirty == eo ||
      (this.dirty != ir && !this.inParent()) ||
      !t.sameMarkup(this.node)
      ? !1
      : (this.updateOuterDeco(n),
        (this.dirty != ir || t.text != this.node.text) &&
          t.text != this.nodeDOM.nodeValue &&
          ((this.nodeDOM.nodeValue = t.text),
          o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
        (this.node = t),
        (this.dirty = ir),
        !0)
  }
  inParent() {
    let t = this.parent.contentDOM
    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == t) return !0
    return !1
  }
  domFromPos(t) {
    return { node: this.nodeDOM, offset: t }
  }
  localPosFromDOM(t, n, r) {
    return t == this.nodeDOM
      ? this.posAtStart + Math.min(n, this.node.text.length)
      : super.localPosFromDOM(t, n, r)
  }
  ignoreMutation(t) {
    return t.type != "characterData" && t.type != "selection"
  }
  slice(t, n, r) {
    let o = this.node.cut(t, n),
      i = document.createTextNode(o.text)
    return new rm(this.parent, o, this.outerDeco, this.innerDeco, i, i, r)
  }
  markDirty(t, n) {
    super.markDirty(t, n),
      this.dom != this.nodeDOM &&
        (t == 0 || n == this.nodeDOM.nodeValue.length) &&
        (this.dirty = eo)
  }
  get domAtom() {
    return !1
  }
  isText(t) {
    return this.node.text == t
  }
}
class MO extends Lu {
  parseRule() {
    return { ignore: !0 }
  }
  matchesHack(t) {
    return this.dirty == ir && this.dom.nodeName == t
  }
  get domAtom() {
    return !0
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG"
  }
}
class WF extends vi {
  constructor(t, n, r, o, i, s, a, l, c, u) {
    super(t, n, r, o, i, s, a, c, u), (this.spec = l)
  }
  update(t, n, r, o) {
    if (this.dirty == eo) return !1
    if (this.spec.update && (this.node.type == t.type || this.spec.multiType)) {
      let i = this.spec.update(t, n, r)
      return i && this.updateInner(t, n, r, o), i
    } else return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, o)
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
  }
  setSelection(t, n, r, o) {
    this.spec.setSelection
      ? this.spec.setSelection(t, n, r.root)
      : super.setSelection(t, n, r, o)
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy()
  }
  stopEvent(t) {
    return this.spec.stopEvent ? this.spec.stopEvent(t) : !1
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(t)
      : super.ignoreMutation(t)
  }
}
function OO(e, t, n) {
  let r = e.firstChild,
    o = !1
  for (let i = 0; i < t.length; i++) {
    let s = t[i],
      a = s.dom
    if (a.parentNode == e) {
      for (; a != r; ) (r = eC(r)), (o = !0)
      r = r.nextSibling
    } else (o = !0), e.insertBefore(a, r)
    if (s instanceof Ns) {
      let l = r ? r.previousSibling : e.lastChild
      OO(s.contentDOM, s.children, n), (r = l ? l.nextSibling : e.firstChild)
    }
  }
  for (; r; ) (r = eC(r)), (o = !0)
  o && n.trackWrites == e && (n.trackWrites = null)
}
const fc = function (e) {
  e && (this.nodeName = e)
}
fc.prototype = Object.create(null)
const Qi = [new fc()]
function Ty(e, t, n) {
  if (e.length == 0) return Qi
  let r = n ? Qi[0] : new fc(),
    o = [r]
  for (let i = 0; i < e.length; i++) {
    let s = e[i].type.attrs
    if (s) {
      s.nodeName && o.push((r = new fc(s.nodeName)))
      for (let a in s) {
        let l = s[a]
        l != null &&
          (n &&
            o.length == 1 &&
            o.push((r = new fc(t.isInline ? "span" : "div"))),
          a == "class"
            ? (r.class = (r.class ? r.class + " " : "") + l)
            : a == "style"
              ? (r.style = (r.style ? r.style + ";" : "") + l)
              : a != "nodeName" && (r[a] = l))
      }
    }
  }
  return o
}
function AO(e, t, n, r) {
  if (n == Qi && r == Qi) return t
  let o = t
  for (let i = 0; i < r.length; i++) {
    let s = r[i],
      a = n[i]
    if (i) {
      let l
      ;(a &&
        a.nodeName == s.nodeName &&
        o != e &&
        (l = o.parentNode) &&
        l.nodeName.toLowerCase() == s.nodeName) ||
        ((l = document.createElement(s.nodeName)),
        (l.pmIsDeco = !0),
        l.appendChild(o),
        (a = Qi[0])),
        (o = l)
    }
    KF(o, a || Qi[0], s)
  }
  return o
}
function KF(e, t, n) {
  for (let r in t)
    r != "class" &&
      r != "style" &&
      r != "nodeName" &&
      !(r in n) &&
      e.removeAttribute(r)
  for (let r in n)
    r != "class" &&
      r != "style" &&
      r != "nodeName" &&
      n[r] != t[r] &&
      e.setAttribute(r, n[r])
  if (t.class != n.class) {
    let r = t.class ? t.class.split(" ").filter(Boolean) : [],
      o = n.class ? n.class.split(" ").filter(Boolean) : []
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && e.classList.remove(r[i])
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && e.classList.add(o[i])
    e.classList.length == 0 && e.removeAttribute("class")
  }
  if (t.style != n.style) {
    if (t.style) {
      let r =
          /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
        o
      for (; (o = r.exec(t.style)); ) e.style.removeProperty(o[1])
    }
    n.style && (e.style.cssText += n.style)
  }
}
function RO(e, t, n) {
  return AO(e, e, Qi, Ty(t, n, e.nodeType != 1))
}
function ip(e, t) {
  if (e.length != t.length) return !1
  for (let n = 0; n < e.length; n++) if (!e[n].type.eq(t[n].type)) return !1
  return !0
}
function eC(e) {
  let t = e.nextSibling
  return e.parentNode.removeChild(e), t
}
class GF {
  constructor(t, n, r) {
    ;(this.lock = n),
      (this.view = r),
      (this.index = 0),
      (this.stack = []),
      (this.changed = !1),
      (this.top = t),
      (this.preMatch = qF(t.node.content, t))
  }
  destroyBetween(t, n) {
    if (t != n) {
      for (let r = t; r < n; r++) this.top.children[r].destroy()
      this.top.children.splice(t, n - t), (this.changed = !0)
    }
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length)
  }
  syncToMarks(t, n, r) {
    let o = 0,
      i = this.stack.length >> 1,
      s = Math.min(i, t.length)
    for (
      ;
      o < s &&
      (o == i - 1 ? this.top : this.stack[(o + 1) << 1]).matchesMark(t[o]) &&
      t[o].type.spec.spanning !== !1;

    )
      o++
    for (; o < i; )
      this.destroyRest(),
        (this.top.dirty = ir),
        (this.index = this.stack.pop()),
        (this.top = this.stack.pop()),
        i--
    for (; i < t.length; ) {
      this.stack.push(this.top, this.index + 1)
      let a = -1
      for (
        let l = this.index;
        l < Math.min(this.index + 3, this.top.children.length);
        l++
      ) {
        let c = this.top.children[l]
        if (c.matchesMark(t[i]) && !this.isLocked(c.dom)) {
          a = l
          break
        }
      }
      if (a > -1)
        a > this.index &&
          ((this.changed = !0), this.destroyBetween(this.index, a)),
          (this.top = this.top.children[this.index])
      else {
        let l = Ns.create(this.top, t[i], n, r)
        this.top.children.splice(this.index, 0, l),
          (this.top = l),
          (this.changed = !0)
      }
      ;(this.index = 0), i++
    }
  }
  findNodeMatch(t, n, r, o) {
    let i = -1,
      s
    if (
      o >= this.preMatch.index &&
      (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top &&
      s.matchesNode(t, n, r)
    )
      i = this.top.children.indexOf(s, this.index)
    else
      for (
        let a = this.index, l = Math.min(this.top.children.length, a + 5);
        a < l;
        a++
      ) {
        let c = this.top.children[a]
        if (c.matchesNode(t, n, r) && !this.preMatch.matched.has(c)) {
          i = a
          break
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0)
  }
  updateNodeAt(t, n, r, o, i) {
    let s = this.top.children[o]
    return (
      s.dirty == eo && s.dom == s.contentDOM && (s.dirty = Xi),
      s.update(t, n, r, i)
        ? (this.destroyBetween(this.index, o), this.index++, !0)
        : !1
    )
  }
  findIndexWithChild(t) {
    for (;;) {
      let n = t.parentNode
      if (!n) return -1
      if (n == this.top.contentDOM) {
        let r = t.pmViewDesc
        if (r) {
          for (let o = this.index; o < this.top.children.length; o++)
            if (this.top.children[o] == r) return o
        }
        return -1
      }
      t = n
    }
  }
  updateNextNode(t, n, r, o, i, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a]
      if (l instanceof vi) {
        let c = this.preMatch.matched.get(l)
        if (c != null && c != i) return !1
        let u = l.dom,
          d,
          f =
            this.isLocked(u) &&
            !(
              t.isText &&
              l.node &&
              l.node.isText &&
              l.nodeDOM.nodeValue == t.text &&
              l.dirty != eo &&
              ip(n, l.outerDeco)
            )
        if (!f && l.update(t, n, r, o))
          return (
            this.destroyBetween(this.index, a),
            l.dom != u && (this.changed = !0),
            this.index++,
            !0
          )
        if (!f && (d = this.recreateWrapper(l, t, n, r, o, s)))
          return (
            this.destroyBetween(this.index, a),
            (this.top.children[this.index] = d),
            d.contentDOM &&
              ((d.dirty = Xi), d.updateChildren(o, s + 1), (d.dirty = ir)),
            (this.changed = !0),
            this.index++,
            !0
          )
        break
      }
    }
    return !1
  }
  recreateWrapper(t, n, r, o, i, s) {
    if (
      t.dirty ||
      n.isAtom ||
      !t.children.length ||
      !t.node.content.eq(n.content) ||
      !ip(r, t.outerDeco) ||
      !o.eq(t.innerDeco)
    )
      return null
    let a = vi.create(this.top, n, r, o, i, s)
    if (a.contentDOM) {
      ;(a.children = t.children), (t.children = [])
      for (let l of a.children) l.parent = a
    }
    return t.destroy(), a
  }
  addNode(t, n, r, o, i) {
    let s = vi.create(this.top, t, n, r, o, i)
    s.contentDOM && s.updateChildren(o, i + 1),
      this.top.children.splice(this.index++, 0, s),
      (this.changed = !0)
  }
  placeWidget(t, n, r) {
    let o =
      this.index < this.top.children.length
        ? this.top.children[this.index]
        : null
    if (
      o &&
      o.matchesWidget(t) &&
      (t == o.widget || !o.widget.type.toDOM.parentNode)
    )
      this.index++
    else {
      let i = new TO(this.top, t, n, r)
      this.top.children.splice(this.index++, 0, i), (this.changed = !0)
    }
  }
  addTextblockHacks() {
    let t = this.top.children[this.index - 1],
      n = this.top
    for (; t instanceof Ns; ) (n = t), (t = n.children[n.children.length - 1])
    ;(!t ||
      !(t instanceof rm) ||
      /\n$/.test(t.node.text) ||
      (this.view.requiresGeckoHackNode && /\s$/.test(t.node.text))) &&
      ((gn || tn) &&
        t &&
        t.dom.contentEditable == "false" &&
        this.addHackNode("IMG", n),
      this.addHackNode("BR", this.top))
  }
  addHackNode(t, n) {
    if (
      n == this.top &&
      this.index < n.children.length &&
      n.children[this.index].matchesHack(t)
    )
      this.index++
    else {
      let r = document.createElement(t)
      t == "IMG" && ((r.className = "ProseMirror-separator"), (r.alt = "")),
        t == "BR" && (r.className = "ProseMirror-trailingBreak")
      let o = new MO(this.top, [], r, null)
      n != this.top
        ? n.children.push(o)
        : n.children.splice(this.index++, 0, o),
        (this.changed = !0)
    }
  }
  isLocked(t) {
    return (
      this.lock &&
      (t == this.lock || (t.nodeType == 1 && t.contains(this.lock.parentNode)))
    )
  }
}
function qF(e, t) {
  let n = t,
    r = n.children.length,
    o = e.childCount,
    i = new Map(),
    s = []
  e: for (; o > 0; ) {
    let a
    for (;;)
      if (r) {
        let c = n.children[r - 1]
        if (c instanceof Ns) (n = c), (r = c.children.length)
        else {
          ;(a = c), r--
          break
        }
      } else {
        if (n == t) break e
        ;(r = n.parent.children.indexOf(n)), (n = n.parent)
      }
    let l = a.node
    if (l) {
      if (l != e.child(o - 1)) break
      --o, i.set(a, o), s.push(a)
    }
  }
  return { index: o, matched: i, matches: s.reverse() }
}
function ZF(e, t) {
  return e.type.side - t.type.side
}
function YF(e, t, n, r) {
  let o = t.locals(e),
    i = 0
  if (o.length == 0) {
    for (let c = 0; c < e.childCount; c++) {
      let u = e.child(c)
      r(u, o, t.forChild(i, u), c), (i += u.nodeSize)
    }
    return
  }
  let s = 0,
    a = [],
    l = null
  for (let c = 0; ; ) {
    let u, d
    for (; s < o.length && o[s].to == i; ) {
      let b = o[s++]
      b.widget && (u ? (d || (d = [u])).push(b) : (u = b))
    }
    if (u)
      if (d) {
        d.sort(ZF)
        for (let b = 0; b < d.length; b++) n(d[b], c, !!l)
      } else n(u, c, !!l)
    let f, p
    if (l) (p = -1), (f = l), (l = null)
    else if (c < e.childCount) (p = c), (f = e.child(c++))
    else break
    for (let b = 0; b < a.length; b++) a[b].to <= i && a.splice(b--, 1)
    for (; s < o.length && o[s].from <= i && o[s].to > i; ) a.push(o[s++])
    let g = i + f.nodeSize
    if (f.isText) {
      let b = g
      s < o.length && o[s].from < b && (b = o[s].from)
      for (let y = 0; y < a.length; y++) a[y].to < b && (b = a[y].to)
      b < g && ((l = f.cut(b - i)), (f = f.cut(0, b - i)), (g = b), (p = -1))
    } else for (; s < o.length && o[s].to < g; ) s++
    let v = f.isInline && !f.isLeaf ? a.filter((b) => !b.inline) : a.slice()
    r(f, v, t.forChild(i, f), p), (i = g)
  }
}
function XF(e) {
  if (e.nodeName == "UL" || e.nodeName == "OL") {
    let t = e.style.cssText
    ;(e.style.cssText = t + "; list-style: square !important"),
      window.getComputedStyle(e).listStyle,
      (e.style.cssText = t)
  }
}
function QF(e, t, n, r) {
  for (let o = 0, i = 0; o < e.childCount && i <= r; ) {
    let s = e.child(o++),
      a = i
    if (((i += s.nodeSize), !s.isText)) continue
    let l = s.text
    for (; o < e.childCount; ) {
      let c = e.child(o++)
      if (((i += c.nodeSize), !c.isText)) break
      l += c.text
    }
    if (i >= n) {
      if (i >= r && l.slice(r - t.length - a, r - a) == t) return r - t.length
      let c = a < r ? l.lastIndexOf(t, r - a - 1) : -1
      if (c >= 0 && c + t.length + a >= n) return a + c
      if (
        n == r &&
        l.length >= r + t.length - a &&
        l.slice(r - a, r - a + t.length) == t
      )
        return r
    }
  }
  return -1
}
function My(e, t, n, r, o) {
  let i = []
  for (let s = 0, a = 0; s < e.length; s++) {
    let l = e[s],
      c = a,
      u = (a += l.size)
    c >= n || u <= t
      ? i.push(l)
      : (c < t && i.push(l.slice(0, t - c, r)),
        o && (i.push(o), (o = void 0)),
        u > n && i.push(l.slice(n - c, l.size, r)))
  }
  return i
}
function Yb(e, t = null) {
  let n = e.domSelectionRange(),
    r = e.state.doc
  if (!n.focusNode) return null
  let o = e.docView.nearestDesc(n.focusNode),
    i = o && o.size == 0,
    s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1)
  if (s < 0) return null
  let a = r.resolve(s),
    l,
    c
  if (nm(n)) {
    for (l = s; o && !o.node; ) o = o.parent
    let d = o.node
    if (
      o &&
      d.isAtom &&
      ye.isSelectable(d) &&
      o.parent &&
      !(d.isInline && SF(n.focusNode, n.focusOffset, o.dom))
    ) {
      let f = o.posBefore
      c = new ye(s == f ? a : r.resolve(f))
    }
  } else {
    if (
      n instanceof e.dom.ownerDocument.defaultView.Selection &&
      n.rangeCount > 1
    ) {
      let d = s,
        f = s
      for (let p = 0; p < n.rangeCount; p++) {
        let g = n.getRangeAt(p)
        ;(d = Math.min(
          d,
          e.docView.posFromDOM(g.startContainer, g.startOffset, 1)
        )),
          (f = Math.max(
            f,
            e.docView.posFromDOM(g.endContainer, g.endOffset, -1)
          ))
      }
      if (d < 0) return null
      ;([l, s] = f == e.state.selection.anchor ? [f, d] : [d, f]),
        (a = r.resolve(s))
    } else l = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1)
    if (l < 0) return null
  }
  let u = r.resolve(l)
  if (!c) {
    let d = t == "pointer" || (e.state.selection.head < a.pos && !i) ? 1 : -1
    c = Xb(e, u, a, d)
  }
  return c
}
function IO(e) {
  return e.editable
    ? e.hasFocus()
    : LO(e) && document.activeElement && document.activeElement.contains(e.dom)
}
function _o(e, t = !1) {
  let n = e.state.selection
  if ((DO(e, n), !!IO(e))) {
    if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && tn) {
      let r = e.domSelectionRange(),
        o = e.domObserver.currentSelection
      if (
        r.anchorNode &&
        o.anchorNode &&
        ks(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)
      ) {
        ;(e.input.mouseDown.delayedSelectionSync = !0),
          e.domObserver.setCurSelection()
        return
      }
    }
    if ((e.domObserver.disconnectSelection(), e.cursorWrapper)) ez(e)
    else {
      let { anchor: r, head: o } = n,
        i,
        s
      tC &&
        !(n instanceof _e) &&
        (n.$from.parent.inlineContent || (i = nC(e, n.from)),
        !n.empty && !n.$from.parent.inlineContent && (s = nC(e, n.to))),
        e.docView.setSelection(r, o, e, t),
        tC && (i && rC(i), s && rC(s)),
        n.visible
          ? e.dom.classList.remove("ProseMirror-hideselection")
          : (e.dom.classList.add("ProseMirror-hideselection"),
            "onselectionchange" in document && JF(e))
    }
    e.domObserver.setCurSelection(), e.domObserver.connectSelection()
  }
}
const tC = gn || (tn && wO < 63)
function nC(e, t) {
  let { node: n, offset: r } = e.docView.domFromPos(t, 0),
    o = r < n.childNodes.length ? n.childNodes[r] : null,
    i = r ? n.childNodes[r - 1] : null
  if (gn && o && o.contentEditable == "false") return kg(o)
  if (
    (!o || o.contentEditable == "false") &&
    (!i || i.contentEditable == "false")
  ) {
    if (o) return kg(o)
    if (i) return kg(i)
  }
}
function kg(e) {
  return (
    (e.contentEditable = "true"),
    gn && e.draggable && ((e.draggable = !1), (e.wasDraggable = !0)),
    e
  )
}
function rC(e) {
  ;(e.contentEditable = "false"),
    e.wasDraggable && ((e.draggable = !0), (e.wasDraggable = null))
}
function JF(e) {
  let t = e.dom.ownerDocument
  t.removeEventListener("selectionchange", e.input.hideSelectionGuard)
  let n = e.domSelectionRange(),
    r = n.anchorNode,
    o = n.anchorOffset
  t.addEventListener(
    "selectionchange",
    (e.input.hideSelectionGuard = () => {
      ;(n.anchorNode != r || n.anchorOffset != o) &&
        (t.removeEventListener("selectionchange", e.input.hideSelectionGuard),
        setTimeout(() => {
          ;(!IO(e) || e.state.selection.visible) &&
            e.dom.classList.remove("ProseMirror-hideselection")
        }, 20))
    })
  )
}
function ez(e) {
  let t = e.domSelection(),
    n = document.createRange()
  if (!t) return
  let r = e.cursorWrapper.dom,
    o = r.nodeName == "IMG"
  o ? n.setStart(r.parentNode, Kt(r) + 1) : n.setStart(r, 0),
    n.collapse(!0),
    t.removeAllRanges(),
    t.addRange(n),
    !o &&
      !e.state.selection.visible &&
      Tn &&
      gi <= 11 &&
      ((r.disabled = !0), (r.disabled = !1))
}
function DO(e, t) {
  if (t instanceof ye) {
    let n = e.docView.descAt(t.from)
    n != e.lastSelectedViewDesc &&
      (oC(e), n && n.selectNode(), (e.lastSelectedViewDesc = n))
  } else oC(e)
}
function oC(e) {
  e.lastSelectedViewDesc &&
    (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(),
    (e.lastSelectedViewDesc = void 0))
}
function Xb(e, t, n, r) {
  return (
    e.someProp("createSelectionBetween", (o) => o(e, t, n)) ||
    _e.between(t, n, r)
  )
}
function iC(e) {
  return e.editable && !e.hasFocus() ? !1 : LO(e)
}
function LO(e) {
  let t = e.domSelectionRange()
  if (!t.anchorNode) return !1
  try {
    return (
      e.dom.contains(
        t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode
      ) &&
      (e.editable ||
        e.dom.contains(
          t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode
        ))
    )
  } catch {
    return !1
  }
}
function tz(e) {
  let t = e.docView.domFromPos(e.state.selection.anchor, 0),
    n = e.domSelectionRange()
  return ks(t.node, t.offset, n.anchorNode, n.anchorOffset)
}
function Oy(e, t) {
  let { $anchor: n, $head: r } = e.selection,
    o = t > 0 ? n.max(r) : n.min(r),
    i = o.parent.inlineContent
      ? o.depth
        ? e.doc.resolve(t > 0 ? o.after() : o.before())
        : null
      : o
  return i && Ne.findFrom(i, t)
}
function Vo(e, t) {
  return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0
}
function sC(e, t, n) {
  let r = e.state.selection
  if (r instanceof _e)
    if (n.indexOf("s") > -1) {
      let { $head: o } = r,
        i = o.textOffset ? null : t < 0 ? o.nodeBefore : o.nodeAfter
      if (!i || i.isText || !i.isLeaf) return !1
      let s = e.state.doc.resolve(o.pos + i.nodeSize * (t < 0 ? -1 : 1))
      return Vo(e, new _e(r.$anchor, s))
    } else if (r.empty) {
      if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
        let o = Oy(e.state, t)
        return o && o instanceof ye ? Vo(e, o) : !1
      } else if (!(Qn && n.indexOf("m") > -1)) {
        let o = r.$head,
          i = o.textOffset ? null : t < 0 ? o.nodeBefore : o.nodeAfter,
          s
        if (!i || i.isText) return !1
        let a = t < 0 ? o.pos - i.nodeSize : o.pos
        return i.isAtom || ((s = e.docView.descAt(a)) && !s.contentDOM)
          ? ye.isSelectable(i)
            ? Vo(e, new ye(t < 0 ? e.state.doc.resolve(o.pos - i.nodeSize) : o))
            : Du
              ? Vo(e, new _e(e.state.doc.resolve(t < 0 ? a : a + i.nodeSize)))
              : !1
          : !1
      }
    } else return !1
  else {
    if (r instanceof ye && r.node.isInline)
      return Vo(e, new _e(t > 0 ? r.$to : r.$from))
    {
      let o = Oy(e.state, t)
      return o ? Vo(e, o) : !1
    }
  }
}
function sp(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function pc(e, t) {
  let n = e.pmViewDesc
  return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR")
}
function Xs(e, t) {
  return t < 0 ? nz(e) : rz(e)
}
function nz(e) {
  let t = e.domSelectionRange(),
    n = t.focusNode,
    r = t.focusOffset
  if (!n) return
  let o,
    i,
    s = !1
  for (
    Ar && n.nodeType == 1 && r < sp(n) && pc(n.childNodes[r], -1) && (s = !0);
    ;

  )
    if (r > 0) {
      if (n.nodeType != 1) break
      {
        let a = n.childNodes[r - 1]
        if (pc(a, -1)) (o = n), (i = --r)
        else if (a.nodeType == 3) (n = a), (r = n.nodeValue.length)
        else break
      }
    } else {
      if (PO(n)) break
      {
        let a = n.previousSibling
        for (; a && pc(a, -1); )
          (o = n.parentNode), (i = Kt(a)), (a = a.previousSibling)
        if (a) (n = a), (r = sp(n))
        else {
          if (((n = n.parentNode), n == e.dom)) break
          r = 0
        }
      }
    }
  s ? Ay(e, n, r) : o && Ay(e, o, i)
}
function rz(e) {
  let t = e.domSelectionRange(),
    n = t.focusNode,
    r = t.focusOffset
  if (!n) return
  let o = sp(n),
    i,
    s
  for (;;)
    if (r < o) {
      if (n.nodeType != 1) break
      let a = n.childNodes[r]
      if (pc(a, 1)) (i = n), (s = ++r)
      else break
    } else {
      if (PO(n)) break
      {
        let a = n.nextSibling
        for (; a && pc(a, 1); )
          (i = a.parentNode), (s = Kt(a) + 1), (a = a.nextSibling)
        if (a) (n = a), (r = 0), (o = sp(n))
        else {
          if (((n = n.parentNode), n == e.dom)) break
          r = o = 0
        }
      }
    }
  i && Ay(e, i, s)
}
function PO(e) {
  let t = e.pmViewDesc
  return t && t.node && t.node.isBlock
}
function oz(e, t) {
  for (; e && t == e.childNodes.length && !Iu(e); )
    (t = Kt(e) + 1), (e = e.parentNode)
  for (; e && t < e.childNodes.length; ) {
    let n = e.childNodes[t]
    if (n.nodeType == 3) return n
    if (n.nodeType == 1 && n.contentEditable == "false") break
    ;(e = n), (t = 0)
  }
}
function iz(e, t) {
  for (; e && !t && !Iu(e); ) (t = Kt(e)), (e = e.parentNode)
  for (; e && t; ) {
    let n = e.childNodes[t - 1]
    if (n.nodeType == 3) return n
    if (n.nodeType == 1 && n.contentEditable == "false") break
    ;(e = n), (t = e.childNodes.length)
  }
}
function Ay(e, t, n) {
  if (t.nodeType != 3) {
    let i, s
    ;(s = oz(t, n))
      ? ((t = s), (n = 0))
      : (i = iz(t, n)) && ((t = i), (n = i.nodeValue.length))
  }
  let r = e.domSelection()
  if (!r) return
  if (nm(r)) {
    let i = document.createRange()
    i.setEnd(t, n), i.setStart(t, n), r.removeAllRanges(), r.addRange(i)
  } else r.extend && r.extend(t, n)
  e.domObserver.setCurSelection()
  let { state: o } = e
  setTimeout(() => {
    e.state == o && _o(e)
  }, 50)
}
function aC(e, t) {
  let n = e.state.doc.resolve(t)
  if (!(tn || NF) && n.parent.inlineContent) {
    let o = e.coordsAtPos(t)
    if (t > n.start()) {
      let i = e.coordsAtPos(t - 1),
        s = (i.top + i.bottom) / 2
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left < o.left ? "ltr" : "rtl"
    }
    if (t < n.end()) {
      let i = e.coordsAtPos(t + 1),
        s = (i.top + i.bottom) / 2
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left > o.left ? "ltr" : "rtl"
    }
  }
  return getComputedStyle(e.dom).direction == "rtl" ? "rtl" : "ltr"
}
function lC(e, t, n) {
  let r = e.state.selection
  if (
    (r instanceof _e && !r.empty) ||
    n.indexOf("s") > -1 ||
    (Qn && n.indexOf("m") > -1)
  )
    return !1
  let { $from: o, $to: i } = r
  if (!o.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
    let s = Oy(e.state, t)
    if (s && s instanceof ye) return Vo(e, s)
  }
  if (!o.parent.inlineContent) {
    let s = t < 0 ? o : i,
      a = r instanceof or ? Ne.near(s, t) : Ne.findFrom(s, t)
    return a ? Vo(e, a) : !1
  }
  return !1
}
function cC(e, t) {
  if (!(e.state.selection instanceof _e)) return !0
  let { $head: n, $anchor: r, empty: o } = e.state.selection
  if (!n.sameParent(r)) return !0
  if (!o) return !1
  if (e.endOfTextblock(t > 0 ? "forward" : "backward")) return !0
  let i = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter)
  if (i && !i.isText) {
    let s = e.state.tr
    return (
      t < 0
        ? s.delete(n.pos - i.nodeSize, n.pos)
        : s.delete(n.pos, n.pos + i.nodeSize),
      e.dispatch(s),
      !0
    )
  }
  return !1
}
function uC(e, t, n) {
  e.domObserver.stop(), (t.contentEditable = n), e.domObserver.start()
}
function sz(e) {
  if (!gn || e.state.selection.$head.parentOffset > 0) return !1
  let { focusNode: t, focusOffset: n } = e.domSelectionRange()
  if (
    t &&
    t.nodeType == 1 &&
    n == 0 &&
    t.firstChild &&
    t.firstChild.contentEditable == "false"
  ) {
    let r = t.firstChild
    uC(e, r, "true"), setTimeout(() => uC(e, r, "false"), 20)
  }
  return !1
}
function az(e) {
  let t = ""
  return (
    e.ctrlKey && (t += "c"),
    e.metaKey && (t += "m"),
    e.altKey && (t += "a"),
    e.shiftKey && (t += "s"),
    t
  )
}
function lz(e, t) {
  let n = t.keyCode,
    r = az(t)
  if (n == 8 || (Qn && n == 72 && r == "c")) return cC(e, -1) || Xs(e, -1)
  if ((n == 46 && !t.shiftKey) || (Qn && n == 68 && r == "c"))
    return cC(e, 1) || Xs(e, 1)
  if (n == 13 || n == 27) return !0
  if (n == 37 || (Qn && n == 66 && r == "c")) {
    let o = n == 37 ? (aC(e, e.state.selection.from) == "ltr" ? -1 : 1) : -1
    return sC(e, o, r) || Xs(e, o)
  } else if (n == 39 || (Qn && n == 70 && r == "c")) {
    let o = n == 39 ? (aC(e, e.state.selection.from) == "ltr" ? 1 : -1) : 1
    return sC(e, o, r) || Xs(e, o)
  } else {
    if (n == 38 || (Qn && n == 80 && r == "c")) return lC(e, -1, r) || Xs(e, -1)
    if (n == 40 || (Qn && n == 78 && r == "c"))
      return sz(e) || lC(e, 1, r) || Xs(e, 1)
    if (r == (Qn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0
  }
  return !1
}
function Qb(e, t) {
  e.someProp("transformCopied", (p) => {
    t = p(t, e)
  })
  let n = [],
    { content: r, openStart: o, openEnd: i } = t
  for (
    ;
    o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

  ) {
    o--, i--
    let p = r.firstChild
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null),
      (r = p.content)
  }
  let s = e.someProp("clipboardSerializer") || Ps.fromSchema(e.state.schema),
    a = UO(),
    l = a.createElement("div")
  l.appendChild(s.serializeFragment(r, { document: a }))
  let c = l.firstChild,
    u,
    d = 0
  for (; c && c.nodeType == 1 && (u = zO[c.nodeName.toLowerCase()]); ) {
    for (let p = u.length - 1; p >= 0; p--) {
      let g = a.createElement(u[p])
      for (; l.firstChild; ) g.appendChild(l.firstChild)
      l.appendChild(g), d++
    }
    c = l.firstChild
  }
  c &&
    c.nodeType == 1 &&
    c.setAttribute(
      "data-pm-slice",
      `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`
    )
  let f =
    e.someProp("clipboardTextSerializer", (p) => p(t, e)) ||
    t.content.textBetween(
      0,
      t.content.size,
      `

`
    )
  return { dom: l, text: f, slice: t }
}
function $O(e, t, n, r, o) {
  let i = o.parent.type.spec.code,
    s,
    a
  if (!n && !t) return null
  let l = t && (r || i || !n)
  if (l) {
    if (
      (e.someProp("transformPastedText", (f) => {
        t = f(t, i || r, e)
      }),
      i)
    )
      return t
        ? new oe(
            Z.from(
              e.state.schema.text(
                t.replace(
                  /\r\n?/g,
                  `
`
                )
              )
            ),
            0,
            0
          )
        : oe.empty
    let d = e.someProp("clipboardTextParser", (f) => f(t, o, r, e))
    if (d) a = d
    else {
      let f = o.marks(),
        { schema: p } = e.state,
        g = Ps.fromSchema(p)
      ;(s = document.createElement("div")),
        t.split(/(?:\r\n?|\n)+/).forEach((v) => {
          let b = s.appendChild(document.createElement("p"))
          v && b.appendChild(g.serializeNode(p.text(v, f)))
        })
    }
  } else
    e.someProp("transformPastedHTML", (d) => {
      n = d(n, e)
    }),
      (s = fz(n)),
      Du && pz(s)
  let c = s && s.querySelector("[data-pm-slice]"),
    u =
      c &&
      /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
        c.getAttribute("data-pm-slice") || ""
      )
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = s.firstChild
      for (; f && f.nodeType != 1; ) f = f.nextSibling
      if (!f) break
      s = f
    }
  if (
    (a ||
      (a = (
        e.someProp("clipboardParser") ||
        e.someProp("domParser") ||
        mi.fromSchema(e.state.schema)
      ).parseSlice(s, {
        preserveWhitespace: !!(l || u),
        context: o,
        ruleFromNode(f) {
          return f.nodeName == "BR" &&
            !f.nextSibling &&
            f.parentNode &&
            !cz.test(f.parentNode.nodeName)
            ? { ignore: !0 }
            : null
        },
      })),
    u)
  )
    a = hz(dC(a, +u[1], +u[2]), u[4])
  else if (((a = oe.maxOpen(uz(a.content, o), !0)), a.openStart || a.openEnd)) {
    let d = 0,
      f = 0
    for (
      let p = a.content.firstChild;
      d < a.openStart && !p.type.spec.isolating;
      d++, p = p.firstChild
    );
    for (
      let p = a.content.lastChild;
      f < a.openEnd && !p.type.spec.isolating;
      f++, p = p.lastChild
    );
    a = dC(a, d, f)
  }
  return (
    e.someProp("transformPasted", (d) => {
      a = d(a, e)
    }),
    a
  )
}
const cz =
  /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i
function uz(e, t) {
  if (e.childCount < 2) return e
  for (let n = t.depth; n >= 0; n--) {
    let o = t.node(n).contentMatchAt(t.index(n)),
      i,
      s = []
    if (
      (e.forEach((a) => {
        if (!s) return
        let l = o.findWrapping(a.type),
          c
        if (!l) return (s = null)
        if ((c = s.length && i.length && jO(l, i, a, s[s.length - 1], 0)))
          s[s.length - 1] = c
        else {
          s.length && (s[s.length - 1] = FO(s[s.length - 1], i.length))
          let u = BO(a, l)
          s.push(u), (o = o.matchType(u.type)), (i = l)
        }
      }),
      s)
    )
      return Z.from(s)
  }
  return e
}
function BO(e, t, n = 0) {
  for (let r = t.length - 1; r >= n; r--) e = t[r].create(null, Z.from(e))
  return e
}
function jO(e, t, n, r, o) {
  if (o < e.length && o < t.length && e[o] == t[o]) {
    let i = jO(e, t, n, r.lastChild, o + 1)
    if (i) return r.copy(r.content.replaceChild(r.childCount - 1, i))
    if (
      r
        .contentMatchAt(r.childCount)
        .matchType(o == e.length - 1 ? n.type : e[o + 1])
    )
      return r.copy(r.content.append(Z.from(BO(n, e, o + 1))))
  }
}
function FO(e, t) {
  if (t == 0) return e
  let n = e.content.replaceChild(e.childCount - 1, FO(e.lastChild, t - 1)),
    r = e.contentMatchAt(e.childCount).fillBefore(Z.empty, !0)
  return e.copy(n.append(r))
}
function Ry(e, t, n, r, o, i) {
  let s = t < 0 ? e.firstChild : e.lastChild,
    a = s.content
  return (
    e.childCount > 1 && (i = 0),
    o < r - 1 && (a = Ry(a, t, n, r, o + 1, i)),
    o >= n &&
      (a =
        t < 0
          ? s
              .contentMatchAt(0)
              .fillBefore(a, i <= o)
              .append(a)
          : a.append(s.contentMatchAt(s.childCount).fillBefore(Z.empty, !0))),
    e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a))
  )
}
function dC(e, t, n) {
  return (
    t < e.openStart &&
      (e = new oe(
        Ry(e.content, -1, t, e.openStart, 0, e.openEnd),
        t,
        e.openEnd
      )),
    n < e.openEnd &&
      (e = new oe(Ry(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)),
    e
  )
}
const zO = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"],
}
let fC = null
function UO() {
  return fC || (fC = document.implementation.createHTMLDocument("title"))
}
let Ng = null
function dz(e) {
  let t = window.trustedTypes
  return t
    ? (Ng ||
        (Ng = t.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })),
      Ng.createHTML(e))
    : e
}
function fz(e) {
  let t = /^(\s*<meta [^>]*>)*/.exec(e)
  t && (e = e.slice(t[0].length))
  let n = UO().createElement("div"),
    r = /<([a-z][^>\s]+)/i.exec(e),
    o
  if (
    ((o = r && zO[r[1].toLowerCase()]) &&
      (e =
        o.map((i) => "<" + i + ">").join("") +
        e +
        o
          .map((i) => "</" + i + ">")
          .reverse()
          .join("")),
    (n.innerHTML = dz(e)),
    o)
  )
    for (let i = 0; i < o.length; i++) n = n.querySelector(o[i]) || n
  return n
}
function pz(e) {
  let t = e.querySelectorAll(
    tn ? "span:not([class]):not([style])" : "span.Apple-converted-space"
  )
  for (let n = 0; n < t.length; n++) {
    let r = t[n]
    r.childNodes.length == 1 &&
      r.textContent == "" &&
      r.parentNode &&
      r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r)
  }
}
function hz(e, t) {
  if (!e.size) return e
  let n = e.content.firstChild.type.schema,
    r
  try {
    r = JSON.parse(t)
  } catch {
    return e
  }
  let { content: o, openStart: i, openEnd: s } = e
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]]
    if (!l || l.hasRequiredAttrs()) break
    ;(o = Z.from(l.create(r[a + 1], o))), i++, s++
  }
  return new oe(o, i, s)
}
const vn = {},
  yn = {},
  mz = { touchstart: !0, touchmove: !0 }
class gz {
  constructor() {
    ;(this.shiftKey = !1),
      (this.mouseDown = null),
      (this.lastKeyCode = null),
      (this.lastKeyCodeTime = 0),
      (this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastIOSEnter = 0),
      (this.lastIOSEnterFallbackTimeout = -1),
      (this.lastFocus = 0),
      (this.lastTouch = 0),
      (this.lastChromeDelete = 0),
      (this.composing = !1),
      (this.compositionNode = null),
      (this.composingTimeout = -1),
      (this.compositionNodes = []),
      (this.compositionEndedAt = -2e8),
      (this.compositionID = 1),
      (this.compositionPendingChanges = 0),
      (this.domChangeCount = 0),
      (this.eventHandlers = Object.create(null)),
      (this.hideSelectionGuard = null)
  }
}
function vz(e) {
  for (let t in vn) {
    let n = vn[t]
    e.dom.addEventListener(
      t,
      (e.input.eventHandlers[t] = (r) => {
        bz(e, r) && !Jb(e, r) && (e.editable || !(r.type in yn)) && n(e, r)
      }),
      mz[t] ? { passive: !0 } : void 0
    )
  }
  gn && e.dom.addEventListener("input", () => null), Iy(e)
}
function ti(e, t) {
  ;(e.input.lastSelectionOrigin = t), (e.input.lastSelectionTime = Date.now())
}
function yz(e) {
  e.domObserver.stop()
  for (let t in e.input.eventHandlers)
    e.dom.removeEventListener(t, e.input.eventHandlers[t])
  clearTimeout(e.input.composingTimeout),
    clearTimeout(e.input.lastIOSEnterFallbackTimeout)
}
function Iy(e) {
  e.someProp("handleDOMEvents", (t) => {
    for (let n in t)
      e.input.eventHandlers[n] ||
        e.dom.addEventListener(n, (e.input.eventHandlers[n] = (r) => Jb(e, r)))
  })
}
function Jb(e, t) {
  return e.someProp("handleDOMEvents", (n) => {
    let r = n[t.type]
    return r ? r(e, t) || t.defaultPrevented : !1
  })
}
function bz(e, t) {
  if (!t.bubbles) return !0
  if (t.defaultPrevented) return !1
  for (let n = t.target; n != e.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(t)))
      return !1
  return !0
}
function xz(e, t) {
  !Jb(e, t) && vn[t.type] && (e.editable || !(t.type in yn)) && vn[t.type](e, t)
}
yn.keydown = (e, t) => {
  let n = t
  if (
    ((e.input.shiftKey = n.keyCode == 16 || n.shiftKey),
    !HO(e, n) &&
      ((e.input.lastKeyCode = n.keyCode),
      (e.input.lastKeyCodeTime = Date.now()),
      !(xo && tn && n.keyCode == 13)))
  )
    if (
      (n.keyCode != 229 && e.domObserver.forceFlush(),
      Qa && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
    ) {
      let r = Date.now()
      ;(e.input.lastIOSEnter = r),
        (e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          e.input.lastIOSEnter == r &&
            (e.someProp("handleKeyDown", (o) => o(e, Hi(13, "Enter"))),
            (e.input.lastIOSEnter = 0))
        }, 200))
    } else
      e.someProp("handleKeyDown", (r) => r(e, n)) || lz(e, n)
        ? n.preventDefault()
        : ti(e, "key")
}
yn.keyup = (e, t) => {
  t.keyCode == 16 && (e.input.shiftKey = !1)
}
yn.keypress = (e, t) => {
  let n = t
  if (HO(e, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (Qn && n.metaKey))
    return
  if (e.someProp("handleKeyPress", (o) => o(e, n))) {
    n.preventDefault()
    return
  }
  let r = e.state.selection
  if (!(r instanceof _e) || !r.$from.sameParent(r.$to)) {
    let o = String.fromCharCode(n.charCode)
    !/[\r\n]/.test(o) &&
      !e.someProp("handleTextInput", (i) => i(e, r.$from.pos, r.$to.pos, o)) &&
      e.dispatch(e.state.tr.insertText(o).scrollIntoView()),
      n.preventDefault()
  }
}
function om(e) {
  return { left: e.clientX, top: e.clientY }
}
function wz(e, t) {
  let n = t.x - e.clientX,
    r = t.y - e.clientY
  return n * n + r * r < 100
}
function e1(e, t, n, r, o) {
  if (r == -1) return !1
  let i = e.state.doc.resolve(r)
  for (let s = i.depth + 1; s > 0; s--)
    if (
      e.someProp(t, (a) =>
        s > i.depth
          ? a(e, n, i.nodeAfter, i.before(s), o, !0)
          : a(e, n, i.node(s), i.before(s), o, !1)
      )
    )
      return !0
  return !1
}
function Da(e, t, n) {
  if ((e.focused || e.focus(), e.state.selection.eq(t))) return
  let r = e.state.tr.setSelection(t)
  n == "pointer" && r.setMeta("pointer", !0), e.dispatch(r)
}
function Ez(e, t) {
  if (t == -1) return !1
  let n = e.state.doc.resolve(t),
    r = n.nodeAfter
  return r && r.isAtom && ye.isSelectable(r)
    ? (Da(e, new ye(n), "pointer"), !0)
    : !1
}
function Cz(e, t) {
  if (t == -1) return !1
  let n = e.state.selection,
    r,
    o
  n instanceof ye && (r = n.node)
  let i = e.state.doc.resolve(t)
  for (let s = i.depth + 1; s > 0; s--) {
    let a = s > i.depth ? i.nodeAfter : i.node(s)
    if (ye.isSelectable(a)) {
      r &&
      n.$from.depth > 0 &&
      s >= n.$from.depth &&
      i.before(n.$from.depth + 1) == n.$from.pos
        ? (o = i.before(n.$from.depth))
        : (o = i.before(s))
      break
    }
  }
  return o != null ? (Da(e, ye.create(e.state.doc, o), "pointer"), !0) : !1
}
function Sz(e, t, n, r, o) {
  return (
    e1(e, "handleClickOn", t, n, r) ||
    e.someProp("handleClick", (i) => i(e, t, r)) ||
    (o ? Cz(e, n) : Ez(e, n))
  )
}
function _z(e, t, n, r) {
  return (
    e1(e, "handleDoubleClickOn", t, n, r) ||
    e.someProp("handleDoubleClick", (o) => o(e, t, r))
  )
}
function kz(e, t, n, r) {
  return (
    e1(e, "handleTripleClickOn", t, n, r) ||
    e.someProp("handleTripleClick", (o) => o(e, t, r)) ||
    Nz(e, n, r)
  )
}
function Nz(e, t, n) {
  if (n.button != 0) return !1
  let r = e.state.doc
  if (t == -1)
    return r.inlineContent
      ? (Da(e, _e.create(r, 0, r.content.size), "pointer"), !0)
      : !1
  let o = r.resolve(t)
  for (let i = o.depth + 1; i > 0; i--) {
    let s = i > o.depth ? o.nodeAfter : o.node(i),
      a = o.before(i)
    if (s.inlineContent)
      Da(e, _e.create(r, a + 1, a + 1 + s.content.size), "pointer")
    else if (ye.isSelectable(s)) Da(e, ye.create(r, a), "pointer")
    else continue
    return !0
  }
}
function t1(e) {
  return ap(e)
}
const VO = Qn ? "metaKey" : "ctrlKey"
vn.mousedown = (e, t) => {
  let n = t
  e.input.shiftKey = n.shiftKey
  let r = t1(e),
    o = Date.now(),
    i = "singleClick"
  o - e.input.lastClick.time < 500 &&
    wz(n, e.input.lastClick) &&
    !n[VO] &&
    (e.input.lastClick.type == "singleClick"
      ? (i = "doubleClick")
      : e.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
    (e.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i })
  let s = e.posAtCoords(om(n))
  s &&
    (i == "singleClick"
      ? (e.input.mouseDown && e.input.mouseDown.done(),
        (e.input.mouseDown = new Tz(e, s, n, !!r)))
      : (i == "doubleClick" ? _z : kz)(e, s.pos, s.inside, n)
        ? n.preventDefault()
        : ti(e, "pointer"))
}
class Tz {
  constructor(t, n, r, o) {
    ;(this.view = t),
      (this.pos = n),
      (this.event = r),
      (this.flushed = o),
      (this.delayedSelectionSync = !1),
      (this.mightDrag = null),
      (this.startDoc = t.state.doc),
      (this.selectNode = !!r[VO]),
      (this.allowDefault = r.shiftKey)
    let i, s
    if (n.inside > -1) (i = t.state.doc.nodeAt(n.inside)), (s = n.inside)
    else {
      let u = t.state.doc.resolve(n.pos)
      ;(i = u.parent), (s = u.depth ? u.before() : 0)
    }
    const a = o ? null : r.target,
      l = a ? t.docView.nearestDesc(a, !0) : null
    this.target = l && l.dom.nodeType == 1 ? l.dom : null
    let { selection: c } = t.state
    ;((r.button == 0 &&
      i.type.spec.draggable &&
      i.type.spec.selectable !== !1) ||
      (c instanceof ye && c.from <= s && c.to > s)) &&
      (this.mightDrag = {
        node: i,
        pos: s,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(
          this.target &&
          Ar &&
          !this.target.hasAttribute("contentEditable")
        ),
      }),
      this.target &&
        this.mightDrag &&
        (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable &&
          setTimeout(() => {
            this.view.input.mouseDown == this &&
              this.target.setAttribute("contentEditable", "false")
          }, 20),
        this.view.domObserver.start()),
      t.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
      t.root.addEventListener("mousemove", (this.move = this.move.bind(this))),
      ti(t, "pointer")
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up),
      this.view.root.removeEventListener("mousemove", this.move),
      this.mightDrag &&
        this.target &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
        this.mightDrag.setUneditable &&
          this.target.removeAttribute("contentEditable"),
        this.view.domObserver.start()),
      this.delayedSelectionSync && setTimeout(() => _o(this.view)),
      (this.view.input.mouseDown = null)
  }
  up(t) {
    if ((this.done(), !this.view.dom.contains(t.target))) return
    let n = this.pos
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(om(t))),
      this.updateAllowDefault(t),
      this.allowDefault || !n
        ? ti(this.view, "pointer")
        : Sz(this.view, n.pos, n.inside, t, this.selectNode)
          ? t.preventDefault()
          : t.button == 0 &&
              (this.flushed ||
                (gn && this.mightDrag && !this.mightDrag.node.isAtom) ||
                (tn &&
                  !this.view.state.selection.visible &&
                  Math.min(
                    Math.abs(n.pos - this.view.state.selection.from),
                    Math.abs(n.pos - this.view.state.selection.to)
                  ) <= 2))
            ? (Da(
                this.view,
                Ne.near(this.view.state.doc.resolve(n.pos)),
                "pointer"
              ),
              t.preventDefault())
            : ti(this.view, "pointer")
  }
  move(t) {
    this.updateAllowDefault(t),
      ti(this.view, "pointer"),
      t.buttons == 0 && this.done()
  }
  updateAllowDefault(t) {
    !this.allowDefault &&
      (Math.abs(this.event.x - t.clientX) > 4 ||
        Math.abs(this.event.y - t.clientY) > 4) &&
      (this.allowDefault = !0)
  }
}
vn.touchstart = (e) => {
  ;(e.input.lastTouch = Date.now()), t1(e), ti(e, "pointer")
}
vn.touchmove = (e) => {
  ;(e.input.lastTouch = Date.now()), ti(e, "pointer")
}
vn.contextmenu = (e) => t1(e)
function HO(e, t) {
  return e.composing
    ? !0
    : gn && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500
      ? ((e.input.compositionEndedAt = -2e8), !0)
      : !1
}
const Mz = xo ? 5e3 : -1
yn.compositionstart = yn.compositionupdate = (e) => {
  if (!e.composing) {
    e.domObserver.flush()
    let { state: t } = e,
      n = t.selection.$to
    if (
      t.selection instanceof _e &&
      (t.storedMarks ||
        (!n.textOffset &&
          n.parentOffset &&
          n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
    )
      (e.markCursor = e.state.storedMarks || n.marks()),
        ap(e, !0),
        (e.markCursor = null)
    else if (
      (ap(e, !t.selection.empty),
      Ar &&
        t.selection.empty &&
        n.parentOffset &&
        !n.textOffset &&
        n.nodeBefore.marks.length)
    ) {
      let r = e.domSelectionRange()
      for (
        let o = r.focusNode, i = r.focusOffset;
        o && o.nodeType == 1 && i != 0;

      ) {
        let s = i < 0 ? o.lastChild : o.childNodes[i - 1]
        if (!s) break
        if (s.nodeType == 3) {
          let a = e.domSelection()
          a && a.collapse(s, s.nodeValue.length)
          break
        } else (o = s), (i = -1)
      }
    }
    e.input.composing = !0
  }
  WO(e, Mz)
}
yn.compositionend = (e, t) => {
  e.composing &&
    ((e.input.composing = !1),
    (e.input.compositionEndedAt = t.timeStamp),
    (e.input.compositionPendingChanges = e.domObserver.pendingRecords().length
      ? e.input.compositionID
      : 0),
    (e.input.compositionNode = null),
    e.input.compositionPendingChanges &&
      Promise.resolve().then(() => e.domObserver.flush()),
    e.input.compositionID++,
    WO(e, 20))
}
function WO(e, t) {
  clearTimeout(e.input.composingTimeout),
    t > -1 && (e.input.composingTimeout = setTimeout(() => ap(e), t))
}
function KO(e) {
  for (
    e.composing &&
    ((e.input.composing = !1), (e.input.compositionEndedAt = Az()));
    e.input.compositionNodes.length > 0;

  )
    e.input.compositionNodes.pop().markParentsDirty()
}
function Oz(e) {
  let t = e.domSelectionRange()
  if (!t.focusNode) return null
  let n = EF(t.focusNode, t.focusOffset),
    r = CF(t.focusNode, t.focusOffset)
  if (n && r && n != r) {
    let o = r.pmViewDesc,
      i = e.domObserver.lastChangedTextNode
    if (n == i || r == i) return i
    if (!o || !o.isText(r.nodeValue)) return r
    if (e.input.compositionNode == r) {
      let s = n.pmViewDesc
      if (!(!s || !s.isText(n.nodeValue))) return r
    }
  }
  return n || r
}
function Az() {
  let e = document.createEvent("Event")
  return e.initEvent("event", !0, !0), e.timeStamp
}
function ap(e, t = !1) {
  if (!(xo && e.domObserver.flushingSoon >= 0)) {
    if (
      (e.domObserver.forceFlush(), KO(e), t || (e.docView && e.docView.dirty))
    ) {
      let n = Yb(e)
      return (
        n && !n.eq(e.state.selection)
          ? e.dispatch(e.state.tr.setSelection(n))
          : (e.markCursor || t) && !e.state.selection.empty
            ? e.dispatch(e.state.tr.deleteSelection())
            : e.updateState(e.state),
        !0
      )
    }
    return !1
  }
}
function Rz(e, t) {
  if (!e.dom.parentNode) return
  let n = e.dom.parentNode.appendChild(document.createElement("div"))
  n.appendChild(t),
    (n.style.cssText = "position: fixed; left: -10000px; top: 10px")
  let r = getSelection(),
    o = document.createRange()
  o.selectNodeContents(t),
    e.dom.blur(),
    r.removeAllRanges(),
    r.addRange(o),
    setTimeout(() => {
      n.parentNode && n.parentNode.removeChild(n), e.focus()
    }, 50)
}
const iu = (Tn && gi < 15) || (Qa && TF < 604)
vn.copy = yn.cut = (e, t) => {
  let n = t,
    r = e.state.selection,
    o = n.type == "cut"
  if (r.empty) return
  let i = iu ? null : n.clipboardData,
    s = r.content(),
    { dom: a, text: l } = Qb(e, s)
  i
    ? (n.preventDefault(),
      i.clearData(),
      i.setData("text/html", a.innerHTML),
      i.setData("text/plain", l))
    : Rz(e, a),
    o &&
      e.dispatch(
        e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")
      )
}
function Iz(e) {
  return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1
    ? e.content.firstChild
    : null
}
function Dz(e, t) {
  if (!e.dom.parentNode) return
  let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code,
    r = e.dom.parentNode.appendChild(
      document.createElement(n ? "textarea" : "div")
    )
  n || (r.contentEditable = "true"),
    (r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    r.focus()
  let o = e.input.shiftKey && e.input.lastKeyCode != 45
  setTimeout(() => {
    e.focus(),
      r.parentNode && r.parentNode.removeChild(r),
      n ? su(e, r.value, null, o, t) : su(e, r.textContent, r.innerHTML, o, t)
  }, 50)
}
function su(e, t, n, r, o) {
  let i = $O(e, t, n, r, e.state.selection.$from)
  if (e.someProp("handlePaste", (l) => l(e, o, i || oe.empty))) return !0
  if (!i) return !1
  let s = Iz(i),
    a = s
      ? e.state.tr.replaceSelectionWith(s, r)
      : e.state.tr.replaceSelection(i)
  return (
    e.dispatch(
      a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
    ),
    !0
  )
}
function GO(e) {
  let t = e.getData("text/plain") || e.getData("Text")
  if (t) return t
  let n = e.getData("text/uri-list")
  return n ? n.replace(/\r?\n/g, " ") : ""
}
yn.paste = (e, t) => {
  let n = t
  if (e.composing && !xo) return
  let r = iu ? null : n.clipboardData,
    o = e.input.shiftKey && e.input.lastKeyCode != 45
  r && su(e, GO(r), r.getData("text/html"), o, n)
    ? n.preventDefault()
    : Dz(e, n)
}
class qO {
  constructor(t, n, r) {
    ;(this.slice = t), (this.move = n), (this.node = r)
  }
}
const ZO = Qn ? "altKey" : "ctrlKey"
vn.dragstart = (e, t) => {
  let n = t,
    r = e.input.mouseDown
  if ((r && r.done(), !n.dataTransfer)) return
  let o = e.state.selection,
    i = o.empty ? null : e.posAtCoords(om(n)),
    s
  if (!(i && i.pos >= o.from && i.pos <= (o instanceof ye ? o.to - 1 : o.to))) {
    if (r && r.mightDrag) s = ye.create(e.state.doc, r.mightDrag.pos)
    else if (n.target && n.target.nodeType == 1) {
      let d = e.docView.nearestDesc(n.target, !0)
      d &&
        d.node.type.spec.draggable &&
        d != e.docView &&
        (s = ye.create(e.state.doc, d.posBefore))
    }
  }
  let a = (s || e.state.selection).content(),
    { dom: l, text: c, slice: u } = Qb(e, a)
  ;(!n.dataTransfer.files.length || !tn || wO > 120) &&
    n.dataTransfer.clearData(),
    n.dataTransfer.setData(iu ? "Text" : "text/html", l.innerHTML),
    (n.dataTransfer.effectAllowed = "copyMove"),
    iu || n.dataTransfer.setData("text/plain", c),
    (e.dragging = new qO(u, !n[ZO], s))
}
vn.dragend = (e) => {
  let t = e.dragging
  window.setTimeout(() => {
    e.dragging == t && (e.dragging = null)
  }, 50)
}
yn.dragover = yn.dragenter = (e, t) => t.preventDefault()
yn.drop = (e, t) => {
  let n = t,
    r = e.dragging
  if (((e.dragging = null), !n.dataTransfer)) return
  let o = e.posAtCoords(om(n))
  if (!o) return
  let i = e.state.doc.resolve(o.pos),
    s = r && r.slice
  s
    ? e.someProp("transformPasted", (g) => {
        s = g(s, e)
      })
    : (s = $O(
        e,
        GO(n.dataTransfer),
        iu ? null : n.dataTransfer.getData("text/html"),
        !1,
        i
      ))
  let a = !!(r && !n[ZO])
  if (e.someProp("handleDrop", (g) => g(e, n, s || oe.empty, a))) {
    n.preventDefault()
    return
  }
  if (!s) return
  n.preventDefault()
  let l = s ? fO(e.state.doc, i.pos, s) : i.pos
  l == null && (l = i.pos)
  let c = e.state.tr
  if (a) {
    let { node: g } = r
    g ? g.replace(c) : c.deleteSelection()
  }
  let u = c.mapping.map(l),
    d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
    f = c.doc
  if (
    (d
      ? c.replaceRangeWith(u, u, s.content.firstChild)
      : c.replaceRange(u, u, s),
    c.doc.eq(f))
  )
    return
  let p = c.doc.resolve(u)
  if (
    d &&
    ye.isSelectable(s.content.firstChild) &&
    p.nodeAfter &&
    p.nodeAfter.sameMarkup(s.content.firstChild)
  )
    c.setSelection(new ye(p))
  else {
    let g = c.mapping.map(l)
    c.mapping.maps[c.mapping.maps.length - 1].forEach((v, b, y, x) => (g = x)),
      c.setSelection(Xb(e, p, c.doc.resolve(g)))
  }
  e.focus(), e.dispatch(c.setMeta("uiEvent", "drop"))
}
vn.focus = (e) => {
  ;(e.input.lastFocus = Date.now()),
    e.focused ||
      (e.domObserver.stop(),
      e.dom.classList.add("ProseMirror-focused"),
      e.domObserver.start(),
      (e.focused = !0),
      setTimeout(() => {
        e.docView &&
          e.hasFocus() &&
          !e.domObserver.currentSelection.eq(e.domSelectionRange()) &&
          _o(e)
      }, 20))
}
vn.blur = (e, t) => {
  let n = t
  e.focused &&
    (e.domObserver.stop(),
    e.dom.classList.remove("ProseMirror-focused"),
    e.domObserver.start(),
    n.relatedTarget &&
      e.dom.contains(n.relatedTarget) &&
      e.domObserver.currentSelection.clear(),
    (e.focused = !1))
}
vn.beforeinput = (e, t) => {
  if (tn && xo && t.inputType == "deleteContentBackward") {
    e.domObserver.flushSoon()
    let { domChangeCount: r } = e.input
    setTimeout(() => {
      if (
        e.input.domChangeCount != r ||
        (e.dom.blur(),
        e.focus(),
        e.someProp("handleKeyDown", (i) => i(e, Hi(8, "Backspace"))))
      )
        return
      let { $cursor: o } = e.state.selection
      o &&
        o.pos > 0 &&
        e.dispatch(e.state.tr.delete(o.pos - 1, o.pos).scrollIntoView())
    }, 50)
  }
}
for (let e in yn) vn[e] = yn[e]
function au(e, t) {
  if (e == t) return !0
  for (let n in e) if (e[n] !== t[n]) return !1
  for (let n in t) if (!(n in e)) return !1
  return !0
}
class lp {
  constructor(t, n) {
    ;(this.toDOM = t), (this.spec = n || ss), (this.side = this.spec.side || 0)
  }
  map(t, n, r, o) {
    let { pos: i, deleted: s } = t.mapResult(n.from + o, this.side < 0 ? -1 : 1)
    return s ? null : new pn(i - r, i - r, this)
  }
  valid() {
    return !0
  }
  eq(t) {
    return (
      this == t ||
      (t instanceof lp &&
        ((this.spec.key && this.spec.key == t.spec.key) ||
          (this.toDOM == t.toDOM && au(this.spec, t.spec))))
    )
  }
  destroy(t) {
    this.spec.destroy && this.spec.destroy(t)
  }
}
class yi {
  constructor(t, n) {
    ;(this.attrs = t), (this.spec = n || ss)
  }
  map(t, n, r, o) {
    let i = t.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
      s = t.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r
    return i >= s ? null : new pn(i, s, this)
  }
  valid(t, n) {
    return n.from < n.to
  }
  eq(t) {
    return (
      this == t ||
      (t instanceof yi && au(this.attrs, t.attrs) && au(this.spec, t.spec))
    )
  }
  static is(t) {
    return t.type instanceof yi
  }
  destroy() {}
}
class n1 {
  constructor(t, n) {
    ;(this.attrs = t), (this.spec = n || ss)
  }
  map(t, n, r, o) {
    let i = t.mapResult(n.from + o, 1)
    if (i.deleted) return null
    let s = t.mapResult(n.to + o, -1)
    return s.deleted || s.pos <= i.pos
      ? null
      : new pn(i.pos - r, s.pos - r, this)
  }
  valid(t, n) {
    let { index: r, offset: o } = t.content.findIndex(n.from),
      i
    return o == n.from && !(i = t.child(r)).isText && o + i.nodeSize == n.to
  }
  eq(t) {
    return (
      this == t ||
      (t instanceof n1 && au(this.attrs, t.attrs) && au(this.spec, t.spec))
    )
  }
  destroy() {}
}
class pn {
  constructor(t, n, r) {
    ;(this.from = t), (this.to = n), (this.type = r)
  }
  copy(t, n) {
    return new pn(t, n, this.type)
  }
  eq(t, n = 0) {
    return (
      this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to
    )
  }
  map(t, n, r) {
    return this.type.map(t, this, n, r)
  }
  static widget(t, n, r) {
    return new pn(t, t, new lp(n, r))
  }
  static inline(t, n, r, o) {
    return new pn(t, n, new yi(r, o))
  }
  static node(t, n, r, o) {
    return new pn(t, n, new n1(r, o))
  }
  get spec() {
    return this.type.spec
  }
  get inline() {
    return this.type instanceof yi
  }
  get widget() {
    return this.type instanceof lp
  }
}
const na = [],
  ss = {}
class mt {
  constructor(t, n) {
    ;(this.local = t.length ? t : na), (this.children = n.length ? n : na)
  }
  static create(t, n) {
    return n.length ? cp(n, t, 0, ss) : Qt
  }
  find(t, n, r) {
    let o = []
    return this.findInner(t == null ? 0 : t, n == null ? 1e9 : n, o, 0, r), o
  }
  findInner(t, n, r, o, i) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s]
      a.from <= n &&
        a.to >= t &&
        (!i || i(a.spec)) &&
        r.push(a.copy(a.from + o, a.to + o))
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > t) {
        let a = this.children[s] + 1
        this.children[s + 2].findInner(t - a, n - a, r, o + a, i)
      }
  }
  map(t, n, r) {
    return this == Qt || t.maps.length == 0
      ? this
      : this.mapInner(t, n, 0, 0, r || ss)
  }
  mapInner(t, n, r, o, i) {
    let s
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(t, r, o)
      l && l.type.valid(n, l)
        ? (s || (s = [])).push(l)
        : i.onRemove && i.onRemove(this.local[a].spec)
    }
    return this.children.length
      ? Lz(this.children, s || [], t, n, r, o, i)
      : s
        ? new mt(s.sort(as), na)
        : Qt
  }
  add(t, n) {
    return n.length
      ? this == Qt
        ? mt.create(t, n)
        : this.addInner(t, n, 0)
      : this
  }
  addInner(t, n, r) {
    let o,
      i = 0
    t.forEach((a, l) => {
      let c = l + r,
        u
      if ((u = XO(n, a, c))) {
        for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
          i += 3
        o[i] == l
          ? (o[i + 2] = o[i + 2].addInner(a, u, c + 1))
          : o.splice(i, 0, l, l + a.nodeSize, cp(u, a, c + 1, ss)),
          (i += 3)
      }
    })
    let s = YO(i ? QO(n) : n, -r)
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(t, s[a]) || s.splice(a--, 1)
    return new mt(
      s.length ? this.local.concat(s).sort(as) : this.local,
      o || this.children
    )
  }
  remove(t) {
    return t.length == 0 || this == Qt ? this : this.removeInner(t, 0)
  }
  removeInner(t, n) {
    let r = this.children,
      o = this.local
    for (let i = 0; i < r.length; i += 3) {
      let s,
        a = r[i] + n,
        l = r[i + 1] + n
      for (let u = 0, d; u < t.length; u++)
        (d = t[u]) &&
          d.from > a &&
          d.to < l &&
          ((t[u] = null), (s || (s = [])).push(d))
      if (!s) continue
      r == this.children && (r = this.children.slice())
      let c = r[i + 2].removeInner(s, a + 1)
      c != Qt ? (r[i + 2] = c) : (r.splice(i, 3), (i -= 3))
    }
    if (o.length) {
      for (let i = 0, s; i < t.length; i++)
        if ((s = t[i]))
          for (let a = 0; a < o.length; a++)
            o[a].eq(s, n) &&
              (o == this.local && (o = this.local.slice()), o.splice(a--, 1))
    }
    return r == this.children && o == this.local
      ? this
      : o.length || r.length
        ? new mt(o, r)
        : Qt
  }
  forChild(t, n) {
    if (this == Qt) return this
    if (n.isLeaf) return mt.empty
    let r, o
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= t) {
        this.children[a] == t && (r = this.children[a + 2])
        break
      }
    let i = t + 1,
      s = i + n.content.size
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a]
      if (l.from < s && l.to > i && l.type instanceof yi) {
        let c = Math.max(i, l.from) - i,
          u = Math.min(s, l.to) - i
        c < u && (o || (o = [])).push(l.copy(c, u))
      }
    }
    if (o) {
      let a = new mt(o.sort(as), na)
      return r ? new Zo([a, r]) : a
    }
    return r || Qt
  }
  eq(t) {
    if (this == t) return !0
    if (
      !(t instanceof mt) ||
      this.local.length != t.local.length ||
      this.children.length != t.children.length
    )
      return !1
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(t.local[n])) return !1
    for (let n = 0; n < this.children.length; n += 3)
      if (
        this.children[n] != t.children[n] ||
        this.children[n + 1] != t.children[n + 1] ||
        !this.children[n + 2].eq(t.children[n + 2])
      )
        return !1
    return !0
  }
  locals(t) {
    return r1(this.localsInner(t))
  }
  localsInner(t) {
    if (this == Qt) return na
    if (t.inlineContent || !this.local.some(yi.is)) return this.local
    let n = []
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof yi || n.push(this.local[r])
    return n
  }
  forEachSet(t) {
    t(this)
  }
}
mt.empty = new mt([], [])
mt.removeOverlap = r1
const Qt = mt.empty
class Zo {
  constructor(t) {
    this.members = t
  }
  map(t, n) {
    const r = this.members.map((o) => o.map(t, n, ss))
    return Zo.from(r)
  }
  forChild(t, n) {
    if (n.isLeaf) return mt.empty
    let r = []
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].forChild(t, n)
      i != Qt && (i instanceof Zo ? (r = r.concat(i.members)) : r.push(i))
    }
    return Zo.from(r)
  }
  eq(t) {
    if (!(t instanceof Zo) || t.members.length != this.members.length) return !1
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(t.members[n])) return !1
    return !0
  }
  locals(t) {
    let n,
      r = !0
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].localsInner(t)
      if (i.length)
        if (!n) n = i
        else {
          r && ((n = n.slice()), (r = !1))
          for (let s = 0; s < i.length; s++) n.push(i[s])
        }
    }
    return n ? r1(r ? n : n.sort(as)) : na
  }
  static from(t) {
    switch (t.length) {
      case 0:
        return Qt
      case 1:
        return t[0]
      default:
        return new Zo(
          t.every((n) => n instanceof mt)
            ? t
            : t.reduce((n, r) => n.concat(r instanceof mt ? r : r.members), [])
        )
    }
  }
  forEachSet(t) {
    for (let n = 0; n < this.members.length; n++) this.members[n].forEachSet(t)
  }
}
function Lz(e, t, n, r, o, i, s) {
  let a = e.slice()
  for (let c = 0, u = i; c < n.maps.length; c++) {
    let d = 0
    n.maps[c].forEach((f, p, g, v) => {
      let b = v - g - (p - f)
      for (let y = 0; y < a.length; y += 3) {
        let x = a[y + 1]
        if (x < 0 || f > x + u - d) continue
        let E = a[y] + u - d
        p >= E
          ? (a[y + 1] = f <= E ? -2 : -1)
          : f >= u && b && ((a[y] += b), (a[y + 1] += b))
      }
      d += b
    }),
      (u = n.maps[c].map(u, -1))
  }
  let l = !1
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        ;(l = !0), (a[c + 1] = -1)
        continue
      }
      let u = n.map(e[c] + i),
        d = u - o
      if (d < 0 || d >= r.content.size) {
        l = !0
        continue
      }
      let f = n.map(e[c + 1] + i, -1),
        p = f - o,
        { index: g, offset: v } = r.content.findIndex(d),
        b = r.maybeChild(g)
      if (b && v == d && v + b.nodeSize == p) {
        let y = a[c + 2].mapInner(n, b, u + 1, e[c] + i + 1, s)
        y != Qt
          ? ((a[c] = d), (a[c + 1] = p), (a[c + 2] = y))
          : ((a[c + 1] = -2), (l = !0))
      } else l = !0
    }
  if (l) {
    let c = Pz(a, e, t, n, o, i, s),
      u = cp(c, r, 0, s)
    t = u.local
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), (d -= 3))
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let p = u.children[d]
      for (; f < a.length && a[f] < p; ) f += 3
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2])
    }
  }
  return new mt(t.sort(as), a)
}
function YO(e, t) {
  if (!t || !e.length) return e
  let n = []
  for (let r = 0; r < e.length; r++) {
    let o = e[r]
    n.push(new pn(o.from + t, o.to + t, o.type))
  }
  return n
}
function Pz(e, t, n, r, o, i, s) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(r, o, c)
      d ? n.push(d) : s.onRemove && s.onRemove(l.local[u].spec)
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1)
  }
  for (let l = 0; l < e.length; l += 3)
    e[l + 1] == -1 && a(e[l + 2], t[l] + i + 1)
  return n
}
function XO(e, t, n) {
  if (t.isLeaf) return null
  let r = n + t.nodeSize,
    o = null
  for (let i = 0, s; i < e.length; i++)
    (s = e[i]) &&
      s.from > n &&
      s.to < r &&
      ((o || (o = [])).push(s), (e[i] = null))
  return o
}
function QO(e) {
  let t = []
  for (let n = 0; n < e.length; n++) e[n] != null && t.push(e[n])
  return t
}
function cp(e, t, n, r) {
  let o = [],
    i = !1
  t.forEach((a, l) => {
    let c = XO(e, a, l + n)
    if (c) {
      i = !0
      let u = cp(c, a, n + l + 1, r)
      u != Qt && o.push(l, l + a.nodeSize, u)
    }
  })
  let s = YO(i ? QO(e) : e, -n).sort(as)
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(t, s[a]) ||
      (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1))
  return s.length || o.length ? new mt(s, o) : Qt
}
function as(e, t) {
  return e.from - t.from || e.to - t.to
}
function r1(e) {
  let t = e
  for (let n = 0; n < t.length - 1; n++) {
    let r = t[n]
    if (r.from != r.to)
      for (let o = n + 1; o < t.length; o++) {
        let i = t[o]
        if (i.from == r.from) {
          i.to != r.to &&
            (t == e && (t = e.slice()),
            (t[o] = i.copy(i.from, r.to)),
            pC(t, o + 1, i.copy(r.to, i.to)))
          continue
        } else {
          i.from < r.to &&
            (t == e && (t = e.slice()),
            (t[n] = r.copy(r.from, i.from)),
            pC(t, o, r.copy(i.from, r.to)))
          break
        }
      }
  }
  return t
}
function pC(e, t, n) {
  for (; t < e.length && as(n, e[t]) > 0; ) t++
  e.splice(t, 0, n)
}
function Tg(e) {
  let t = []
  return (
    e.someProp("decorations", (n) => {
      let r = n(e.state)
      r && r != Qt && t.push(r)
    }),
    e.cursorWrapper && t.push(mt.create(e.state.doc, [e.cursorWrapper.deco])),
    Zo.from(t)
  )
}
const $z = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0,
  },
  Bz = Tn && gi <= 11
class jz {
  constructor() {
    ;(this.anchorNode = null),
      (this.anchorOffset = 0),
      (this.focusNode = null),
      (this.focusOffset = 0)
  }
  set(t) {
    ;(this.anchorNode = t.anchorNode),
      (this.anchorOffset = t.anchorOffset),
      (this.focusNode = t.focusNode),
      (this.focusOffset = t.focusOffset)
  }
  clear() {
    this.anchorNode = this.focusNode = null
  }
  eq(t) {
    return (
      t.anchorNode == this.anchorNode &&
      t.anchorOffset == this.anchorOffset &&
      t.focusNode == this.focusNode &&
      t.focusOffset == this.focusOffset
    )
  }
}
class Fz {
  constructor(t, n) {
    ;(this.view = t),
      (this.handleDOMChange = n),
      (this.queue = []),
      (this.flushingSoon = -1),
      (this.observer = null),
      (this.currentSelection = new jz()),
      (this.onCharData = null),
      (this.suppressingSelectionUpdates = !1),
      (this.lastChangedTextNode = null),
      (this.observer =
        window.MutationObserver &&
        new window.MutationObserver((r) => {
          for (let o = 0; o < r.length; o++) this.queue.push(r[o])
          Tn &&
          gi <= 11 &&
          r.some(
            (o) =>
              (o.type == "childList" && o.removedNodes.length) ||
              (o.type == "characterData" &&
                o.oldValue.length > o.target.nodeValue.length)
          )
            ? this.flushSoon()
            : this.flush()
        })),
      Bz &&
        (this.onCharData = (r) => {
          this.queue.push({
            target: r.target,
            type: "characterData",
            oldValue: r.prevValue,
          }),
            this.flushSoon()
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this))
  }
  flushSoon() {
    this.flushingSoon < 0 &&
      (this.flushingSoon = window.setTimeout(() => {
        ;(this.flushingSoon = -1), this.flush()
      }, 20))
  }
  forceFlush() {
    this.flushingSoon > -1 &&
      (window.clearTimeout(this.flushingSoon),
      (this.flushingSoon = -1),
      this.flush())
  }
  start() {
    this.observer &&
      (this.observer.takeRecords(), this.observer.observe(this.view.dom, $z)),
      this.onCharData &&
        this.view.dom.addEventListener(
          "DOMCharacterDataModified",
          this.onCharData
        ),
      this.connectSelection()
  }
  stop() {
    if (this.observer) {
      let t = this.observer.takeRecords()
      if (t.length) {
        for (let n = 0; n < t.length; n++) this.queue.push(t[n])
        window.setTimeout(() => this.flush(), 20)
      }
      this.observer.disconnect()
    }
    this.onCharData &&
      this.view.dom.removeEventListener(
        "DOMCharacterDataModified",
        this.onCharData
      ),
      this.disconnectSelection()
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener(
      "selectionchange",
      this.onSelectionChange
    )
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener(
      "selectionchange",
      this.onSelectionChange
    )
  }
  suppressSelectionUpdates() {
    ;(this.suppressingSelectionUpdates = !0),
      setTimeout(() => (this.suppressingSelectionUpdates = !1), 50)
  }
  onSelectionChange() {
    if (iC(this.view)) {
      if (this.suppressingSelectionUpdates) return _o(this.view)
      if (Tn && gi <= 11 && !this.view.state.selection.empty) {
        let t = this.view.domSelectionRange()
        if (
          t.focusNode &&
          ks(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
        )
          return this.flushSoon()
      }
      this.flush()
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange())
  }
  ignoreSelectionChange(t) {
    if (!t.focusNode) return !0
    let n = new Set(),
      r
    for (let i = t.focusNode; i; i = Xa(i)) n.add(i)
    for (let i = t.anchorNode; i; i = Xa(i))
      if (n.has(i)) {
        r = i
        break
      }
    let o = r && this.view.docView.nearestDesc(r)
    if (
      o &&
      o.ignoreMutation({
        type: "selection",
        target: r.nodeType == 3 ? r.parentNode : r,
      })
    )
      return this.setCurSelection(), !0
  }
  pendingRecords() {
    if (this.observer)
      for (let t of this.observer.takeRecords()) this.queue.push(t)
    return this.queue
  }
  flush() {
    let { view: t } = this
    if (!t.docView || this.flushingSoon > -1) return
    let n = this.pendingRecords()
    n.length && (this.queue = [])
    let r = t.domSelectionRange(),
      o =
        !this.suppressingSelectionUpdates &&
        !this.currentSelection.eq(r) &&
        iC(t) &&
        !this.ignoreSelectionChange(r),
      i = -1,
      s = -1,
      a = !1,
      l = []
    if (t.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l)
        d &&
          ((i = i < 0 ? d.from : Math.min(d.from, i)),
          (s = s < 0 ? d.to : Math.max(d.to, s)),
          d.typeOver && (a = !0))
      }
    if (Ar && l.length) {
      let u = l.filter((d) => d.nodeName == "BR")
      if (u.length == 2) {
        let [d, f] = u
        d.parentNode && d.parentNode.parentNode == f.parentNode
          ? f.remove()
          : d.remove()
      } else {
        let { focusNode: d } = this.currentSelection
        for (let f of u) {
          let p = f.parentNode
          p && p.nodeName == "LI" && (!d || Vz(t, d) != p) && f.remove()
        }
      }
    }
    let c = null
    i < 0 &&
    o &&
    t.input.lastFocus > Date.now() - 200 &&
    Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 &&
    nm(r) &&
    (c = Yb(t)) &&
    c.eq(Ne.near(t.state.doc.resolve(0), 1))
      ? ((t.input.lastFocus = 0),
        _o(t),
        this.currentSelection.set(r),
        t.scrollToSelection())
      : (i > -1 || o) &&
        (i > -1 && (t.docView.markDirty(i, s), zz(t)),
        this.handleDOMChange(i, s, a, l),
        t.docView && t.docView.dirty
          ? t.updateState(t.state)
          : this.currentSelection.eq(r) || _o(t),
        this.currentSelection.set(r))
  }
  registerMutation(t, n) {
    if (n.indexOf(t.target) > -1) return null
    let r = this.view.docView.nearestDesc(t.target)
    if (
      (t.type == "attributes" &&
        (r == this.view.docView ||
          t.attributeName == "contenteditable" ||
          (t.attributeName == "style" &&
            !t.oldValue &&
            !t.target.getAttribute("style")))) ||
      !r ||
      r.ignoreMutation(t)
    )
      return null
    if (t.type == "childList") {
      for (let u = 0; u < t.addedNodes.length; u++) {
        let d = t.addedNodes[u]
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d)
      }
      if (
        r.contentDOM &&
        r.contentDOM != r.dom &&
        !r.contentDOM.contains(t.target)
      )
        return { from: r.posBefore, to: r.posAfter }
      let o = t.previousSibling,
        i = t.nextSibling
      if (Tn && gi <= 11 && t.addedNodes.length)
        for (let u = 0; u < t.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = t.addedNodes[u]
          ;(!d || Array.prototype.indexOf.call(t.addedNodes, d) < 0) && (o = d),
            (!f || Array.prototype.indexOf.call(t.addedNodes, f) < 0) && (i = f)
        }
      let s = o && o.parentNode == t.target ? Kt(o) + 1 : 0,
        a = r.localPosFromDOM(t.target, s, -1),
        l = i && i.parentNode == t.target ? Kt(i) : t.target.childNodes.length,
        c = r.localPosFromDOM(t.target, l, 1)
      return { from: a, to: c }
    } else
      return t.type == "attributes"
        ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
        : ((this.lastChangedTextNode = t.target),
          {
            from: r.posAtStart,
            to: r.posAtEnd,
            typeOver: t.target.nodeValue == t.oldValue,
          })
  }
}
let hC = new WeakMap(),
  mC = !1
function zz(e) {
  if (
    !hC.has(e) &&
    (hC.set(e, null),
    ["normal", "nowrap", "pre-line"].indexOf(
      getComputedStyle(e.dom).whiteSpace
    ) !== -1)
  ) {
    if (((e.requiresGeckoHackNode = Ar), mC)) return
    console.warn(
      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
    ),
      (mC = !0)
  }
}
function gC(e, t) {
  let n = t.startContainer,
    r = t.startOffset,
    o = t.endContainer,
    i = t.endOffset,
    s = e.domAtPos(e.state.selection.anchor)
  return (
    ks(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]),
    { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i }
  )
}
function Uz(e, t) {
  if (t.getComposedRanges) {
    let o = t.getComposedRanges(e.root)[0]
    if (o) return gC(e, o)
  }
  let n
  function r(o) {
    o.preventDefault(),
      o.stopImmediatePropagation(),
      (n = o.getTargetRanges()[0])
  }
  return (
    e.dom.addEventListener("beforeinput", r, !0),
    document.execCommand("indent"),
    e.dom.removeEventListener("beforeinput", r, !0),
    n ? gC(e, n) : null
  )
}
function Vz(e, t) {
  for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
    let r = e.docView.nearestDesc(n, !0)
    if (r && r.node.isBlock) return n
  }
  return null
}
function Hz(e, t, n) {
  let {
      node: r,
      fromOffset: o,
      toOffset: i,
      from: s,
      to: a,
    } = e.docView.parseRange(t, n),
    l = e.domSelectionRange(),
    c,
    u = l.anchorNode
  if (
    (u &&
      e.dom.contains(u.nodeType == 1 ? u : u.parentNode) &&
      ((c = [{ node: u, offset: l.anchorOffset }]),
      nm(l) || c.push({ node: l.focusNode, offset: l.focusOffset })),
    tn && e.input.lastKeyCode === 8)
  )
    for (let b = i; b > o; b--) {
      let y = r.childNodes[b - 1],
        x = y.pmViewDesc
      if (y.nodeName == "BR" && !x) {
        i = b
        break
      }
      if (!x || x.size) break
    }
  let d = e.state.doc,
    f = e.someProp("domParser") || mi.fromSchema(e.state.schema),
    p = d.resolve(s),
    g = null,
    v = f.parse(r, {
      topNode: p.parent,
      topMatch: p.parent.contentMatchAt(p.index()),
      topOpen: !0,
      from: o,
      to: i,
      preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: c,
      ruleFromNode: Wz,
      context: p,
    })
  if (c && c[0].pos != null) {
    let b = c[0].pos,
      y = c[1] && c[1].pos
    y == null && (y = b), (g = { anchor: b + s, head: y + s })
  }
  return { doc: v, sel: g, from: s, to: a }
}
function Wz(e) {
  let t = e.pmViewDesc
  if (t) return t.parseRule()
  if (e.nodeName == "BR" && e.parentNode) {
    if (gn && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
      let n = document.createElement("div")
      return n.appendChild(document.createElement("li")), { skip: n }
    } else if (
      e.parentNode.lastChild == e ||
      (gn && /^(tr|table)$/i.test(e.parentNode.nodeName))
    )
      return { ignore: !0 }
  } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
    return { ignore: !0 }
  return null
}
const Kz =
  /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i
function Gz(e, t, n, r, o) {
  let i =
    e.input.compositionPendingChanges ||
    (e.composing ? e.input.compositionID : 0)
  if (((e.input.compositionPendingChanges = 0), t < 0)) {
    let R =
        e.input.lastSelectionTime > Date.now() - 50
          ? e.input.lastSelectionOrigin
          : null,
      B = Yb(e, R)
    if (B && !e.state.selection.eq(B)) {
      if (
        tn &&
        xo &&
        e.input.lastKeyCode === 13 &&
        Date.now() - 100 < e.input.lastKeyCodeTime &&
        e.someProp("handleKeyDown", (j) => j(e, Hi(13, "Enter")))
      )
        return
      let V = e.state.tr.setSelection(B)
      R == "pointer"
        ? V.setMeta("pointer", !0)
        : R == "key" && V.scrollIntoView(),
        i && V.setMeta("composition", i),
        e.dispatch(V)
    }
    return
  }
  let s = e.state.doc.resolve(t),
    a = s.sharedDepth(n)
  ;(t = s.before(a + 1)), (n = e.state.doc.resolve(n).after(a + 1))
  let l = e.state.selection,
    c = Hz(e, t, n),
    u = e.state.doc,
    d = u.slice(c.from, c.to),
    f,
    p
  e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime
    ? ((f = e.state.selection.to), (p = "end"))
    : ((f = e.state.selection.from), (p = "start")),
    (e.input.lastKeyCode = null)
  let g = Yz(d.content, c.doc.content, c.from, f, p)
  if (
    (g && e.input.domChangeCount++,
    ((Qa && e.input.lastIOSEnter > Date.now() - 225) || xo) &&
      o.some((R) => R.nodeType == 1 && !Kz.test(R.nodeName)) &&
      (!g || g.endA >= g.endB) &&
      e.someProp("handleKeyDown", (R) => R(e, Hi(13, "Enter"))))
  ) {
    e.input.lastIOSEnter = 0
    return
  }
  if (!g)
    if (
      r &&
      l instanceof _e &&
      !l.empty &&
      l.$head.sameParent(l.$anchor) &&
      !e.composing &&
      !(c.sel && c.sel.anchor != c.sel.head)
    )
      g = { start: l.from, endA: l.to, endB: l.to }
    else {
      if (c.sel) {
        let R = vC(e, e.state.doc, c.sel)
        if (R && !R.eq(e.state.selection)) {
          let B = e.state.tr.setSelection(R)
          i && B.setMeta("composition", i), e.dispatch(B)
        }
      }
      return
    }
  e.state.selection.from < e.state.selection.to &&
    g.start == g.endB &&
    e.state.selection instanceof _e &&
    (g.start > e.state.selection.from &&
    g.start <= e.state.selection.from + 2 &&
    e.state.selection.from >= c.from
      ? (g.start = e.state.selection.from)
      : g.endA < e.state.selection.to &&
        g.endA >= e.state.selection.to - 2 &&
        e.state.selection.to <= c.to &&
        ((g.endB += e.state.selection.to - g.endA),
        (g.endA = e.state.selection.to))),
    Tn &&
      gi <= 11 &&
      g.endB == g.start + 1 &&
      g.endA == g.start &&
      g.start > c.from &&
      c.doc.textBetween(g.start - c.from - 1, g.start - c.from + 1) == " " &&
      (g.start--, g.endA--, g.endB--)
  let v = c.doc.resolveNoCache(g.start - c.from),
    b = c.doc.resolveNoCache(g.endB - c.from),
    y = u.resolve(g.start),
    x = v.sameParent(b) && v.parent.inlineContent && y.end() >= g.endA,
    E
  if (
    ((Qa &&
      e.input.lastIOSEnter > Date.now() - 225 &&
      (!x || o.some((R) => R.nodeName == "DIV" || R.nodeName == "P"))) ||
      (!x &&
        v.pos < c.doc.content.size &&
        !v.sameParent(b) &&
        (E = Ne.findFrom(c.doc.resolve(v.pos + 1), 1, !0)) &&
        E.head == b.pos)) &&
    e.someProp("handleKeyDown", (R) => R(e, Hi(13, "Enter")))
  ) {
    e.input.lastIOSEnter = 0
    return
  }
  if (
    e.state.selection.anchor > g.start &&
    Zz(u, g.start, g.endA, v, b) &&
    e.someProp("handleKeyDown", (R) => R(e, Hi(8, "Backspace")))
  ) {
    xo && tn && e.domObserver.suppressSelectionUpdates()
    return
  }
  tn && g.endB == g.start && (e.input.lastChromeDelete = Date.now()),
    xo &&
      !x &&
      v.start() != b.start() &&
      b.parentOffset == 0 &&
      v.depth == b.depth &&
      c.sel &&
      c.sel.anchor == c.sel.head &&
      c.sel.head == g.endA &&
      ((g.endB -= 2),
      (b = c.doc.resolveNoCache(g.endB - c.from)),
      setTimeout(() => {
        e.someProp("handleKeyDown", function (R) {
          return R(e, Hi(13, "Enter"))
        })
      }, 20))
  let w = g.start,
    C = g.endA,
    S,
    M,
    N
  if (x) {
    if (v.pos == b.pos)
      Tn &&
        gi <= 11 &&
        v.parentOffset == 0 &&
        (e.domObserver.suppressSelectionUpdates(), setTimeout(() => _o(e), 20)),
        (S = e.state.tr.delete(w, C)),
        (M = u.resolve(g.start).marksAcross(u.resolve(g.endA)))
    else if (
      g.endA == g.endB &&
      (N = qz(
        v.parent.content.cut(v.parentOffset, b.parentOffset),
        y.parent.content.cut(y.parentOffset, g.endA - y.start())
      ))
    )
      (S = e.state.tr),
        N.type == "add" ? S.addMark(w, C, N.mark) : S.removeMark(w, C, N.mark)
    else if (
      v.parent.child(v.index()).isText &&
      v.index() == b.index() - (b.textOffset ? 0 : 1)
    ) {
      let R = v.parent.textBetween(v.parentOffset, b.parentOffset)
      if (e.someProp("handleTextInput", (B) => B(e, w, C, R))) return
      S = e.state.tr.insertText(R, w, C)
    }
  }
  if (
    (S ||
      (S = e.state.tr.replace(
        w,
        C,
        c.doc.slice(g.start - c.from, g.endB - c.from)
      )),
    c.sel)
  ) {
    let R = vC(e, S.doc, c.sel)
    R &&
      !(
        (tn &&
          e.composing &&
          R.empty &&
          (g.start != g.endB || e.input.lastChromeDelete < Date.now() - 100) &&
          (R.head == w || R.head == S.mapping.map(C) - 1)) ||
        (Tn && R.empty && R.head == w)
      ) &&
      S.setSelection(R)
  }
  M && S.ensureMarks(M),
    i && S.setMeta("composition", i),
    e.dispatch(S.scrollIntoView())
}
function vC(e, t, n) {
  return Math.max(n.anchor, n.head) > t.content.size
    ? null
    : Xb(e, t.resolve(n.anchor), t.resolve(n.head))
}
function qz(e, t) {
  let n = e.firstChild.marks,
    r = t.firstChild.marks,
    o = n,
    i = r,
    s,
    a,
    l
  for (let u = 0; u < r.length; u++) o = r[u].removeFromSet(o)
  for (let u = 0; u < n.length; u++) i = n[u].removeFromSet(i)
  if (o.length == 1 && i.length == 0)
    (a = o[0]), (s = "add"), (l = (u) => u.mark(a.addToSet(u.marks)))
  else if (o.length == 0 && i.length == 1)
    (a = i[0]), (s = "remove"), (l = (u) => u.mark(a.removeFromSet(u.marks)))
  else return null
  let c = []
  for (let u = 0; u < t.childCount; u++) c.push(l(t.child(u)))
  if (Z.from(c).eq(e)) return { mark: a, type: s }
}
function Zz(e, t, n, r, o) {
  if (n - t <= o.pos - r.pos || Mg(r, !0, !1) < o.pos) return !1
  let i = e.resolve(t)
  if (!r.parent.isTextblock) {
    let a = i.nodeAfter
    return a != null && n == t + a.nodeSize
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock) return !1
  let s = e.resolve(Mg(i, !0, !0))
  return !s.parent.isTextblock || s.pos > n || Mg(s, !0, !1) < n
    ? !1
    : r.parent.content.cut(r.parentOffset).eq(s.parent.content)
}
function Mg(e, t, n) {
  let r = e.depth,
    o = t ? e.end() : e.pos
  for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
    r--, o++, (t = !1)
  if (n) {
    let i = e.node(r).maybeChild(e.indexAfter(r))
    for (; i && !i.isLeaf; ) (i = i.firstChild), o++
  }
  return o
}
function Yz(e, t, n, r, o) {
  let i = e.findDiffStart(t, n)
  if (i == null) return null
  let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size)
  if (o == "end") {
    let l = Math.max(0, i - Math.min(s, a))
    r -= s + l - i
  }
  if (s < i && e.size < t.size) {
    let l = r <= i && r >= s ? i - r : 0
    ;(i -= l),
      i && i < t.size && yC(t.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1),
      (a = i + (a - s)),
      (s = i)
  } else if (a < i) {
    let l = r <= i && r >= a ? i - r : 0
    ;(i -= l),
      i && i < e.size && yC(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1),
      (s = i + (s - a)),
      (a = i)
  }
  return { start: i, endA: s, endB: a }
}
function yC(e) {
  if (e.length != 2) return !1
  let t = e.charCodeAt(0),
    n = e.charCodeAt(1)
  return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319
}
class Xz {
  constructor(t, n) {
    ;(this._root = null),
      (this.focused = !1),
      (this.trackWrites = null),
      (this.mounted = !1),
      (this.markCursor = null),
      (this.cursorWrapper = null),
      (this.lastSelectedViewDesc = void 0),
      (this.input = new gz()),
      (this.prevDirectPlugins = []),
      (this.pluginViews = []),
      (this.requiresGeckoHackNode = !1),
      (this.dragging = null),
      (this._props = n),
      (this.state = n.state),
      (this.directPlugins = n.plugins || []),
      this.directPlugins.forEach(CC),
      (this.dispatch = this.dispatch.bind(this)),
      (this.dom = (t && t.mount) || document.createElement("div")),
      t &&
        (t.appendChild
          ? t.appendChild(this.dom)
          : typeof t == "function"
            ? t(this.dom)
            : t.mount && (this.mounted = !0)),
      (this.editable = wC(this)),
      xC(this),
      (this.nodeViews = EC(this)),
      (this.docView = JE(this.state.doc, bC(this), Tg(this), this.dom, this)),
      (this.domObserver = new Fz(this, (r, o, i, s) => Gz(this, r, o, i, s))),
      this.domObserver.start(),
      vz(this),
      this.updatePluginViews()
  }
  get composing() {
    return this.input.composing
  }
  get props() {
    if (this._props.state != this.state) {
      let t = this._props
      this._props = {}
      for (let n in t) this._props[n] = t[n]
      this._props.state = this.state
    }
    return this._props
  }
  update(t) {
    t.handleDOMEvents != this._props.handleDOMEvents && Iy(this)
    let n = this._props
    ;(this._props = t),
      t.plugins && (t.plugins.forEach(CC), (this.directPlugins = t.plugins)),
      this.updateStateInner(t.state, n)
  }
  setProps(t) {
    let n = {}
    for (let r in this._props) n[r] = this._props[r]
    n.state = this.state
    for (let r in t) n[r] = t[r]
    this.update(n)
  }
  updateState(t) {
    this.updateStateInner(t, this._props)
  }
  updateStateInner(t, n) {
    var r
    let o = this.state,
      i = !1,
      s = !1
    t.storedMarks && this.composing && (KO(this), (s = !0)), (this.state = t)
    let a = o.plugins != t.plugins || this._props.plugins != n.plugins
    if (
      a ||
      this._props.plugins != n.plugins ||
      this._props.nodeViews != n.nodeViews
    ) {
      let p = EC(this)
      Jz(p, this.nodeViews) && ((this.nodeViews = p), (i = !0))
    }
    ;(a || n.handleDOMEvents != this._props.handleDOMEvents) && Iy(this),
      (this.editable = wC(this)),
      xC(this)
    let l = Tg(this),
      c = bC(this),
      u =
        o.plugins != t.plugins && !o.doc.eq(t.doc)
          ? "reset"
          : t.scrollToSelection > o.scrollToSelection
            ? "to selection"
            : "preserve",
      d = i || !this.docView.matchesNode(t.doc, c, l)
    ;(d || !t.selection.eq(o.selection)) && (s = !0)
    let f =
      u == "preserve" && s && this.dom.style.overflowAnchor == null && AF(this)
    if (s) {
      this.domObserver.stop()
      let p =
        d &&
        (Tn || tn) &&
        !this.composing &&
        !o.selection.empty &&
        !t.selection.empty &&
        Qz(o.selection, t.selection)
      if (d) {
        let g = tn
          ? (this.trackWrites = this.domSelectionRange().focusNode)
          : null
        this.composing && (this.input.compositionNode = Oz(this)),
          (i || !this.docView.update(t.doc, c, l, this)) &&
            (this.docView.updateOuterDeco(c),
            this.docView.destroy(),
            (this.docView = JE(t.doc, c, l, this.dom, this))),
          g && !this.trackWrites && (p = !0)
      }
      p ||
      !(
        this.input.mouseDown &&
        this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
        tz(this)
      )
        ? _o(this, p)
        : (DO(this, t.selection), this.domObserver.setCurSelection()),
        this.domObserver.start()
    }
    this.updatePluginViews(o),
      !((r = this.dragging) === null || r === void 0) &&
        r.node &&
        !o.doc.eq(t.doc) &&
        this.updateDraggedNode(this.dragging, o),
      u == "reset"
        ? (this.dom.scrollTop = 0)
        : u == "to selection"
          ? this.scrollToSelection()
          : f && RF(f)
  }
  scrollToSelection() {
    let t = this.domSelectionRange().focusNode
    if (!(!t || !this.dom.contains(t.nodeType == 1 ? t : t.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this)))
        if (this.state.selection instanceof ye) {
          let n = this.docView.domAfterPos(this.state.selection.from)
          n.nodeType == 1 && GE(this, n.getBoundingClientRect(), t)
        } else GE(this, this.coordsAtPos(this.state.selection.head, 1), t)
    }
  }
  destroyPluginViews() {
    let t
    for (; (t = this.pluginViews.pop()); ) t.destroy && t.destroy()
  }
  updatePluginViews(t) {
    if (
      !t ||
      t.plugins != this.state.plugins ||
      this.directPlugins != this.prevDirectPlugins
    ) {
      ;(this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews()
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n]
        r.update && r.update(this, t)
      }
  }
  updateDraggedNode(t, n) {
    let r = t.node,
      o = -1
    if (this.state.doc.nodeAt(r.from) == r.node) o = r.from
    else {
      let i = r.from + (this.state.doc.content.size - n.doc.content.size)
      ;(i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i)
    }
    this.dragging = new qO(
      t.slice,
      t.move,
      o < 0 ? void 0 : ye.create(this.state.doc, o)
    )
  }
  someProp(t, n) {
    let r = this._props && this._props[t],
      o
    if (r != null && (o = n ? n(r) : r)) return o
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[t]
      if (a != null && (o = n ? n(a) : a)) return o
    }
    let i = this.state.plugins
    if (i)
      for (let s = 0; s < i.length; s++) {
        let a = i[s].props[t]
        if (a != null && (o = n ? n(a) : a)) return o
      }
  }
  hasFocus() {
    if (Tn) {
      let t = this.root.activeElement
      if (t == this.dom) return !0
      if (!t || !this.dom.contains(t)) return !1
      for (; t && this.dom != t && this.dom.contains(t); ) {
        if (t.contentEditable == "false") return !1
        t = t.parentElement
      }
      return !0
    }
    return this.root.activeElement == this.dom
  }
  focus() {
    this.domObserver.stop(),
      this.editable && IF(this.dom),
      _o(this),
      this.domObserver.start()
  }
  get root() {
    let t = this._root
    if (t == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
          return (
            n.getSelection ||
              (Object.getPrototypeOf(n).getSelection = () =>
                n.ownerDocument.getSelection()),
            (this._root = n)
          )
    }
    return t || document
  }
  updateRoot() {
    this._root = null
  }
  posAtCoords(t) {
    return BF(this, t)
  }
  coordsAtPos(t, n = 1) {
    return kO(this, t, n)
  }
  domAtPos(t, n = 0) {
    return this.docView.domFromPos(t, n)
  }
  nodeDOM(t) {
    let n = this.docView.descAt(t)
    return n ? n.nodeDOM : null
  }
  posAtDOM(t, n, r = -1) {
    let o = this.docView.posFromDOM(t, n, r)
    if (o == null) throw new RangeError("DOM position not inside the editor")
    return o
  }
  endOfTextblock(t, n) {
    return VF(this, n || this.state, t)
  }
  pasteHTML(t, n) {
    return su(this, "", t, !1, n || new ClipboardEvent("paste"))
  }
  pasteText(t, n) {
    return su(this, t, null, !0, n || new ClipboardEvent("paste"))
  }
  serializeForClipboard(t) {
    return Qb(this, t)
  }
  destroy() {
    this.docView &&
      (yz(this),
      this.destroyPluginViews(),
      this.mounted
        ? (this.docView.update(this.state.doc, [], Tg(this), this),
          (this.dom.textContent = ""))
        : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
      this.docView.destroy(),
      (this.docView = null),
      xF())
  }
  get isDestroyed() {
    return this.docView == null
  }
  dispatchEvent(t) {
    return xz(this, t)
  }
  dispatch(t) {
    let n = this._props.dispatchTransaction
    n ? n.call(this, t) : this.updateState(this.state.apply(t))
  }
  domSelectionRange() {
    let t = this.domSelection()
    return t
      ? (gn &&
          this.root.nodeType === 11 &&
          _F(this.dom.ownerDocument) == this.dom &&
          Uz(this, t)) ||
          t
      : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 }
  }
  domSelection() {
    return this.root.getSelection()
  }
}
function bC(e) {
  let t = Object.create(null)
  return (
    (t.class = "ProseMirror"),
    (t.contenteditable = String(e.editable)),
    e.someProp("attributes", (n) => {
      if ((typeof n == "function" && (n = n(e.state)), n))
        for (let r in n)
          r == "class"
            ? (t.class += " " + n[r])
            : r == "style"
              ? (t.style = (t.style ? t.style + ";" : "") + n[r])
              : !t[r] &&
                r != "contenteditable" &&
                r != "nodeName" &&
                (t[r] = String(n[r]))
    }),
    t.translate || (t.translate = "no"),
    [pn.node(0, e.state.doc.content.size, t)]
  )
}
function xC(e) {
  if (e.markCursor) {
    let t = document.createElement("img")
    ;(t.className = "ProseMirror-separator"),
      t.setAttribute("mark-placeholder", "true"),
      t.setAttribute("alt", ""),
      (e.cursorWrapper = {
        dom: t,
        deco: pn.widget(e.state.selection.from, t, {
          raw: !0,
          marks: e.markCursor,
        }),
      })
  } else e.cursorWrapper = null
}
function wC(e) {
  return !e.someProp("editable", (t) => t(e.state) === !1)
}
function Qz(e, t) {
  let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head))
  return e.$anchor.start(n) != t.$anchor.start(n)
}
function EC(e) {
  let t = Object.create(null)
  function n(r) {
    for (let o in r) Object.prototype.hasOwnProperty.call(t, o) || (t[o] = r[o])
  }
  return e.someProp("nodeViews", n), e.someProp("markViews", n), t
}
function Jz(e, t) {
  let n = 0,
    r = 0
  for (let o in e) {
    if (e[o] != t[o]) return !0
    n++
  }
  for (let o in t) r++
  return n != r
}
function CC(e) {
  if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
    throw new RangeError(
      "Plugins passed directly to the view must not have a state component"
    )
}
var Mi = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
  },
  up = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
  },
  eU = typeof navigator < "u" && /Mac/.test(navigator.platform),
  tU =
    typeof navigator < "u" &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
for (var Gt = 0; Gt < 10; Gt++) Mi[48 + Gt] = Mi[96 + Gt] = String(Gt)
for (var Gt = 1; Gt <= 24; Gt++) Mi[Gt + 111] = "F" + Gt
for (var Gt = 65; Gt <= 90; Gt++)
  (Mi[Gt] = String.fromCharCode(Gt + 32)), (up[Gt] = String.fromCharCode(Gt))
for (var Og in Mi) up.hasOwnProperty(Og) || (up[Og] = Mi[Og])
function nU(e) {
  var t =
      (eU && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey) ||
      (tU && e.shiftKey && e.key && e.key.length == 1) ||
      e.key == "Unidentified",
    n =
      (!t && e.key) ||
      (e.shiftKey ? up : Mi)[e.keyCode] ||
      e.key ||
      "Unidentified"
  return (
    n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
  )
}
const rU =
  typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1
function oU(e) {
  let t = e.split(/-(?!$)/),
    n = t[t.length - 1]
  n == "Space" && (n = " ")
  let r, o, i, s
  for (let a = 0; a < t.length - 1; a++) {
    let l = t[a]
    if (/^(cmd|meta|m)$/i.test(l)) s = !0
    else if (/^a(lt)?$/i.test(l)) r = !0
    else if (/^(c|ctrl|control)$/i.test(l)) o = !0
    else if (/^s(hift)?$/i.test(l)) i = !0
    else if (/^mod$/i.test(l)) rU ? (s = !0) : (o = !0)
    else throw new Error("Unrecognized modifier name: " + l)
  }
  return (
    r && (n = "Alt-" + n),
    o && (n = "Ctrl-" + n),
    s && (n = "Meta-" + n),
    i && (n = "Shift-" + n),
    n
  )
}
function iU(e) {
  let t = Object.create(null)
  for (let n in e) t[oU(n)] = e[n]
  return t
}
function Ag(e, t, n = !0) {
  return (
    t.altKey && (e = "Alt-" + e),
    t.ctrlKey && (e = "Ctrl-" + e),
    t.metaKey && (e = "Meta-" + e),
    n && t.shiftKey && (e = "Shift-" + e),
    e
  )
}
function sU(e) {
  return new rt({ props: { handleKeyDown: JO(e) } })
}
function JO(e) {
  let t = iU(e)
  return function (n, r) {
    let o = nU(r),
      i,
      s = t[Ag(o, r)]
    if (s && s(n.state, n.dispatch, n)) return !0
    if (o.length == 1 && o != " ") {
      if (r.shiftKey) {
        let a = t[Ag(o, r, !1)]
        if (a && a(n.state, n.dispatch, n)) return !0
      }
      if (
        (r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) &&
        (i = Mi[r.keyCode]) &&
        i != o
      ) {
        let a = t[Ag(i, r)]
        if (a && a(n.state, n.dispatch, n)) return !0
      }
    }
    return !1
  }
}
const aU = (e, t) =>
  e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0)
function eA(e, t) {
  let { $cursor: n } = e.selection
  return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0)
    ? null
    : n
}
const lU = (e, t, n) => {
    let r = eA(e, n)
    if (!r) return !1
    let o = o1(r)
    if (!o) {
      let s = r.blockRange(),
        a = s && wl(s)
      return a == null ? !1 : (t && t(e.tr.lift(s, a).scrollIntoView()), !0)
    }
    let i = o.nodeBefore
    if (oA(e, o, t, -1)) return !0
    if (r.parent.content.size == 0 && (Ja(i, "end") || ye.isSelectable(i)))
      for (let s = r.depth; ; s--) {
        let a = em(e.doc, r.before(s), r.after(s), oe.empty)
        if (a && a.slice.size < a.to - a.from) {
          if (t) {
            let l = e.tr.step(a)
            l.setSelection(
              Ja(i, "end")
                ? Ne.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1)
                : ye.create(l.doc, o.pos - i.nodeSize)
            ),
              t(l.scrollIntoView())
          }
          return !0
        }
        if (s == 1 || r.node(s - 1).childCount > 1) break
      }
    return i.isAtom && o.depth == r.depth - 1
      ? (t && t(e.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0)
      : !1
  },
  cU = (e, t, n) => {
    let r = eA(e, n)
    if (!r) return !1
    let o = o1(r)
    return o ? tA(e, o, t) : !1
  },
  uU = (e, t, n) => {
    let r = nA(e, n)
    if (!r) return !1
    let o = i1(r)
    return o ? tA(e, o, t) : !1
  }
function tA(e, t, n) {
  let r = t.nodeBefore,
    o = r,
    i = t.pos - 1
  for (; !o.isTextblock; i--) {
    if (o.type.spec.isolating) return !1
    let u = o.lastChild
    if (!u) return !1
    o = u
  }
  let s = t.nodeAfter,
    a = s,
    l = t.pos + 1
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating) return !1
    let u = a.firstChild
    if (!u) return !1
    a = u
  }
  let c = em(e.doc, i, l, oe.empty)
  if (!c || c.from != i || (c instanceof Mt && c.slice.size >= l - i)) return !1
  if (n) {
    let u = e.tr.step(c)
    u.setSelection(_e.create(u.doc, i)), n(u.scrollIntoView())
  }
  return !0
}
function Ja(e, t, n = !1) {
  for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock) return !0
    if (n && r.childCount != 1) return !1
  }
  return !1
}
const dU = (e, t, n) => {
  let { $head: r, empty: o } = e.selection,
    i = r
  if (!o) return !1
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0) return !1
    i = o1(r)
  }
  let s = i && i.nodeBefore
  return !s || !ye.isSelectable(s)
    ? !1
    : (t &&
        t(
          e.tr
            .setSelection(ye.create(e.doc, i.pos - s.nodeSize))
            .scrollIntoView()
        ),
      !0)
}
function o1(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      if (e.index(t) > 0) return e.doc.resolve(e.before(t + 1))
      if (e.node(t).type.spec.isolating) break
    }
  return null
}
function nA(e, t) {
  let { $cursor: n } = e.selection
  return !n ||
    (t
      ? !t.endOfTextblock("forward", e)
      : n.parentOffset < n.parent.content.size)
    ? null
    : n
}
const fU = (e, t, n) => {
    let r = nA(e, n)
    if (!r) return !1
    let o = i1(r)
    if (!o) return !1
    let i = o.nodeAfter
    if (oA(e, o, t, 1)) return !0
    if (r.parent.content.size == 0 && (Ja(i, "start") || ye.isSelectable(i))) {
      let s = em(e.doc, r.before(), r.after(), oe.empty)
      if (s && s.slice.size < s.to - s.from) {
        if (t) {
          let a = e.tr.step(s)
          a.setSelection(
            Ja(i, "start")
              ? Ne.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1)
              : ye.create(a.doc, a.mapping.map(o.pos))
          ),
            t(a.scrollIntoView())
        }
        return !0
      }
    }
    return i.isAtom && o.depth == r.depth - 1
      ? (t && t(e.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0)
      : !1
  },
  pU = (e, t, n) => {
    let { $head: r, empty: o } = e.selection,
      i = r
    if (!o) return !1
    if (r.parent.isTextblock) {
      if (
        n
          ? !n.endOfTextblock("forward", e)
          : r.parentOffset < r.parent.content.size
      )
        return !1
      i = i1(r)
    }
    let s = i && i.nodeAfter
    return !s || !ye.isSelectable(s)
      ? !1
      : (t && t(e.tr.setSelection(ye.create(e.doc, i.pos)).scrollIntoView()),
        !0)
  }
function i1(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      let n = e.node(t)
      if (e.index(t) + 1 < n.childCount) return e.doc.resolve(e.after(t + 1))
      if (n.type.spec.isolating) break
    }
  return null
}
const hU = (e, t) => {
    let n = e.selection,
      r = n instanceof ye,
      o
    if (r) {
      if (n.node.isTextblock || !Di(e.doc, n.from)) return !1
      o = n.from
    } else if (((o = Jh(e.doc, n.from, -1)), o == null)) return !1
    if (t) {
      let i = e.tr.join(o)
      r &&
        i.setSelection(
          ye.create(i.doc, o - e.doc.resolve(o).nodeBefore.nodeSize)
        ),
        t(i.scrollIntoView())
    }
    return !0
  },
  mU = (e, t) => {
    let n = e.selection,
      r
    if (n instanceof ye) {
      if (n.node.isTextblock || !Di(e.doc, n.to)) return !1
      r = n.to
    } else if (((r = Jh(e.doc, n.to, 1)), r == null)) return !1
    return t && t(e.tr.join(r).scrollIntoView()), !0
  },
  gU = (e, t) => {
    let { $from: n, $to: r } = e.selection,
      o = n.blockRange(r),
      i = o && wl(o)
    return i == null ? !1 : (t && t(e.tr.lift(o, i).scrollIntoView()), !0)
  },
  vU = (e, t) => {
    let { $head: n, $anchor: r } = e.selection
    return !n.parent.type.spec.code || !n.sameParent(r)
      ? !1
      : (t &&
          t(
            e.tr
              .insertText(
                `
`
              )
              .scrollIntoView()
          ),
        !0)
  }
function rA(e) {
  for (let t = 0; t < e.edgeCount; t++) {
    let { type: n } = e.edge(t)
    if (n.isTextblock && !n.hasRequiredAttrs()) return n
  }
  return null
}
const yU = (e, t) => {
    let { $head: n, $anchor: r } = e.selection
    if (!n.parent.type.spec.code || !n.sameParent(r)) return !1
    let o = n.node(-1),
      i = n.indexAfter(-1),
      s = rA(o.contentMatchAt(i))
    if (!s || !o.canReplaceWith(i, i, s)) return !1
    if (t) {
      let a = n.after(),
        l = e.tr.replaceWith(a, a, s.createAndFill())
      l.setSelection(Ne.near(l.doc.resolve(a), 1)), t(l.scrollIntoView())
    }
    return !0
  },
  bU = (e, t) => {
    let n = e.selection,
      { $from: r, $to: o } = n
    if (n instanceof or || r.parent.inlineContent || o.parent.inlineContent)
      return !1
    let i = rA(o.parent.contentMatchAt(o.indexAfter()))
    if (!i || !i.isTextblock) return !1
    if (t) {
      let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos,
        a = e.tr.insert(s, i.createAndFill())
      a.setSelection(_e.create(a.doc, s + 1)), t(a.scrollIntoView())
    }
    return !0
  },
  xU = (e, t) => {
    let { $cursor: n } = e.selection
    if (!n || n.parent.content.size) return !1
    if (n.depth > 1 && n.after() != n.end(-1)) {
      let i = n.before()
      if (Ra(e.doc, i)) return t && t(e.tr.split(i).scrollIntoView()), !0
    }
    let r = n.blockRange(),
      o = r && wl(r)
    return o == null ? !1 : (t && t(e.tr.lift(r, o).scrollIntoView()), !0)
  },
  wU = (e, t) => {
    let { $from: n, to: r } = e.selection,
      o,
      i = n.sharedDepth(r)
    return i == 0
      ? !1
      : ((o = n.before(i)), t && t(e.tr.setSelection(ye.create(e.doc, o))), !0)
  }
function EU(e, t, n) {
  let r = t.nodeBefore,
    o = t.nodeAfter,
    i = t.index()
  return !r || !o || !r.type.compatibleContent(o.type)
    ? !1
    : !r.content.size && t.parent.canReplace(i - 1, i)
      ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0)
      : !t.parent.canReplace(i, i + 1) || !(o.isTextblock || Di(e.doc, t.pos))
        ? !1
        : (n && n(e.tr.join(t.pos).scrollIntoView()), !0)
}
function oA(e, t, n, r) {
  let o = t.nodeBefore,
    i = t.nodeAfter,
    s,
    a,
    l = o.type.spec.isolating || i.type.spec.isolating
  if (!l && EU(e, t, n)) return !0
  let c = !l && t.parent.canReplace(t.index(), t.index() + 1)
  if (
    c &&
    (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i.type)) &&
    a.matchType(s[0] || i.type).validEnd
  ) {
    if (n) {
      let p = t.pos + i.nodeSize,
        g = Z.empty
      for (let y = s.length - 1; y >= 0; y--) g = Z.from(s[y].create(null, g))
      g = Z.from(o.copy(g))
      let v = e.tr.step(
          new Bt(t.pos - 1, p, t.pos, p, new oe(g, 1, 0), s.length, !0)
        ),
        b = v.doc.resolve(p + 2 * s.length)
      b.nodeAfter &&
        b.nodeAfter.type == o.type &&
        Di(v.doc, b.pos) &&
        v.join(b.pos),
        n(v.scrollIntoView())
    }
    return !0
  }
  let u = i.type.spec.isolating || (r > 0 && l) ? null : Ne.findFrom(t, 1),
    d = u && u.$from.blockRange(u.$to),
    f = d && wl(d)
  if (f != null && f >= t.depth)
    return n && n(e.tr.lift(d, f).scrollIntoView()), !0
  if (c && Ja(i, "start", !0) && Ja(o, "end")) {
    let p = o,
      g = []
    for (; g.push(p), !p.isTextblock; ) p = p.lastChild
    let v = i,
      b = 1
    for (; !v.isTextblock; v = v.firstChild) b++
    if (p.canReplace(p.childCount, p.childCount, v.content)) {
      if (n) {
        let y = Z.empty
        for (let E = g.length - 1; E >= 0; E--) y = Z.from(g[E].copy(y))
        let x = e.tr.step(
          new Bt(
            t.pos - g.length,
            t.pos + i.nodeSize,
            t.pos + b,
            t.pos + i.nodeSize - b,
            new oe(y, g.length, 0),
            0,
            !0
          )
        )
        n(x.scrollIntoView())
      }
      return !0
    }
  }
  return !1
}
function iA(e) {
  return function (t, n) {
    let r = t.selection,
      o = e < 0 ? r.$from : r.$to,
      i = o.depth
    for (; o.node(i).isInline; ) {
      if (!i) return !1
      i--
    }
    return o.node(i).isTextblock
      ? (n &&
          n(t.tr.setSelection(_e.create(t.doc, e < 0 ? o.start(i) : o.end(i)))),
        !0)
      : !1
  }
}
const CU = iA(-1),
  SU = iA(1)
function _U(e, t = null) {
  return function (n, r) {
    let { $from: o, $to: i } = n.selection,
      s = o.blockRange(i),
      a = s && Gb(s, e, t)
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1
  }
}
function SC(e, t = null) {
  return function (n, r) {
    let o = !1
    for (let i = 0; i < n.selection.ranges.length && !o; i++) {
      let {
        $from: { pos: s },
        $to: { pos: a },
      } = n.selection.ranges[i]
      n.doc.nodesBetween(s, a, (l, c) => {
        if (o) return !1
        if (!(!l.isTextblock || l.hasMarkup(e, t)))
          if (l.type == e) o = !0
          else {
            let u = n.doc.resolve(c),
              d = u.index()
            o = u.parent.canReplaceWith(d, d + 1, e)
          }
      })
    }
    if (!o) return !1
    if (r) {
      let i = n.tr
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let {
          $from: { pos: a },
          $to: { pos: l },
        } = n.selection.ranges[s]
        i.setBlockType(a, l, e, t)
      }
      r(i.scrollIntoView())
    }
    return !0
  }
}
typeof navigator < "u"
  ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
  : typeof os < "u" && os.platform && os.platform() == "darwin"
function kU(e, t = null) {
  return function (n, r) {
    let { $from: o, $to: i } = n.selection,
      s = o.blockRange(i)
    if (!s) return !1
    let a = r ? n.tr : null
    return NU(a, s, e, t) ? (r && r(a.scrollIntoView()), !0) : !1
  }
}
function NU(e, t, n, r = null) {
  let o = !1,
    i = t,
    s = t.$from.doc
  if (
    t.depth >= 2 &&
    t.$from.node(t.depth - 1).type.compatibleContent(n) &&
    t.startIndex == 0
  ) {
    if (t.$from.index(t.depth - 1) == 0) return !1
    let l = s.resolve(t.start - 2)
    ;(i = new rp(l, l, t.depth)),
      t.endIndex < t.parent.childCount &&
        (t = new rp(t.$from, s.resolve(t.$to.end(t.depth)), t.depth)),
      (o = !0)
  }
  let a = Gb(i, n, r, t)
  return a ? (e && TU(e, t, a, o, n), !0) : !1
}
function TU(e, t, n, r, o) {
  let i = Z.empty
  for (let u = n.length - 1; u >= 0; u--)
    i = Z.from(n[u].type.create(n[u].attrs, i))
  e.step(
    new Bt(
      t.start - (r ? 2 : 0),
      t.end,
      t.start,
      t.end,
      new oe(i, 0, 0),
      n.length,
      !0
    )
  )
  let s = 0
  for (let u = 0; u < n.length; u++) n[u].type == o && (s = u + 1)
  let a = n.length - s,
    l = t.start + n.length - (r ? 2 : 0),
    c = t.parent
  for (let u = t.startIndex, d = t.endIndex, f = !0; u < d; u++, f = !1)
    !f && Ra(e.doc, l, a) && (e.split(l, a), (l += 2 * a)),
      (l += c.child(u).nodeSize)
  return e
}
function MU(e) {
  return function (t, n) {
    let { $from: r, $to: o } = t.selection,
      i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == e)
    return i
      ? n
        ? r.node(i.depth - 1).type == e
          ? OU(t, n, e, i)
          : AU(t, n, i)
        : !0
      : !1
  }
}
function OU(e, t, n, r) {
  let o = e.tr,
    i = r.end,
    s = r.$to.end(r.depth)
  i < s &&
    (o.step(
      new Bt(
        i - 1,
        s,
        i,
        s,
        new oe(Z.from(n.create(null, r.parent.copy())), 1, 0),
        1,
        !0
      )
    ),
    (r = new rp(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth)))
  const a = wl(r)
  if (a == null) return !1
  o.lift(r, a)
  let l = o.doc.resolve(o.mapping.map(i, -1) - 1)
  return (
    Di(o.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && o.join(l.pos),
    t(o.scrollIntoView()),
    !0
  )
}
function AU(e, t, n) {
  let r = e.tr,
    o = n.parent
  for (let p = n.end, g = n.endIndex - 1, v = n.startIndex; g > v; g--)
    (p -= o.child(g).nodeSize), r.delete(p - 1, p + 1)
  let i = r.doc.resolve(n.start),
    s = i.nodeAfter
  if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) return !1
  let a = n.startIndex == 0,
    l = n.endIndex == o.childCount,
    c = i.node(-1),
    u = i.index(-1)
  if (
    !c.canReplace(
      u + (a ? 0 : 1),
      u + 1,
      s.content.append(l ? Z.empty : Z.from(o))
    )
  )
    return !1
  let d = i.pos,
    f = d + s.nodeSize
  return (
    r.step(
      new Bt(
        d - (a ? 1 : 0),
        f + (l ? 1 : 0),
        d + 1,
        f - 1,
        new oe(
          (a ? Z.empty : Z.from(o.copy(Z.empty))).append(
            l ? Z.empty : Z.from(o.copy(Z.empty))
          ),
          a ? 0 : 1,
          l ? 0 : 1
        ),
        a ? 0 : 1
      )
    ),
    t(r.scrollIntoView()),
    !0
  )
}
function RU(e) {
  return function (t, n) {
    let { $from: r, $to: o } = t.selection,
      i = r.blockRange(o, (c) => c.childCount > 0 && c.firstChild.type == e)
    if (!i) return !1
    let s = i.startIndex
    if (s == 0) return !1
    let a = i.parent,
      l = a.child(s - 1)
    if (l.type != e) return !1
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type,
        u = Z.from(c ? e.create() : null),
        d = new oe(
          Z.from(e.create(null, Z.from(a.type.create(null, u)))),
          c ? 3 : 1,
          0
        ),
        f = i.start,
        p = i.end
      n(t.tr.step(new Bt(f - (c ? 3 : 1), p, f, p, d, 1, !0)).scrollIntoView())
    }
    return !0
  }
}
function im(e) {
  const { state: t, transaction: n } = e
  let { selection: r } = n,
    { doc: o } = n,
    { storedMarks: i } = n
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return i
    },
    get selection() {
      return r
    },
    get doc() {
      return o
    },
    get tr() {
      return (r = n.selection), (o = n.doc), (i = n.storedMarks), n
    },
  }
}
class sm {
  constructor(t) {
    ;(this.editor = t.editor),
      (this.rawCommands = this.editor.extensionManager.commands),
      (this.customState = t.state)
  }
  get hasCustomState() {
    return !!this.customState
  }
  get state() {
    return this.customState || this.editor.state
  }
  get commands() {
    const { rawCommands: t, editor: n, state: r } = this,
      { view: o } = n,
      { tr: i } = r,
      s = this.buildProps(i)
    return Object.fromEntries(
      Object.entries(t).map(([a, l]) => [
        a,
        (...u) => {
          const d = l(...u)(s)
          return (
            !i.getMeta("preventDispatch") &&
              !this.hasCustomState &&
              o.dispatch(i),
            d
          )
        },
      ])
    )
  }
  get chain() {
    return () => this.createChain()
  }
  get can() {
    return () => this.createCan()
  }
  createChain(t, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this,
      { view: s } = o,
      a = [],
      l = !!t,
      c = t || i.tr,
      u = () => (
        !l &&
          n &&
          !c.getMeta("preventDispatch") &&
          !this.hasCustomState &&
          s.dispatch(c),
        a.every((f) => f === !0)
      ),
      d = {
        ...Object.fromEntries(
          Object.entries(r).map(([f, p]) => [
            f,
            (...v) => {
              const b = this.buildProps(c, n),
                y = p(...v)(b)
              return a.push(y), d
            },
          ])
        ),
        run: u,
      }
    return d
  }
  createCan(t) {
    const { rawCommands: n, state: r } = this,
      o = !1,
      i = t || r.tr,
      s = this.buildProps(i, o)
    return {
      ...Object.fromEntries(
        Object.entries(n).map(([l, c]) => [
          l,
          (...u) => c(...u)({ ...s, dispatch: void 0 }),
        ])
      ),
      chain: () => this.createChain(i, o),
    }
  }
  buildProps(t, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this,
      { view: s } = o,
      a = {
        tr: t,
        editor: o,
        view: s,
        state: im({ state: i, transaction: t }),
        dispatch: n ? () => {} : void 0,
        chain: () => this.createChain(t, n),
        can: () => this.createCan(t),
        get commands() {
          return Object.fromEntries(
            Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(a)])
          )
        },
      }
    return a
  }
}
class IU {
  constructor() {
    this.callbacks = {}
  }
  on(t, n) {
    return (
      this.callbacks[t] || (this.callbacks[t] = []),
      this.callbacks[t].push(n),
      this
    )
  }
  emit(t, ...n) {
    const r = this.callbacks[t]
    return r && r.forEach((o) => o.apply(this, n)), this
  }
  off(t, n) {
    const r = this.callbacks[t]
    return (
      r &&
        (n
          ? (this.callbacks[t] = r.filter((o) => o !== n))
          : delete this.callbacks[t]),
      this
    )
  }
  once(t, n) {
    const r = (...o) => {
      this.off(t, r), n.apply(this, o)
    }
    return this.on(t, r)
  }
  removeAllListeners() {
    this.callbacks = {}
  }
}
function ce(e, t, n) {
  return e.config[t] === void 0 && e.parent
    ? ce(e.parent, t, n)
    : typeof e.config[t] == "function"
      ? e.config[t].bind({ ...n, parent: e.parent ? ce(e.parent, t, n) : null })
      : e.config[t]
}
function am(e) {
  const t = e.filter((o) => o.type === "extension"),
    n = e.filter((o) => o.type === "node"),
    r = e.filter((o) => o.type === "mark")
  return { baseExtensions: t, nodeExtensions: n, markExtensions: r }
}
function sA(e) {
  const t = [],
    { nodeExtensions: n, markExtensions: r } = am(e),
    o = [...n, ...r],
    i = {
      default: null,
      rendered: !0,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: !0,
      isRequired: !1,
    }
  return (
    e.forEach((s) => {
      const a = {
          name: s.name,
          options: s.options,
          storage: s.storage,
          extensions: o,
        },
        l = ce(s, "addGlobalAttributes", a)
      if (!l) return
      l().forEach((u) => {
        u.types.forEach((d) => {
          Object.entries(u.attributes).forEach(([f, p]) => {
            t.push({ type: d, name: f, attribute: { ...i, ...p } })
          })
        })
      })
    }),
    o.forEach((s) => {
      const a = { name: s.name, options: s.options, storage: s.storage },
        l = ce(s, "addAttributes", a)
      if (!l) return
      const c = l()
      Object.entries(c).forEach(([u, d]) => {
        const f = { ...i, ...d }
        typeof (f == null ? void 0 : f.default) == "function" &&
          (f.default = f.default()),
          f != null &&
            f.isRequired &&
            (f == null ? void 0 : f.default) === void 0 &&
            delete f.default,
          t.push({ type: s.name, name: u, attribute: f })
      })
    }),
    t
  )
}
function Ft(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(
        `There is no node type named '${e}'. Maybe you forgot to add the extension?`
      )
    return t.nodes[e]
  }
  return e
}
function lt(...e) {
  return e
    .filter((t) => !!t)
    .reduce((t, n) => {
      const r = { ...t }
      return (
        Object.entries(n).forEach(([o, i]) => {
          if (!r[o]) {
            r[o] = i
            return
          }
          if (o === "class") {
            const a = i ? String(i).split(" ") : [],
              l = r[o] ? r[o].split(" ") : [],
              c = a.filter((u) => !l.includes(u))
            r[o] = [...l, ...c].join(" ")
          } else if (o === "style") {
            const a = i
                ? i
                    .split(";")
                    .map((u) => u.trim())
                    .filter(Boolean)
                : [],
              l = r[o]
                ? r[o]
                    .split(";")
                    .map((u) => u.trim())
                    .filter(Boolean)
                : [],
              c = new Map()
            l.forEach((u) => {
              const [d, f] = u.split(":").map((p) => p.trim())
              c.set(d, f)
            }),
              a.forEach((u) => {
                const [d, f] = u.split(":").map((p) => p.trim())
                c.set(d, f)
              }),
              (r[o] = Array.from(c.entries())
                .map(([u, d]) => `${u}: ${d}`)
                .join("; "))
          } else r[o] = i
        }),
        r
      )
    }, {})
}
function dp(e, t) {
  return t
    .filter((n) => n.type === e.type.name)
    .filter((n) => n.attribute.rendered)
    .map((n) =>
      n.attribute.renderHTML
        ? n.attribute.renderHTML(e.attrs) || {}
        : { [n.name]: e.attrs[n.name] }
    )
    .reduce((n, r) => lt(n, r), {})
}
function aA(e) {
  return typeof e == "function"
}
function Oe(e, t = void 0, ...n) {
  return aA(e) ? (t ? e.bind(t)(...n) : e(...n)) : e
}
function DU(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object
}
function LU(e) {
  return typeof e != "string"
    ? e
    : e.match(/^[+-]?(?:\d*\.)?\d+$/)
      ? Number(e)
      : e === "true"
        ? !0
        : e === "false"
          ? !1
          : e
}
function _C(e, t) {
  return "style" in e
    ? e
    : {
        ...e,
        getAttrs: (n) => {
          const r = e.getAttrs ? e.getAttrs(n) : e.attrs
          if (r === !1) return !1
          const o = t.reduce((i, s) => {
            const a = s.attribute.parseHTML
              ? s.attribute.parseHTML(n)
              : LU(n.getAttribute(s.name))
            return a == null ? i : { ...i, [s.name]: a }
          }, {})
          return { ...r, ...o }
        },
      }
}
function kC(e) {
  return Object.fromEntries(
    Object.entries(e).filter(([t, n]) =>
      t === "attrs" && DU(n) ? !1 : n != null
    )
  )
}
function PU(e, t) {
  var n
  const r = sA(e),
    { nodeExtensions: o, markExtensions: i } = am(e),
    s =
      (n = o.find((c) => ce(c, "topNode"))) === null || n === void 0
        ? void 0
        : n.name,
    a = Object.fromEntries(
      o.map((c) => {
        const u = r.filter((y) => y.type === c.name),
          d = {
            name: c.name,
            options: c.options,
            storage: c.storage,
            editor: t,
          },
          f = e.reduce((y, x) => {
            const E = ce(x, "extendNodeSchema", d)
            return { ...y, ...(E ? E(c) : {}) }
          }, {}),
          p = kC({
            ...f,
            content: Oe(ce(c, "content", d)),
            marks: Oe(ce(c, "marks", d)),
            group: Oe(ce(c, "group", d)),
            inline: Oe(ce(c, "inline", d)),
            atom: Oe(ce(c, "atom", d)),
            selectable: Oe(ce(c, "selectable", d)),
            draggable: Oe(ce(c, "draggable", d)),
            code: Oe(ce(c, "code", d)),
            whitespace: Oe(ce(c, "whitespace", d)),
            linebreakReplacement: Oe(ce(c, "linebreakReplacement", d)),
            defining: Oe(ce(c, "defining", d)),
            isolating: Oe(ce(c, "isolating", d)),
            attrs: Object.fromEntries(
              u.map((y) => {
                var x
                return [
                  y.name,
                  {
                    default:
                      (x = y == null ? void 0 : y.attribute) === null ||
                      x === void 0
                        ? void 0
                        : x.default,
                  },
                ]
              })
            ),
          }),
          g = Oe(ce(c, "parseHTML", d))
        g && (p.parseDOM = g.map((y) => _C(y, u)))
        const v = ce(c, "renderHTML", d)
        v && (p.toDOM = (y) => v({ node: y, HTMLAttributes: dp(y, u) }))
        const b = ce(c, "renderText", d)
        return b && (p.toText = b), [c.name, p]
      })
    ),
    l = Object.fromEntries(
      i.map((c) => {
        const u = r.filter((b) => b.type === c.name),
          d = {
            name: c.name,
            options: c.options,
            storage: c.storage,
            editor: t,
          },
          f = e.reduce((b, y) => {
            const x = ce(y, "extendMarkSchema", d)
            return { ...b, ...(x ? x(c) : {}) }
          }, {}),
          p = kC({
            ...f,
            inclusive: Oe(ce(c, "inclusive", d)),
            excludes: Oe(ce(c, "excludes", d)),
            group: Oe(ce(c, "group", d)),
            spanning: Oe(ce(c, "spanning", d)),
            code: Oe(ce(c, "code", d)),
            attrs: Object.fromEntries(
              u.map((b) => {
                var y
                return [
                  b.name,
                  {
                    default:
                      (y = b == null ? void 0 : b.attribute) === null ||
                      y === void 0
                        ? void 0
                        : y.default,
                  },
                ]
              })
            ),
          }),
          g = Oe(ce(c, "parseHTML", d))
        g && (p.parseDOM = g.map((b) => _C(b, u)))
        const v = ce(c, "renderHTML", d)
        return (
          v && (p.toDOM = (b) => v({ mark: b, HTMLAttributes: dp(b, u) })),
          [c.name, p]
        )
      })
    )
  return new tO({ topNode: s, nodes: a, marks: l })
}
function Rg(e, t) {
  return t.nodes[e] || t.marks[e] || null
}
function NC(e, t) {
  return Array.isArray(t)
    ? t.some((n) => (typeof n == "string" ? n : n.name) === e.name)
    : t
}
function s1(e, t) {
  const n = Ps.fromSchema(t).serializeFragment(e),
    o = document.implementation.createHTMLDocument().createElement("div")
  return o.appendChild(n), o.innerHTML
}
const $U = (e, t = 500) => {
  let n = ""
  const r = e.parentOffset
  return (
    e.parent.nodesBetween(Math.max(0, r - t), r, (o, i, s, a) => {
      var l, c
      const u =
        ((c = (l = o.type.spec).toText) === null || c === void 0
          ? void 0
          : c.call(l, { node: o, pos: i, parent: s, index: a })) ||
        o.textContent ||
        "%leaf%"
      n += o.isAtom && !o.isText ? u : u.slice(0, Math.max(0, r - i))
    }),
    n
  )
}
function a1(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]"
}
class Pu {
  constructor(t) {
    ;(this.find = t.find), (this.handler = t.handler)
  }
}
const BU = (e, t) => {
  if (a1(t)) return t.exec(e)
  const n = t(e)
  if (!n) return null
  const r = [n.text]
  return (
    (r.index = n.index),
    (r.input = e),
    (r.data = n.data),
    n.replaceWith &&
      (n.text.includes(n.replaceWith) ||
        console.warn(
          '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
        ),
      r.push(n.replaceWith)),
    r
  )
}
function _d(e) {
  var t
  const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = e,
    { view: l } = n
  if (l.composing) return !1
  const c = l.state.doc.resolve(r)
  if (
    c.parent.type.spec.code ||
    (!((t = c.nodeBefore || c.nodeAfter) === null || t === void 0) &&
      t.marks.find((f) => f.type.spec.code))
  )
    return !1
  let u = !1
  const d = $U(c) + i
  return (
    s.forEach((f) => {
      if (u) return
      const p = BU(d, f.find)
      if (!p) return
      const g = l.state.tr,
        v = im({ state: l.state, transaction: g }),
        b = { from: r - (p[0].length - i.length), to: o },
        { commands: y, chain: x, can: E } = new sm({ editor: n, state: v })
      f.handler({
        state: v,
        range: b,
        match: p,
        commands: y,
        chain: x,
        can: E,
      }) === null ||
        !g.steps.length ||
        (g.setMeta(a, { transform: g, from: r, to: o, text: i }),
        l.dispatch(g),
        (u = !0))
    }),
    u
  )
}
function jU(e) {
  const { editor: t, rules: n } = e,
    r = new rt({
      state: {
        init() {
          return null
        },
        apply(o, i, s) {
          const a = o.getMeta(r)
          if (a) return a
          const l = o.getMeta("applyInputRules")
          return (
            !!l &&
              setTimeout(() => {
                let { text: u } = l
                typeof u == "string" ? (u = u) : (u = s1(Z.from(u), s.schema))
                const { from: d } = l,
                  f = d + u.length
                _d({ editor: t, from: d, to: f, text: u, rules: n, plugin: r })
              }),
            o.selectionSet || o.docChanged ? null : i
          )
        },
      },
      props: {
        handleTextInput(o, i, s, a) {
          return _d({ editor: t, from: i, to: s, text: a, rules: n, plugin: r })
        },
        handleDOMEvents: {
          compositionend: (o) => (
            setTimeout(() => {
              const { $cursor: i } = o.state.selection
              i &&
                _d({
                  editor: t,
                  from: i.pos,
                  to: i.pos,
                  text: "",
                  rules: n,
                  plugin: r,
                })
            }),
            !1
          ),
        },
        handleKeyDown(o, i) {
          if (i.key !== "Enter") return !1
          const { $cursor: s } = o.state.selection
          return s
            ? _d({
                editor: t,
                from: s.pos,
                to: s.pos,
                text: `
`,
                rules: n,
                plugin: r,
              })
            : !1
        },
      },
      isInputRules: !0,
    })
  return r
}
function FU(e) {
  return Object.prototype.toString.call(e).slice(8, -1)
}
function kd(e) {
  return FU(e) !== "Object"
    ? !1
    : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype
}
function lm(e, t) {
  const n = { ...e }
  return (
    kd(e) &&
      kd(t) &&
      Object.keys(t).forEach((r) => {
        kd(t[r]) && kd(e[r]) ? (n[r] = lm(e[r], t[r])) : (n[r] = t[r])
      }),
    n
  )
}
class Rr {
  constructor(t = {}) {
    ;(this.type = "mark"),
      (this.name = "mark"),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...t }),
      (this.name = this.config.name),
      t.defaultOptions &&
        Object.keys(t.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = Oe(ce(this, "addOptions", { name: this.name }))),
      (this.storage =
        Oe(
          ce(this, "addStorage", { name: this.name, options: this.options })
        ) || {})
  }
  static create(t = {}) {
    return new Rr(t)
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => lm(this.options, t),
    })
    return (n.name = this.name), (n.parent = this.parent), n
  }
  extend(t = {}) {
    const n = new Rr(t)
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = t.name ? t.name : n.parent.name),
      t.defaultOptions &&
        Object.keys(t.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Oe(ce(n, "addOptions", { name: n.name }))),
      (n.storage = Oe(
        ce(n, "addStorage", { name: n.name, options: n.options })
      )),
      n
    )
  }
  static handleExit({ editor: t, mark: n }) {
    const { tr: r } = t.state,
      o = t.state.selection.$from
    if (o.pos === o.end()) {
      const s = o.marks()
      if (!!!s.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1
      const l = s.find((c) => (c == null ? void 0 : c.type.name) === n.name)
      return (
        l && r.removeStoredMark(l),
        r.insertText(" ", o.pos),
        t.view.dispatch(r),
        !0
      )
    }
    return !1
  }
}
function zU(e) {
  return typeof e == "number"
}
class UU {
  constructor(t) {
    ;(this.find = t.find), (this.handler = t.handler)
  }
}
const VU = (e, t, n) => {
  if (a1(t)) return [...e.matchAll(t)]
  const r = t(e, n)
  return r
    ? r.map((o) => {
        const i = [o.text]
        return (
          (i.index = o.index),
          (i.input = e),
          (i.data = o.data),
          o.replaceWith &&
            (o.text.includes(o.replaceWith) ||
              console.warn(
                '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
              ),
            i.push(o.replaceWith)),
          i
        )
      })
    : []
}
function HU(e) {
  const {
      editor: t,
      state: n,
      from: r,
      to: o,
      rule: i,
      pasteEvent: s,
      dropEvent: a,
    } = e,
    { commands: l, chain: c, can: u } = new sm({ editor: t, state: n }),
    d = []
  return (
    n.doc.nodesBetween(r, o, (p, g) => {
      if (!p.isTextblock || p.type.spec.code) return
      const v = Math.max(r, g),
        b = Math.min(o, g + p.content.size),
        y = p.textBetween(v - g, b - g, void 0, "")
      VU(y, i.find, s).forEach((E) => {
        if (E.index === void 0) return
        const w = v + E.index + 1,
          C = w + E[0].length,
          S = { from: n.tr.mapping.map(w), to: n.tr.mapping.map(C) },
          M = i.handler({
            state: n,
            range: S,
            match: E,
            commands: l,
            chain: c,
            can: u,
            pasteEvent: s,
            dropEvent: a,
          })
        d.push(M)
      })
    }),
    d.every((p) => p !== null)
  )
}
let Nd = null
const WU = (e) => {
  var t
  const n = new ClipboardEvent("paste", { clipboardData: new DataTransfer() })
  return (
    (t = n.clipboardData) === null || t === void 0 || t.setData("text/html", e),
    n
  )
}
function KU(e) {
  const { editor: t, rules: n } = e
  let r = null,
    o = !1,
    i = !1,
    s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
    a
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null
  } catch {
    a = null
  }
  const l = ({ state: u, from: d, to: f, rule: p, pasteEvt: g }) => {
    const v = u.tr,
      b = im({ state: u, transaction: v })
    if (
      !(
        !HU({
          editor: t,
          state: b,
          from: Math.max(d - 1, 0),
          to: f.b - 1,
          rule: p,
          pasteEvent: g,
          dropEvent: a,
        }) || !v.steps.length
      )
    ) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null
      } catch {
        a = null
      }
      return (
        (s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null),
        v
      )
    }
  }
  return n.map(
    (u) =>
      new rt({
        view(d) {
          const f = (g) => {
              var v
              ;(r =
                !((v = d.dom.parentElement) === null || v === void 0) &&
                v.contains(g.target)
                  ? d.dom.parentElement
                  : null),
                r && (Nd = t)
            },
            p = () => {
              Nd && (Nd = null)
            }
          return (
            window.addEventListener("dragstart", f),
            window.addEventListener("dragend", p),
            {
              destroy() {
                window.removeEventListener("dragstart", f),
                  window.removeEventListener("dragend", p)
              },
            }
          )
        },
        props: {
          handleDOMEvents: {
            drop: (d, f) => {
              if (((i = r === d.dom.parentElement), (a = f), !i)) {
                const p = Nd
                p &&
                  setTimeout(() => {
                    const g = p.state.selection
                    g && p.commands.deleteRange({ from: g.from, to: g.to })
                  }, 10)
              }
              return !1
            },
            paste: (d, f) => {
              var p
              const g =
                (p = f.clipboardData) === null || p === void 0
                  ? void 0
                  : p.getData("text/html")
              return (
                (s = f), (o = !!(g != null && g.includes("data-pm-slice"))), !1
              )
            },
          },
        },
        appendTransaction: (d, f, p) => {
          const g = d[0],
            v = g.getMeta("uiEvent") === "paste" && !o,
            b = g.getMeta("uiEvent") === "drop" && !i,
            y = g.getMeta("applyPasteRules"),
            x = !!y
          if (!v && !b && !x) return
          if (x) {
            let { text: C } = y
            typeof C == "string" ? (C = C) : (C = s1(Z.from(C), p.schema))
            const { from: S } = y,
              M = S + C.length,
              N = WU(C)
            return l({ rule: u, state: p, from: S, to: { b: M }, pasteEvt: N })
          }
          const E = f.doc.content.findDiffStart(p.doc.content),
            w = f.doc.content.findDiffEnd(p.doc.content)
          if (!(!zU(E) || !w || E === w.b))
            return l({ rule: u, state: p, from: E, to: w, pasteEvt: s })
        },
      })
  )
}
function GU(e) {
  const t = e.filter((n, r) => e.indexOf(n) !== r)
  return Array.from(new Set(t))
}
class wa {
  constructor(t, n) {
    ;(this.splittableMarks = []),
      (this.editor = n),
      (this.extensions = wa.resolve(t)),
      (this.schema = PU(this.extensions, n)),
      this.setupExtensions()
  }
  static resolve(t) {
    const n = wa.sort(wa.flatten(t)),
      r = GU(n.map((o) => o.name))
    return (
      r.length &&
        console.warn(
          `[tiptap warn]: Duplicate extension names found: [${r.map((o) => `'${o}'`).join(", ")}]. This can lead to issues.`
        ),
      n
    )
  }
  static flatten(t) {
    return t
      .map((n) => {
        const r = { name: n.name, options: n.options, storage: n.storage },
          o = ce(n, "addExtensions", r)
        return o ? [n, ...this.flatten(o())] : n
      })
      .flat(10)
  }
  static sort(t) {
    return t.sort((r, o) => {
      const i = ce(r, "priority") || 100,
        s = ce(o, "priority") || 100
      return i > s ? -1 : i < s ? 1 : 0
    })
  }
  get commands() {
    return this.extensions.reduce((t, n) => {
      const r = {
          name: n.name,
          options: n.options,
          storage: n.storage,
          editor: this.editor,
          type: Rg(n.name, this.schema),
        },
        o = ce(n, "addCommands", r)
      return o ? { ...t, ...o() } : t
    }, {})
  }
  get plugins() {
    const { editor: t } = this,
      n = wa.sort([...this.extensions].reverse()),
      r = [],
      o = [],
      i = n
        .map((s) => {
          const a = {
              name: s.name,
              options: s.options,
              storage: s.storage,
              editor: t,
              type: Rg(s.name, this.schema),
            },
            l = [],
            c = ce(s, "addKeyboardShortcuts", a)
          let u = {}
          if (
            (s.type === "mark" &&
              ce(s, "exitable", a) &&
              (u.ArrowRight = () => Rr.handleExit({ editor: t, mark: s })),
            c)
          ) {
            const v = Object.fromEntries(
              Object.entries(c()).map(([b, y]) => [b, () => y({ editor: t })])
            )
            u = { ...u, ...v }
          }
          const d = sU(u)
          l.push(d)
          const f = ce(s, "addInputRules", a)
          NC(s, t.options.enableInputRules) && f && r.push(...f())
          const p = ce(s, "addPasteRules", a)
          NC(s, t.options.enablePasteRules) && p && o.push(...p())
          const g = ce(s, "addProseMirrorPlugins", a)
          if (g) {
            const v = g()
            l.push(...v)
          }
          return l
        })
        .flat()
    return [jU({ editor: t, rules: r }), ...KU({ editor: t, rules: o }), ...i]
  }
  get attributes() {
    return sA(this.extensions)
  }
  get nodeViews() {
    const { editor: t } = this,
      { nodeExtensions: n } = am(this.extensions)
    return Object.fromEntries(
      n
        .filter((r) => !!ce(r, "addNodeView"))
        .map((r) => {
          const o = this.attributes.filter((l) => l.type === r.name),
            i = {
              name: r.name,
              options: r.options,
              storage: r.storage,
              editor: t,
              type: Ft(r.name, this.schema),
            },
            s = ce(r, "addNodeView", i)
          if (!s) return []
          const a = (l, c, u, d, f) => {
            const p = dp(l, o)
            return s()({
              node: l,
              view: c,
              getPos: u,
              decorations: d,
              innerDecorations: f,
              editor: t,
              extension: r,
              HTMLAttributes: p,
            })
          }
          return [r.name, a]
        })
    )
  }
  setupExtensions() {
    this.extensions.forEach((t) => {
      var n
      this.editor.extensionStorage[t.name] = t.storage
      const r = {
        name: t.name,
        options: t.options,
        storage: t.storage,
        editor: this.editor,
        type: Rg(t.name, this.schema),
      }
      t.type === "mark" &&
        (!((n = Oe(ce(t, "keepOnSplit", r))) !== null && n !== void 0) || n) &&
        this.splittableMarks.push(t.name)
      const o = ce(t, "onBeforeCreate", r),
        i = ce(t, "onCreate", r),
        s = ce(t, "onUpdate", r),
        a = ce(t, "onSelectionUpdate", r),
        l = ce(t, "onTransaction", r),
        c = ce(t, "onFocus", r),
        u = ce(t, "onBlur", r),
        d = ce(t, "onDestroy", r)
      o && this.editor.on("beforeCreate", o),
        i && this.editor.on("create", i),
        s && this.editor.on("update", s),
        a && this.editor.on("selectionUpdate", a),
        l && this.editor.on("transaction", l),
        c && this.editor.on("focus", c),
        u && this.editor.on("blur", u),
        d && this.editor.on("destroy", d)
    })
  }
}
class ct {
  constructor(t = {}) {
    ;(this.type = "extension"),
      (this.name = "extension"),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...t }),
      (this.name = this.config.name),
      t.defaultOptions &&
        Object.keys(t.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = Oe(ce(this, "addOptions", { name: this.name }))),
      (this.storage =
        Oe(
          ce(this, "addStorage", { name: this.name, options: this.options })
        ) || {})
  }
  static create(t = {}) {
    return new ct(t)
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => lm(this.options, t),
    })
    return (n.name = this.name), (n.parent = this.parent), n
  }
  extend(t = {}) {
    const n = new ct({ ...this.config, ...t })
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = t.name ? t.name : n.parent.name),
      t.defaultOptions &&
        Object.keys(t.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Oe(ce(n, "addOptions", { name: n.name }))),
      (n.storage = Oe(
        ce(n, "addStorage", { name: n.name, options: n.options })
      )),
      n
    )
  }
}
function lA(e, t, n) {
  const { from: r, to: o } = t,
    {
      blockSeparator: i = `

`,
      textSerializers: s = {},
    } = n || {}
  let a = ""
  return (
    e.nodesBetween(r, o, (l, c, u, d) => {
      var f
      l.isBlock && c > r && (a += i)
      const p = s == null ? void 0 : s[l.type.name]
      if (p)
        return (
          u && (a += p({ node: l, pos: c, parent: u, index: d, range: t })), !1
        )
      l.isText &&
        (a +=
          (f = l == null ? void 0 : l.text) === null || f === void 0
            ? void 0
            : f.slice(Math.max(r, c) - c, o - c))
    }),
    a
  )
}
function cA(e) {
  return Object.fromEntries(
    Object.entries(e.nodes)
      .filter(([, t]) => t.spec.toText)
      .map(([t, n]) => [t, n.spec.toText])
  )
}
const qU = ct.create({
    name: "clipboardTextSerializer",
    addOptions() {
      return { blockSeparator: void 0 }
    },
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor: e } = this,
                { state: t, schema: n } = e,
                { doc: r, selection: o } = t,
                { ranges: i } = o,
                s = Math.min(...i.map((u) => u.$from.pos)),
                a = Math.max(...i.map((u) => u.$to.pos)),
                l = cA(n)
              return lA(
                r,
                { from: s, to: a },
                {
                  ...(this.options.blockSeparator !== void 0
                    ? { blockSeparator: this.options.blockSeparator }
                    : {}),
                  textSerializers: l,
                }
              )
            },
          },
        }),
      ]
    },
  }),
  ZU =
    () =>
    ({ editor: e, view: t }) => (
      requestAnimationFrame(() => {
        var n
        e.isDestroyed ||
          (t.dom.blur(),
          (n = window == null ? void 0 : window.getSelection()) === null ||
            n === void 0 ||
            n.removeAllRanges())
      }),
      !0
    ),
  YU =
    (e = !1) =>
    ({ commands: t }) =>
      t.setContent("", e),
  XU =
    () =>
    ({ state: e, tr: t, dispatch: n }) => {
      const { selection: r } = t,
        { ranges: o } = r
      return (
        n &&
          o.forEach(({ $from: i, $to: s }) => {
            e.doc.nodesBetween(i.pos, s.pos, (a, l) => {
              if (a.type.isText) return
              const { doc: c, mapping: u } = t,
                d = c.resolve(u.map(l)),
                f = c.resolve(u.map(l + a.nodeSize)),
                p = d.blockRange(f)
              if (!p) return
              const g = wl(p)
              if (a.type.isTextblock) {
                const { defaultType: v } = d.parent.contentMatchAt(d.index())
                t.setNodeMarkup(p.start, v)
              }
              ;(g || g === 0) && t.lift(p, g)
            })
          }),
        !0
      )
    },
  QU = (e) => (t) => e(t),
  JU =
    () =>
    ({ state: e, dispatch: t }) =>
      bU(e, t),
  eV =
    (e, t) =>
    ({ editor: n, tr: r }) => {
      const { state: o } = n,
        i = o.doc.slice(e.from, e.to)
      r.deleteRange(e.from, e.to)
      const s = r.mapping.map(t)
      return (
        r.insert(s, i.content), r.setSelection(new _e(r.doc.resolve(s - 1))), !0
      )
    },
  tV =
    () =>
    ({ tr: e, dispatch: t }) => {
      const { selection: n } = e,
        r = n.$anchor.node()
      if (r.content.size > 0) return !1
      const o = e.selection.$anchor
      for (let i = o.depth; i > 0; i -= 1)
        if (o.node(i).type === r.type) {
          if (t) {
            const a = o.before(i),
              l = o.after(i)
            e.delete(a, l).scrollIntoView()
          }
          return !0
        }
      return !1
    },
  nV =
    (e) =>
    ({ tr: t, state: n, dispatch: r }) => {
      const o = Ft(e, n.schema),
        i = t.selection.$anchor
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === o) {
          if (r) {
            const l = i.before(s),
              c = i.after(s)
            t.delete(l, c).scrollIntoView()
          }
          return !0
        }
      return !1
    },
  rV =
    (e) =>
    ({ tr: t, dispatch: n }) => {
      const { from: r, to: o } = e
      return n && t.delete(r, o), !0
    },
  oV =
    () =>
    ({ state: e, dispatch: t }) =>
      aU(e, t),
  iV =
    () =>
    ({ commands: e }) =>
      e.keyboardShortcut("Enter"),
  sV =
    () =>
    ({ state: e, dispatch: t }) =>
      yU(e, t)
function fp(e, t, n = { strict: !0 }) {
  const r = Object.keys(t)
  return r.length
    ? r.every((o) =>
        n.strict ? t[o] === e[o] : a1(t[o]) ? t[o].test(e[o]) : t[o] === e[o]
      )
    : !0
}
function uA(e, t, n = {}) {
  return e.find(
    (r) =>
      r.type === t &&
      fp(Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])), n)
  )
}
function TC(e, t, n = {}) {
  return !!uA(e, t, n)
}
function cm(e, t, n) {
  var r
  if (!e || !t) return
  let o = e.parent.childAfter(e.parentOffset)
  if (
    ((!o.node || !o.node.marks.some((u) => u.type === t)) &&
      (o = e.parent.childBefore(e.parentOffset)),
    !o.node ||
      !o.node.marks.some((u) => u.type === t) ||
      ((n =
        n ||
        ((r = o.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs)),
      !uA([...o.node.marks], t, n)))
  )
    return
  let s = o.index,
    a = e.start() + o.offset,
    l = s + 1,
    c = a + o.node.nodeSize
  for (; s > 0 && TC([...e.parent.child(s - 1).marks], t, n); )
    (s -= 1), (a -= e.parent.child(s).nodeSize)
  for (; l < e.parent.childCount && TC([...e.parent.child(l).marks], t, n); )
    (c += e.parent.child(l).nodeSize), (l += 1)
  return { from: a, to: c }
}
function Pi(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(
        `There is no mark type named '${e}'. Maybe you forgot to add the extension?`
      )
    return t.marks[e]
  }
  return e
}
const aV =
    (e, t = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      const i = Pi(e, r.schema),
        { doc: s, selection: a } = n,
        { $from: l, from: c, to: u } = a
      if (o) {
        const d = cm(l, i, t)
        if (d && d.from <= c && d.to >= u) {
          const f = _e.create(s, d.from, d.to)
          n.setSelection(f)
        }
      }
      return !0
    },
  lV = (e) => (t) => {
    const n = typeof e == "function" ? e(t) : e
    for (let r = 0; r < n.length; r += 1) if (n[r](t)) return !0
    return !1
  }
function l1(e) {
  return e instanceof _e
}
function wo(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n)
}
function dA(e, t = null) {
  if (!t) return null
  const n = Ne.atStart(e),
    r = Ne.atEnd(e)
  if (t === "start" || t === !0) return n
  if (t === "end") return r
  const o = n.from,
    i = r.to
  return t === "all"
    ? _e.create(e, wo(0, o, i), wo(e.content.size, o, i))
    : _e.create(e, wo(t, o, i), wo(t, o, i))
}
function fA() {
  return (
    navigator.platform === "Android" || /android/i.test(navigator.userAgent)
  )
}
function um() {
  return (
    [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod",
    ].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document)
  )
}
const cV =
    (e = null, t = {}) =>
    ({ editor: n, view: r, tr: o, dispatch: i }) => {
      t = { scrollIntoView: !0, ...t }
      const s = () => {
        ;(um() || fA()) && r.dom.focus(),
          requestAnimationFrame(() => {
            n.isDestroyed ||
              (r.focus(),
              t != null && t.scrollIntoView && n.commands.scrollIntoView())
          })
      }
      if ((r.hasFocus() && e === null) || e === !1) return !0
      if (i && e === null && !l1(n.state.selection)) return s(), !0
      const a = dA(o.doc, e) || n.state.selection,
        l = n.state.selection.eq(a)
      return (
        i &&
          (l || o.setSelection(a),
          l && o.storedMarks && o.setStoredMarks(o.storedMarks),
          s()),
        !0
      )
    },
  uV = (e, t) => (n) => e.every((r, o) => t(r, { ...n, index: o })),
  dV =
    (e, t) =>
    ({ tr: n, commands: r }) =>
      r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t),
  pA = (e) => {
    const t = e.childNodes
    for (let n = t.length - 1; n >= 0; n -= 1) {
      const r = t[n]
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
        ? e.removeChild(r)
        : r.nodeType === 1 && pA(r)
    }
    return e
  }
function Td(e) {
  const t = `<body>${e}</body>`,
    n = new window.DOMParser().parseFromString(t, "text/html").body
  return pA(n)
}
function pp(e, t, n) {
  if (e instanceof hi || e instanceof Z) return e
  n = { slice: !0, parseOptions: {}, ...n }
  const r = typeof e == "object" && e !== null,
    o = typeof e == "string"
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return Z.fromArray(e.map((a) => t.nodeFromJSON(a)))
      const s = t.nodeFromJSON(e)
      return n.errorOnInvalidContent && s.check(), s
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i })
      return (
        console.warn(
          "[tiptap warn]: Invalid content.",
          "Passed value:",
          e,
          "Error:",
          i
        ),
        pp("", t, n)
      )
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let s = !1,
        a = ""
      const l = new tO({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (
                  (s = !0), (a = typeof c == "string" ? c : c.outerHTML), null
                ),
              },
            ],
          },
        }),
      })
      if (
        (n.slice
          ? mi.fromSchema(l).parseSlice(Td(e), n.parseOptions)
          : mi.fromSchema(l).parse(Td(e), n.parseOptions),
        n.errorOnInvalidContent && s)
      )
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`),
        })
    }
    const i = mi.fromSchema(t)
    return n.slice
      ? i.parseSlice(Td(e), n.parseOptions).content
      : i.parse(Td(e), n.parseOptions)
  }
  return pp("", t, n)
}
function fV(e, t, n) {
  const r = e.steps.length - 1
  if (r < t) return
  const o = e.steps[r]
  if (!(o instanceof Mt || o instanceof Bt)) return
  const i = e.mapping.maps[r]
  let s = 0
  i.forEach((a, l, c, u) => {
    s === 0 && (s = u)
  }),
    e.setSelection(Ne.near(e.doc.resolve(s), n))
}
const pV = (e) => !("type" in e),
  hV =
    (e, t, n) =>
    ({ tr: r, dispatch: o, editor: i }) => {
      var s
      if (o) {
        n = {
          parseOptions: i.options.parseOptions,
          updateSelection: !0,
          applyInputRules: !1,
          applyPasteRules: !1,
          ...n,
        }
        let a
        try {
          a = pp(t, i.schema, {
            parseOptions: { preserveWhitespace: "full", ...n.parseOptions },
            errorOnInvalidContent:
              (s = n.errorOnInvalidContent) !== null && s !== void 0
                ? s
                : i.options.enableContentCheck,
          })
        } catch (g) {
          return (
            i.emit("contentError", {
              editor: i,
              error: g,
              disableCollaboration: () => {
                i.storage.collaboration &&
                  (i.storage.collaboration.isDisabled = !0)
              },
            }),
            !1
          )
        }
        let { from: l, to: c } =
            typeof e == "number"
              ? { from: e, to: e }
              : { from: e.from, to: e.to },
          u = !0,
          d = !0
        if (
          ((pV(a) ? a : [a]).forEach((g) => {
            g.check(),
              (u = u ? g.isText && g.marks.length === 0 : !1),
              (d = d ? g.isBlock : !1)
          }),
          l === c && d)
        ) {
          const { parent: g } = r.doc.resolve(l)
          g.isTextblock &&
            !g.type.spec.code &&
            !g.childCount &&
            ((l -= 1), (c += 1))
        }
        let p
        if (u) {
          if (Array.isArray(t)) p = t.map((g) => g.text || "").join("")
          else if (t instanceof Z) {
            let g = ""
            t.forEach((v) => {
              v.text && (g += v.text)
            }),
              (p = g)
          } else typeof t == "object" && t && t.text ? (p = t.text) : (p = t)
          r.insertText(p, l, c)
        } else (p = a), r.replaceWith(l, c, p)
        n.updateSelection && fV(r, r.steps.length - 1, -1),
          n.applyInputRules &&
            r.setMeta("applyInputRules", { from: l, text: p }),
          n.applyPasteRules &&
            r.setMeta("applyPasteRules", { from: l, text: p })
      }
      return !0
    },
  mV =
    () =>
    ({ state: e, dispatch: t }) =>
      hU(e, t),
  gV =
    () =>
    ({ state: e, dispatch: t }) =>
      mU(e, t),
  vV =
    () =>
    ({ state: e, dispatch: t }) =>
      lU(e, t),
  yV =
    () =>
    ({ state: e, dispatch: t }) =>
      fU(e, t),
  bV =
    () =>
    ({ state: e, dispatch: t, tr: n }) => {
      try {
        const r = Jh(e.doc, e.selection.$from.pos, -1)
        return r == null ? !1 : (n.join(r, 2), t && t(n), !0)
      } catch {
        return !1
      }
    },
  xV =
    () =>
    ({ state: e, dispatch: t, tr: n }) => {
      try {
        const r = Jh(e.doc, e.selection.$from.pos, 1)
        return r == null ? !1 : (n.join(r, 2), t && t(n), !0)
      } catch {
        return !1
      }
    },
  wV =
    () =>
    ({ state: e, dispatch: t }) =>
      cU(e, t),
  EV =
    () =>
    ({ state: e, dispatch: t }) =>
      uU(e, t)
function hA() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1
}
function CV(e) {
  const t = e.split(/-(?!$)/)
  let n = t[t.length - 1]
  n === "Space" && (n = " ")
  let r, o, i, s
  for (let a = 0; a < t.length - 1; a += 1) {
    const l = t[a]
    if (/^(cmd|meta|m)$/i.test(l)) s = !0
    else if (/^a(lt)?$/i.test(l)) r = !0
    else if (/^(c|ctrl|control)$/i.test(l)) o = !0
    else if (/^s(hift)?$/i.test(l)) i = !0
    else if (/^mod$/i.test(l)) um() || hA() ? (s = !0) : (o = !0)
    else throw new Error(`Unrecognized modifier name: ${l}`)
  }
  return (
    r && (n = `Alt-${n}`),
    o && (n = `Ctrl-${n}`),
    s && (n = `Meta-${n}`),
    i && (n = `Shift-${n}`),
    n
  )
}
const SV =
  (e) =>
  ({ editor: t, view: n, tr: r, dispatch: o }) => {
    const i = CV(e).split(/-(?!$)/),
      s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)),
      a = new KeyboardEvent("keydown", {
        key: s === "Space" ? " " : s,
        altKey: i.includes("Alt"),
        ctrlKey: i.includes("Ctrl"),
        metaKey: i.includes("Meta"),
        shiftKey: i.includes("Shift"),
        bubbles: !0,
        cancelable: !0,
      }),
      l = t.captureTransaction(() => {
        n.someProp("handleKeyDown", (c) => c(n, a))
      })
    return (
      l == null ||
        l.steps.forEach((c) => {
          const u = c.map(r.mapping)
          u && o && r.maybeStep(u)
        }),
      !0
    )
  }
function lu(e, t, n = {}) {
  const { from: r, to: o, empty: i } = e.selection,
    s = t ? Ft(t, e.schema) : null,
    a = []
  e.doc.nodesBetween(r, o, (d, f) => {
    if (d.isText) return
    const p = Math.max(r, f),
      g = Math.min(o, f + d.nodeSize)
    a.push({ node: d, from: p, to: g })
  })
  const l = o - r,
    c = a
      .filter((d) => (s ? s.name === d.node.type.name : !0))
      .filter((d) => fp(d.node.attrs, n, { strict: !1 }))
  return i ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l
}
const _V =
    (e, t = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = Ft(e, n.schema)
      return lu(n, o, t) ? gU(n, r) : !1
    },
  kV =
    () =>
    ({ state: e, dispatch: t }) =>
      xU(e, t),
  NV =
    (e) =>
    ({ state: t, dispatch: n }) => {
      const r = Ft(e, t.schema)
      return MU(r)(t, n)
    },
  TV =
    () =>
    ({ state: e, dispatch: t }) =>
      vU(e, t)
function dm(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null
}
function MC(e, t) {
  const n = typeof t == "string" ? [t] : t
  return Object.keys(e).reduce(
    (r, o) => (n.includes(o) || (r[o] = e[o]), r),
    {}
  )
}
const MV =
    (e, t) =>
    ({ tr: n, state: r, dispatch: o }) => {
      let i = null,
        s = null
      const a = dm(typeof e == "string" ? e : e.name, r.schema)
      return a
        ? (a === "node" && (i = Ft(e, r.schema)),
          a === "mark" && (s = Pi(e, r.schema)),
          o &&
            n.selection.ranges.forEach((l) => {
              r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
                i && i === c.type && n.setNodeMarkup(u, void 0, MC(c.attrs, t)),
                  s &&
                    c.marks.length &&
                    c.marks.forEach((d) => {
                      s === d.type &&
                        n.addMark(u, u + c.nodeSize, s.create(MC(d.attrs, t)))
                    })
              })
            }),
          !0)
        : !1
    },
  OV =
    () =>
    ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0),
  AV =
    () =>
    ({ tr: e, dispatch: t }) => {
      if (t) {
        const n = new or(e.doc)
        e.setSelection(n)
      }
      return !0
    },
  RV =
    () =>
    ({ state: e, dispatch: t }) =>
      dU(e, t),
  IV =
    () =>
    ({ state: e, dispatch: t }) =>
      pU(e, t),
  DV =
    () =>
    ({ state: e, dispatch: t }) =>
      wU(e, t),
  LV =
    () =>
    ({ state: e, dispatch: t }) =>
      SU(e, t),
  PV =
    () =>
    ({ state: e, dispatch: t }) =>
      CU(e, t)
function Dy(e, t, n = {}, r = {}) {
  return pp(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent,
  })
}
const $V =
  (e, t = !1, n = {}, r = {}) =>
  ({ editor: o, tr: i, dispatch: s, commands: a }) => {
    var l, c
    const { doc: u } = i
    if (n.preserveWhitespace !== "full") {
      const d = Dy(e, o.schema, n, {
        errorOnInvalidContent:
          (l = r.errorOnInvalidContent) !== null && l !== void 0
            ? l
            : o.options.enableContentCheck,
      })
      return (
        s && i.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !t),
        !0
      )
    }
    return (
      s && i.setMeta("preventUpdate", !t),
      a.insertContentAt({ from: 0, to: u.content.size }, e, {
        parseOptions: n,
        errorOnInvalidContent:
          (c = r.errorOnInvalidContent) !== null && c !== void 0
            ? c
            : o.options.enableContentCheck,
      })
    )
  }
function mA(e, t) {
  const n = Pi(t, e.schema),
    { from: r, to: o, empty: i } = e.selection,
    s = []
  i
    ? (e.storedMarks && s.push(...e.storedMarks),
      s.push(...e.selection.$head.marks()))
    : e.doc.nodesBetween(r, o, (l) => {
        s.push(...l.marks)
      })
  const a = s.find((l) => l.type.name === n.name)
  return a ? { ...a.attrs } : {}
}
function BV(e, t) {
  const n = new vO(e)
  return (
    t.forEach((r) => {
      r.steps.forEach((o) => {
        n.step(o)
      })
    }),
    n
  )
}
function jV(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t)
    if (n.isTextblock && !n.hasRequiredAttrs()) return n
  }
  return null
}
function Ly(e, t) {
  const n = []
  return (
    e.descendants((r, o) => {
      t(r) && n.push({ node: r, pos: o })
    }),
    n
  )
}
function FV(e, t, n) {
  const r = []
  return (
    e.nodesBetween(t.from, t.to, (o, i) => {
      n(o) && r.push({ node: o, pos: i })
    }),
    r
  )
}
function zV(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n)
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r,
      }
  }
}
function c1(e) {
  return (t) => zV(t.$from, e)
}
function UV(e, t) {
  const n = { from: 0, to: e.content.size }
  return lA(e, n, t)
}
function VV(e, t) {
  const n = Ft(t, e.schema),
    { from: r, to: o } = e.selection,
    i = []
  e.doc.nodesBetween(r, o, (a) => {
    i.push(a)
  })
  const s = i.reverse().find((a) => a.type.name === n.name)
  return s ? { ...s.attrs } : {}
}
function gA(e, t) {
  const n = dm(typeof t == "string" ? t : t.name, e.schema)
  return n === "node" ? VV(e, t) : n === "mark" ? mA(e, t) : {}
}
function HV(e, t = JSON.stringify) {
  const n = {}
  return e.filter((r) => {
    const o = t(r)
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : (n[o] = !0)
  })
}
function WV(e) {
  const t = HV(e)
  return t.length === 1
    ? t
    : t.filter(
        (n, r) =>
          !t
            .filter((i, s) => s !== r)
            .some(
              (i) =>
                n.oldRange.from >= i.oldRange.from &&
                n.oldRange.to <= i.oldRange.to &&
                n.newRange.from >= i.newRange.from &&
                n.newRange.to <= i.newRange.to
            )
      )
}
function KV(e) {
  const { mapping: t, steps: n } = e,
    r = []
  return (
    t.maps.forEach((o, i) => {
      const s = []
      if (o.ranges.length)
        o.forEach((a, l) => {
          s.push({ from: a, to: l })
        })
      else {
        const { from: a, to: l } = n[i]
        if (a === void 0 || l === void 0) return
        s.push({ from: a, to: l })
      }
      s.forEach(({ from: a, to: l }) => {
        const c = t.slice(i).map(a, -1),
          u = t.slice(i).map(l),
          d = t.invert().map(c, -1),
          f = t.invert().map(u)
        r.push({ oldRange: { from: d, to: f }, newRange: { from: c, to: u } })
      })
    }),
    WV(r)
  )
}
function u1(e, t, n) {
  const r = []
  return (
    e === t
      ? n
          .resolve(e)
          .marks()
          .forEach((o) => {
            const i = n.resolve(e),
              s = cm(i, o.type)
            s && r.push({ mark: o, ...s })
          })
      : n.nodesBetween(e, t, (o, i) => {
          !o ||
            (o == null ? void 0 : o.nodeSize) === void 0 ||
            r.push(
              ...o.marks.map((s) => ({ from: i, to: i + o.nodeSize, mark: s }))
            )
        }),
    r
  )
}
function af(e, t, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = e.find((i) => i.type === t && i.name === r)
      return o ? o.attribute.keepOnSplit : !1
    })
  )
}
function Py(e, t, n = {}) {
  const { empty: r, ranges: o } = e.selection,
    i = t ? Pi(t, e.schema) : null
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks())
      .filter((d) => (i ? i.name === d.type.name : !0))
      .find((d) => fp(d.attrs, n, { strict: !1 }))
  let s = 0
  const a = []
  if (
    (o.forEach(({ $from: d, $to: f }) => {
      const p = d.pos,
        g = f.pos
      e.doc.nodesBetween(p, g, (v, b) => {
        if (!v.isText && !v.marks.length) return
        const y = Math.max(p, b),
          x = Math.min(g, b + v.nodeSize),
          E = x - y
        ;(s += E), a.push(...v.marks.map((w) => ({ mark: w, from: y, to: x })))
      })
    }),
    s === 0)
  )
    return !1
  const l = a
      .filter((d) => (i ? i.name === d.mark.type.name : !0))
      .filter((d) => fp(d.mark.attrs, n, { strict: !1 }))
      .reduce((d, f) => d + f.to - f.from, 0),
    c = a
      .filter((d) => (i ? d.mark.type !== i && d.mark.type.excludes(i) : !0))
      .reduce((d, f) => d + f.to - f.from, 0)
  return (l > 0 ? l + c : l) >= s
}
function GV(e, t, n = {}) {
  if (!t) return lu(e, null, n) || Py(e, null, n)
  const r = dm(t, e.schema)
  return r === "node" ? lu(e, t, n) : r === "mark" ? Py(e, t, n) : !1
}
function OC(e, t) {
  const { nodeExtensions: n } = am(t),
    r = n.find((s) => s.name === e)
  if (!r) return !1
  const o = { name: r.name, options: r.options, storage: r.storage },
    i = Oe(ce(r, "group", o))
  return typeof i != "string" ? !1 : i.split(" ").includes("list")
}
function fm(e, { checkChildren: t = !0, ignoreWhitespace: n = !1 } = {}) {
  var r
  if (n) {
    if (e.type.name === "hardBreak") return !0
    if (e.isText)
      return /^\s*$/m.test((r = e.text) !== null && r !== void 0 ? r : "")
  }
  if (e.isText) return !e.text
  if (e.isAtom || e.isLeaf) return !1
  if (e.content.childCount === 0) return !0
  if (t) {
    let o = !0
    return (
      e.content.forEach((i) => {
        o !== !1 &&
          (fm(i, { ignoreWhitespace: n, checkChildren: t }) || (o = !1))
      }),
      o
    )
  }
  return !1
}
function vA(e) {
  return e instanceof ye
}
function qV(e, t, n) {
  const o = e.state.doc.content.size,
    i = wo(t, 0, o),
    s = wo(n, 0, o),
    a = e.coordsAtPos(i),
    l = e.coordsAtPos(s, -1),
    c = Math.min(a.top, l.top),
    u = Math.max(a.bottom, l.bottom),
    d = Math.min(a.left, l.left),
    f = Math.max(a.right, l.right),
    p = f - d,
    g = u - c,
    y = {
      top: c,
      bottom: u,
      left: d,
      right: f,
      width: p,
      height: g,
      x: d,
      y: c,
    }
  return { ...y, toJSON: () => y }
}
function ZV(e, t, n) {
  var r
  const { selection: o } = t
  let i = null
  if ((l1(o) && (i = o.$cursor), i)) {
    const a = (r = e.storedMarks) !== null && r !== void 0 ? r : i.marks()
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n))
  }
  const { ranges: s } = o
  return s.some(({ $from: a, $to: l }) => {
    let c =
      a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1
    return (
      e.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
        if (c) return !1
        if (u.isInline) {
          const p = !f || f.type.allowsMarkType(n),
            g = !!n.isInSet(u.marks) || !u.marks.some((v) => v.type.excludes(n))
          c = p && g
        }
        return !c
      }),
      c
    )
  })
}
const YV =
    (e, t = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      const { selection: i } = n,
        { empty: s, ranges: a } = i,
        l = Pi(e, r.schema)
      if (o)
        if (s) {
          const c = mA(r, l)
          n.addStoredMark(l.create({ ...c, ...t }))
        } else
          a.forEach((c) => {
            const u = c.$from.pos,
              d = c.$to.pos
            r.doc.nodesBetween(u, d, (f, p) => {
              const g = Math.max(p, u),
                v = Math.min(p + f.nodeSize, d)
              f.marks.find((y) => y.type === l)
                ? f.marks.forEach((y) => {
                    l === y.type &&
                      n.addMark(g, v, l.create({ ...y.attrs, ...t }))
                  })
                : n.addMark(g, v, l.create(t))
            })
          })
      return ZV(r, n, l)
    },
  XV =
    (e, t) =>
    ({ tr: n }) => (n.setMeta(e, t), !0),
  QV =
    (e, t = {}) =>
    ({ state: n, dispatch: r, chain: o }) => {
      const i = Ft(e, n.schema)
      let s
      return (
        n.selection.$anchor.sameParent(n.selection.$head) &&
          (s = n.selection.$anchor.parent.attrs),
        i.isTextblock
          ? o()
              .command(({ commands: a }) =>
                SC(i, { ...s, ...t })(n) ? !0 : a.clearNodes()
              )
              .command(({ state: a }) => SC(i, { ...s, ...t })(a, r))
              .run()
          : (console.warn(
              '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
            ),
            !1)
      )
    },
  JV =
    (e) =>
    ({ tr: t, dispatch: n }) => {
      if (n) {
        const { doc: r } = t,
          o = wo(e, 0, r.content.size),
          i = ye.create(r, o)
        t.setSelection(i)
      }
      return !0
    },
  eH =
    (e) =>
    ({ tr: t, dispatch: n }) => {
      if (n) {
        const { doc: r } = t,
          { from: o, to: i } = typeof e == "number" ? { from: e, to: e } : e,
          s = _e.atStart(r).from,
          a = _e.atEnd(r).to,
          l = wo(o, s, a),
          c = wo(i, s, a),
          u = _e.create(r, l, c)
        t.setSelection(u)
      }
      return !0
    },
  tH =
    (e) =>
    ({ state: t, dispatch: n }) => {
      const r = Ft(e, t.schema)
      return RU(r)(t, n)
    }
function AC(e, t) {
  const n =
    e.storedMarks || (e.selection.$to.parentOffset && e.selection.$from.marks())
  if (n) {
    const r = n.filter((o) => (t == null ? void 0 : t.includes(o.type.name)))
    e.tr.ensureMarks(r)
  }
}
const nH =
    ({ keepMarks: e = !0 } = {}) =>
    ({ tr: t, state: n, dispatch: r, editor: o }) => {
      const { selection: i, doc: s } = t,
        { $from: a, $to: l } = i,
        c = o.extensionManager.attributes,
        u = af(c, a.node().type.name, a.node().attrs)
      if (i instanceof ye && i.node.isBlock)
        return !a.parentOffset || !Ra(s, a.pos)
          ? !1
          : (r &&
              (e && AC(n, o.extensionManager.splittableMarks),
              t.split(a.pos).scrollIntoView()),
            !0)
      if (!a.parent.isBlock) return !1
      const d = l.parentOffset === l.parent.content.size,
        f =
          a.depth === 0
            ? void 0
            : jV(a.node(-1).contentMatchAt(a.indexAfter(-1)))
      let p = d && f ? [{ type: f, attrs: u }] : void 0,
        g = Ra(t.doc, t.mapping.map(a.pos), 1, p)
      if (
        (!p &&
          !g &&
          Ra(t.doc, t.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) &&
          ((g = !0), (p = f ? [{ type: f, attrs: u }] : void 0)),
        r)
      ) {
        if (
          g &&
          (i instanceof _e && t.deleteSelection(),
          t.split(t.mapping.map(a.pos), 1, p),
          f && !d && !a.parentOffset && a.parent.type !== f)
        ) {
          const v = t.mapping.map(a.before()),
            b = t.doc.resolve(v)
          a.node(-1).canReplaceWith(b.index(), b.index() + 1, f) &&
            t.setNodeMarkup(t.mapping.map(a.before()), f)
        }
        e && AC(n, o.extensionManager.splittableMarks), t.scrollIntoView()
      }
      return g
    },
  rH =
    (e, t = {}) =>
    ({ tr: n, state: r, dispatch: o, editor: i }) => {
      var s
      const a = Ft(e, r.schema),
        { $from: l, $to: c } = r.selection,
        u = r.selection.node
      if ((u && u.isBlock) || l.depth < 2 || !l.sameParent(c)) return !1
      const d = l.node(-1)
      if (d.type !== a) return !1
      const f = i.extensionManager.attributes
      if (
        l.parent.content.size === 0 &&
        l.node(-1).childCount === l.indexAfter(-1)
      ) {
        if (
          l.depth === 2 ||
          l.node(-3).type !== a ||
          l.index(-2) !== l.node(-2).childCount - 1
        )
          return !1
        if (o) {
          let y = Z.empty
          const x = l.index(-1) ? 1 : l.index(-2) ? 2 : 3
          for (let N = l.depth - x; N >= l.depth - 3; N -= 1)
            y = Z.from(l.node(N).copy(y))
          const E =
              l.indexAfter(-1) < l.node(-2).childCount
                ? 1
                : l.indexAfter(-2) < l.node(-3).childCount
                  ? 2
                  : 3,
            w = { ...af(f, l.node().type.name, l.node().attrs), ...t },
            C =
              ((s = a.contentMatch.defaultType) === null || s === void 0
                ? void 0
                : s.createAndFill(w)) || void 0
          y = y.append(Z.from(a.createAndFill(null, C) || void 0))
          const S = l.before(l.depth - (x - 1))
          n.replace(S, l.after(-E), new oe(y, 4 - x, 0))
          let M = -1
          n.doc.nodesBetween(S, n.doc.content.size, (N, R) => {
            if (M > -1) return !1
            N.isTextblock && N.content.size === 0 && (M = R + 1)
          }),
            M > -1 && n.setSelection(_e.near(n.doc.resolve(M))),
            n.scrollIntoView()
        }
        return !0
      }
      const p = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null,
        g = { ...af(f, d.type.name, d.attrs), ...t },
        v = { ...af(f, l.node().type.name, l.node().attrs), ...t }
      n.delete(l.pos, c.pos)
      const b = p
        ? [
            { type: a, attrs: g },
            { type: p, attrs: v },
          ]
        : [{ type: a, attrs: g }]
      if (!Ra(n.doc, l.pos, 2)) return !1
      if (o) {
        const { selection: y, storedMarks: x } = r,
          { splittableMarks: E } = i.extensionManager,
          w = x || (y.$to.parentOffset && y.$from.marks())
        if ((n.split(l.pos, 2, b).scrollIntoView(), !w || !o)) return !0
        const C = w.filter((S) => E.includes(S.type.name))
        n.ensureMarks(C)
      }
      return !0
    },
  Ig = (e, t) => {
    const n = c1((s) => s.type === t)(e.selection)
    if (!n) return !0
    const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth)
    if (r === void 0) return !0
    const o = e.doc.nodeAt(r)
    return (
      n.node.type === (o == null ? void 0 : o.type) &&
        Di(e.doc, n.pos) &&
        e.join(n.pos),
      !0
    )
  },
  Dg = (e, t) => {
    const n = c1((s) => s.type === t)(e.selection)
    if (!n) return !0
    const r = e.doc.resolve(n.start).after(n.depth)
    if (r === void 0) return !0
    const o = e.doc.nodeAt(r)
    return (
      n.node.type === (o == null ? void 0 : o.type) &&
        Di(e.doc, r) &&
        e.join(r),
      !0
    )
  },
  oH =
    (e, t, n, r = {}) =>
    ({
      editor: o,
      tr: i,
      state: s,
      dispatch: a,
      chain: l,
      commands: c,
      can: u,
    }) => {
      const { extensions: d, splittableMarks: f } = o.extensionManager,
        p = Ft(e, s.schema),
        g = Ft(t, s.schema),
        { selection: v, storedMarks: b } = s,
        { $from: y, $to: x } = v,
        E = y.blockRange(x),
        w = b || (v.$to.parentOffset && v.$from.marks())
      if (!E) return !1
      const C = c1((S) => OC(S.type.name, d))(v)
      if (E.depth >= 1 && C && E.depth - C.depth <= 1) {
        if (C.node.type === p) return c.liftListItem(g)
        if (OC(C.node.type.name, d) && p.validContent(C.node.content) && a)
          return l()
            .command(() => (i.setNodeMarkup(C.pos, p), !0))
            .command(() => Ig(i, p))
            .command(() => Dg(i, p))
            .run()
      }
      return !n || !w || !a
        ? l()
            .command(() => (u().wrapInList(p, r) ? !0 : c.clearNodes()))
            .wrapInList(p, r)
            .command(() => Ig(i, p))
            .command(() => Dg(i, p))
            .run()
        : l()
            .command(() => {
              const S = u().wrapInList(p, r),
                M = w.filter((N) => f.includes(N.type.name))
              return i.ensureMarks(M), S ? !0 : c.clearNodes()
            })
            .wrapInList(p, r)
            .command(() => Ig(i, p))
            .command(() => Dg(i, p))
            .run()
    },
  iH =
    (e, t = {}, n = {}) =>
    ({ state: r, commands: o }) => {
      const { extendEmptyMarkRange: i = !1 } = n,
        s = Pi(e, r.schema)
      return Py(r, s, t)
        ? o.unsetMark(s, { extendEmptyMarkRange: i })
        : o.setMark(s, t)
    },
  sH =
    (e, t, n = {}) =>
    ({ state: r, commands: o }) => {
      const i = Ft(e, r.schema),
        s = Ft(t, r.schema),
        a = lu(r, i, n)
      let l
      return (
        r.selection.$anchor.sameParent(r.selection.$head) &&
          (l = r.selection.$anchor.parent.attrs),
        a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n })
      )
    },
  aH =
    (e, t = {}) =>
    ({ state: n, commands: r }) => {
      const o = Ft(e, n.schema)
      return lu(n, o, t) ? r.lift(o) : r.wrapIn(o, t)
    },
  lH =
    () =>
    ({ state: e, dispatch: t }) => {
      const n = e.plugins
      for (let r = 0; r < n.length; r += 1) {
        const o = n[r]
        let i
        if (o.spec.isInputRules && (i = o.getState(e))) {
          if (t) {
            const s = e.tr,
              a = i.transform
            for (let l = a.steps.length - 1; l >= 0; l -= 1)
              s.step(a.steps[l].invert(a.docs[l]))
            if (i.text) {
              const l = s.doc.resolve(i.from).marks()
              s.replaceWith(i.from, i.to, e.schema.text(i.text, l))
            } else s.delete(i.from, i.to)
          }
          return !0
        }
      }
      return !1
    },
  cH =
    () =>
    ({ tr: e, dispatch: t }) => {
      const { selection: n } = e,
        { empty: r, ranges: o } = n
      return (
        r ||
          (t &&
            o.forEach((i) => {
              e.removeMark(i.$from.pos, i.$to.pos)
            })),
        !0
      )
    },
  uH =
    (e, t = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      var i
      const { extendEmptyMarkRange: s = !1 } = t,
        { selection: a } = n,
        l = Pi(e, r.schema),
        { $from: c, empty: u, ranges: d } = a
      if (!o) return !0
      if (u && s) {
        let { from: f, to: p } = a
        const g =
            (i = c.marks().find((b) => b.type === l)) === null || i === void 0
              ? void 0
              : i.attrs,
          v = cm(c, l, g)
        v && ((f = v.from), (p = v.to)), n.removeMark(f, p, l)
      } else
        d.forEach((f) => {
          n.removeMark(f.$from.pos, f.$to.pos, l)
        })
      return n.removeStoredMark(l), !0
    },
  dH =
    (e, t = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      let i = null,
        s = null
      const a = dm(typeof e == "string" ? e : e.name, r.schema)
      return a
        ? (a === "node" && (i = Ft(e, r.schema)),
          a === "mark" && (s = Pi(e, r.schema)),
          o &&
            n.selection.ranges.forEach((l) => {
              const c = l.$from.pos,
                u = l.$to.pos
              let d, f, p, g
              n.selection.empty
                ? r.doc.nodesBetween(c, u, (v, b) => {
                    i &&
                      i === v.type &&
                      ((p = Math.max(b, c)),
                      (g = Math.min(b + v.nodeSize, u)),
                      (d = b),
                      (f = v))
                  })
                : r.doc.nodesBetween(c, u, (v, b) => {
                    b < c &&
                      i &&
                      i === v.type &&
                      ((p = Math.max(b, c)),
                      (g = Math.min(b + v.nodeSize, u)),
                      (d = b),
                      (f = v)),
                      b >= c &&
                        b <= u &&
                        (i &&
                          i === v.type &&
                          n.setNodeMarkup(b, void 0, { ...v.attrs, ...t }),
                        s &&
                          v.marks.length &&
                          v.marks.forEach((y) => {
                            if (s === y.type) {
                              const x = Math.max(b, c),
                                E = Math.min(b + v.nodeSize, u)
                              n.addMark(x, E, s.create({ ...y.attrs, ...t }))
                            }
                          }))
                  }),
                f &&
                  (d !== void 0 &&
                    n.setNodeMarkup(d, void 0, { ...f.attrs, ...t }),
                  s &&
                    f.marks.length &&
                    f.marks.forEach((v) => {
                      s === v.type &&
                        n.addMark(p, g, s.create({ ...v.attrs, ...t }))
                    }))
            }),
          !0)
        : !1
    },
  fH =
    (e, t = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = Ft(e, n.schema)
      return _U(o, t)(n, r)
    },
  pH =
    (e, t = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = Ft(e, n.schema)
      return kU(o, t)(n, r)
    }
var hH = Object.freeze({
  __proto__: null,
  blur: ZU,
  clearContent: YU,
  clearNodes: XU,
  command: QU,
  createParagraphNear: JU,
  cut: eV,
  deleteCurrentNode: tV,
  deleteNode: nV,
  deleteRange: rV,
  deleteSelection: oV,
  enter: iV,
  exitCode: sV,
  extendMarkRange: aV,
  first: lV,
  focus: cV,
  forEach: uV,
  insertContent: dV,
  insertContentAt: hV,
  joinBackward: vV,
  joinDown: gV,
  joinForward: yV,
  joinItemBackward: bV,
  joinItemForward: xV,
  joinTextblockBackward: wV,
  joinTextblockForward: EV,
  joinUp: mV,
  keyboardShortcut: SV,
  lift: _V,
  liftEmptyBlock: kV,
  liftListItem: NV,
  newlineInCode: TV,
  resetAttributes: MV,
  scrollIntoView: OV,
  selectAll: AV,
  selectNodeBackward: RV,
  selectNodeForward: IV,
  selectParentNode: DV,
  selectTextblockEnd: LV,
  selectTextblockStart: PV,
  setContent: $V,
  setMark: YV,
  setMeta: XV,
  setNode: QV,
  setNodeSelection: JV,
  setTextSelection: eH,
  sinkListItem: tH,
  splitBlock: nH,
  splitListItem: rH,
  toggleList: oH,
  toggleMark: iH,
  toggleNode: sH,
  toggleWrap: aH,
  undoInputRule: lH,
  unsetAllMarks: cH,
  unsetMark: uH,
  updateAttributes: dH,
  wrapIn: fH,
  wrapInList: pH,
})
const mH = ct.create({
    name: "commands",
    addCommands() {
      return { ...hH }
    },
  }),
  gH = ct.create({
    name: "drop",
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("tiptapDrop"),
          props: {
            handleDrop: (e, t, n, r) => {
              this.editor.emit("drop", {
                editor: this.editor,
                event: t,
                slice: n,
                moved: r,
              })
            },
          },
        }),
      ]
    },
  }),
  vH = ct.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("editable"),
          props: { editable: () => this.editor.options.editable },
        }),
      ]
    },
  }),
  yH = new At("focusEvents"),
  bH = ct.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor: e } = this
      return [
        new rt({
          key: yH,
          props: {
            handleDOMEvents: {
              focus: (t, n) => {
                e.isFocused = !0
                const r = e.state.tr
                  .setMeta("focus", { event: n })
                  .setMeta("addToHistory", !1)
                return t.dispatch(r), !1
              },
              blur: (t, n) => {
                e.isFocused = !1
                const r = e.state.tr
                  .setMeta("blur", { event: n })
                  .setMeta("addToHistory", !1)
                return t.dispatch(r), !1
              },
            },
          },
        }),
      ]
    },
  }),
  xH = ct.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const e = () =>
          this.editor.commands.first(({ commands: s }) => [
            () => s.undoInputRule(),
            () =>
              s.command(({ tr: a }) => {
                const { selection: l, doc: c } = a,
                  { empty: u, $anchor: d } = l,
                  { pos: f, parent: p } = d,
                  g = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d,
                  v = g.parent.type.spec.isolating,
                  b = d.pos - d.parentOffset,
                  y =
                    v && g.parent.childCount === 1
                      ? b === d.pos
                      : Ne.atStart(c).from === f
                return !u ||
                  !p.type.isTextblock ||
                  p.textContent.length ||
                  !y ||
                  (y && d.parent.type.name === "paragraph")
                  ? !1
                  : s.clearNodes()
              }),
            () => s.deleteSelection(),
            () => s.joinBackward(),
            () => s.selectNodeBackward(),
          ]),
        t = () =>
          this.editor.commands.first(({ commands: s }) => [
            () => s.deleteSelection(),
            () => s.deleteCurrentNode(),
            () => s.joinForward(),
            () => s.selectNodeForward(),
          ]),
        r = {
          Enter: () =>
            this.editor.commands.first(({ commands: s }) => [
              () => s.newlineInCode(),
              () => s.createParagraphNear(),
              () => s.liftEmptyBlock(),
              () => s.splitBlock(),
            ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: e,
          "Mod-Backspace": e,
          "Shift-Backspace": e,
          Delete: t,
          "Mod-Delete": t,
          "Mod-a": () => this.editor.commands.selectAll(),
        },
        o = { ...r },
        i = {
          ...r,
          "Ctrl-h": e,
          "Alt-Backspace": e,
          "Ctrl-d": t,
          "Ctrl-Alt-Backspace": t,
          "Alt-Delete": t,
          "Alt-d": t,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
        }
      return um() || hA() ? i : o
    },
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("clearDocument"),
          appendTransaction: (e, t, n) => {
            if (e.some((v) => v.getMeta("composition"))) return
            const r = e.some((v) => v.docChanged) && !t.doc.eq(n.doc),
              o = e.some((v) => v.getMeta("preventClearDocument"))
            if (!r || o) return
            const { empty: i, from: s, to: a } = t.selection,
              l = Ne.atStart(t.doc).from,
              c = Ne.atEnd(t.doc).to
            if (i || !(s === l && a === c) || !fm(n.doc)) return
            const f = n.tr,
              p = im({ state: n, transaction: f }),
              { commands: g } = new sm({ editor: this.editor, state: p })
            if ((g.clearNodes(), !!f.steps.length)) return f
          },
        }),
      ]
    },
  }),
  wH = ct.create({
    name: "paste",
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("tiptapPaste"),
          props: {
            handlePaste: (e, t, n) => {
              this.editor.emit("paste", {
                editor: this.editor,
                event: t,
                slice: n,
              })
            },
          },
        }),
      ]
    },
  }),
  EH = ct.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("tabindex"),
          props: {
            attributes: () => (this.editor.isEditable ? { tabindex: "0" } : {}),
          },
        }),
      ]
    },
  })
class Wi {
  get name() {
    return this.node.type.name
  }
  constructor(t, n, r = !1, o = null) {
    ;(this.currentNode = null),
      (this.actualDepth = null),
      (this.isBlock = r),
      (this.resolvedPos = t),
      (this.editor = n),
      (this.currentNode = o)
  }
  get node() {
    return this.currentNode || this.resolvedPos.node()
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node
  }
  get depth() {
    var t
    return (t = this.actualDepth) !== null && t !== void 0
      ? t
      : this.resolvedPos.depth
  }
  get pos() {
    return this.resolvedPos.pos
  }
  get content() {
    return this.node.content
  }
  set content(t) {
    let n = this.from,
      r = this.to
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(
          `You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
        )
        return
      }
      ;(n = this.from + 1), (r = this.to - 1)
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, t)
  }
  get attributes() {
    return this.node.attrs
  }
  get textContent() {
    return this.node.textContent
  }
  get size() {
    return this.node.nodeSize
  }
  get from() {
    return this.isBlock
      ? this.pos
      : this.resolvedPos.start(this.resolvedPos.depth)
  }
  get range() {
    return { from: this.from, to: this.to }
  }
  get to() {
    return this.isBlock
      ? this.pos + this.size
      : this.resolvedPos.end(this.resolvedPos.depth) +
          (this.node.isText ? 0 : 1)
  }
  get parent() {
    if (this.depth === 0) return null
    const t = this.resolvedPos.start(this.resolvedPos.depth - 1),
      n = this.resolvedPos.doc.resolve(t)
    return new Wi(n, this.editor)
  }
  get before() {
    let t = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2))
    return (
      t.depth !== this.depth &&
        (t = this.resolvedPos.doc.resolve(this.from - 3)),
      new Wi(t, this.editor)
    )
  }
  get after() {
    let t = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1))
    return (
      t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.to + 3)),
      new Wi(t, this.editor)
    )
  }
  get children() {
    const t = []
    return (
      this.node.content.forEach((n, r) => {
        const o = n.isBlock && !n.isTextblock,
          i = n.isAtom && !n.isText,
          s = this.pos + r + (i ? 0 : 1),
          a = this.resolvedPos.doc.resolve(s)
        if (!o && a.depth <= this.depth) return
        const l = new Wi(a, this.editor, o, o ? n : null)
        o && (l.actualDepth = this.depth + 1),
          t.push(new Wi(a, this.editor, o, o ? n : null))
      }),
      t
    )
  }
  get firstChild() {
    return this.children[0] || null
  }
  get lastChild() {
    const t = this.children
    return t[t.length - 1] || null
  }
  closest(t, n = {}) {
    let r = null,
      o = this.parent
    for (; o && !r; ) {
      if (o.node.type.name === t)
        if (Object.keys(n).length > 0) {
          const i = o.node.attrs,
            s = Object.keys(n)
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a]
            if (i[l] !== n[l]) break
          }
        } else r = o
      o = o.parent
    }
    return r
  }
  querySelector(t, n = {}) {
    return this.querySelectorAll(t, n, !0)[0] || null
  }
  querySelectorAll(t, n = {}, r = !1) {
    let o = []
    if (!this.children || this.children.length === 0) return o
    const i = Object.keys(n)
    return (
      this.children.forEach((s) => {
        ;(r && o.length > 0) ||
          (s.node.type.name === t &&
            i.every((l) => n[l] === s.node.attrs[l]) &&
            o.push(s),
          !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(t, n, r))))
      }),
      o
    )
  }
  setAttribute(t) {
    const { tr: n } = this.editor.state
    n.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...t }),
      this.editor.view.dispatch(n)
  }
}
const CH = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`
function SH(e, t, n) {
  const r = document.querySelector(
    `style[data-tiptap-style${n ? `-${n}` : ""}]`
  )
  if (r !== null) return r
  const o = document.createElement("style")
  return (
    t && o.setAttribute("nonce", t),
    o.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
    (o.innerHTML = e),
    document.getElementsByTagName("head")[0].appendChild(o),
    o
  )
}
class _H extends IU {
  constructor(t = {}) {
    super(),
      (this.isFocused = !1),
      (this.isInitialized = !1),
      (this.extensionStorage = {}),
      (this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: !0,
        injectNonce: void 0,
        extensions: [],
        autofocus: !1,
        editable: !0,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: !0,
        enablePasteRules: !0,
        enableCoreExtensions: !0,
        enableContentCheck: !1,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: n }) => {
          throw n
        },
        onPaste: () => null,
        onDrop: () => null,
      }),
      (this.isCapturingTransaction = !1),
      (this.capturedTransaction = null),
      this.setOptions(t),
      this.createExtensionManager(),
      this.createCommandManager(),
      this.createSchema(),
      this.on("beforeCreate", this.options.onBeforeCreate),
      this.emit("beforeCreate", { editor: this }),
      this.on("contentError", this.options.onContentError),
      this.createView(),
      this.injectCSS(),
      this.on("create", this.options.onCreate),
      this.on("update", this.options.onUpdate),
      this.on("selectionUpdate", this.options.onSelectionUpdate),
      this.on("transaction", this.options.onTransaction),
      this.on("focus", this.options.onFocus),
      this.on("blur", this.options.onBlur),
      this.on("destroy", this.options.onDestroy),
      this.on("drop", ({ event: n, slice: r, moved: o }) =>
        this.options.onDrop(n, r, o)
      ),
      this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)),
      window.setTimeout(() => {
        this.isDestroyed ||
          (this.commands.focus(this.options.autofocus),
          this.emit("create", { editor: this }),
          (this.isInitialized = !0))
      }, 0)
  }
  get storage() {
    return this.extensionStorage
  }
  get commands() {
    return this.commandManager.commands
  }
  chain() {
    return this.commandManager.chain()
  }
  can() {
    return this.commandManager.can()
  }
  injectCSS() {
    this.options.injectCSS &&
      document &&
      (this.css = SH(CH, this.options.injectNonce))
  }
  setOptions(t = {}) {
    ;(this.options = { ...this.options, ...t }),
      !(!this.view || !this.state || this.isDestroyed) &&
        (this.options.editorProps &&
          this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state))
  }
  setEditable(t, n = !0) {
    this.setOptions({ editable: t }),
      n && this.emit("update", { editor: this, transaction: this.state.tr })
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable
  }
  get state() {
    return this.view.state
  }
  registerPlugin(t, n) {
    const r = aA(n)
        ? n(t, [...this.state.plugins])
        : [...this.state.plugins, t],
      o = this.state.reconfigure({ plugins: r })
    return this.view.updateState(o), o
  }
  unregisterPlugin(t) {
    if (this.isDestroyed) return
    const n = this.state.plugins
    let r = n
    if (
      ([].concat(t).forEach((i) => {
        const s = typeof i == "string" ? `${i}$` : i.key
        r = n.filter((a) => !a.key.startsWith(s))
      }),
      n.length === r.length)
    )
      return
    const o = this.state.reconfigure({ plugins: r })
    return this.view.updateState(o), o
  }
  createExtensionManager() {
    var t, n
    const o = [
      ...(this.options.enableCoreExtensions
        ? [
            vH,
            qU.configure({
              blockSeparator:
                (n =
                  (t = this.options.coreExtensionOptions) === null ||
                  t === void 0
                    ? void 0
                    : t.clipboardTextSerializer) === null || n === void 0
                  ? void 0
                  : n.blockSeparator,
            }),
            mH,
            bH,
            xH,
            EH,
            gH,
            wH,
          ].filter((i) =>
            typeof this.options.enableCoreExtensions == "object"
              ? this.options.enableCoreExtensions[i.name] !== !1
              : !0
          )
        : []),
      ...this.options.extensions,
    ].filter((i) =>
      ["extension", "node", "mark"].includes(i == null ? void 0 : i.type)
    )
    this.extensionManager = new wa(o, this)
  }
  createCommandManager() {
    this.commandManager = new sm({ editor: this })
  }
  createSchema() {
    this.schema = this.extensionManager.schema
  }
  createView() {
    var t
    let n
    try {
      n = Dy(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck,
      })
    } catch (s) {
      if (
        !(s instanceof Error) ||
        ![
          "[tiptap error]: Invalid JSON content",
          "[tiptap error]: Invalid HTML content",
        ].includes(s.message)
      )
        throw s
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration &&
            (this.storage.collaboration.isDisabled = !0),
            (this.options.extensions = this.options.extensions.filter(
              (a) => a.name !== "collaboration"
            )),
            this.createExtensionManager()
        },
      }),
        (n = Dy(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: !1,
        }))
    }
    const r = dA(n, this.options.autofocus)
    this.view = new Xz(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        role: "textbox",
        ...((t = this.options.editorProps) === null || t === void 0
          ? void 0
          : t.attributes),
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: xa.create({ doc: n, selection: r || void 0 }),
    })
    const o = this.state.reconfigure({ plugins: this.extensionManager.plugins })
    this.view.updateState(o), this.createNodeViews(), this.prependClass()
    const i = this.view.dom
    i.editor = this
  }
  createNodeViews() {
    this.view.isDestroyed ||
      this.view.setProps({ nodeViews: this.extensionManager.nodeViews })
  }
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`
  }
  captureTransaction(t) {
    ;(this.isCapturingTransaction = !0), t(), (this.isCapturingTransaction = !1)
    const n = this.capturedTransaction
    return (this.capturedTransaction = null), n
  }
  dispatchTransaction(t) {
    if (this.view.isDestroyed) return
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = t
        return
      }
      t.steps.forEach((s) => {
        var a
        return (a = this.capturedTransaction) === null || a === void 0
          ? void 0
          : a.step(s)
      })
      return
    }
    const n = this.state.apply(t),
      r = !this.state.selection.eq(n.selection)
    this.emit("beforeTransaction", {
      editor: this,
      transaction: t,
      nextState: n,
    }),
      this.view.updateState(n),
      this.emit("transaction", { editor: this, transaction: t }),
      r && this.emit("selectionUpdate", { editor: this, transaction: t })
    const o = t.getMeta("focus"),
      i = t.getMeta("blur")
    o && this.emit("focus", { editor: this, event: o.event, transaction: t }),
      i && this.emit("blur", { editor: this, event: i.event, transaction: t }),
      !(!t.docChanged || t.getMeta("preventUpdate")) &&
        this.emit("update", { editor: this, transaction: t })
  }
  getAttributes(t) {
    return gA(this.state, t)
  }
  isActive(t, n) {
    const r = typeof t == "string" ? t : null,
      o = typeof t == "string" ? n : t
    return GV(this.state, r, o)
  }
  getJSON() {
    return this.state.doc.toJSON()
  }
  getHTML() {
    return s1(this.state.doc.content, this.schema)
  }
  getText(t) {
    const {
      blockSeparator: n = `

`,
      textSerializers: r = {},
    } = t || {}
    return UV(this.state.doc, {
      blockSeparator: n,
      textSerializers: { ...cA(this.schema), ...r },
    })
  }
  get isEmpty() {
    return fm(this.state.doc)
  }
  getCharacterCount() {
    return (
      console.warn(
        '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
      ),
      this.state.doc.content.size - 2
    )
  }
  destroy() {
    if ((this.emit("destroy"), this.view)) {
      const t = this.view.dom
      t && t.editor && delete t.editor, this.view.destroy()
    }
    this.removeAllListeners()
  }
  get isDestroyed() {
    var t
    return !(!((t = this.view) === null || t === void 0) && t.docView)
  }
  $node(t, n) {
    var r
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelector(t, n)) || null
    )
  }
  $nodes(t, n) {
    var r
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelectorAll(t, n)) || null
    )
  }
  $pos(t) {
    const n = this.state.doc.resolve(t)
    return new Wi(n, this)
  }
  get $doc() {
    return this.$pos(0)
  }
}
function el(e) {
  return new Pu({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const o = Oe(e.getAttributes, void 0, r)
      if (o === !1 || o === null) return null
      const { tr: i } = t,
        s = r[r.length - 1],
        a = r[0]
      if (s) {
        const l = a.search(/\S/),
          c = n.from + a.indexOf(s),
          u = c + s.length
        if (
          u1(n.from, n.to, t.doc)
            .filter((p) =>
              p.mark.type.excluded.find(
                (v) => v === e.type && v !== p.mark.type
              )
            )
            .filter((p) => p.to > c).length
        )
          return null
        u < n.to && i.delete(u, n.to), c > n.from && i.delete(n.from + l, c)
        const f = n.from + l + s.length
        i.addMark(n.from + l, f, e.type.create(o || {})),
          i.removeStoredMark(e.type)
      }
    },
  })
}
function yA(e) {
  return new Pu({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const o = Oe(e.getAttributes, void 0, r) || {},
        { tr: i } = t,
        s = n.from
      let a = n.to
      const l = e.type.create(o)
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1])
        let u = s + c
        u > a ? (u = a) : (a = u + r[1].length)
        const d = r[0][r[0].length - 1]
        i.insertText(d, s + r[0].length - 1), i.replaceWith(u, a, l)
      } else if (r[0]) {
        const c = e.type.isInline ? s : s - 1
        i.insert(c, e.type.create(o)).delete(i.mapping.map(s), i.mapping.map(a))
      }
      i.scrollIntoView()
    },
  })
}
function $y(e) {
  return new Pu({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const o = t.doc.resolve(n.from),
        i = Oe(e.getAttributes, void 0, r) || {}
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), e.type))
        return null
      t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, i)
    },
  })
}
function vt(e) {
  return new Pu({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      let o = e.replace,
        i = n.from
      const s = n.to
      if (r[1]) {
        const a = r[0].lastIndexOf(r[1])
        ;(o += r[0].slice(a + r[1].length)), (i += a)
        const l = i - s
        l > 0 && ((o = r[0].slice(a - l, a) + o), (i = s))
      }
      t.tr.insertText(o, i, s)
    },
  })
}
function tl(e) {
  return new Pu({
    find: e.find,
    handler: ({ state: t, range: n, match: r, chain: o }) => {
      const i = Oe(e.getAttributes, void 0, r) || {},
        s = t.tr.delete(n.from, n.to),
        l = s.doc.resolve(n.from).blockRange(),
        c = l && Gb(l, e.type, i)
      if (!c) return null
      if ((s.wrap(l, c), e.keepMarks && e.editor)) {
        const { selection: d, storedMarks: f } = t,
          { splittableMarks: p } = e.editor.extensionManager,
          g = f || (d.$to.parentOffset && d.$from.marks())
        if (g) {
          const v = g.filter((b) => p.includes(b.type.name))
          s.ensureMarks(v)
        }
      }
      if (e.keepAttributes) {
        const d =
          e.type.name === "bulletList" || e.type.name === "orderedList"
            ? "listItem"
            : "taskList"
        o().updateAttributes(d, i).run()
      }
      const u = s.doc.resolve(n.from - 1).nodeBefore
      u &&
        u.type === e.type &&
        Di(s.doc, n.from - 1) &&
        (!e.joinPredicate || e.joinPredicate(r, u)) &&
        s.join(n.from - 1)
    },
  })
}
let Rn = class By {
  constructor(t = {}) {
    ;(this.type = "node"),
      (this.name = "node"),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...t }),
      (this.name = this.config.name),
      t.defaultOptions &&
        Object.keys(t.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = Oe(ce(this, "addOptions", { name: this.name }))),
      (this.storage =
        Oe(
          ce(this, "addStorage", { name: this.name, options: this.options })
        ) || {})
  }
  static create(t = {}) {
    return new By(t)
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => lm(this.options, t),
    })
    return (n.name = this.name), (n.parent = this.parent), n
  }
  extend(t = {}) {
    const n = new By(t)
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = t.name ? t.name : n.parent.name),
      t.defaultOptions &&
        Object.keys(t.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Oe(ce(n, "addOptions", { name: n.name }))),
      (n.storage = Oe(
        ce(n, "addStorage", { name: n.name, options: n.options })
      )),
      n
    )
  }
}
class kH {
  constructor(t, n, r) {
    ;(this.isDragging = !1),
      (this.component = t),
      (this.editor = n.editor),
      (this.options = { stopEvent: null, ignoreMutation: null, ...r }),
      (this.extension = n.extension),
      (this.node = n.node),
      (this.decorations = n.decorations),
      (this.innerDecorations = n.innerDecorations),
      (this.view = n.view),
      (this.HTMLAttributes = n.HTMLAttributes),
      (this.getPos = n.getPos),
      this.mount()
  }
  mount() {}
  get dom() {
    return this.editor.view.dom
  }
  get contentDOM() {
    return null
  }
  onDragStart(t) {
    var n, r, o, i, s, a, l
    const { view: c } = this.editor,
      u = t.target,
      d =
        u.nodeType === 3
          ? (n = u.parentElement) === null || n === void 0
            ? void 0
            : n.closest("[data-drag-handle]")
          : u.closest("[data-drag-handle]")
    if (
      !this.dom ||
      (!((r = this.contentDOM) === null || r === void 0) && r.contains(u)) ||
      !d
    )
      return
    let f = 0,
      p = 0
    if (this.dom !== d) {
      const x = this.dom.getBoundingClientRect(),
        E = d.getBoundingClientRect(),
        w =
          (o = t.offsetX) !== null && o !== void 0
            ? o
            : (i = t.nativeEvent) === null || i === void 0
              ? void 0
              : i.offsetX,
        C =
          (s = t.offsetY) !== null && s !== void 0
            ? s
            : (a = t.nativeEvent) === null || a === void 0
              ? void 0
              : a.offsetY
      ;(f = E.x - x.x + w), (p = E.y - x.y + C)
    }
    const g = this.dom.cloneNode(!0)
    ;(l = t.dataTransfer) === null || l === void 0 || l.setDragImage(g, f, p)
    const v = this.getPos()
    if (typeof v != "number") return
    const b = ye.create(c.state.doc, v),
      y = c.state.tr.setSelection(b)
    c.dispatch(y)
  }
  stopEvent(t) {
    var n
    if (!this.dom) return !1
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: t })
    const r = t.target
    if (
      !(
        this.dom.contains(r) &&
        !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))
      )
    )
      return !1
    const i = t.type.startsWith("drag"),
      s = t.type === "drop"
    if (
      (["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) ||
        r.isContentEditable) &&
      !s &&
      !i
    )
      return !0
    const { isEditable: l } = this.editor,
      { isDragging: c } = this,
      u = !!this.node.type.spec.draggable,
      d = ye.isSelectable(this.node),
      f = t.type === "copy",
      p = t.type === "paste",
      g = t.type === "cut",
      v = t.type === "mousedown"
    if (
      (!u && d && i && t.target === this.dom && t.preventDefault(),
      u && i && !c && t.target === this.dom)
    )
      return t.preventDefault(), !1
    if (u && l && !c && v) {
      const b = r.closest("[data-drag-handle]")
      b &&
        (this.dom === b || this.dom.contains(b)) &&
        ((this.isDragging = !0),
        document.addEventListener(
          "dragend",
          () => {
            this.isDragging = !1
          },
          { once: !0 }
        ),
        document.addEventListener(
          "drop",
          () => {
            this.isDragging = !1
          },
          { once: !0 }
        ),
        document.addEventListener(
          "mouseup",
          () => {
            this.isDragging = !1
          },
          { once: !0 }
        ))
    }
    return !(c || s || f || p || g || (v && d))
  }
  ignoreMutation(t) {
    return !this.dom || !this.contentDOM
      ? !0
      : typeof this.options.ignoreMutation == "function"
        ? this.options.ignoreMutation({ mutation: t })
        : this.node.isLeaf || this.node.isAtom
          ? !0
          : t.type === "selection" ||
              (this.dom.contains(t.target) &&
                t.type === "childList" &&
                (um() || fA()) &&
                this.editor.isFocused &&
                [
                  ...Array.from(t.addedNodes),
                  ...Array.from(t.removedNodes),
                ].every((r) => r.isContentEditable))
            ? !1
            : this.contentDOM === t.target && t.type === "attributes"
              ? !0
              : !this.contentDOM.contains(t.target)
  }
  updateAttributes(t) {
    this.editor.commands.command(({ tr: n }) => {
      const r = this.getPos()
      return typeof r != "number"
        ? !1
        : (n.setNodeMarkup(r, void 0, { ...this.node.attrs, ...t }), !0)
    })
  }
  deleteNode() {
    const t = this.getPos()
    if (typeof t != "number") return
    const n = t + this.node.nodeSize
    this.editor.commands.deleteRange({ from: t, to: n })
  }
}
function Ts(e) {
  return new UU({
    find: e.find,
    handler: ({ state: t, range: n, match: r, pasteEvent: o }) => {
      const i = Oe(e.getAttributes, void 0, r, o)
      if (i === !1 || i === null) return null
      const { tr: s } = t,
        a = r[r.length - 1],
        l = r[0]
      let c = n.to
      if (a) {
        const u = l.search(/\S/),
          d = n.from + l.indexOf(a),
          f = d + a.length
        if (
          u1(n.from, n.to, t.doc)
            .filter((g) =>
              g.mark.type.excluded.find(
                (b) => b === e.type && b !== g.mark.type
              )
            )
            .filter((g) => g.to > d).length
        )
          return null
        f < n.to && s.delete(f, n.to),
          d > n.from && s.delete(n.from + u, d),
          (c = n.from + u + a.length),
          s.addMark(n.from + u, c, e.type.create(i || {})),
          s.removeStoredMark(e.type)
      }
    },
  })
}
var Mn = "top",
  ur = "bottom",
  dr = "right",
  On = "left",
  d1 = "auto",
  $u = [Mn, ur, dr, On],
  nl = "start",
  cu = "end",
  NH = "clippingParents",
  bA = "viewport",
  Pl = "popper",
  TH = "reference",
  RC = $u.reduce(function (e, t) {
    return e.concat([t + "-" + nl, t + "-" + cu])
  }, []),
  xA = [].concat($u, [d1]).reduce(function (e, t) {
    return e.concat([t, t + "-" + nl, t + "-" + cu])
  }, []),
  MH = "beforeRead",
  OH = "read",
  AH = "afterRead",
  RH = "beforeMain",
  IH = "main",
  DH = "afterMain",
  LH = "beforeWrite",
  PH = "write",
  $H = "afterWrite",
  BH = [MH, OH, AH, RH, IH, DH, LH, PH, $H]
function to(e) {
  return e ? (e.nodeName || "").toLowerCase() : null
}
function Un(e) {
  if (e == null) return window
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument
    return (t && t.defaultView) || window
  }
  return e
}
function Ms(e) {
  var t = Un(e).Element
  return e instanceof t || e instanceof Element
}
function sr(e) {
  var t = Un(e).HTMLElement
  return e instanceof t || e instanceof HTMLElement
}
function f1(e) {
  if (typeof ShadowRoot > "u") return !1
  var t = Un(e).ShadowRoot
  return e instanceof t || e instanceof ShadowRoot
}
function jH(e) {
  var t = e.state
  Object.keys(t.elements).forEach(function (n) {
    var r = t.styles[n] || {},
      o = t.attributes[n] || {},
      i = t.elements[n]
    !sr(i) ||
      !to(i) ||
      (Object.assign(i.style, r),
      Object.keys(o).forEach(function (s) {
        var a = o[s]
        a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a)
      }))
  })
}
function FH(e) {
  var t = e.state,
    n = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: { position: "absolute" },
      reference: {},
    }
  return (
    Object.assign(t.elements.popper.style, n.popper),
    (t.styles = n),
    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
    function () {
      Object.keys(t.elements).forEach(function (r) {
        var o = t.elements[r],
          i = t.attributes[r] || {},
          s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]),
          a = s.reduce(function (l, c) {
            return (l[c] = ""), l
          }, {})
        !sr(o) ||
          !to(o) ||
          (Object.assign(o.style, a),
          Object.keys(i).forEach(function (l) {
            o.removeAttribute(l)
          }))
      })
    }
  )
}
const wA = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: jH,
  effect: FH,
  requires: ["computeStyles"],
}
function Zr(e) {
  return e.split("-")[0]
}
var ls = Math.max,
  hp = Math.min,
  rl = Math.round
function jy() {
  var e = navigator.userAgentData
  return e != null && e.brands && Array.isArray(e.brands)
    ? e.brands
        .map(function (t) {
          return t.brand + "/" + t.version
        })
        .join(" ")
    : navigator.userAgent
}
function EA() {
  return !/^((?!chrome|android).)*safari/i.test(jy())
}
function ol(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1)
  var r = e.getBoundingClientRect(),
    o = 1,
    i = 1
  t &&
    sr(e) &&
    ((o = (e.offsetWidth > 0 && rl(r.width) / e.offsetWidth) || 1),
    (i = (e.offsetHeight > 0 && rl(r.height) / e.offsetHeight) || 1))
  var s = Ms(e) ? Un(e) : window,
    a = s.visualViewport,
    l = !EA() && n,
    c = (r.left + (l && a ? a.offsetLeft : 0)) / o,
    u = (r.top + (l && a ? a.offsetTop : 0)) / i,
    d = r.width / o,
    f = r.height / i
  return {
    width: d,
    height: f,
    top: u,
    right: c + d,
    bottom: u + f,
    left: c,
    x: c,
    y: u,
  }
}
function p1(e) {
  var t = ol(e),
    n = e.offsetWidth,
    r = e.offsetHeight
  return (
    Math.abs(t.width - n) <= 1 && (n = t.width),
    Math.abs(t.height - r) <= 1 && (r = t.height),
    { x: e.offsetLeft, y: e.offsetTop, width: n, height: r }
  )
}
function CA(e, t) {
  var n = t.getRootNode && t.getRootNode()
  if (e.contains(t)) return !0
  if (n && f1(n)) {
    var r = t
    do {
      if (r && e.isSameNode(r)) return !0
      r = r.parentNode || r.host
    } while (r)
  }
  return !1
}
function Io(e) {
  return Un(e).getComputedStyle(e)
}
function zH(e) {
  return ["table", "td", "th"].indexOf(to(e)) >= 0
}
function $i(e) {
  return ((Ms(e) ? e.ownerDocument : e.document) || window.document)
    .documentElement
}
function pm(e) {
  return to(e) === "html"
    ? e
    : e.assignedSlot || e.parentNode || (f1(e) ? e.host : null) || $i(e)
}
function IC(e) {
  return !sr(e) || Io(e).position === "fixed" ? null : e.offsetParent
}
function UH(e) {
  var t = /firefox/i.test(jy()),
    n = /Trident/i.test(jy())
  if (n && sr(e)) {
    var r = Io(e)
    if (r.position === "fixed") return null
  }
  var o = pm(e)
  for (f1(o) && (o = o.host); sr(o) && ["html", "body"].indexOf(to(o)) < 0; ) {
    var i = Io(o)
    if (
      i.transform !== "none" ||
      i.perspective !== "none" ||
      i.contain === "paint" ||
      ["transform", "perspective"].indexOf(i.willChange) !== -1 ||
      (t && i.willChange === "filter") ||
      (t && i.filter && i.filter !== "none")
    )
      return o
    o = o.parentNode
  }
  return null
}
function Bu(e) {
  for (var t = Un(e), n = IC(e); n && zH(n) && Io(n).position === "static"; )
    n = IC(n)
  return n &&
    (to(n) === "html" || (to(n) === "body" && Io(n).position === "static"))
    ? t
    : n || UH(e) || t
}
function h1(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function hc(e, t, n) {
  return ls(e, hp(t, n))
}
function VH(e, t, n) {
  var r = hc(e, t, n)
  return r > n ? n : r
}
function SA() {
  return { top: 0, right: 0, bottom: 0, left: 0 }
}
function _A(e) {
  return Object.assign({}, SA(), e)
}
function kA(e, t) {
  return t.reduce(function (n, r) {
    return (n[r] = e), n
  }, {})
}
var HH = function (t, n) {
  return (
    (t =
      typeof t == "function"
        ? t(Object.assign({}, n.rects, { placement: n.placement }))
        : t),
    _A(typeof t != "number" ? t : kA(t, $u))
  )
}
function WH(e) {
  var t,
    n = e.state,
    r = e.name,
    o = e.options,
    i = n.elements.arrow,
    s = n.modifiersData.popperOffsets,
    a = Zr(n.placement),
    l = h1(a),
    c = [On, dr].indexOf(a) >= 0,
    u = c ? "height" : "width"
  if (!(!i || !s)) {
    var d = HH(o.padding, n),
      f = p1(i),
      p = l === "y" ? Mn : On,
      g = l === "y" ? ur : dr,
      v =
        n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u],
      b = s[l] - n.rects.reference[l],
      y = Bu(i),
      x = y ? (l === "y" ? y.clientHeight || 0 : y.clientWidth || 0) : 0,
      E = v / 2 - b / 2,
      w = d[p],
      C = x - f[u] - d[g],
      S = x / 2 - f[u] / 2 + E,
      M = hc(w, S, C),
      N = l
    n.modifiersData[r] = ((t = {}), (t[N] = M), (t.centerOffset = M - S), t)
  }
}
function KH(e) {
  var t = e.state,
    n = e.options,
    r = n.element,
    o = r === void 0 ? "[data-popper-arrow]" : r
  o != null &&
    ((typeof o == "string" && ((o = t.elements.popper.querySelector(o)), !o)) ||
      (CA(t.elements.popper, o) && (t.elements.arrow = o)))
}
const GH = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: WH,
  effect: KH,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
}
function il(e) {
  return e.split("-")[1]
}
var qH = { top: "auto", right: "auto", bottom: "auto", left: "auto" }
function ZH(e, t) {
  var n = e.x,
    r = e.y,
    o = t.devicePixelRatio || 1
  return { x: rl(n * o) / o || 0, y: rl(r * o) / o || 0 }
}
function DC(e) {
  var t,
    n = e.popper,
    r = e.popperRect,
    o = e.placement,
    i = e.variation,
    s = e.offsets,
    a = e.position,
    l = e.gpuAcceleration,
    c = e.adaptive,
    u = e.roundOffsets,
    d = e.isFixed,
    f = s.x,
    p = f === void 0 ? 0 : f,
    g = s.y,
    v = g === void 0 ? 0 : g,
    b = typeof u == "function" ? u({ x: p, y: v }) : { x: p, y: v }
  ;(p = b.x), (v = b.y)
  var y = s.hasOwnProperty("x"),
    x = s.hasOwnProperty("y"),
    E = On,
    w = Mn,
    C = window
  if (c) {
    var S = Bu(n),
      M = "clientHeight",
      N = "clientWidth"
    if (
      (S === Un(n) &&
        ((S = $i(n)),
        Io(S).position !== "static" &&
          a === "absolute" &&
          ((M = "scrollHeight"), (N = "scrollWidth"))),
      (S = S),
      o === Mn || ((o === On || o === dr) && i === cu))
    ) {
      w = ur
      var R = d && S === C && C.visualViewport ? C.visualViewport.height : S[M]
      ;(v -= R - r.height), (v *= l ? 1 : -1)
    }
    if (o === On || ((o === Mn || o === ur) && i === cu)) {
      E = dr
      var B = d && S === C && C.visualViewport ? C.visualViewport.width : S[N]
      ;(p -= B - r.width), (p *= l ? 1 : -1)
    }
  }
  var V = Object.assign({ position: a }, c && qH),
    j = u === !0 ? ZH({ x: p, y: v }, Un(n)) : { x: p, y: v }
  if (((p = j.x), (v = j.y), l)) {
    var U
    return Object.assign(
      {},
      V,
      ((U = {}),
      (U[w] = x ? "0" : ""),
      (U[E] = y ? "0" : ""),
      (U.transform =
        (C.devicePixelRatio || 1) <= 1
          ? "translate(" + p + "px, " + v + "px)"
          : "translate3d(" + p + "px, " + v + "px, 0)"),
      U)
    )
  }
  return Object.assign(
    {},
    V,
    ((t = {}),
    (t[w] = x ? v + "px" : ""),
    (t[E] = y ? p + "px" : ""),
    (t.transform = ""),
    t)
  )
}
function YH(e) {
  var t = e.state,
    n = e.options,
    r = n.gpuAcceleration,
    o = r === void 0 ? !0 : r,
    i = n.adaptive,
    s = i === void 0 ? !0 : i,
    a = n.roundOffsets,
    l = a === void 0 ? !0 : a,
    c = {
      placement: Zr(t.placement),
      variation: il(t.placement),
      popper: t.elements.popper,
      popperRect: t.rects.popper,
      gpuAcceleration: o,
      isFixed: t.options.strategy === "fixed",
    }
  t.modifiersData.popperOffsets != null &&
    (t.styles.popper = Object.assign(
      {},
      t.styles.popper,
      DC(
        Object.assign({}, c, {
          offsets: t.modifiersData.popperOffsets,
          position: t.options.strategy,
          adaptive: s,
          roundOffsets: l,
        })
      )
    )),
    t.modifiersData.arrow != null &&
      (t.styles.arrow = Object.assign(
        {},
        t.styles.arrow,
        DC(
          Object.assign({}, c, {
            offsets: t.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: l,
          })
        )
      )),
    (t.attributes.popper = Object.assign({}, t.attributes.popper, {
      "data-popper-placement": t.placement,
    }))
}
const XH = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: YH,
  data: {},
}
var Md = { passive: !0 }
function QH(e) {
  var t = e.state,
    n = e.instance,
    r = e.options,
    o = r.scroll,
    i = o === void 0 ? !0 : o,
    s = r.resize,
    a = s === void 0 ? !0 : s,
    l = Un(t.elements.popper),
    c = [].concat(t.scrollParents.reference, t.scrollParents.popper)
  return (
    i &&
      c.forEach(function (u) {
        u.addEventListener("scroll", n.update, Md)
      }),
    a && l.addEventListener("resize", n.update, Md),
    function () {
      i &&
        c.forEach(function (u) {
          u.removeEventListener("scroll", n.update, Md)
        }),
        a && l.removeEventListener("resize", n.update, Md)
    }
  )
}
const JH = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: QH,
  data: {},
}
var eW = { left: "right", right: "left", bottom: "top", top: "bottom" }
function lf(e) {
  return e.replace(/left|right|bottom|top/g, function (t) {
    return eW[t]
  })
}
var tW = { start: "end", end: "start" }
function LC(e) {
  return e.replace(/start|end/g, function (t) {
    return tW[t]
  })
}
function m1(e) {
  var t = Un(e),
    n = t.pageXOffset,
    r = t.pageYOffset
  return { scrollLeft: n, scrollTop: r }
}
function g1(e) {
  return ol($i(e)).left + m1(e).scrollLeft
}
function nW(e, t) {
  var n = Un(e),
    r = $i(e),
    o = n.visualViewport,
    i = r.clientWidth,
    s = r.clientHeight,
    a = 0,
    l = 0
  if (o) {
    ;(i = o.width), (s = o.height)
    var c = EA()
    ;(c || (!c && t === "fixed")) && ((a = o.offsetLeft), (l = o.offsetTop))
  }
  return { width: i, height: s, x: a + g1(e), y: l }
}
function rW(e) {
  var t,
    n = $i(e),
    r = m1(e),
    o = (t = e.ownerDocument) == null ? void 0 : t.body,
    i = ls(
      n.scrollWidth,
      n.clientWidth,
      o ? o.scrollWidth : 0,
      o ? o.clientWidth : 0
    ),
    s = ls(
      n.scrollHeight,
      n.clientHeight,
      o ? o.scrollHeight : 0,
      o ? o.clientHeight : 0
    ),
    a = -r.scrollLeft + g1(e),
    l = -r.scrollTop
  return (
    Io(o || n).direction === "rtl" &&
      (a += ls(n.clientWidth, o ? o.clientWidth : 0) - i),
    { width: i, height: s, x: a, y: l }
  )
}
function v1(e) {
  var t = Io(e),
    n = t.overflow,
    r = t.overflowX,
    o = t.overflowY
  return /auto|scroll|overlay|hidden/.test(n + o + r)
}
function NA(e) {
  return ["html", "body", "#document"].indexOf(to(e)) >= 0
    ? e.ownerDocument.body
    : sr(e) && v1(e)
      ? e
      : NA(pm(e))
}
function mc(e, t) {
  var n
  t === void 0 && (t = [])
  var r = NA(e),
    o = r === ((n = e.ownerDocument) == null ? void 0 : n.body),
    i = Un(r),
    s = o ? [i].concat(i.visualViewport || [], v1(r) ? r : []) : r,
    a = t.concat(s)
  return o ? a : a.concat(mc(pm(s)))
}
function Fy(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height,
  })
}
function oW(e, t) {
  var n = ol(e, !1, t === "fixed")
  return (
    (n.top = n.top + e.clientTop),
    (n.left = n.left + e.clientLeft),
    (n.bottom = n.top + e.clientHeight),
    (n.right = n.left + e.clientWidth),
    (n.width = e.clientWidth),
    (n.height = e.clientHeight),
    (n.x = n.left),
    (n.y = n.top),
    n
  )
}
function PC(e, t, n) {
  return t === bA ? Fy(nW(e, n)) : Ms(t) ? oW(t, n) : Fy(rW($i(e)))
}
function iW(e) {
  var t = mc(pm(e)),
    n = ["absolute", "fixed"].indexOf(Io(e).position) >= 0,
    r = n && sr(e) ? Bu(e) : e
  return Ms(r)
    ? t.filter(function (o) {
        return Ms(o) && CA(o, r) && to(o) !== "body"
      })
    : []
}
function sW(e, t, n, r) {
  var o = t === "clippingParents" ? iW(e) : [].concat(t),
    i = [].concat(o, [n]),
    s = i[0],
    a = i.reduce(
      function (l, c) {
        var u = PC(e, c, r)
        return (
          (l.top = ls(u.top, l.top)),
          (l.right = hp(u.right, l.right)),
          (l.bottom = hp(u.bottom, l.bottom)),
          (l.left = ls(u.left, l.left)),
          l
        )
      },
      PC(e, s, r)
    )
  return (
    (a.width = a.right - a.left),
    (a.height = a.bottom - a.top),
    (a.x = a.left),
    (a.y = a.top),
    a
  )
}
function TA(e) {
  var t = e.reference,
    n = e.element,
    r = e.placement,
    o = r ? Zr(r) : null,
    i = r ? il(r) : null,
    s = t.x + t.width / 2 - n.width / 2,
    a = t.y + t.height / 2 - n.height / 2,
    l
  switch (o) {
    case Mn:
      l = { x: s, y: t.y - n.height }
      break
    case ur:
      l = { x: s, y: t.y + t.height }
      break
    case dr:
      l = { x: t.x + t.width, y: a }
      break
    case On:
      l = { x: t.x - n.width, y: a }
      break
    default:
      l = { x: t.x, y: t.y }
  }
  var c = o ? h1(o) : null
  if (c != null) {
    var u = c === "y" ? "height" : "width"
    switch (i) {
      case nl:
        l[c] = l[c] - (t[u] / 2 - n[u] / 2)
        break
      case cu:
        l[c] = l[c] + (t[u] / 2 - n[u] / 2)
        break
    }
  }
  return l
}
function uu(e, t) {
  t === void 0 && (t = {})
  var n = t,
    r = n.placement,
    o = r === void 0 ? e.placement : r,
    i = n.strategy,
    s = i === void 0 ? e.strategy : i,
    a = n.boundary,
    l = a === void 0 ? NH : a,
    c = n.rootBoundary,
    u = c === void 0 ? bA : c,
    d = n.elementContext,
    f = d === void 0 ? Pl : d,
    p = n.altBoundary,
    g = p === void 0 ? !1 : p,
    v = n.padding,
    b = v === void 0 ? 0 : v,
    y = _A(typeof b != "number" ? b : kA(b, $u)),
    x = f === Pl ? TH : Pl,
    E = e.rects.popper,
    w = e.elements[g ? x : f],
    C = sW(Ms(w) ? w : w.contextElement || $i(e.elements.popper), l, u, s),
    S = ol(e.elements.reference),
    M = TA({ reference: S, element: E, strategy: "absolute", placement: o }),
    N = Fy(Object.assign({}, E, M)),
    R = f === Pl ? N : S,
    B = {
      top: C.top - R.top + y.top,
      bottom: R.bottom - C.bottom + y.bottom,
      left: C.left - R.left + y.left,
      right: R.right - C.right + y.right,
    },
    V = e.modifiersData.offset
  if (f === Pl && V) {
    var j = V[o]
    Object.keys(B).forEach(function (U) {
      var W = [dr, ur].indexOf(U) >= 0 ? 1 : -1,
        ee = [Mn, ur].indexOf(U) >= 0 ? "y" : "x"
      B[U] += j[ee] * W
    })
  }
  return B
}
function aW(e, t) {
  t === void 0 && (t = {})
  var n = t,
    r = n.placement,
    o = n.boundary,
    i = n.rootBoundary,
    s = n.padding,
    a = n.flipVariations,
    l = n.allowedAutoPlacements,
    c = l === void 0 ? xA : l,
    u = il(r),
    d = u
      ? a
        ? RC
        : RC.filter(function (g) {
            return il(g) === u
          })
      : $u,
    f = d.filter(function (g) {
      return c.indexOf(g) >= 0
    })
  f.length === 0 && (f = d)
  var p = f.reduce(function (g, v) {
    return (
      (g[v] = uu(e, { placement: v, boundary: o, rootBoundary: i, padding: s })[
        Zr(v)
      ]),
      g
    )
  }, {})
  return Object.keys(p).sort(function (g, v) {
    return p[g] - p[v]
  })
}
function lW(e) {
  if (Zr(e) === d1) return []
  var t = lf(e)
  return [LC(e), t, LC(t)]
}
function cW(e) {
  var t = e.state,
    n = e.options,
    r = e.name
  if (!t.modifiersData[r]._skip) {
    for (
      var o = n.mainAxis,
        i = o === void 0 ? !0 : o,
        s = n.altAxis,
        a = s === void 0 ? !0 : s,
        l = n.fallbackPlacements,
        c = n.padding,
        u = n.boundary,
        d = n.rootBoundary,
        f = n.altBoundary,
        p = n.flipVariations,
        g = p === void 0 ? !0 : p,
        v = n.allowedAutoPlacements,
        b = t.options.placement,
        y = Zr(b),
        x = y === b,
        E = l || (x || !g ? [lf(b)] : lW(b)),
        w = [b].concat(E).reduce(function (ve, he) {
          return ve.concat(
            Zr(he) === d1
              ? aW(t, {
                  placement: he,
                  boundary: u,
                  rootBoundary: d,
                  padding: c,
                  flipVariations: g,
                  allowedAutoPlacements: v,
                })
              : he
          )
        }, []),
        C = t.rects.reference,
        S = t.rects.popper,
        M = new Map(),
        N = !0,
        R = w[0],
        B = 0;
      B < w.length;
      B++
    ) {
      var V = w[B],
        j = Zr(V),
        U = il(V) === nl,
        W = [Mn, ur].indexOf(j) >= 0,
        ee = W ? "width" : "height",
        I = uu(t, {
          placement: V,
          boundary: u,
          rootBoundary: d,
          altBoundary: f,
          padding: c,
        }),
        O = W ? (U ? dr : On) : U ? ur : Mn
      C[ee] > S[ee] && (O = lf(O))
      var _ = lf(O),
        A = []
      if (
        (i && A.push(I[j] <= 0),
        a && A.push(I[O] <= 0, I[_] <= 0),
        A.every(function (ve) {
          return ve
        }))
      ) {
        ;(R = V), (N = !1)
        break
      }
      M.set(V, A)
    }
    if (N)
      for (
        var P = g ? 3 : 1,
          H = function (he) {
            var xe = w.find(function (Ae) {
              var je = M.get(Ae)
              if (je)
                return je.slice(0, he).every(function (Fe) {
                  return Fe
                })
            })
            if (xe) return (R = xe), "break"
          },
          X = P;
        X > 0;
        X--
      ) {
        var ae = H(X)
        if (ae === "break") break
      }
    t.placement !== R &&
      ((t.modifiersData[r]._skip = !0), (t.placement = R), (t.reset = !0))
  }
}
const uW = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: cW,
  requiresIfExists: ["offset"],
  data: { _skip: !1 },
}
function $C(e, t, n) {
  return (
    n === void 0 && (n = { x: 0, y: 0 }),
    {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x,
    }
  )
}
function BC(e) {
  return [Mn, dr, ur, On].some(function (t) {
    return e[t] >= 0
  })
}
function dW(e) {
  var t = e.state,
    n = e.name,
    r = t.rects.reference,
    o = t.rects.popper,
    i = t.modifiersData.preventOverflow,
    s = uu(t, { elementContext: "reference" }),
    a = uu(t, { altBoundary: !0 }),
    l = $C(s, r),
    c = $C(a, o, i),
    u = BC(l),
    d = BC(c)
  ;(t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d,
  }),
    (t.attributes.popper = Object.assign({}, t.attributes.popper, {
      "data-popper-reference-hidden": u,
      "data-popper-escaped": d,
    }))
}
const fW = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: dW,
}
function pW(e, t, n) {
  var r = Zr(e),
    o = [On, Mn].indexOf(r) >= 0 ? -1 : 1,
    i = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n,
    s = i[0],
    a = i[1]
  return (
    (s = s || 0),
    (a = (a || 0) * o),
    [On, dr].indexOf(r) >= 0 ? { x: a, y: s } : { x: s, y: a }
  )
}
function hW(e) {
  var t = e.state,
    n = e.options,
    r = e.name,
    o = n.offset,
    i = o === void 0 ? [0, 0] : o,
    s = xA.reduce(function (u, d) {
      return (u[d] = pW(d, t.rects, i)), u
    }, {}),
    a = s[t.placement],
    l = a.x,
    c = a.y
  t.modifiersData.popperOffsets != null &&
    ((t.modifiersData.popperOffsets.x += l),
    (t.modifiersData.popperOffsets.y += c)),
    (t.modifiersData[r] = s)
}
const mW = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: hW,
}
function gW(e) {
  var t = e.state,
    n = e.name
  t.modifiersData[n] = TA({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement,
  })
}
const vW = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: gW,
  data: {},
}
function yW(e) {
  return e === "x" ? "y" : "x"
}
function bW(e) {
  var t = e.state,
    n = e.options,
    r = e.name,
    o = n.mainAxis,
    i = o === void 0 ? !0 : o,
    s = n.altAxis,
    a = s === void 0 ? !1 : s,
    l = n.boundary,
    c = n.rootBoundary,
    u = n.altBoundary,
    d = n.padding,
    f = n.tether,
    p = f === void 0 ? !0 : f,
    g = n.tetherOffset,
    v = g === void 0 ? 0 : g,
    b = uu(t, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }),
    y = Zr(t.placement),
    x = il(t.placement),
    E = !x,
    w = h1(y),
    C = yW(w),
    S = t.modifiersData.popperOffsets,
    M = t.rects.reference,
    N = t.rects.popper,
    R =
      typeof v == "function"
        ? v(Object.assign({}, t.rects, { placement: t.placement }))
        : v,
    B =
      typeof R == "number"
        ? { mainAxis: R, altAxis: R }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, R),
    V = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
    j = { x: 0, y: 0 }
  if (S) {
    if (i) {
      var U,
        W = w === "y" ? Mn : On,
        ee = w === "y" ? ur : dr,
        I = w === "y" ? "height" : "width",
        O = S[w],
        _ = O + b[W],
        A = O - b[ee],
        P = p ? -N[I] / 2 : 0,
        H = x === nl ? M[I] : N[I],
        X = x === nl ? -N[I] : -M[I],
        ae = t.elements.arrow,
        ve = p && ae ? p1(ae) : { width: 0, height: 0 },
        he = t.modifiersData["arrow#persistent"]
          ? t.modifiersData["arrow#persistent"].padding
          : SA(),
        xe = he[W],
        Ae = he[ee],
        je = hc(0, M[I], ve[I]),
        Fe = E ? M[I] / 2 - P - je - xe - B.mainAxis : H - je - xe - B.mainAxis,
        Ze = E
          ? -M[I] / 2 + P + je + Ae + B.mainAxis
          : X + je + Ae + B.mainAxis,
        dt = t.elements.arrow && Bu(t.elements.arrow),
        kt = dt ? (w === "y" ? dt.clientTop || 0 : dt.clientLeft || 0) : 0,
        ft = (U = V == null ? void 0 : V[w]) != null ? U : 0,
        Et = O + Fe - ft - kt,
        He = O + Ze - ft,
        be = hc(p ? hp(_, Et) : _, O, p ? ls(A, He) : A)
      ;(S[w] = be), (j[w] = be - O)
    }
    if (a) {
      var yt,
        ue = w === "x" ? Mn : On,
        me = w === "x" ? ur : dr,
        $e = S[C],
        fe = C === "y" ? "height" : "width",
        k = $e + b[ue],
        D = $e - b[me],
        F = [Mn, On].indexOf(y) !== -1,
        te = (yt = V == null ? void 0 : V[C]) != null ? yt : 0,
        $ = F ? k : $e - M[fe] - N[fe] - te + B.altAxis,
        T = F ? $e + M[fe] + N[fe] - te - B.altAxis : D,
        L = p && F ? VH($, $e, T) : hc(p ? $ : k, $e, p ? T : D)
      ;(S[C] = L), (j[C] = L - $e)
    }
    t.modifiersData[r] = j
  }
}
const xW = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: bW,
  requiresIfExists: ["offset"],
}
function wW(e) {
  return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
}
function EW(e) {
  return e === Un(e) || !sr(e) ? m1(e) : wW(e)
}
function CW(e) {
  var t = e.getBoundingClientRect(),
    n = rl(t.width) / e.offsetWidth || 1,
    r = rl(t.height) / e.offsetHeight || 1
  return n !== 1 || r !== 1
}
function SW(e, t, n) {
  n === void 0 && (n = !1)
  var r = sr(t),
    o = sr(t) && CW(t),
    i = $i(t),
    s = ol(e, o, n),
    a = { scrollLeft: 0, scrollTop: 0 },
    l = { x: 0, y: 0 }
  return (
    (r || (!r && !n)) &&
      ((to(t) !== "body" || v1(i)) && (a = EW(t)),
      sr(t)
        ? ((l = ol(t, !0)), (l.x += t.clientLeft), (l.y += t.clientTop))
        : i && (l.x = g1(i))),
    {
      x: s.left + a.scrollLeft - l.x,
      y: s.top + a.scrollTop - l.y,
      width: s.width,
      height: s.height,
    }
  )
}
function _W(e) {
  var t = new Map(),
    n = new Set(),
    r = []
  e.forEach(function (i) {
    t.set(i.name, i)
  })
  function o(i) {
    n.add(i.name)
    var s = [].concat(i.requires || [], i.requiresIfExists || [])
    s.forEach(function (a) {
      if (!n.has(a)) {
        var l = t.get(a)
        l && o(l)
      }
    }),
      r.push(i)
  }
  return (
    e.forEach(function (i) {
      n.has(i.name) || o(i)
    }),
    r
  )
}
function kW(e) {
  var t = _W(e)
  return BH.reduce(function (n, r) {
    return n.concat(
      t.filter(function (o) {
        return o.phase === r
      })
    )
  }, [])
}
function NW(e) {
  var t
  return function () {
    return (
      t ||
        (t = new Promise(function (n) {
          Promise.resolve().then(function () {
            ;(t = void 0), n(e())
          })
        })),
      t
    )
  }
}
function TW(e) {
  var t = e.reduce(function (n, r) {
    var o = n[r.name]
    return (
      (n[r.name] = o
        ? Object.assign({}, o, r, {
            options: Object.assign({}, o.options, r.options),
            data: Object.assign({}, o.data, r.data),
          })
        : r),
      n
    )
  }, {})
  return Object.keys(t).map(function (n) {
    return t[n]
  })
}
var jC = { placement: "bottom", modifiers: [], strategy: "absolute" }
function FC() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n]
  return !t.some(function (r) {
    return !(r && typeof r.getBoundingClientRect == "function")
  })
}
function MW(e) {
  e === void 0 && (e = {})
  var t = e,
    n = t.defaultModifiers,
    r = n === void 0 ? [] : n,
    o = t.defaultOptions,
    i = o === void 0 ? jC : o
  return function (a, l, c) {
    c === void 0 && (c = i)
    var u = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, jC, i),
        modifiersData: {},
        elements: { reference: a, popper: l },
        attributes: {},
        styles: {},
      },
      d = [],
      f = !1,
      p = {
        state: u,
        setOptions: function (y) {
          var x = typeof y == "function" ? y(u.options) : y
          v(),
            (u.options = Object.assign({}, i, u.options, x)),
            (u.scrollParents = {
              reference: Ms(a)
                ? mc(a)
                : a.contextElement
                  ? mc(a.contextElement)
                  : [],
              popper: mc(l),
            })
          var E = kW(TW([].concat(r, u.options.modifiers)))
          return (
            (u.orderedModifiers = E.filter(function (w) {
              return w.enabled
            })),
            g(),
            p.update()
          )
        },
        forceUpdate: function () {
          if (!f) {
            var y = u.elements,
              x = y.reference,
              E = y.popper
            if (FC(x, E)) {
              ;(u.rects = {
                reference: SW(x, Bu(E), u.options.strategy === "fixed"),
                popper: p1(E),
              }),
                (u.reset = !1),
                (u.placement = u.options.placement),
                u.orderedModifiers.forEach(function (B) {
                  return (u.modifiersData[B.name] = Object.assign({}, B.data))
                })
              for (var w = 0; w < u.orderedModifiers.length; w++) {
                if (u.reset === !0) {
                  ;(u.reset = !1), (w = -1)
                  continue
                }
                var C = u.orderedModifiers[w],
                  S = C.fn,
                  M = C.options,
                  N = M === void 0 ? {} : M,
                  R = C.name
                typeof S == "function" &&
                  (u = S({ state: u, options: N, name: R, instance: p }) || u)
              }
            }
          }
        },
        update: NW(function () {
          return new Promise(function (b) {
            p.forceUpdate(), b(u)
          })
        }),
        destroy: function () {
          v(), (f = !0)
        },
      }
    if (!FC(a, l)) return p
    p.setOptions(c).then(function (b) {
      !f && c.onFirstUpdate && c.onFirstUpdate(b)
    })
    function g() {
      u.orderedModifiers.forEach(function (b) {
        var y = b.name,
          x = b.options,
          E = x === void 0 ? {} : x,
          w = b.effect
        if (typeof w == "function") {
          var C = w({ state: u, name: y, instance: p, options: E }),
            S = function () {}
          d.push(C || S)
        }
      })
    }
    function v() {
      d.forEach(function (b) {
        return b()
      }),
        (d = [])
    }
    return p
  }
}
var OW = [JH, vW, XH, wA, mW, uW, xW, GH, fW],
  AW = MW({ defaultModifiers: OW }),
  RW = "tippy-box",
  MA = "tippy-content",
  IW = "tippy-backdrop",
  OA = "tippy-arrow",
  AA = "tippy-svg-arrow",
  Vi = { passive: !0, capture: !0 },
  RA = function () {
    return document.body
  }
function Lg(e, t, n) {
  if (Array.isArray(e)) {
    var r = e[t]
    return r == null ? (Array.isArray(n) ? n[t] : n) : r
  }
  return e
}
function y1(e, t) {
  var n = {}.toString.call(e)
  return n.indexOf("[object") === 0 && n.indexOf(t + "]") > -1
}
function IA(e, t) {
  return typeof e == "function" ? e.apply(void 0, t) : e
}
function zC(e, t) {
  if (t === 0) return e
  var n
  return function (r) {
    clearTimeout(n),
      (n = setTimeout(function () {
        e(r)
      }, t))
  }
}
function DW(e) {
  return e.split(/\s+/).filter(Boolean)
}
function ra(e) {
  return [].concat(e)
}
function UC(e, t) {
  e.indexOf(t) === -1 && e.push(t)
}
function LW(e) {
  return e.filter(function (t, n) {
    return e.indexOf(t) === n
  })
}
function PW(e) {
  return e.split("-")[0]
}
function mp(e) {
  return [].slice.call(e)
}
function VC(e) {
  return Object.keys(e).reduce(function (t, n) {
    return e[n] !== void 0 && (t[n] = e[n]), t
  }, {})
}
function gc() {
  return document.createElement("div")
}
function hm(e) {
  return ["Element", "Fragment"].some(function (t) {
    return y1(e, t)
  })
}
function $W(e) {
  return y1(e, "NodeList")
}
function BW(e) {
  return y1(e, "MouseEvent")
}
function jW(e) {
  return !!(e && e._tippy && e._tippy.reference === e)
}
function FW(e) {
  return hm(e)
    ? [e]
    : $W(e)
      ? mp(e)
      : Array.isArray(e)
        ? e
        : mp(document.querySelectorAll(e))
}
function Pg(e, t) {
  e.forEach(function (n) {
    n && (n.style.transitionDuration = t + "ms")
  })
}
function HC(e, t) {
  e.forEach(function (n) {
    n && n.setAttribute("data-state", t)
  })
}
function zW(e) {
  var t,
    n = ra(e),
    r = n[0]
  return r != null && (t = r.ownerDocument) != null && t.body
    ? r.ownerDocument
    : document
}
function UW(e, t) {
  var n = t.clientX,
    r = t.clientY
  return e.every(function (o) {
    var i = o.popperRect,
      s = o.popperState,
      a = o.props,
      l = a.interactiveBorder,
      c = PW(s.placement),
      u = s.modifiersData.offset
    if (!u) return !0
    var d = c === "bottom" ? u.top.y : 0,
      f = c === "top" ? u.bottom.y : 0,
      p = c === "right" ? u.left.x : 0,
      g = c === "left" ? u.right.x : 0,
      v = i.top - r + d > l,
      b = r - i.bottom - f > l,
      y = i.left - n + p > l,
      x = n - i.right - g > l
    return v || b || y || x
  })
}
function $g(e, t, n) {
  var r = t + "EventListener"
  ;["transitionend", "webkitTransitionEnd"].forEach(function (o) {
    e[r](o, n)
  })
}
function WC(e, t) {
  for (var n = t; n; ) {
    var r
    if (e.contains(n)) return !0
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host
  }
  return !1
}
var zr = { isTouch: !1 },
  KC = 0
function VW() {
  zr.isTouch ||
    ((zr.isTouch = !0),
    window.performance && document.addEventListener("mousemove", DA))
}
function DA() {
  var e = performance.now()
  e - KC < 20 &&
    ((zr.isTouch = !1), document.removeEventListener("mousemove", DA)),
    (KC = e)
}
function HW() {
  var e = document.activeElement
  if (jW(e)) {
    var t = e._tippy
    e.blur && !t.state.isVisible && e.blur()
  }
}
function WW() {
  document.addEventListener("touchstart", VW, Vi),
    window.addEventListener("blur", HW)
}
var KW = typeof window < "u" && typeof document < "u",
  GW = KW ? !!window.msCrypto : !1,
  qW = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 },
  ZW = {
    allowHTML: !1,
    animation: "fade",
    arrow: !0,
    content: "",
    inertia: !1,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999,
  },
  wr = Object.assign(
    {
      appendTo: RA,
      aria: { content: "auto", expanded: "auto" },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: !0,
      ignoreAttributes: !1,
      interactive: !1,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function () {},
      onBeforeUpdate: function () {},
      onCreate: function () {},
      onDestroy: function () {},
      onHidden: function () {},
      onHide: function () {},
      onMount: function () {},
      onShow: function () {},
      onShown: function () {},
      onTrigger: function () {},
      onUntrigger: function () {},
      onClickOutside: function () {},
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: !1,
      touch: !0,
      trigger: "mouseenter focus",
      triggerTarget: null,
    },
    qW,
    ZW
  ),
  YW = Object.keys(wr),
  XW = function (t) {
    var n = Object.keys(t)
    n.forEach(function (r) {
      wr[r] = t[r]
    })
  }
function LA(e) {
  var t = e.plugins || [],
    n = t.reduce(function (r, o) {
      var i = o.name,
        s = o.defaultValue
      if (i) {
        var a
        r[i] = e[i] !== void 0 ? e[i] : (a = wr[i]) != null ? a : s
      }
      return r
    }, {})
  return Object.assign({}, e, n)
}
function QW(e, t) {
  var n = t ? Object.keys(LA(Object.assign({}, wr, { plugins: t }))) : YW,
    r = n.reduce(function (o, i) {
      var s = (e.getAttribute("data-tippy-" + i) || "").trim()
      if (!s) return o
      if (i === "content") o[i] = s
      else
        try {
          o[i] = JSON.parse(s)
        } catch {
          o[i] = s
        }
      return o
    }, {})
  return r
}
function GC(e, t) {
  var n = Object.assign(
    {},
    t,
    { content: IA(t.content, [e]) },
    t.ignoreAttributes ? {} : QW(e, t.plugins)
  )
  return (
    (n.aria = Object.assign({}, wr.aria, n.aria)),
    (n.aria = {
      expanded: n.aria.expanded === "auto" ? t.interactive : n.aria.expanded,
      content:
        n.aria.content === "auto"
          ? t.interactive
            ? null
            : "describedby"
          : n.aria.content,
    }),
    n
  )
}
var JW = function () {
  return "innerHTML"
}
function zy(e, t) {
  e[JW()] = t
}
function qC(e) {
  var t = gc()
  return (
    e === !0
      ? (t.className = OA)
      : ((t.className = AA), hm(e) ? t.appendChild(e) : zy(t, e)),
    t
  )
}
function ZC(e, t) {
  hm(t.content)
    ? (zy(e, ""), e.appendChild(t.content))
    : typeof t.content != "function" &&
      (t.allowHTML ? zy(e, t.content) : (e.textContent = t.content))
}
function Uy(e) {
  var t = e.firstElementChild,
    n = mp(t.children)
  return {
    box: t,
    content: n.find(function (r) {
      return r.classList.contains(MA)
    }),
    arrow: n.find(function (r) {
      return r.classList.contains(OA) || r.classList.contains(AA)
    }),
    backdrop: n.find(function (r) {
      return r.classList.contains(IW)
    }),
  }
}
function PA(e) {
  var t = gc(),
    n = gc()
  ;(n.className = RW),
    n.setAttribute("data-state", "hidden"),
    n.setAttribute("tabindex", "-1")
  var r = gc()
  ;(r.className = MA),
    r.setAttribute("data-state", "hidden"),
    ZC(r, e.props),
    t.appendChild(n),
    n.appendChild(r),
    o(e.props, e.props)
  function o(i, s) {
    var a = Uy(t),
      l = a.box,
      c = a.content,
      u = a.arrow
    s.theme
      ? l.setAttribute("data-theme", s.theme)
      : l.removeAttribute("data-theme"),
      typeof s.animation == "string"
        ? l.setAttribute("data-animation", s.animation)
        : l.removeAttribute("data-animation"),
      s.inertia
        ? l.setAttribute("data-inertia", "")
        : l.removeAttribute("data-inertia"),
      (l.style.maxWidth =
        typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth),
      s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"),
      (i.content !== s.content || i.allowHTML !== s.allowHTML) &&
        ZC(c, e.props),
      s.arrow
        ? u
          ? i.arrow !== s.arrow &&
            (l.removeChild(u), l.appendChild(qC(s.arrow)))
          : l.appendChild(qC(s.arrow))
        : u && l.removeChild(u)
  }
  return { popper: t, onUpdate: o }
}
PA.$$tippy = !0
var eK = 1,
  Od = [],
  Bg = []
function tK(e, t) {
  var n = GC(e, Object.assign({}, wr, LA(VC(t)))),
    r,
    o,
    i,
    s = !1,
    a = !1,
    l = !1,
    c = !1,
    u,
    d,
    f,
    p = [],
    g = zC(Et, n.interactiveDebounce),
    v,
    b = eK++,
    y = null,
    x = LW(n.plugins),
    E = {
      isEnabled: !0,
      isVisible: !1,
      isDestroyed: !1,
      isMounted: !1,
      isShown: !1,
    },
    w = {
      id: b,
      reference: e,
      popper: gc(),
      popperInstance: y,
      props: n,
      state: E,
      plugins: x,
      clearDelayTimeouts: $,
      setProps: T,
      setContent: L,
      show: K,
      hide: ie,
      hideWithInteractivity: Se,
      enable: F,
      disable: te,
      unmount: an,
      destroy: oo,
    }
  if (!n.render) return w
  var C = n.render(w),
    S = C.popper,
    M = C.onUpdate
  S.setAttribute("data-tippy-root", ""),
    (S.id = "tippy-" + w.id),
    (w.popper = S),
    (e._tippy = w),
    (S._tippy = w)
  var N = x.map(function (z) {
      return z.fn(w)
    }),
    R = e.hasAttribute("aria-expanded")
  return (
    dt(),
    P(),
    O(),
    _("onCreate", [w]),
    n.showOnCreate && k(),
    S.addEventListener("mouseenter", function () {
      w.props.interactive && w.state.isVisible && w.clearDelayTimeouts()
    }),
    S.addEventListener("mouseleave", function () {
      w.props.interactive &&
        w.props.trigger.indexOf("mouseenter") >= 0 &&
        W().addEventListener("mousemove", g)
    }),
    w
  )
  function B() {
    var z = w.props.touch
    return Array.isArray(z) ? z : [z, 0]
  }
  function V() {
    return B()[0] === "hold"
  }
  function j() {
    var z
    return !!((z = w.props.render) != null && z.$$tippy)
  }
  function U() {
    return v || e
  }
  function W() {
    var z = U().parentNode
    return z ? zW(z) : document
  }
  function ee() {
    return Uy(S)
  }
  function I(z) {
    return (w.state.isMounted && !w.state.isVisible) ||
      zr.isTouch ||
      (u && u.type === "focus")
      ? 0
      : Lg(w.props.delay, z ? 0 : 1, wr.delay)
  }
  function O(z) {
    z === void 0 && (z = !1),
      (S.style.pointerEvents = w.props.interactive && !z ? "" : "none"),
      (S.style.zIndex = "" + w.props.zIndex)
  }
  function _(z, de, we) {
    if (
      (we === void 0 && (we = !0),
      N.forEach(function (Ie) {
        Ie[z] && Ie[z].apply(Ie, de)
      }),
      we)
    ) {
      var ze
      ;(ze = w.props)[z].apply(ze, de)
    }
  }
  function A() {
    var z = w.props.aria
    if (z.content) {
      var de = "aria-" + z.content,
        we = S.id,
        ze = ra(w.props.triggerTarget || e)
      ze.forEach(function (Ie) {
        var ln = Ie.getAttribute(de)
        if (w.state.isVisible) Ie.setAttribute(de, ln ? ln + " " + we : we)
        else {
          var Gn = ln && ln.replace(we, "").trim()
          Gn ? Ie.setAttribute(de, Gn) : Ie.removeAttribute(de)
        }
      })
    }
  }
  function P() {
    if (!(R || !w.props.aria.expanded)) {
      var z = ra(w.props.triggerTarget || e)
      z.forEach(function (de) {
        w.props.interactive
          ? de.setAttribute(
              "aria-expanded",
              w.state.isVisible && de === U() ? "true" : "false"
            )
          : de.removeAttribute("aria-expanded")
      })
    }
  }
  function H() {
    W().removeEventListener("mousemove", g),
      (Od = Od.filter(function (z) {
        return z !== g
      }))
  }
  function X(z) {
    if (!(zr.isTouch && (l || z.type === "mousedown"))) {
      var de = (z.composedPath && z.composedPath()[0]) || z.target
      if (!(w.props.interactive && WC(S, de))) {
        if (
          ra(w.props.triggerTarget || e).some(function (we) {
            return WC(we, de)
          })
        ) {
          if (
            zr.isTouch ||
            (w.state.isVisible && w.props.trigger.indexOf("click") >= 0)
          )
            return
        } else _("onClickOutside", [w, z])
        w.props.hideOnClick === !0 &&
          (w.clearDelayTimeouts(),
          w.hide(),
          (a = !0),
          setTimeout(function () {
            a = !1
          }),
          w.state.isMounted || xe())
      }
    }
  }
  function ae() {
    l = !0
  }
  function ve() {
    l = !1
  }
  function he() {
    var z = W()
    z.addEventListener("mousedown", X, !0),
      z.addEventListener("touchend", X, Vi),
      z.addEventListener("touchstart", ve, Vi),
      z.addEventListener("touchmove", ae, Vi)
  }
  function xe() {
    var z = W()
    z.removeEventListener("mousedown", X, !0),
      z.removeEventListener("touchend", X, Vi),
      z.removeEventListener("touchstart", ve, Vi),
      z.removeEventListener("touchmove", ae, Vi)
  }
  function Ae(z, de) {
    Fe(z, function () {
      !w.state.isVisible && S.parentNode && S.parentNode.contains(S) && de()
    })
  }
  function je(z, de) {
    Fe(z, de)
  }
  function Fe(z, de) {
    var we = ee().box
    function ze(Ie) {
      Ie.target === we && ($g(we, "remove", ze), de())
    }
    if (z === 0) return de()
    $g(we, "remove", d), $g(we, "add", ze), (d = ze)
  }
  function Ze(z, de, we) {
    we === void 0 && (we = !1)
    var ze = ra(w.props.triggerTarget || e)
    ze.forEach(function (Ie) {
      Ie.addEventListener(z, de, we),
        p.push({ node: Ie, eventType: z, handler: de, options: we })
    })
  }
  function dt() {
    V() &&
      (Ze("touchstart", ft, { passive: !0 }),
      Ze("touchend", He, { passive: !0 })),
      DW(w.props.trigger).forEach(function (z) {
        if (z !== "manual")
          switch ((Ze(z, ft), z)) {
            case "mouseenter":
              Ze("mouseleave", He)
              break
            case "focus":
              Ze(GW ? "focusout" : "blur", be)
              break
            case "focusin":
              Ze("focusout", be)
              break
          }
      })
  }
  function kt() {
    p.forEach(function (z) {
      var de = z.node,
        we = z.eventType,
        ze = z.handler,
        Ie = z.options
      de.removeEventListener(we, ze, Ie)
    }),
      (p = [])
  }
  function ft(z) {
    var de,
      we = !1
    if (!(!w.state.isEnabled || yt(z) || a)) {
      var ze = ((de = u) == null ? void 0 : de.type) === "focus"
      ;(u = z),
        (v = z.currentTarget),
        P(),
        !w.state.isVisible &&
          BW(z) &&
          Od.forEach(function (Ie) {
            return Ie(z)
          }),
        z.type === "click" &&
        (w.props.trigger.indexOf("mouseenter") < 0 || s) &&
        w.props.hideOnClick !== !1 &&
        w.state.isVisible
          ? (we = !0)
          : k(z),
        z.type === "click" && (s = !we),
        we && !ze && D(z)
    }
  }
  function Et(z) {
    var de = z.target,
      we = U().contains(de) || S.contains(de)
    if (!(z.type === "mousemove" && we)) {
      var ze = fe()
        .concat(S)
        .map(function (Ie) {
          var ln,
            Gn = Ie._tippy,
            zs = (ln = Gn.popperInstance) == null ? void 0 : ln.state
          return zs
            ? {
                popperRect: Ie.getBoundingClientRect(),
                popperState: zs,
                props: n,
              }
            : null
        })
        .filter(Boolean)
      UW(ze, z) && (H(), D(z))
    }
  }
  function He(z) {
    var de = yt(z) || (w.props.trigger.indexOf("click") >= 0 && s)
    if (!de) {
      if (w.props.interactive) {
        w.hideWithInteractivity(z)
        return
      }
      D(z)
    }
  }
  function be(z) {
    ;(w.props.trigger.indexOf("focusin") < 0 && z.target !== U()) ||
      (w.props.interactive && z.relatedTarget && S.contains(z.relatedTarget)) ||
      D(z)
  }
  function yt(z) {
    return zr.isTouch ? V() !== z.type.indexOf("touch") >= 0 : !1
  }
  function ue() {
    me()
    var z = w.props,
      de = z.popperOptions,
      we = z.placement,
      ze = z.offset,
      Ie = z.getReferenceClientRect,
      ln = z.moveTransition,
      Gn = j() ? Uy(S).arrow : null,
      zs = Ie
        ? {
            getBoundingClientRect: Ie,
            contextElement: Ie.contextElement || U(),
          }
        : e,
      lx = {
        name: "$$tippy",
        enabled: !0,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function (Hu) {
          var Us = Hu.state
          if (j()) {
            var VD = ee(),
              Cm = VD.box
            ;["placement", "reference-hidden", "escaped"].forEach(
              function (Wu) {
                Wu === "placement"
                  ? Cm.setAttribute("data-placement", Us.placement)
                  : Us.attributes.popper["data-popper-" + Wu]
                    ? Cm.setAttribute("data-" + Wu, "")
                    : Cm.removeAttribute("data-" + Wu)
              }
            ),
              (Us.attributes.popper = {})
          }
        },
      },
      ji = [
        { name: "offset", options: { offset: ze } },
        {
          name: "preventOverflow",
          options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } },
        },
        { name: "flip", options: { padding: 5 } },
        { name: "computeStyles", options: { adaptive: !ln } },
        lx,
      ]
    j() &&
      Gn &&
      ji.push({ name: "arrow", options: { element: Gn, padding: 3 } }),
      ji.push.apply(ji, (de == null ? void 0 : de.modifiers) || []),
      (w.popperInstance = AW(
        zs,
        S,
        Object.assign({}, de, {
          placement: we,
          onFirstUpdate: f,
          modifiers: ji,
        })
      ))
  }
  function me() {
    w.popperInstance && (w.popperInstance.destroy(), (w.popperInstance = null))
  }
  function $e() {
    var z = w.props.appendTo,
      de,
      we = U()
    ;(w.props.interactive && z === RA) || z === "parent"
      ? (de = we.parentNode)
      : (de = IA(z, [we])),
      de.contains(S) || de.appendChild(S),
      (w.state.isMounted = !0),
      ue()
  }
  function fe() {
    return mp(S.querySelectorAll("[data-tippy-root]"))
  }
  function k(z) {
    w.clearDelayTimeouts(), z && _("onTrigger", [w, z]), he()
    var de = I(!0),
      we = B(),
      ze = we[0],
      Ie = we[1]
    zr.isTouch && ze === "hold" && Ie && (de = Ie),
      de
        ? (r = setTimeout(function () {
            w.show()
          }, de))
        : w.show()
  }
  function D(z) {
    if (
      (w.clearDelayTimeouts(), _("onUntrigger", [w, z]), !w.state.isVisible)
    ) {
      xe()
      return
    }
    if (
      !(
        w.props.trigger.indexOf("mouseenter") >= 0 &&
        w.props.trigger.indexOf("click") >= 0 &&
        ["mouseleave", "mousemove"].indexOf(z.type) >= 0 &&
        s
      )
    ) {
      var de = I(!1)
      de
        ? (o = setTimeout(function () {
            w.state.isVisible && w.hide()
          }, de))
        : (i = requestAnimationFrame(function () {
            w.hide()
          }))
    }
  }
  function F() {
    w.state.isEnabled = !0
  }
  function te() {
    w.hide(), (w.state.isEnabled = !1)
  }
  function $() {
    clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i)
  }
  function T(z) {
    if (!w.state.isDestroyed) {
      _("onBeforeUpdate", [w, z]), kt()
      var de = w.props,
        we = GC(e, Object.assign({}, de, VC(z), { ignoreAttributes: !0 }))
      ;(w.props = we),
        dt(),
        de.interactiveDebounce !== we.interactiveDebounce &&
          (H(), (g = zC(Et, we.interactiveDebounce))),
        de.triggerTarget && !we.triggerTarget
          ? ra(de.triggerTarget).forEach(function (ze) {
              ze.removeAttribute("aria-expanded")
            })
          : we.triggerTarget && e.removeAttribute("aria-expanded"),
        P(),
        O(),
        M && M(de, we),
        w.popperInstance &&
          (ue(),
          fe().forEach(function (ze) {
            requestAnimationFrame(ze._tippy.popperInstance.forceUpdate)
          })),
        _("onAfterUpdate", [w, z])
    }
  }
  function L(z) {
    w.setProps({ content: z })
  }
  function K() {
    var z = w.state.isVisible,
      de = w.state.isDestroyed,
      we = !w.state.isEnabled,
      ze = zr.isTouch && !w.props.touch,
      Ie = Lg(w.props.duration, 0, wr.duration)
    if (
      !(z || de || we || ze) &&
      !U().hasAttribute("disabled") &&
      (_("onShow", [w], !1), w.props.onShow(w) !== !1)
    ) {
      if (
        ((w.state.isVisible = !0),
        j() && (S.style.visibility = "visible"),
        O(),
        he(),
        w.state.isMounted || (S.style.transition = "none"),
        j())
      ) {
        var ln = ee(),
          Gn = ln.box,
          zs = ln.content
        Pg([Gn, zs], 0)
      }
      ;(f = function () {
        var ji
        if (!(!w.state.isVisible || c)) {
          if (
            ((c = !0),
            S.offsetHeight,
            (S.style.transition = w.props.moveTransition),
            j() && w.props.animation)
          ) {
            var Em = ee(),
              Hu = Em.box,
              Us = Em.content
            Pg([Hu, Us], Ie), HC([Hu, Us], "visible")
          }
          A(),
            P(),
            UC(Bg, w),
            (ji = w.popperInstance) == null || ji.forceUpdate(),
            _("onMount", [w]),
            w.props.animation &&
              j() &&
              je(Ie, function () {
                ;(w.state.isShown = !0), _("onShown", [w])
              })
        }
      }),
        $e()
    }
  }
  function ie() {
    var z = !w.state.isVisible,
      de = w.state.isDestroyed,
      we = !w.state.isEnabled,
      ze = Lg(w.props.duration, 1, wr.duration)
    if (!(z || de || we) && (_("onHide", [w], !1), w.props.onHide(w) !== !1)) {
      if (
        ((w.state.isVisible = !1),
        (w.state.isShown = !1),
        (c = !1),
        (s = !1),
        j() && (S.style.visibility = "hidden"),
        H(),
        xe(),
        O(!0),
        j())
      ) {
        var Ie = ee(),
          ln = Ie.box,
          Gn = Ie.content
        w.props.animation && (Pg([ln, Gn], ze), HC([ln, Gn], "hidden"))
      }
      A(), P(), w.props.animation ? j() && Ae(ze, w.unmount) : w.unmount()
    }
  }
  function Se(z) {
    W().addEventListener("mousemove", g), UC(Od, g), g(z)
  }
  function an() {
    w.state.isVisible && w.hide(),
      w.state.isMounted &&
        (me(),
        fe().forEach(function (z) {
          z._tippy.unmount()
        }),
        S.parentNode && S.parentNode.removeChild(S),
        (Bg = Bg.filter(function (z) {
          return z !== w
        })),
        (w.state.isMounted = !1),
        _("onHidden", [w]))
  }
  function oo() {
    w.state.isDestroyed ||
      (w.clearDelayTimeouts(),
      w.unmount(),
      kt(),
      delete e._tippy,
      (w.state.isDestroyed = !0),
      _("onDestroy", [w]))
  }
}
function ju(e, t) {
  t === void 0 && (t = {})
  var n = wr.plugins.concat(t.plugins || [])
  WW()
  var r = Object.assign({}, t, { plugins: n }),
    o = FW(e),
    i = o.reduce(function (s, a) {
      var l = a && tK(a, r)
      return l && s.push(l), s
    }, [])
  return hm(e) ? i[0] : i
}
ju.defaultProps = wr
ju.setDefaultProps = XW
ju.currentInput = zr
Object.assign({}, wA, {
  effect: function (t) {
    var n = t.state,
      r = {
        popper: {
          position: n.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      }
    Object.assign(n.elements.popper.style, r.popper),
      (n.styles = r),
      n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow)
  },
})
ju.setDefaultProps({ render: PA })
class nK {
  constructor({
    editor: t,
    element: n,
    view: r,
    tippyOptions: o = {},
    updateDelay: i = 250,
    shouldShow: s,
  }) {
    ;(this.preventHide = !1),
      (this.shouldShow = ({ view: a, state: l, from: c, to: u }) => {
        const { doc: d, selection: f } = l,
          { empty: p } = f,
          g = !d.textBetween(c, u).length && l1(l.selection),
          v = this.element.contains(document.activeElement)
        return !(!(a.hasFocus() || v) || p || g || !this.editor.isEditable)
      }),
      (this.mousedownHandler = () => {
        this.preventHide = !0
      }),
      (this.dragstartHandler = () => {
        this.hide()
      }),
      (this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view))
      }),
      (this.blurHandler = ({ event: a }) => {
        var l
        if (this.preventHide) {
          this.preventHide = !1
          return
        }
        ;(a != null &&
          a.relatedTarget &&
          !((l = this.element.parentNode) === null || l === void 0) &&
          l.contains(a.relatedTarget)) ||
          ((a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom &&
            this.hide())
      }),
      (this.tippyBlurHandler = (a) => {
        this.blurHandler({ event: a })
      }),
      (this.handleDebouncedUpdate = (a, l) => {
        const c = !(l != null && l.selection.eq(a.state.selection)),
          u = !(l != null && l.doc.eq(a.state.doc))
        ;(!c && !u) ||
          (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer),
          (this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(a, c, u, l)
          }, this.updateDelay)))
      }),
      (this.updateHandler = (a, l, c, u) => {
        var d, f, p
        const { state: g, composing: v } = a,
          { selection: b } = g
        if (v || (!l && !c)) return
        this.createTooltip()
        const { ranges: x } = b,
          E = Math.min(...x.map((S) => S.$from.pos)),
          w = Math.max(...x.map((S) => S.$to.pos))
        if (
          !((d = this.shouldShow) === null || d === void 0
            ? void 0
            : d.call(this, {
                editor: this.editor,
                element: this.element,
                view: a,
                state: g,
                oldState: u,
                from: E,
                to: w,
              }))
        ) {
          this.hide()
          return
        }
        ;(f = this.tippy) === null ||
          f === void 0 ||
          f.setProps({
            getReferenceClientRect:
              ((p = this.tippyOptions) === null || p === void 0
                ? void 0
                : p.getReferenceClientRect) ||
              (() => {
                if (vA(g.selection)) {
                  let S = a.nodeDOM(E)
                  if (S) {
                    const M = S.dataset.nodeViewWrapper
                      ? S
                      : S.querySelector("[data-node-view-wrapper]")
                    if ((M && (S = M.firstChild), S))
                      return S.getBoundingClientRect()
                  }
                }
                return qV(a, E, w)
              }),
          }),
          this.show()
      }),
      (this.editor = t),
      (this.element = n),
      (this.view = r),
      (this.updateDelay = i),
      s && (this.shouldShow = s),
      this.element.addEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.addEventListener("dragstart", this.dragstartHandler),
      this.editor.on("focus", this.focusHandler),
      this.editor.on("blur", this.blurHandler),
      (this.tippyOptions = o),
      this.element.remove(),
      (this.element.style.visibility = "visible")
  }
  createTooltip() {
    const { element: t } = this.editor.options,
      n = !!t.parentElement
    this.tippy ||
      !n ||
      ((this.tippy = ju(t, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: !0,
        trigger: "manual",
        placement: "top",
        hideOnClick: "toggle",
        ...this.tippyOptions,
      })),
      this.tippy.popper.firstChild &&
        this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ))
  }
  update(t, n) {
    const { state: r } = t,
      o = r.selection.from !== r.selection.to
    if (this.updateDelay > 0 && o) {
      this.handleDebouncedUpdate(t, n)
      return
    }
    const i = !(n != null && n.selection.eq(t.state.selection)),
      s = !(n != null && n.doc.eq(t.state.doc))
    this.updateHandler(t, i, s, n)
  }
  show() {
    var t
    ;(t = this.tippy) === null || t === void 0 || t.show()
  }
  hide() {
    var t
    ;(t = this.tippy) === null || t === void 0 || t.hide()
  }
  destroy() {
    var t, n
    !((t = this.tippy) === null || t === void 0) &&
      t.popper.firstChild &&
      this.tippy.popper.firstChild.removeEventListener(
        "blur",
        this.tippyBlurHandler
      ),
      (n = this.tippy) === null || n === void 0 || n.destroy(),
      this.element.removeEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler),
      this.editor.off("focus", this.focusHandler),
      this.editor.off("blur", this.blurHandler)
  }
}
const $A = (e) =>
  new rt({
    key: typeof e.pluginKey == "string" ? new At(e.pluginKey) : e.pluginKey,
    view: (t) => new nK({ view: t, ...e }),
  })
ct.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null,
    }
  },
  addProseMirrorPlugins() {
    return this.options.element
      ? [
          $A({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow,
          }),
        ]
      : []
  },
})
function rK(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e
}
var BA = { exports: {} },
  jg = {}
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var YC
function oK() {
  if (YC) return jg
  YC = 1
  var e = G
  function t(d, f) {
    return (d === f && (d !== 0 || 1 / d === 1 / f)) || (d !== d && f !== f)
  }
  var n = typeof Object.is == "function" ? Object.is : t,
    r = e.useState,
    o = e.useEffect,
    i = e.useLayoutEffect,
    s = e.useDebugValue
  function a(d, f) {
    var p = f(),
      g = r({ inst: { value: p, getSnapshot: f } }),
      v = g[0].inst,
      b = g[1]
    return (
      i(
        function () {
          ;(v.value = p), (v.getSnapshot = f), l(v) && b({ inst: v })
        },
        [d, p, f]
      ),
      o(
        function () {
          return (
            l(v) && b({ inst: v }),
            d(function () {
              l(v) && b({ inst: v })
            })
          )
        },
        [d]
      ),
      s(p),
      p
    )
  }
  function l(d) {
    var f = d.getSnapshot
    d = d.value
    try {
      var p = f()
      return !n(d, p)
    } catch {
      return !0
    }
  }
  function c(d, f) {
    return f()
  }
  var u =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? c
      : a
  return (
    (jg.useSyncExternalStore =
      e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u),
    jg
  )
}
BA.exports = oK()
var b1 = BA.exports
const iK =
    (...e) =>
    (t) => {
      e.forEach((n) => {
        typeof n == "function" ? n(t) : n && (n.current = t)
      })
    },
  sK = ({ contentComponent: e }) => {
    const t = b1.useSyncExternalStore(
      e.subscribe,
      e.getSnapshot,
      e.getServerSnapshot
    )
    return G.createElement(G.Fragment, null, Object.values(t))
  }
function aK() {
  const e = new Set()
  let t = {}
  return {
    subscribe(n) {
      return (
        e.add(n),
        () => {
          e.delete(n)
        }
      )
    },
    getSnapshot() {
      return t
    },
    getServerSnapshot() {
      return t
    },
    setRenderer(n, r) {
      ;(t = { ...t, [n]: vh.createPortal(r.reactElement, r.element, n) }),
        e.forEach((o) => o())
    },
    removeRenderer(n) {
      const r = { ...t }
      delete r[n], (t = r), e.forEach((o) => o())
    },
  }
}
class lK extends G.Component {
  constructor(t) {
    var n
    super(t),
      (this.editorContentRef = G.createRef()),
      (this.initialized = !1),
      (this.state = {
        hasContentComponentInitialized: !!(
          !((n = t.editor) === null || n === void 0) && n.contentComponent
        ),
      })
  }
  componentDidMount() {
    this.init()
  }
  componentDidUpdate() {
    this.init()
  }
  init() {
    const t = this.props.editor
    if (t && !t.isDestroyed && t.options.element) {
      if (t.contentComponent) return
      const n = this.editorContentRef.current
      n.append(...t.options.element.childNodes),
        t.setOptions({ element: n }),
        (t.contentComponent = aK()),
        this.state.hasContentComponentInitialized ||
          (this.unsubscribeToContentComponent = t.contentComponent.subscribe(
            () => {
              this.setState((r) =>
                r.hasContentComponentInitialized
                  ? r
                  : { hasContentComponentInitialized: !0 }
              ),
                this.unsubscribeToContentComponent &&
                  this.unsubscribeToContentComponent()
            }
          )),
        t.createNodeViews(),
        (this.initialized = !0)
    }
  }
  componentWillUnmount() {
    const t = this.props.editor
    if (
      !t ||
      ((this.initialized = !1),
      t.isDestroyed || t.view.setProps({ nodeViews: {} }),
      this.unsubscribeToContentComponent &&
        this.unsubscribeToContentComponent(),
      (t.contentComponent = null),
      !t.options.element.firstChild)
    )
      return
    const n = document.createElement("div")
    n.append(...t.options.element.childNodes), t.setOptions({ element: n })
  }
  render() {
    const { editor: t, innerRef: n, ...r } = this.props
    return G.createElement(
      G.Fragment,
      null,
      G.createElement("div", { ref: iK(n, this.editorContentRef), ...r }),
      (t == null ? void 0 : t.contentComponent) &&
        G.createElement(sK, { contentComponent: t.contentComponent })
    )
  }
}
const cK = m.forwardRef((e, t) => {
    const n = G.useMemo(
      () => Math.floor(Math.random() * 4294967295).toString(),
      [e.editor]
    )
    return G.createElement(lK, { key: n, innerRef: t, ...e })
  }),
  uK = G.memo(cK)
var dK = function e(t, n) {
    if (t === n) return !0
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1
      var r, o, i
      if (Array.isArray(t)) {
        if (((r = t.length), r != n.length)) return !1
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1
        return !0
      }
      if (t instanceof Map && n instanceof Map) {
        if (t.size !== n.size) return !1
        for (o of t.entries()) if (!n.has(o[0])) return !1
        for (o of t.entries()) if (!e(o[1], n.get(o[0]))) return !1
        return !0
      }
      if (t instanceof Set && n instanceof Set) {
        if (t.size !== n.size) return !1
        for (o of t.entries()) if (!n.has(o[0])) return !1
        return !0
      }
      if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
        if (((r = t.length), r != n.length)) return !1
        for (o = r; o-- !== 0; ) if (t[o] !== n[o]) return !1
        return !0
      }
      if (t.constructor === RegExp)
        return t.source === n.source && t.flags === n.flags
      if (t.valueOf !== Object.prototype.valueOf)
        return t.valueOf() === n.valueOf()
      if (t.toString !== Object.prototype.toString)
        return t.toString() === n.toString()
      if (((i = Object.keys(t)), (r = i.length), r !== Object.keys(n).length))
        return !1
      for (o = r; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1
      for (o = r; o-- !== 0; ) {
        var s = i[o]
        if (!(s === "_owner" && t.$$typeof) && !e(t[s], n[s])) return !1
      }
      return !0
    }
    return t !== t && n !== n
  },
  fK = rK(dK),
  jA = { exports: {} },
  Fg = {}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var XC
function pK() {
  if (XC) return Fg
  XC = 1
  var e = G,
    t = b1
  function n(c, u) {
    return (c === u && (c !== 0 || 1 / c === 1 / u)) || (c !== c && u !== u)
  }
  var r = typeof Object.is == "function" ? Object.is : n,
    o = t.useSyncExternalStore,
    i = e.useRef,
    s = e.useEffect,
    a = e.useMemo,
    l = e.useDebugValue
  return (
    (Fg.useSyncExternalStoreWithSelector = function (c, u, d, f, p) {
      var g = i(null)
      if (g.current === null) {
        var v = { hasValue: !1, value: null }
        g.current = v
      } else v = g.current
      g = a(
        function () {
          function y(S) {
            if (!x) {
              if (((x = !0), (E = S), (S = f(S)), p !== void 0 && v.hasValue)) {
                var M = v.value
                if (p(M, S)) return (w = M)
              }
              return (w = S)
            }
            if (((M = w), r(E, S))) return M
            var N = f(S)
            return p !== void 0 && p(M, N) ? M : ((E = S), (w = N))
          }
          var x = !1,
            E,
            w,
            C = d === void 0 ? null : d
          return [
            function () {
              return y(u())
            },
            C === null
              ? void 0
              : function () {
                  return y(C())
                },
          ]
        },
        [u, d, f, p]
      )
      var b = o(c, g[0], g[1])
      return (
        s(
          function () {
            ;(v.hasValue = !0), (v.value = b)
          },
          [b]
        ),
        l(b),
        b
      )
    }),
    Fg
  )
}
jA.exports = pK()
var hK = jA.exports
const mK = typeof window < "u" ? m.useLayoutEffect : m.useEffect
class gK {
  constructor(t) {
    ;(this.transactionNumber = 0),
      (this.lastTransactionNumber = 0),
      (this.subscribers = new Set()),
      (this.editor = t),
      (this.lastSnapshot = { editor: t, transactionNumber: 0 }),
      (this.getSnapshot = this.getSnapshot.bind(this)),
      (this.getServerSnapshot = this.getServerSnapshot.bind(this)),
      (this.watch = this.watch.bind(this)),
      (this.subscribe = this.subscribe.bind(this))
  }
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber
      ? this.lastSnapshot
      : ((this.lastTransactionNumber = this.transactionNumber),
        (this.lastSnapshot = {
          editor: this.editor,
          transactionNumber: this.transactionNumber,
        }),
        this.lastSnapshot)
  }
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 }
  }
  subscribe(t) {
    return (
      this.subscribers.add(t),
      () => {
        this.subscribers.delete(t)
      }
    )
  }
  watch(t) {
    if (((this.editor = t), this.editor)) {
      const n = () => {
          ;(this.transactionNumber += 1), this.subscribers.forEach((o) => o())
        },
        r = this.editor
      return (
        r.on("transaction", n),
        () => {
          r.off("transaction", n)
        }
      )
    }
  }
}
function vK(e) {
  var t
  const [n] = m.useState(() => new gK(e.editor)),
    r = hK.useSyncExternalStoreWithSelector(
      n.subscribe,
      n.getSnapshot,
      n.getServerSnapshot,
      e.selector,
      (t = e.equalityFn) !== null && t !== void 0 ? t : fK
    )
  return mK(() => n.watch(e.editor), [e.editor, n]), m.useDebugValue(r), r
}
const yK = !1,
  Vy = typeof window > "u",
  bK = Vy || !!(typeof window < "u" && window.next)
class x1 {
  constructor(t) {
    ;(this.editor = null),
      (this.subscriptions = new Set()),
      (this.isComponentMounted = !1),
      (this.previousDeps = null),
      (this.instanceId = ""),
      (this.options = t),
      (this.subscriptions = new Set()),
      this.setEditor(this.getInitialEditor()),
      this.scheduleDestroy(),
      (this.getEditor = this.getEditor.bind(this)),
      (this.getServerSnapshot = this.getServerSnapshot.bind(this)),
      (this.subscribe = this.subscribe.bind(this)),
      (this.refreshEditorInstance = this.refreshEditorInstance.bind(this)),
      (this.scheduleDestroy = this.scheduleDestroy.bind(this)),
      (this.onRender = this.onRender.bind(this)),
      (this.createEditor = this.createEditor.bind(this))
  }
  setEditor(t) {
    ;(this.editor = t),
      (this.instanceId = Math.random().toString(36).slice(2, 9)),
      this.subscriptions.forEach((n) => n())
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0)
      return Vy || bK ? null : this.createEditor()
    if (this.options.current.immediatelyRender && Vy && yK)
      throw new Error(
        "Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches."
      )
    return this.options.current.immediatelyRender ? this.createEditor() : null
  }
  createEditor() {
    const t = {
      ...this.options.current,
      onBeforeCreate: (...r) => {
        var o, i
        return (i = (o = this.options.current).onBeforeCreate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onBlur: (...r) => {
        var o, i
        return (i = (o = this.options.current).onBlur) === null || i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onCreate: (...r) => {
        var o, i
        return (i = (o = this.options.current).onCreate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onDestroy: (...r) => {
        var o, i
        return (i = (o = this.options.current).onDestroy) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onFocus: (...r) => {
        var o, i
        return (i = (o = this.options.current).onFocus) === null || i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onSelectionUpdate: (...r) => {
        var o, i
        return (i = (o = this.options.current).onSelectionUpdate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onTransaction: (...r) => {
        var o, i
        return (i = (o = this.options.current).onTransaction) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onUpdate: (...r) => {
        var o, i
        return (i = (o = this.options.current).onUpdate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onContentError: (...r) => {
        var o, i
        return (i = (o = this.options.current).onContentError) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onDrop: (...r) => {
        var o, i
        return (i = (o = this.options.current).onDrop) === null || i === void 0
          ? void 0
          : i.call(o, ...r)
      },
      onPaste: (...r) => {
        var o, i
        return (i = (o = this.options.current).onPaste) === null || i === void 0
          ? void 0
          : i.call(o, ...r)
      },
    }
    return new _H(t)
  }
  getEditor() {
    return this.editor
  }
  getServerSnapshot() {
    return null
  }
  subscribe(t) {
    return (
      this.subscriptions.add(t),
      () => {
        this.subscriptions.delete(t)
      }
    )
  }
  static compareOptions(t, n) {
    return Object.keys(t).every((r) =>
      [
        "onCreate",
        "onBeforeCreate",
        "onDestroy",
        "onUpdate",
        "onTransaction",
        "onFocus",
        "onBlur",
        "onSelectionUpdate",
        "onContentError",
        "onDrop",
        "onPaste",
      ].includes(r)
        ? !0
        : r === "extensions" && t.extensions && n.extensions
          ? t.extensions.length !== n.extensions.length
            ? !1
            : t.extensions.every((o, i) => {
                var s
                return (
                  o ===
                  ((s = n.extensions) === null || s === void 0 ? void 0 : s[i])
                )
              })
          : t[r] === n[r]
    )
  }
  onRender(t) {
    return () => (
      (this.isComponentMounted = !0),
      clearTimeout(this.scheduledDestructionTimeout),
      this.editor && !this.editor.isDestroyed && t.length === 0
        ? x1.compareOptions(this.options.current, this.editor.options) ||
          this.editor.setOptions({
            ...this.options.current,
            editable: this.editor.isEditable,
          })
        : this.refreshEditorInstance(t),
      () => {
        ;(this.isComponentMounted = !1), this.scheduleDestroy()
      }
    )
  }
  refreshEditorInstance(t) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = t
        return
      }
      if (
        this.previousDeps.length === t.length &&
        this.previousDeps.every((r, o) => r === t[o])
      )
        return
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(),
      this.setEditor(this.createEditor()),
      (this.previousDeps = t)
  }
  scheduleDestroy() {
    const t = this.instanceId,
      n = this.editor
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === t) {
        n && n.setOptions(this.options.current)
        return
      }
      n &&
        !n.isDestroyed &&
        (n.destroy(), this.instanceId === t && this.setEditor(null))
    }, 1)
  }
}
function xK(e = {}, t = []) {
  const n = m.useRef(e)
  n.current = e
  const [r] = m.useState(() => new x1(n)),
    o = b1.useSyncExternalStore(r.subscribe, r.getEditor, r.getServerSnapshot)
  return (
    m.useDebugValue(o),
    m.useEffect(r.onRender(t)),
    vK({
      editor: o,
      selector: ({ transactionNumber: i }) =>
        e.shouldRerenderOnTransaction === !1
          ? null
          : e.immediatelyRender && i === 0
            ? 0
            : i + 1,
    }),
    o
  )
}
const FA = m.createContext({ editor: null })
FA.Consumer
const wK = () => m.useContext(FA),
  EK = (e) => {
    const [t, n] = m.useState(null),
      { editor: r } = wK()
    return (
      m.useEffect(() => {
        var o
        if (
          !t ||
          (!((o = e.editor) === null || o === void 0) && o.isDestroyed) ||
          (r != null && r.isDestroyed)
        )
          return
        const {
            pluginKey: i = "bubbleMenu",
            editor: s,
            tippyOptions: a = {},
            updateDelay: l,
            shouldShow: c = null,
          } = e,
          u = s || r
        if (!u) {
          console.warn(
            "BubbleMenu component is not rendered inside of an editor component or does not have editor prop."
          )
          return
        }
        const d = $A({
          updateDelay: l,
          editor: u,
          element: t,
          pluginKey: i,
          shouldShow: c,
          tippyOptions: a,
        })
        return (
          u.registerPlugin(d),
          () => {
            u.unregisterPlugin(i)
          }
        )
      }, [e.editor, r, t]),
      G.createElement(
        "div",
        { ref: n, className: e.className, style: { visibility: "hidden" } },
        e.children
      )
    )
  },
  zA = m.createContext({ onDragStart: void 0 }),
  CK = () => m.useContext(zA),
  SK = G.forwardRef((e, t) => {
    const { onDragStart: n } = CK(),
      r = e.as || "div"
    return G.createElement(r, {
      ...e,
      ref: t,
      "data-node-view-wrapper": "",
      onDragStart: n,
      style: { whiteSpace: "normal", ...e.style },
    })
  })
function _K(e) {
  return !!(
    typeof e == "function" &&
    e.prototype &&
    e.prototype.isReactComponent
  )
}
function kK(e) {
  var t
  return (
    typeof e == "object" &&
    ((t = e.$$typeof) === null || t === void 0 ? void 0 : t.toString()) ===
      "Symbol(react.forward_ref)"
  )
}
class NK {
  constructor(
    t,
    { editor: n, props: r = {}, as: o = "div", className: i = "" }
  ) {
    ;(this.ref = null),
      (this.id = Math.floor(Math.random() * 4294967295).toString()),
      (this.component = t),
      (this.editor = n),
      (this.props = r),
      (this.element = document.createElement(o)),
      this.element.classList.add("react-renderer"),
      i && this.element.classList.add(...i.split(" ")),
      this.editor.isInitialized
        ? Rs.flushSync(() => {
            this.render()
          })
        : this.render()
  }
  render() {
    var t
    const n = this.component,
      r = this.props,
      o = this.editor
    ;(_K(n) || kK(n)) &&
      (r.ref = (i) => {
        this.ref = i
      }),
      (this.reactElement = G.createElement(n, { ...r })),
      (t = o == null ? void 0 : o.contentComponent) === null ||
        t === void 0 ||
        t.setRenderer(this.id, this)
  }
  updateProps(t = {}) {
    ;(this.props = { ...this.props, ...t }), this.render()
  }
  destroy() {
    var t
    const n = this.editor
    ;(t = n == null ? void 0 : n.contentComponent) === null ||
      t === void 0 ||
      t.removeRenderer(this.id)
  }
  updateAttributes(t) {
    Object.keys(t).forEach((n) => {
      this.element.setAttribute(n, t[n])
    })
  }
}
class TK extends kH {
  mount() {
    const t = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (c = {}) => this.updateAttributes(c),
      deleteNode: () => this.deleteNode(),
    }
    if (!this.component.displayName) {
      const c = (u) => u.charAt(0).toUpperCase() + u.substring(1)
      this.component.displayName = c(this.extension.name)
    }
    const o = {
        onDragStart: this.onDragStart.bind(this),
        nodeViewContentRef: (c) => {
          c &&
            this.contentDOMElement &&
            c.firstChild !== this.contentDOMElement &&
            c.appendChild(this.contentDOMElement)
        },
      },
      i = this.component,
      s = G.memo((c) =>
        G.createElement(zA.Provider, { value: o }, G.createElement(i, c))
      )
    ;(s.displayName = "ReactNodeView"),
      this.node.isLeaf
        ? (this.contentDOMElement = null)
        : this.options.contentDOMElementTag
          ? (this.contentDOMElement = document.createElement(
              this.options.contentDOMElementTag
            ))
          : (this.contentDOMElement = document.createElement(
              this.node.isInline ? "span" : "div"
            )),
      this.contentDOMElement &&
        ((this.contentDOMElement.dataset.nodeViewContentReact = ""),
        (this.contentDOMElement.style.whiteSpace = "inherit"))
    let a = this.node.isInline ? "span" : "div"
    this.options.as && (a = this.options.as)
    const { className: l = "" } = this.options
    ;(this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)),
      (this.renderer = new NK(s, {
        editor: this.editor,
        props: t,
        as: a,
        className: `node-${this.node.type.name} ${l}`.trim(),
      })),
      this.editor.on("selectionUpdate", this.handleSelectionUpdate),
      this.updateElementAttributes()
  }
  get dom() {
    var t
    if (
      this.renderer.element.firstElementChild &&
      !(
        !(
          (t = this.renderer.element.firstElementChild) === null || t === void 0
        ) && t.hasAttribute("data-node-view-wrapper")
      )
    )
      throw Error(
        "Please use the NodeViewWrapper component for your node view."
      )
    return this.renderer.element
  }
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement
  }
  handleSelectionUpdate() {
    const { from: t, to: n } = this.editor.state.selection,
      r = this.getPos()
    if (typeof r == "number")
      if (t <= r && n >= r + this.node.nodeSize) {
        if (this.renderer.props.selected) return
        this.selectNode()
      } else {
        if (!this.renderer.props.selected) return
        this.deselectNode()
      }
  }
  update(t, n, r) {
    const o = (i) => {
      this.renderer.updateProps(i),
        typeof this.options.attrs == "function" &&
          this.updateElementAttributes()
    }
    if (t.type !== this.node.type) return !1
    if (typeof this.options.update == "function") {
      const i = this.node,
        s = this.decorations,
        a = this.innerDecorations
      return (
        (this.node = t),
        (this.decorations = n),
        (this.innerDecorations = r),
        this.options.update({
          oldNode: i,
          oldDecorations: s,
          newNode: t,
          newDecorations: n,
          oldInnerDecorations: a,
          innerDecorations: r,
          updateProps: () =>
            o({ node: t, decorations: n, innerDecorations: r }),
        })
      )
    }
    return (
      (t === this.node &&
        this.decorations === n &&
        this.innerDecorations === r) ||
        ((this.node = t),
        (this.decorations = n),
        (this.innerDecorations = r),
        o({ node: t, decorations: n, innerDecorations: r })),
      !0
    )
  }
  selectNode() {
    this.renderer.updateProps({ selected: !0 }),
      this.renderer.element.classList.add("ProseMirror-selectednode")
  }
  deselectNode() {
    this.renderer.updateProps({ selected: !1 }),
      this.renderer.element.classList.remove("ProseMirror-selectednode")
  }
  destroy() {
    this.renderer.destroy(),
      this.editor.off("selectionUpdate", this.handleSelectionUpdate),
      (this.contentDOMElement = null)
  }
  updateElementAttributes() {
    if (this.options.attrs) {
      let t = {}
      if (typeof this.options.attrs == "function") {
        const n = this.editor.extensionManager.attributes,
          r = dp(this.node, n)
        t = this.options.attrs({ node: this.node, HTMLAttributes: r })
      } else t = this.options.attrs
      this.renderer.updateAttributes(t)
    }
  }
}
function MK(e, t) {
  return (n) => (n.editor.contentComponent ? new TK(e, n, t) : {})
}
function ut(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    o,
    i
  for (i = 0; i < r.length; i++)
    (o = r[i]), !(t.indexOf(o) >= 0) && (n[o] = e[o])
  return n
}
var OK = ["color"],
  Fu = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, OK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  AK = ["color"],
  RK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, AK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  IK = ["color"],
  DK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, IK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M5 2V1H10V2H5ZM4.75 0C4.33579 0 4 0.335786 4 0.75V1H3.5C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H7V13H3.5C3.22386 13 3 12.7761 3 12.5V2.5C3 2.22386 3.22386 2 3.5 2H4V2.25C4 2.66421 4.33579 3 4.75 3H10.25C10.6642 3 11 2.66421 11 2.25V2H11.5C11.7761 2 12 2.22386 12 2.5V7H13V2.5C13 1.67157 12.3284 1 11.5 1H11V0.75C11 0.335786 10.6642 0 10.25 0H4.75ZM9 8.5C9 8.77614 8.77614 9 8.5 9C8.22386 9 8 8.77614 8 8.5C8 8.22386 8.22386 8 8.5 8C8.77614 8 9 8.22386 9 8.5ZM10.5 9C10.7761 9 11 8.77614 11 8.5C11 8.22386 10.7761 8 10.5 8C10.2239 8 10 8.22386 10 8.5C10 8.77614 10.2239 9 10.5 9ZM13 8.5C13 8.77614 12.7761 9 12.5 9C12.2239 9 12 8.77614 12 8.5C12 8.22386 12.2239 8 12.5 8C12.7761 8 13 8.22386 13 8.5ZM14.5 9C14.7761 9 15 8.77614 15 8.5C15 8.22386 14.7761 8 14.5 8C14.2239 8 14 8.22386 14 8.5C14 8.77614 14.2239 9 14.5 9ZM15 10.5C15 10.7761 14.7761 11 14.5 11C14.2239 11 14 10.7761 14 10.5C14 10.2239 14.2239 10 14.5 10C14.7761 10 15 10.2239 15 10.5ZM14.5 13C14.7761 13 15 12.7761 15 12.5C15 12.2239 14.7761 12 14.5 12C14.2239 12 14 12.2239 14 12.5C14 12.7761 14.2239 13 14.5 13ZM14.5 15C14.7761 15 15 14.7761 15 14.5C15 14.2239 14.7761 14 14.5 14C14.2239 14 14 14.2239 14 14.5C14 14.7761 14.2239 15 14.5 15ZM8.5 11C8.77614 11 9 10.7761 9 10.5C9 10.2239 8.77614 10 8.5 10C8.22386 10 8 10.2239 8 10.5C8 10.7761 8.22386 11 8.5 11ZM9 12.5C9 12.7761 8.77614 13 8.5 13C8.22386 13 8 12.7761 8 12.5C8 12.2239 8.22386 12 8.5 12C8.77614 12 9 12.2239 9 12.5ZM8.5 15C8.77614 15 9 14.7761 9 14.5C9 14.2239 8.77614 14 8.5 14C8.22386 14 8 14.2239 8 14.5C8 14.7761 8.22386 15 8.5 15ZM11 14.5C11 14.7761 10.7761 15 10.5 15C10.2239 15 10 14.7761 10 14.5C10 14.2239 10.2239 14 10.5 14C10.7761 14 11 14.2239 11 14.5ZM12.5 15C12.7761 15 13 14.7761 13 14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5C12 14.7761 12.2239 15 12.5 15Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  LK = ["color"],
  UA = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, LK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M9.96424 2.68571C10.0668 2.42931 9.94209 2.13833 9.6857 2.03577C9.4293 1.93322 9.13832 2.05792 9.03576 2.31432L5.03576 12.3143C4.9332 12.5707 5.05791 12.8617 5.3143 12.9642C5.5707 13.0668 5.86168 12.9421 5.96424 12.6857L9.96424 2.68571ZM3.85355 5.14646C4.04882 5.34172 4.04882 5.6583 3.85355 5.85356L2.20711 7.50001L3.85355 9.14646C4.04882 9.34172 4.04882 9.6583 3.85355 9.85356C3.65829 10.0488 3.34171 10.0488 3.14645 9.85356L1.14645 7.85356C0.951184 7.6583 0.951184 7.34172 1.14645 7.14646L3.14645 5.14646C3.34171 4.9512 3.65829 4.9512 3.85355 5.14646ZM11.1464 5.14646C11.3417 4.9512 11.6583 4.9512 11.8536 5.14646L13.8536 7.14646C14.0488 7.34172 14.0488 7.6583 13.8536 7.85356L11.8536 9.85356C11.6583 10.0488 11.3417 10.0488 11.1464 9.85356C10.9512 9.6583 10.9512 9.34172 11.1464 9.14646L12.7929 7.50001L11.1464 5.85356C10.9512 5.6583 10.9512 5.34172 11.1464 5.14646Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  PK = ["color"],
  $K = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, PK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  BK = ["color"],
  jK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, BK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  FK = ["color"],
  VA = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, FK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  zK = ["color"],
  UK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, zK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M7.50005 1.04999C7.74858 1.04999 7.95005 1.25146 7.95005 1.49999V8.41359L10.1819 6.18179C10.3576 6.00605 10.6425 6.00605 10.8182 6.18179C10.994 6.35753 10.994 6.64245 10.8182 6.81819L7.81825 9.81819C7.64251 9.99392 7.35759 9.99392 7.18185 9.81819L4.18185 6.81819C4.00611 6.64245 4.00611 6.35753 4.18185 6.18179C4.35759 6.00605 4.64251 6.00605 4.81825 6.18179L7.05005 8.41359V1.49999C7.05005 1.25146 7.25152 1.04999 7.50005 1.04999ZM2.5 10C2.77614 10 3 10.2239 3 10.5V12C3 12.5539 3.44565 13 3.99635 13H11.0012C11.5529 13 12 12.5528 12 12V10.5C12 10.2239 12.2239 10 12.5 10C12.7761 10 13 10.2239 13 10.5V12C13 13.1041 12.1062 14 11.0012 14H3.99635C2.89019 14 2 13.103 2 12V10.5C2 10.2239 2.22386 10 2.5 10Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  VK = ["color"],
  HK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, VK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M3 2C2.44772 2 2 2.44772 2 3V12C2 12.5523 2.44772 13 3 13H12C12.5523 13 13 12.5523 13 12V8.5C13 8.22386 12.7761 8 12.5 8C12.2239 8 12 8.22386 12 8.5V12H3V3L6.5 3C6.77614 3 7 2.77614 7 2.5C7 2.22386 6.77614 2 6.5 2H3ZM12.8536 2.14645C12.9015 2.19439 12.9377 2.24964 12.9621 2.30861C12.9861 2.36669 12.9996 2.4303 13 2.497L13 2.5V2.50049V5.5C13 5.77614 12.7761 6 12.5 6C12.2239 6 12 5.77614 12 5.5V3.70711L6.85355 8.85355C6.65829 9.04882 6.34171 9.04882 6.14645 8.85355C5.95118 8.65829 5.95118 8.34171 6.14645 8.14645L11.2929 3H9.5C9.22386 3 9 2.77614 9 2.5C9 2.22386 9.22386 2 9.5 2H12.4999H12.5C12.5678 2 12.6324 2.01349 12.6914 2.03794C12.7504 2.06234 12.8056 2.09851 12.8536 2.14645Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  WK = ["color"],
  KK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, WK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M5.10505 12C4.70805 12 4.4236 11.912 4.25171 11.736C4.0839 11.5559 4 11.2715 4 10.8827V4.11733C4 3.72033 4.08595 3.43588 4.25784 3.26398C4.43383 3.08799 4.71623 3 5.10505 3C6.42741 3 8.25591 3 9.02852 3C10.1373 3 11.0539 3.98153 11.0539 5.1846C11.0539 6.08501 10.6037 6.81855 9.70327 7.23602C10.8657 7.44851 11.5176 8.62787 11.5176 9.48128C11.5176 10.5125 10.9902 12 9.27734 12C8.77742 12 6.42626 12 5.10505 12ZM8.37891 8.00341H5.8V10.631H8.37891C8.9 10.631 9.6296 10.1211 9.6296 9.29877C9.6296 8.47643 8.9 8.00341 8.37891 8.00341ZM5.8 4.36903V6.69577H8.17969C8.53906 6.69577 9.27734 6.35939 9.27734 5.50002C9.27734 4.64064 8.48047 4.36903 8.17969 4.36903H5.8Z",
        fill: r,
      })
    )
  }),
  GK = ["color"],
  qK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, GK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M5.67494 3.50017C5.67494 3.25164 5.87641 3.05017 6.12494 3.05017H10.6249C10.8735 3.05017 11.0749 3.25164 11.0749 3.50017C11.0749 3.7487 10.8735 3.95017 10.6249 3.95017H9.00587L7.2309 11.05H8.87493C9.12345 11.05 9.32493 11.2515 9.32493 11.5C9.32493 11.7486 9.12345 11.95 8.87493 11.95H4.37493C4.1264 11.95 3.92493 11.7486 3.92493 11.5C3.92493 11.2515 4.1264 11.05 4.37493 11.05H5.99397L7.76894 3.95017H6.12494C5.87641 3.95017 5.67494 3.7487 5.67494 3.50017Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  ZK = ["color"],
  YK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, ZK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M7.49991 0.876892C3.84222 0.876892 0.877075 3.84204 0.877075 7.49972C0.877075 11.1574 3.84222 14.1226 7.49991 14.1226C11.1576 14.1226 14.1227 11.1574 14.1227 7.49972C14.1227 3.84204 11.1576 0.876892 7.49991 0.876892ZM1.82707 7.49972C1.82707 4.36671 4.36689 1.82689 7.49991 1.82689C10.6329 1.82689 13.1727 4.36671 13.1727 7.49972C13.1727 10.6327 10.6329 13.1726 7.49991 13.1726C4.36689 13.1726 1.82707 10.6327 1.82707 7.49972ZM8.24992 4.49999C8.24992 4.9142 7.91413 5.24999 7.49992 5.24999C7.08571 5.24999 6.74992 4.9142 6.74992 4.49999C6.74992 4.08577 7.08571 3.74999 7.49992 3.74999C7.91413 3.74999 8.24992 4.08577 8.24992 4.49999ZM6.00003 5.99999H6.50003H7.50003C7.77618 5.99999 8.00003 6.22384 8.00003 6.49999V9.99999H8.50003H9.00003V11H8.50003H7.50003H6.50003H6.00003V9.99999H6.50003H7.00003V6.99999H6.50003H6.00003V5.99999Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  XK = ["color"],
  QK = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, XK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M3.68979 2.75C3.89667 2.74979 4.08232 2.87701 4.15679 3.07003L7.36662 11.39C7.46602 11.6477 7.33774 11.9371 7.0801 12.0365C6.82247 12.1359 6.53304 12.0076 6.43365 11.75L5.3825 9.02537H2.01133L0.966992 11.749C0.868128 12.0068 0.578964 12.1357 0.321126 12.0369C0.0632878 11.938 -0.0655864 11.6488 0.0332774 11.391L3.22344 3.07099C3.29751 2.87782 3.4829 2.75021 3.68979 2.75ZM3.69174 4.64284L5.05458 8.17537H2.33724L3.69174 4.64284ZM10.8989 5.20703C9.25818 5.20703 8.00915 6.68569 8.00915 8.60972C8.00915 10.6337 9.35818 12.0124 10.8989 12.0124C11.7214 12.0124 12.5744 11.6692 13.1543 11.0219V11.53C13.1543 11.7785 13.3557 11.98 13.6043 11.98C13.8528 11.98 14.0543 11.7785 14.0543 11.53V5.72C14.0543 5.47147 13.8528 5.27 13.6043 5.27C13.3557 5.27 13.1543 5.47147 13.1543 5.72V6.22317C12.6054 5.60095 11.7924 5.20703 10.8989 5.20703ZM13.1543 9.79823V7.30195C12.7639 6.58101 11.9414 6.05757 11.0868 6.05757C10.1088 6.05757 9.03503 6.96581 9.03503 8.60955C9.03503 10.1533 10.0088 11.1615 11.0868 11.1615C11.9701 11.1615 12.7719 10.4952 13.1543 9.79823Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  JK = ["color"],
  eG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, JK)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M8.51194 3.00541C9.18829 2.54594 10.0435 2.53694 10.6788 2.95419C10.8231 3.04893 10.9771 3.1993 11.389 3.61119C11.8009 4.02307 11.9513 4.17714 12.046 4.32141C12.4633 4.95675 12.4543 5.81192 11.9948 6.48827C11.8899 6.64264 11.7276 6.80811 11.3006 7.23511L10.6819 7.85383C10.4867 8.04909 10.4867 8.36567 10.6819 8.56093C10.8772 8.7562 11.1938 8.7562 11.389 8.56093L12.0077 7.94221L12.0507 7.89929C12.4203 7.52976 12.6568 7.2933 12.822 7.0502C13.4972 6.05623 13.5321 4.76252 12.8819 3.77248C12.7233 3.53102 12.4922 3.30001 12.1408 2.94871L12.0961 2.90408L12.0515 2.85942C11.7002 2.508 11.4692 2.27689 11.2277 2.11832C10.2377 1.46813 8.94398 1.50299 7.95001 2.17822C7.70691 2.34336 7.47044 2.57991 7.1009 2.94955L7.058 2.99247L6.43928 3.61119C6.24401 3.80645 6.24401 4.12303 6.43928 4.31829C6.63454 4.51355 6.95112 4.51355 7.14638 4.31829L7.7651 3.69957C8.1921 3.27257 8.35757 3.11027 8.51194 3.00541ZM4.31796 7.14672C4.51322 6.95146 4.51322 6.63487 4.31796 6.43961C4.12269 6.24435 3.80611 6.24435 3.61085 6.43961L2.99213 7.05833L2.94922 7.10124C2.57957 7.47077 2.34303 7.70724 2.17788 7.95035C1.50265 8.94432 1.4678 10.238 2.11799 11.2281C2.27656 11.4695 2.50766 11.7005 2.8591 12.0518L2.90374 12.0965L2.94837 12.1411C3.29967 12.4925 3.53068 12.7237 3.77214 12.8822C4.76219 13.5324 6.05589 13.4976 7.04986 12.8223C7.29296 12.6572 7.52943 12.4206 7.89896 12.051L7.89897 12.051L7.94188 12.0081L8.5606 11.3894C8.75586 11.1941 8.75586 10.8775 8.5606 10.6823C8.36533 10.487 8.04875 10.487 7.85349 10.6823L7.23477 11.301C6.80777 11.728 6.6423 11.8903 6.48794 11.9951C5.81158 12.4546 4.95642 12.4636 4.32107 12.0464C4.17681 11.9516 4.02274 11.8012 3.61085 11.3894C3.19896 10.9775 3.0486 10.8234 2.95385 10.6791C2.53661 10.0438 2.54561 9.18863 3.00507 8.51227C3.10993 8.35791 3.27224 8.19244 3.69924 7.76544L4.31796 7.14672ZM9.62172 6.08558C9.81698 5.89032 9.81698 5.57373 9.62172 5.37847C9.42646 5.18321 9.10988 5.18321 8.91461 5.37847L5.37908 8.91401C5.18382 9.10927 5.18382 9.42585 5.37908 9.62111C5.57434 9.81637 5.89092 9.81637 6.08619 9.62111L9.62172 6.08558Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  tG = ["color"],
  nG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, tG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M4.50021 0C4.77635 0 5.0002 0.223853 5.0002 0.49999V2.49995C5.0002 2.77609 4.77635 2.99994 4.50021 2.99994C4.22408 2.99994 4.00022 2.77609 4.00022 2.49995V0.49999C4.00022 0.223853 4.22408 0 4.50021 0ZM0.646451 0.64647C0.84171 0.451212 1.15829 0.451212 1.35354 0.64647L2.85351 2.14644C3.04877 2.3417 3.04877 2.65827 2.85351 2.85353C2.65826 3.04879 2.34168 3.04879 2.14642 2.85353L0.646452 1.35356C0.451193 1.1583 0.451193 0.841728 0.646451 0.64647ZM0.00030517 4.49991C0.00030517 4.22377 0.224158 3.99992 0.500295 3.99992H2.50025C2.77639 3.99992 3.00024 4.22377 3.00024 4.49991C3.00024 4.77605 2.77639 4.9999 2.50025 4.9999H0.500295C0.224158 4.9999 0.00030517 4.77605 0.00030517 4.49991ZM12.0001 10.4998C12.0001 10.2236 12.2239 9.9998 12.5001 9.9998H14.5C14.7761 9.9998 15 10.2236 15 10.4998C15 10.7759 14.7761 10.9998 14.5 10.9998H12.5001C12.2239 10.9998 12.0001 10.7759 12.0001 10.4998ZM10.5001 11.9998C10.7762 11.9998 11.0001 12.2236 11.0001 12.4997V14.4997C11.0001 14.7758 10.7762 14.9997 10.5001 14.9997C10.224 14.9997 10.0001 14.7758 10.0001 14.4997V12.4997C10.0001 12.2236 10.224 11.9998 10.5001 11.9998ZM12.1462 12.1462C12.3415 11.951 12.658 11.951 12.8533 12.1462L14.3533 13.6462C14.5485 13.8415 14.5485 14.158 14.3533 14.3533C14.158 14.5485 13.8414 14.5485 13.6462 14.3533L12.1462 12.8533C11.951 12.6581 11.951 12.3415 12.1462 12.1462ZM7.76478 3.69938C8.19177 3.27238 8.35724 3.11008 8.5116 3.00522C9.18794 2.54577 10.0431 2.53677 10.6784 2.95401C10.8227 3.04875 10.9767 3.19911 11.3886 3.61099C11.8005 4.02287 11.9509 4.17694 12.0456 4.3212C12.4628 4.95653 12.4539 5.81168 11.9944 6.48802C11.8895 6.64238 11.7272 6.80785 11.3002 7.23484L10.6815 7.85354C10.4863 8.0488 10.4863 8.36538 10.6815 8.56064C10.8768 8.75589 11.1934 8.75589 11.3886 8.56064L12.0073 7.94193L12.0502 7.89903C12.4199 7.5295 12.6564 7.29303 12.8216 7.04993C13.4968 6.05598 13.5316 4.7623 12.8815 3.77228C12.7229 3.53083 12.4918 3.29982 12.1404 2.94853L12.0957 2.9039L12.0511 2.85925C11.6998 2.50782 11.4688 2.27672 11.2273 2.11816C10.2373 1.46798 8.94364 1.50284 7.94968 2.17805C7.70659 2.34319 7.47012 2.57973 7.1006 2.94936L7.1006 2.94937L7.05769 2.99228L6.43898 3.61099C6.24372 3.80625 6.24372 4.12282 6.43898 4.31808C6.63424 4.51334 6.95081 4.51334 7.14607 4.31808L7.76478 3.69938ZM2.99191 7.05807L2.94899 7.10097C2.57935 7.4705 2.34282 7.70697 2.17767 7.95006C1.50246 8.94401 1.4676 10.2377 2.11778 11.2277C2.27634 11.4692 2.50744 11.7002 2.85886 12.0515L2.85888 12.0515L2.90352 12.0961L2.94815 12.1407L2.94815 12.1407L2.94817 12.1408C3.29945 12.4922 3.53045 12.7233 3.7719 12.8818C4.76193 13.532 6.0556 13.4972 7.04956 12.8219C7.29265 12.6568 7.52912 12.4203 7.89865 12.0506L7.94155 12.0077L8.56026 11.389C8.75552 11.1937 8.75552 10.8772 8.56026 10.6819C8.365 10.4867 8.04842 10.4867 7.85317 10.6819L7.23446 11.3006C6.80747 11.7276 6.642 11.8899 6.48764 11.9948C5.8113 12.4542 4.95615 12.4632 4.32082 12.046C4.17656 11.9512 4.02249 11.8009 3.61061 11.389C3.19873 10.9771 3.04837 10.8231 2.95363 10.6788C2.53639 10.0435 2.54539 9.18832 3.00484 8.51198C3.10971 8.35761 3.27201 8.19215 3.699 7.76516L4.3177 7.14645C4.51296 6.95119 4.51296 6.63462 4.3177 6.43936C4.12245 6.2441 3.80587 6.2441 3.61061 6.43936L2.99191 7.05807Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  rG = ["color"],
  HA = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, rG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M1.5 5.25C1.91421 5.25 2.25 4.91421 2.25 4.5C2.25 4.08579 1.91421 3.75 1.5 3.75C1.08579 3.75 0.75 4.08579 0.75 4.5C0.75 4.91421 1.08579 5.25 1.5 5.25ZM4 4.5C4 4.22386 4.22386 4 4.5 4H13.5C13.7761 4 14 4.22386 14 4.5C14 4.77614 13.7761 5 13.5 5H4.5C4.22386 5 4 4.77614 4 4.5ZM4.5 7C4.22386 7 4 7.22386 4 7.5C4 7.77614 4.22386 8 4.5 8H13.5C13.7761 8 14 7.77614 14 7.5C14 7.22386 13.7761 7 13.5 7H4.5ZM4.5 10C4.22386 10 4 10.2239 4 10.5C4 10.7761 4.22386 11 4.5 11H13.5C13.7761 11 14 10.7761 14 10.5C14 10.2239 13.7761 10 13.5 10H4.5ZM2.25 7.5C2.25 7.91421 1.91421 8.25 1.5 8.25C1.08579 8.25 0.75 7.91421 0.75 7.5C0.75 7.08579 1.08579 6.75 1.5 6.75C1.91421 6.75 2.25 7.08579 2.25 7.5ZM1.5 11.25C1.91421 11.25 2.25 10.9142 2.25 10.5C2.25 10.0858 1.91421 9.75 1.5 9.75C1.08579 9.75 0.75 10.0858 0.75 10.5C0.75 10.9142 1.08579 11.25 1.5 11.25Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  oG = ["color"],
  iG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, oG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  sG = ["color"],
  aG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, sG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M9.42503 3.44136C10.0561 3.23654 10.7837 3.2402 11.3792 3.54623C12.7532 4.25224 13.3477 6.07191 12.7946 8C12.5465 8.8649 12.1102 9.70472 11.1861 10.5524C10.262 11.4 8.98034 11.9 8.38571 11.9C8.17269 11.9 8 11.7321 8 11.525C8 11.3179 8.17644 11.15 8.38571 11.15C9.06497 11.15 9.67189 10.7804 10.3906 10.236C10.9406 9.8193 11.3701 9.28633 11.608 8.82191C12.0628 7.93367 12.0782 6.68174 11.3433 6.34901C10.9904 6.73455 10.5295 6.95946 9.97725 6.95946C8.7773 6.95946 8.0701 5.99412 8.10051 5.12009C8.12957 4.28474 8.66032 3.68954 9.42503 3.44136ZM3.42503 3.44136C4.05614 3.23654 4.78366 3.2402 5.37923 3.54623C6.7532 4.25224 7.34766 6.07191 6.79462 8C6.54654 8.8649 6.11019 9.70472 5.1861 10.5524C4.26201 11.4 2.98034 11.9 2.38571 11.9C2.17269 11.9 2 11.7321 2 11.525C2 11.3179 2.17644 11.15 2.38571 11.15C3.06497 11.15 3.67189 10.7804 4.39058 10.236C4.94065 9.8193 5.37014 9.28633 5.60797 8.82191C6.06282 7.93367 6.07821 6.68174 5.3433 6.34901C4.99037 6.73455 4.52948 6.95946 3.97725 6.95946C2.7773 6.95946 2.0701 5.99412 2.10051 5.12009C2.12957 4.28474 2.66032 3.68954 3.42503 3.44136Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  lG = ["color"],
  cG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, lG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M11.5 3.04999C11.7485 3.04999 11.95 3.25146 11.95 3.49999V7.49999C11.95 7.74852 11.7485 7.94999 11.5 7.94999C11.2515 7.94999 11.05 7.74852 11.05 7.49999V4.58639L4.58638 11.05H7.49999C7.74852 11.05 7.94999 11.2515 7.94999 11.5C7.94999 11.7485 7.74852 11.95 7.49999 11.95L3.49999 11.95C3.38064 11.95 3.26618 11.9026 3.18179 11.8182C3.0974 11.7338 3.04999 11.6193 3.04999 11.5L3.04999 7.49999C3.04999 7.25146 3.25146 7.04999 3.49999 7.04999C3.74852 7.04999 3.94999 7.25146 3.94999 7.49999L3.94999 10.4136L10.4136 3.94999L7.49999 3.94999C7.25146 3.94999 7.04999 3.74852 7.04999 3.49999C7.04999 3.25146 7.25146 3.04999 7.49999 3.04999L11.5 3.04999Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  uG = ["color"],
  dG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, uG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M5.00003 3.25C5.00003 2.97386 4.77617 2.75 4.50003 2.75C4.22389 2.75 4.00003 2.97386 4.00003 3.25V7.10003H2.49998C2.27906 7.10003 2.09998 7.27912 2.09998 7.50003C2.09998 7.72094 2.27906 7.90003 2.49998 7.90003H4.00003V8.55C4.00003 10.483 5.56703 12.05 7.50003 12.05C9.43303 12.05 11 10.483 11 8.55V7.90003H12.5C12.7209 7.90003 12.9 7.72094 12.9 7.50003C12.9 7.27912 12.7209 7.10003 12.5 7.10003H11V3.25C11 2.97386 10.7762 2.75 10.5 2.75C10.2239 2.75 10 2.97386 10 3.25V7.10003H5.00003V3.25ZM5.00003 7.90003V8.55C5.00003 9.93071 6.11932 11.05 7.50003 11.05C8.88074 11.05 10 9.93071 10 8.55V7.90003H5.00003Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  fG = ["color"],
  pG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, fG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M13.3536 2.35355C13.5488 2.15829 13.5488 1.84171 13.3536 1.64645C13.1583 1.45118 12.8417 1.45118 12.6464 1.64645L11.9291 2.36383C11.9159 2.32246 11.897 2.28368 11.8732 2.24845C11.7923 2.12875 11.6554 2.05005 11.5001 2.05005H3.50005C3.29909 2.05005 3.1289 2.18178 3.07111 2.3636C3.05743 2.40665 3.05005 2.45249 3.05005 2.50007V4.50001C3.05005 4.74854 3.25152 4.95001 3.50005 4.95001C3.74858 4.95001 3.95005 4.74854 3.95005 4.50001V2.95005H6.95006V7.34284L1.64645 12.6464C1.45118 12.8417 1.45118 13.1583 1.64645 13.3536C1.84171 13.5488 2.15829 13.5488 2.35355 13.3536L6.95006 8.75705V12.0501H5.7544C5.50587 12.0501 5.3044 12.2515 5.3044 12.5001C5.3044 12.7486 5.50587 12.9501 5.7544 12.9501H9.2544C9.50293 12.9501 9.7044 12.7486 9.7044 12.5001C9.7044 12.2515 9.50293 12.0501 9.2544 12.0501H8.05006V7.65705L13.3536 2.35355ZM8.05006 6.24284L11.0501 3.24283V2.95005H8.05006V6.24284Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  hG = ["color"],
  mG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, hG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M5.5 1C5.22386 1 5 1.22386 5 1.5C5 1.77614 5.22386 2 5.5 2H9.5C9.77614 2 10 1.77614 10 1.5C10 1.22386 9.77614 1 9.5 1H5.5ZM3 3.5C3 3.22386 3.22386 3 3.5 3H5H10H11.5C11.7761 3 12 3.22386 12 3.5C12 3.77614 11.7761 4 11.5 4H11V12C11 12.5523 10.5523 13 10 13H5C4.44772 13 4 12.5523 4 12V4L3.5 4C3.22386 4 3 3.77614 3 3.5ZM5 4H10V12H5V4Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  gG = ["color"],
  vG = m.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      o = ut(e, gG)
    return m.createElement(
      "svg",
      Object.assign(
        {
          width: "15",
          height: "15",
          viewBox: "0 0 15 15",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
        },
        o,
        { ref: t }
      ),
      m.createElement("path", {
        d: "M5.00001 2.75C5.00001 2.47386 4.77615 2.25 4.50001 2.25C4.22387 2.25 4.00001 2.47386 4.00001 2.75V8.05C4.00001 9.983 5.56702 11.55 7.50001 11.55C9.43301 11.55 11 9.983 11 8.05V2.75C11 2.47386 10.7762 2.25 10.5 2.25C10.2239 2.25 10 2.47386 10 2.75V8.05C10 9.43071 8.88072 10.55 7.50001 10.55C6.1193 10.55 5.00001 9.43071 5.00001 8.05V2.75ZM3.49998 13.1001C3.27906 13.1001 3.09998 13.2791 3.09998 13.5001C3.09998 13.721 3.27906 13.9001 3.49998 13.9001H11.5C11.7209 13.9001 11.9 13.721 11.9 13.5001C11.9 13.2791 11.7209 13.1001 11.5 13.1001H3.49998Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      })
    )
  }),
  Hy = ["Enter", " "],
  yG = ["ArrowDown", "PageUp", "Home"],
  WA = ["ArrowUp", "PageDown", "End"],
  bG = [...yG, ...WA],
  xG = { ltr: [...Hy, "ArrowRight"], rtl: [...Hy, "ArrowLeft"] },
  wG = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] },
  zu = "Menu",
  [du, EG, CG] = a2(zu),
  [$s, KA] = Wn(zu, [CG, gl, vl]),
  mm = gl(),
  GA = vl(),
  [SG, Bs] = $s(zu),
  [_G, Uu] = $s(zu),
  qA = (e) => {
    const {
        __scopeMenu: t,
        open: n = !1,
        children: r,
        dir: o,
        onOpenChange: i,
        modal: s = !0,
      } = e,
      a = mm(t),
      [l, c] = m.useState(null),
      u = m.useRef(!1),
      d = Nr(i),
      f = Hh(o)
    return (
      m.useEffect(() => {
        const p = () => {
            ;(u.current = !0),
              document.addEventListener("pointerdown", g, {
                capture: !0,
                once: !0,
              }),
              document.addEventListener("pointermove", g, {
                capture: !0,
                once: !0,
              })
          },
          g = () => (u.current = !1)
        return (
          document.addEventListener("keydown", p, { capture: !0 }),
          () => {
            document.removeEventListener("keydown", p, { capture: !0 }),
              document.removeEventListener("pointerdown", g, { capture: !0 }),
              document.removeEventListener("pointermove", g, { capture: !0 })
          }
        )
      }, []),
      h.jsx(vb, {
        ...a,
        children: h.jsx(SG, {
          scope: t,
          open: n,
          onOpenChange: d,
          content: l,
          onContentChange: c,
          children: h.jsx(_G, {
            scope: t,
            onClose: m.useCallback(() => d(!1), [d]),
            isUsingKeyboardRef: u,
            dir: f,
            modal: s,
            children: r,
          }),
        }),
      })
    )
  }
qA.displayName = zu
var kG = "MenuAnchor",
  w1 = m.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e,
      o = mm(n)
    return h.jsx(Nh, { ...o, ...r, ref: t })
  })
w1.displayName = kG
var E1 = "MenuPortal",
  [NG, ZA] = $s(E1, { forceMount: void 0 }),
  YA = (e) => {
    const { __scopeMenu: t, forceMount: n, children: r, container: o } = e,
      i = Bs(E1, t)
    return h.jsx(NG, {
      scope: t,
      forceMount: n,
      children: h.jsx(Kn, {
        present: n || i.open,
        children: h.jsx(Th, { asChild: !0, container: o, children: r }),
      }),
    })
  }
YA.displayName = E1
var ar = "MenuContent",
  [TG, C1] = $s(ar),
  XA = m.forwardRef((e, t) => {
    const n = ZA(ar, e.__scopeMenu),
      { forceMount: r = n.forceMount, ...o } = e,
      i = Bs(ar, e.__scopeMenu),
      s = Uu(ar, e.__scopeMenu)
    return h.jsx(du.Provider, {
      scope: e.__scopeMenu,
      children: h.jsx(Kn, {
        present: r || i.open,
        children: h.jsx(du.Slot, {
          scope: e.__scopeMenu,
          children: s.modal
            ? h.jsx(MG, { ...o, ref: t })
            : h.jsx(OG, { ...o, ref: t }),
        }),
      }),
    })
  }),
  MG = m.forwardRef((e, t) => {
    const n = Bs(ar, e.__scopeMenu),
      r = m.useRef(null),
      o = tt(t, r)
    return (
      m.useEffect(() => {
        const i = r.current
        if (i) return $h(i)
      }, []),
      h.jsx(S1, {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: ge(e.onFocusOutside, (i) => i.preventDefault(), {
          checkForDefaultPrevented: !1,
        }),
        onDismiss: () => n.onOpenChange(!1),
      })
    )
  }),
  OG = m.forwardRef((e, t) => {
    const n = Bs(ar, e.__scopeMenu)
    return h.jsx(S1, {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1),
    })
  }),
  S1 = m.forwardRef((e, t) => {
    const {
        __scopeMenu: n,
        loop: r = !1,
        trapFocus: o,
        onOpenAutoFocus: i,
        onCloseAutoFocus: s,
        disableOutsidePointerEvents: a,
        onEntryFocus: l,
        onEscapeKeyDown: c,
        onPointerDownOutside: u,
        onFocusOutside: d,
        onInteractOutside: f,
        onDismiss: p,
        disableOutsideScroll: g,
        ...v
      } = e,
      b = Bs(ar, n),
      y = Uu(ar, n),
      x = mm(n),
      E = GA(n),
      w = EG(n),
      [C, S] = m.useState(null),
      M = m.useRef(null),
      N = tt(t, M, b.onContentChange),
      R = m.useRef(0),
      B = m.useRef(""),
      V = m.useRef(0),
      j = m.useRef(null),
      U = m.useRef("right"),
      W = m.useRef(0),
      ee = g ? Sb : m.Fragment,
      I = g ? { as: An, allowPinchZoom: !0 } : void 0,
      O = (A) => {
        var Ae, je
        const P = B.current + A,
          H = w().filter((Fe) => !Fe.disabled),
          X = document.activeElement,
          ae =
            (Ae = H.find((Fe) => Fe.ref.current === X)) == null
              ? void 0
              : Ae.textValue,
          ve = H.map((Fe) => Fe.textValue),
          he = UG(ve, P, ae),
          xe =
            (je = H.find((Fe) => Fe.textValue === he)) == null
              ? void 0
              : je.ref.current
        ;(function Fe(Ze) {
          ;(B.current = Ze),
            window.clearTimeout(R.current),
            Ze !== "" && (R.current = window.setTimeout(() => Fe(""), 1e3))
        })(P),
          xe && setTimeout(() => xe.focus())
      }
    m.useEffect(() => () => window.clearTimeout(R.current), []), wb()
    const _ = m.useCallback((A) => {
      var H, X
      return (
        U.current === ((H = j.current) == null ? void 0 : H.side) &&
        HG(A, (X = j.current) == null ? void 0 : X.area)
      )
    }, [])
    return h.jsx(TG, {
      scope: n,
      searchRef: B,
      onItemEnter: m.useCallback(
        (A) => {
          _(A) && A.preventDefault()
        },
        [_]
      ),
      onItemLeave: m.useCallback(
        (A) => {
          var P
          _(A) || ((P = M.current) == null || P.focus(), S(null))
        },
        [_]
      ),
      onTriggerLeave: m.useCallback(
        (A) => {
          _(A) && A.preventDefault()
        },
        [_]
      ),
      pointerGraceTimerRef: V,
      onPointerGraceIntentChange: m.useCallback((A) => {
        j.current = A
      }, []),
      children: h.jsx(ee, {
        ...I,
        children: h.jsx(Lh, {
          asChild: !0,
          trapped: o,
          onMountAutoFocus: ge(i, (A) => {
            var P
            A.preventDefault(),
              (P = M.current) == null || P.focus({ preventScroll: !0 })
          }),
          onUnmountAutoFocus: s,
          children: h.jsx(ku, {
            asChild: !0,
            disableOutsidePointerEvents: a,
            onEscapeKeyDown: c,
            onPointerDownOutside: u,
            onFocusOutside: d,
            onInteractOutside: f,
            onDismiss: p,
            children: h.jsx(Ib, {
              asChild: !0,
              ...E,
              dir: y.dir,
              orientation: "vertical",
              loop: r,
              currentTabStopId: C,
              onCurrentTabStopIdChange: S,
              onEntryFocus: ge(l, (A) => {
                y.isUsingKeyboardRef.current || A.preventDefault()
              }),
              preventScrollOnEntryFocus: !0,
              children: h.jsx(yb, {
                role: "menu",
                "aria-orientation": "vertical",
                "data-state": pR(b.open),
                "data-radix-menu-content": "",
                dir: y.dir,
                ...x,
                ...v,
                ref: N,
                style: { outline: "none", ...v.style },
                onKeyDown: ge(v.onKeyDown, (A) => {
                  const H =
                      A.target.closest("[data-radix-menu-content]") ===
                      A.currentTarget,
                    X = A.ctrlKey || A.altKey || A.metaKey,
                    ae = A.key.length === 1
                  H &&
                    (A.key === "Tab" && A.preventDefault(),
                    !X && ae && O(A.key))
                  const ve = M.current
                  if (A.target !== ve || !bG.includes(A.key)) return
                  A.preventDefault()
                  const xe = w()
                    .filter((Ae) => !Ae.disabled)
                    .map((Ae) => Ae.ref.current)
                  WA.includes(A.key) && xe.reverse(), FG(xe)
                }),
                onBlur: ge(e.onBlur, (A) => {
                  A.currentTarget.contains(A.target) ||
                    (window.clearTimeout(R.current), (B.current = ""))
                }),
                onPointerMove: ge(
                  e.onPointerMove,
                  fu((A) => {
                    const P = A.target,
                      H = W.current !== A.clientX
                    if (A.currentTarget.contains(P) && H) {
                      const X = A.clientX > W.current ? "right" : "left"
                      ;(U.current = X), (W.current = A.clientX)
                    }
                  })
                ),
              }),
            }),
          }),
        }),
      }),
    })
  })
XA.displayName = ar
var AG = "MenuGroup",
  _1 = m.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e
    return h.jsx(Le.div, { role: "group", ...r, ref: t })
  })
_1.displayName = AG
var RG = "MenuLabel",
  QA = m.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e
    return h.jsx(Le.div, { ...r, ref: t })
  })
QA.displayName = RG
var gp = "MenuItem",
  QC = "menu.itemSelect",
  gm = m.forwardRef((e, t) => {
    const { disabled: n = !1, onSelect: r, ...o } = e,
      i = m.useRef(null),
      s = Uu(gp, e.__scopeMenu),
      a = C1(gp, e.__scopeMenu),
      l = tt(t, i),
      c = m.useRef(!1),
      u = () => {
        const d = i.current
        if (!n && d) {
          const f = new CustomEvent(QC, { bubbles: !0, cancelable: !0 })
          d.addEventListener(QC, (p) => (r == null ? void 0 : r(p)), {
            once: !0,
          }),
            LN(d, f),
            f.defaultPrevented ? (c.current = !1) : s.onClose()
        }
      }
    return h.jsx(JA, {
      ...o,
      ref: l,
      disabled: n,
      onClick: ge(e.onClick, u),
      onPointerDown: (d) => {
        var f
        ;(f = e.onPointerDown) == null || f.call(e, d), (c.current = !0)
      },
      onPointerUp: ge(e.onPointerUp, (d) => {
        var f
        c.current || (f = d.currentTarget) == null || f.click()
      }),
      onKeyDown: ge(e.onKeyDown, (d) => {
        const f = a.searchRef.current !== ""
        n ||
          (f && d.key === " ") ||
          (Hy.includes(d.key) && (d.currentTarget.click(), d.preventDefault()))
      }),
    })
  })
gm.displayName = gp
var JA = m.forwardRef((e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = e,
      s = C1(gp, n),
      a = GA(n),
      l = m.useRef(null),
      c = tt(t, l),
      [u, d] = m.useState(!1),
      [f, p] = m.useState("")
    return (
      m.useEffect(() => {
        var v
        const g = l.current
        g && p(((v = g.textContent) != null ? v : "").trim())
      }, [i.children]),
      h.jsx(du.ItemSlot, {
        scope: n,
        disabled: r,
        textValue: o != null ? o : f,
        children: h.jsx(Db, {
          asChild: !0,
          ...a,
          focusable: !r,
          children: h.jsx(Le.div, {
            role: "menuitem",
            "data-highlighted": u ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: c,
            onPointerMove: ge(
              e.onPointerMove,
              fu((g) => {
                r
                  ? s.onItemLeave(g)
                  : (s.onItemEnter(g),
                    g.defaultPrevented ||
                      g.currentTarget.focus({ preventScroll: !0 }))
              })
            ),
            onPointerLeave: ge(
              e.onPointerLeave,
              fu((g) => s.onItemLeave(g))
            ),
            onFocus: ge(e.onFocus, () => d(!0)),
            onBlur: ge(e.onBlur, () => d(!1)),
          }),
        }),
      })
    )
  }),
  IG = "MenuCheckboxItem",
  eR = m.forwardRef((e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = e
    return h.jsx(iR, {
      scope: e.__scopeMenu,
      checked: n,
      children: h.jsx(gm, {
        role: "menuitemcheckbox",
        "aria-checked": vp(n) ? "mixed" : n,
        ...o,
        ref: t,
        "data-state": N1(n),
        onSelect: ge(
          o.onSelect,
          () => (r == null ? void 0 : r(vp(n) ? !0 : !n)),
          { checkForDefaultPrevented: !1 }
        ),
      }),
    })
  })
eR.displayName = IG
var tR = "MenuRadioGroup",
  [DG, LG] = $s(tR, { value: void 0, onValueChange: () => {} }),
  nR = m.forwardRef((e, t) => {
    const { value: n, onValueChange: r, ...o } = e,
      i = Nr(r)
    return h.jsx(DG, {
      scope: e.__scopeMenu,
      value: n,
      onValueChange: i,
      children: h.jsx(_1, { ...o, ref: t }),
    })
  })
nR.displayName = tR
var rR = "MenuRadioItem",
  oR = m.forwardRef((e, t) => {
    const { value: n, ...r } = e,
      o = LG(rR, e.__scopeMenu),
      i = n === o.value
    return h.jsx(iR, {
      scope: e.__scopeMenu,
      checked: i,
      children: h.jsx(gm, {
        role: "menuitemradio",
        "aria-checked": i,
        ...r,
        ref: t,
        "data-state": N1(i),
        onSelect: ge(
          r.onSelect,
          () => {
            var s
            return (s = o.onValueChange) == null ? void 0 : s.call(o, n)
          },
          { checkForDefaultPrevented: !1 }
        ),
      }),
    })
  })
oR.displayName = rR
var k1 = "MenuItemIndicator",
  [iR, PG] = $s(k1, { checked: !1 }),
  sR = m.forwardRef((e, t) => {
    const { __scopeMenu: n, forceMount: r, ...o } = e,
      i = PG(k1, n)
    return h.jsx(Kn, {
      present: r || vp(i.checked) || i.checked === !0,
      children: h.jsx(Le.span, { ...o, ref: t, "data-state": N1(i.checked) }),
    })
  })
sR.displayName = k1
var $G = "MenuSeparator",
  aR = m.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e
    return h.jsx(Le.div, {
      role: "separator",
      "aria-orientation": "horizontal",
      ...r,
      ref: t,
    })
  })
aR.displayName = $G
var BG = "MenuArrow",
  lR = m.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e,
      o = mm(n)
    return h.jsx(bb, { ...o, ...r, ref: t })
  })
lR.displayName = BG
var jG = "MenuSub",
  [ene, cR] = $s(jG),
  Zl = "MenuSubTrigger",
  uR = m.forwardRef((e, t) => {
    const n = Bs(Zl, e.__scopeMenu),
      r = Uu(Zl, e.__scopeMenu),
      o = cR(Zl, e.__scopeMenu),
      i = C1(Zl, e.__scopeMenu),
      s = m.useRef(null),
      { pointerGraceTimerRef: a, onPointerGraceIntentChange: l } = i,
      c = { __scopeMenu: e.__scopeMenu },
      u = m.useCallback(() => {
        s.current && window.clearTimeout(s.current), (s.current = null)
      }, [])
    return (
      m.useEffect(() => u, [u]),
      m.useEffect(() => {
        const d = a.current
        return () => {
          window.clearTimeout(d), l(null)
        }
      }, [a, l]),
      h.jsx(w1, {
        asChild: !0,
        ...c,
        children: h.jsx(JA, {
          id: o.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": n.open,
          "aria-controls": o.contentId,
          "data-state": pR(n.open),
          ...e,
          ref: xh(t, o.onTriggerChange),
          onClick: (d) => {
            var f
            ;(f = e.onClick) == null || f.call(e, d),
              !(e.disabled || d.defaultPrevented) &&
                (d.currentTarget.focus(), n.open || n.onOpenChange(!0))
          },
          onPointerMove: ge(
            e.onPointerMove,
            fu((d) => {
              i.onItemEnter(d),
                !d.defaultPrevented &&
                  !e.disabled &&
                  !n.open &&
                  !s.current &&
                  (i.onPointerGraceIntentChange(null),
                  (s.current = window.setTimeout(() => {
                    n.onOpenChange(!0), u()
                  }, 100)))
            })
          ),
          onPointerLeave: ge(
            e.onPointerLeave,
            fu((d) => {
              var p, g
              u()
              const f =
                (p = n.content) == null ? void 0 : p.getBoundingClientRect()
              if (f) {
                const v = (g = n.content) == null ? void 0 : g.dataset.side,
                  b = v === "right",
                  y = b ? -5 : 5,
                  x = f[b ? "left" : "right"],
                  E = f[b ? "right" : "left"]
                i.onPointerGraceIntentChange({
                  area: [
                    { x: d.clientX + y, y: d.clientY },
                    { x, y: f.top },
                    { x: E, y: f.top },
                    { x: E, y: f.bottom },
                    { x, y: f.bottom },
                  ],
                  side: v,
                }),
                  window.clearTimeout(a.current),
                  (a.current = window.setTimeout(
                    () => i.onPointerGraceIntentChange(null),
                    300
                  ))
              } else {
                if ((i.onTriggerLeave(d), d.defaultPrevented)) return
                i.onPointerGraceIntentChange(null)
              }
            })
          ),
          onKeyDown: ge(e.onKeyDown, (d) => {
            var p
            const f = i.searchRef.current !== ""
            e.disabled ||
              (f && d.key === " ") ||
              (xG[r.dir].includes(d.key) &&
                (n.onOpenChange(!0),
                (p = n.content) == null || p.focus(),
                d.preventDefault()))
          }),
        }),
      })
    )
  })
uR.displayName = Zl
var dR = "MenuSubContent",
  fR = m.forwardRef((e, t) => {
    const n = ZA(ar, e.__scopeMenu),
      { forceMount: r = n.forceMount, ...o } = e,
      i = Bs(ar, e.__scopeMenu),
      s = Uu(ar, e.__scopeMenu),
      a = cR(dR, e.__scopeMenu),
      l = m.useRef(null),
      c = tt(t, l)
    return h.jsx(du.Provider, {
      scope: e.__scopeMenu,
      children: h.jsx(Kn, {
        present: r || i.open,
        children: h.jsx(du.Slot, {
          scope: e.__scopeMenu,
          children: h.jsx(S1, {
            id: a.contentId,
            "aria-labelledby": a.triggerId,
            ...o,
            ref: c,
            align: "start",
            side: s.dir === "rtl" ? "left" : "right",
            disableOutsidePointerEvents: !1,
            disableOutsideScroll: !1,
            trapFocus: !1,
            onOpenAutoFocus: (u) => {
              var d
              s.isUsingKeyboardRef.current &&
                ((d = l.current) == null || d.focus()),
                u.preventDefault()
            },
            onCloseAutoFocus: (u) => u.preventDefault(),
            onFocusOutside: ge(e.onFocusOutside, (u) => {
              u.target !== a.trigger && i.onOpenChange(!1)
            }),
            onEscapeKeyDown: ge(e.onEscapeKeyDown, (u) => {
              s.onClose(), u.preventDefault()
            }),
            onKeyDown: ge(e.onKeyDown, (u) => {
              var p
              const d = u.currentTarget.contains(u.target),
                f = wG[s.dir].includes(u.key)
              d &&
                f &&
                (i.onOpenChange(!1),
                (p = a.trigger) == null || p.focus(),
                u.preventDefault())
            }),
          }),
        }),
      }),
    })
  })
fR.displayName = dR
function pR(e) {
  return e ? "open" : "closed"
}
function vp(e) {
  return e === "indeterminate"
}
function N1(e) {
  return vp(e) ? "indeterminate" : e ? "checked" : "unchecked"
}
function FG(e) {
  const t = document.activeElement
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return
}
function zG(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}
function UG(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t,
    i = n ? e.indexOf(n) : -1
  let s = zG(e, Math.max(i, 0))
  o.length === 1 && (s = s.filter((c) => c !== n))
  const l = s.find((c) => c.toLowerCase().startsWith(o.toLowerCase()))
  return l !== n ? l : void 0
}
function VG(e, t) {
  const { x: n, y: r } = e
  let o = !1
  for (let i = 0, s = t.length - 1; i < t.length; s = i++) {
    const a = t[i].x,
      l = t[i].y,
      c = t[s].x,
      u = t[s].y
    l > r != u > r && n < ((c - a) * (r - l)) / (u - l) + a && (o = !o)
  }
  return o
}
function HG(e, t) {
  if (!t) return !1
  const n = { x: e.clientX, y: e.clientY }
  return VG(n, t)
}
function fu(e) {
  return (t) => (t.pointerType === "mouse" ? e(t) : void 0)
}
var WG = qA,
  KG = w1,
  GG = YA,
  qG = XA,
  ZG = _1,
  YG = QA,
  XG = gm,
  QG = eR,
  JG = nR,
  eq = oR,
  tq = sR,
  nq = aR,
  rq = lR,
  oq = uR,
  iq = fR,
  T1 = "DropdownMenu",
  [sq, tne] = Wn(T1, [KA]),
  wn = KA(),
  [aq, hR] = sq(T1),
  mR = (e) => {
    const {
        __scopeDropdownMenu: t,
        children: n,
        dir: r,
        open: o,
        defaultOpen: i,
        onOpenChange: s,
        modal: a = !0,
      } = e,
      l = wn(t),
      c = m.useRef(null),
      [u = !1, d] = Ir({ prop: o, defaultProp: i, onChange: s })
    return h.jsx(aq, {
      scope: t,
      triggerId: fi(),
      triggerRef: c,
      contentId: fi(),
      open: u,
      onOpenChange: d,
      onOpenToggle: m.useCallback(() => d((f) => !f), [d]),
      modal: a,
      children: h.jsx(WG, {
        ...l,
        open: u,
        onOpenChange: d,
        dir: r,
        modal: a,
        children: n,
      }),
    })
  }
mR.displayName = T1
var gR = "DropdownMenuTrigger",
  vR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e,
      i = hR(gR, n),
      s = wn(n)
    return h.jsx(KG, {
      asChild: !0,
      ...s,
      children: h.jsx(Le.button, {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: xh(t, i.triggerRef),
        onPointerDown: ge(e.onPointerDown, (a) => {
          !r &&
            a.button === 0 &&
            a.ctrlKey === !1 &&
            (i.onOpenToggle(), i.open || a.preventDefault())
        }),
        onKeyDown: ge(e.onKeyDown, (a) => {
          r ||
            (["Enter", " "].includes(a.key) && i.onOpenToggle(),
            a.key === "ArrowDown" && i.onOpenChange(!0),
            ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault())
        }),
      }),
    })
  })
vR.displayName = gR
var lq = "DropdownMenuPortal",
  yR = (e) => {
    const { __scopeDropdownMenu: t, ...n } = e,
      r = wn(t)
    return h.jsx(GG, { ...r, ...n })
  }
yR.displayName = lq
var bR = "DropdownMenuContent",
  xR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = hR(bR, n),
      i = wn(n),
      s = m.useRef(!1)
    return h.jsx(qG, {
      id: o.contentId,
      "aria-labelledby": o.triggerId,
      ...i,
      ...r,
      ref: t,
      onCloseAutoFocus: ge(e.onCloseAutoFocus, (a) => {
        var l
        s.current || (l = o.triggerRef.current) == null || l.focus(),
          (s.current = !1),
          a.preventDefault()
      }),
      onInteractOutside: ge(e.onInteractOutside, (a) => {
        const l = a.detail.originalEvent,
          c = l.button === 0 && l.ctrlKey === !0,
          u = l.button === 2 || c
        ;(!o.modal || u) && (s.current = !0)
      }),
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    })
  })
xR.displayName = bR
var cq = "DropdownMenuGroup",
  uq = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(ZG, { ...o, ...r, ref: t })
  })
uq.displayName = cq
var dq = "DropdownMenuLabel",
  wR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(YG, { ...o, ...r, ref: t })
  })
wR.displayName = dq
var fq = "DropdownMenuItem",
  ER = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(XG, { ...o, ...r, ref: t })
  })
ER.displayName = fq
var pq = "DropdownMenuCheckboxItem",
  CR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(QG, { ...o, ...r, ref: t })
  })
CR.displayName = pq
var hq = "DropdownMenuRadioGroup",
  mq = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(JG, { ...o, ...r, ref: t })
  })
mq.displayName = hq
var gq = "DropdownMenuRadioItem",
  SR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(eq, { ...o, ...r, ref: t })
  })
SR.displayName = gq
var vq = "DropdownMenuItemIndicator",
  _R = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(tq, { ...o, ...r, ref: t })
  })
_R.displayName = vq
var yq = "DropdownMenuSeparator",
  kR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(nq, { ...o, ...r, ref: t })
  })
kR.displayName = yq
var bq = "DropdownMenuArrow",
  xq = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(rq, { ...o, ...r, ref: t })
  })
xq.displayName = bq
var wq = "DropdownMenuSubTrigger",
  NR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(oq, { ...o, ...r, ref: t })
  })
NR.displayName = wq
var Eq = "DropdownMenuSubContent",
  TR = m.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      o = wn(n)
    return h.jsx(iq, {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    })
  })
TR.displayName = Eq
var Cq = mR,
  Sq = vR,
  _q = yR,
  MR = xR,
  OR = wR,
  AR = ER,
  RR = CR,
  IR = SR,
  DR = _R,
  LR = kR,
  PR = NR,
  $R = TR
const M1 = Cq,
  O1 = Sq,
  kq = m.forwardRef(({ className: e, inset: t, children: n, ...r }, o) =>
    h.jsxs(PR, {
      ref: o,
      className: q(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        t && "pl-8",
        e
      ),
      ...r,
      children: [n, h.jsx(Q3, { className: "ml-auto h-4 w-4" })],
    })
  )
kq.displayName = PR.displayName
const Nq = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx($R, {
    ref: n,
    className: q(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...t,
  })
)
Nq.displayName = $R.displayName
const vm = m.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) =>
  h.jsx(_q, {
    children: h.jsx(MR, {
      ref: r,
      sideOffset: t,
      className: q(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...n,
    }),
  })
)
vm.displayName = MR.displayName
const ym = m.forwardRef(({ className: e, inset: t, ...n }, r) =>
  h.jsx(AR, {
    ref: r,
    className: q(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      t && "pl-8",
      e
    ),
    ...n,
  })
)
ym.displayName = AR.displayName
const Tq = m.forwardRef(({ className: e, children: t, checked: n, ...r }, o) =>
  h.jsxs(RR, {
    ref: o,
    className: q(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      e
    ),
    checked: n,
    ...r,
    children: [
      h.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: h.jsx(DR, { children: h.jsx(hN, { className: "h-4 w-4" }) }),
      }),
      t,
    ],
  })
)
Tq.displayName = RR.displayName
const Mq = m.forwardRef(({ className: e, children: t, ...n }, r) =>
  h.jsxs(IR, {
    ref: r,
    className: q(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      e
    ),
    ...n,
    children: [
      h.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: h.jsx(DR, {
          children: h.jsx(mN, { className: "h-2 w-2 fill-current" }),
        }),
      }),
      t,
    ],
  })
)
Mq.displayName = IR.displayName
const Oq = m.forwardRef(({ className: e, inset: t, ...n }, r) =>
  h.jsx(OR, {
    ref: r,
    className: q("px-2 py-1.5 text-sm font-semibold", t && "pl-8", e),
    ...n,
  })
)
Oq.displayName = OR.displayName
const Aq = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(LR, { ref: n, className: q("-mx-1 my-1 h-px bg-muted", e), ...t })
)
Aq.displayName = LR.displayName
var Rq = "Toggle",
  A1 = m.forwardRef((e, t) => {
    const { pressed: n, defaultPressed: r = !1, onPressedChange: o, ...i } = e,
      [s = !1, a] = Ir({ prop: n, onChange: o, defaultProp: r })
    return h.jsx(Le.button, {
      type: "button",
      "aria-pressed": s,
      "data-state": s ? "on" : "off",
      "data-disabled": e.disabled ? "" : void 0,
      ...i,
      ref: t,
      onClick: ge(e.onClick, () => {
        e.disabled || a(!s)
      }),
    })
  })
A1.displayName = Rq
var BR = A1
const jR = pl(
    "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
    {
      variants: {
        variant: {
          default: "bg-transparent",
          outline:
            "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
        },
        size: {
          default: "h-10 px-3 min-w-10",
          sm: "h-9 px-2.5 min-w-9",
          lg: "h-11 px-5 min-w-11",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    }
  ),
  FR = m.forwardRef(({ className: e, variant: t, size: n, ...r }, o) =>
    h.jsx(BR, {
      ref: o,
      className: q(jR({ variant: t, size: n, className: e })),
      ...r,
    })
  )
FR.displayName = BR.displayName
const Er = m.forwardRef(
  (
    {
      isActive: e,
      children: t,
      tooltip: n,
      className: r,
      tooltipOptions: o,
      ...i
    },
    s
  ) => {
    const a = h.jsx(FR, {
      size: "sm",
      ref: s,
      className: q("size-8 p-0", { "bg-accent": e }, r),
      ...i,
      children: t,
    })
    return n
      ? h.jsxs(Ih, {
          children: [
            h.jsx(Dh, { asChild: !0, children: a }),
            h.jsx(Tu, {
              ...o,
              children: h.jsx("div", {
                className: "flex flex-col items-center text-center",
                children: n,
              }),
            }),
          ],
        })
      : a
  }
)
Er.displayName = "ToolbarButton"
const Iq = () => typeof window < "u",
  JC = () => Iq() && window.navigator.platform === "MacIntel",
  Dq = {
    mod: JC()
      ? { symbol: "", readable: "Command" }
      : { symbol: "Ctrl", readable: "Control" },
    alt: JC()
      ? { symbol: "", readable: "Option" }
      : { symbol: "Alt", readable: "Alt" },
    shift: { symbol: "", readable: "Shift" },
  },
  zR = (e) => Dq[e.toLowerCase()] || { symbol: e, readable: e },
  eS = (e, t) => {
    switch (t) {
      case "json":
        return e.getJSON()
      case "html":
        return e.isEmpty ? "" : e.getHTML()
      default:
        return e.getText()
    }
  },
  Wy = (e, t = { requireHostname: !1 }) => {
    if (
      e.includes(`
`)
    )
      return !1
    try {
      const n = new URL(e)
      return [
        "javascript:",
        "file:",
        "vbscript:",
        ...(t.allowBase64 ? [] : ["data:"]),
      ].includes(n.protocol)
        ? !1
        : t.allowBase64 && n.protocol === "data:"
          ? /^data:image\/[a-z]+;base64,/.test(e)
          : n.hostname
            ? !0
            : n.protocol !== "" &&
              (n.pathname.startsWith("//") || n.pathname.startsWith("http")) &&
              !t.requireHostname
    } catch {
      return !1
    }
  },
  Lq = (e, t = {}) => {
    if (e)
      return t.allowBase64 && e.startsWith("data:image")
        ? Wy(e, { requireHostname: !1, allowBase64: !0 })
          ? e
          : void 0
        : Wy(e, { requireHostname: !1, allowBase64: t.allowBase64 }) ||
            /^(\/|#|mailto:|sms:|fax:|tel:)/.test(e)
          ? e
          : `https://${e}`
  },
  Pq = async (e) => {
    const n = await (await fetch(e)).blob()
    return new Promise((r, o) => {
      const i = new FileReader()
      ;(i.onloadend = () => {
        typeof i.result == "string"
          ? r(i.result)
          : o(new Error("Failed to convert Blob to base64"))
      }),
        (i.onerror = o),
        i.readAsDataURL(n)
    })
  },
  pu = () => Math.random().toString(36).slice(2, 11),
  zg = (e) =>
    new Promise((t, n) => {
      const r = new FileReader()
      ;(r.onloadend = () => {
        typeof r.result == "string"
          ? t(r.result)
          : n(new Error("Failed to convert File to base64"))
      }),
        (r.onerror = n),
        r.readAsDataURL(e)
    }),
  tS = (e, t, n, r, o) => {
    const { isValidType: i, isValidSize: s } = $q(e, t)
    i && s
      ? r.push(n)
      : (i || o.push({ file: e, reason: "type" }),
        s || o.push({ file: e, reason: "size" }))
  },
  $q = (e, { allowedMimeTypes: t, maxFileSize: n }) => {
    const r = e instanceof File ? e.type : Bq(e),
      o = e instanceof File ? e.size : atob(e.split(",")[1]).length,
      i = t.length === 0 || t.includes(r) || t.includes(`${r.split("/")[0]}/*`),
      s = !n || o <= n
    return { isValidType: i, isValidSize: s }
  },
  Bq = (e) => {
    const t = e.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/)
    return t && t.length > 1 ? t[1] : "unknown"
  },
  jq = (e) => {
    if (e.startsWith("data:")) {
      const t = e.match(/^data:[^;]+;base64,(.+)$/)
      if (t && t[1]) e = t[1]
      else return !1
    }
    try {
      return btoa(atob(e)) === e
    } catch {
      return !1
    }
  },
  yp = (e, t) => {
    const n = [],
      r = []
    return (
      e.forEach((o) => {
        const i = "src" in o ? o.src : o
        i instanceof File
          ? tS(i, t, o, n, r)
          : typeof i == "string" &&
            (jq(i)
              ? t.allowBase64
                ? tS(i, t, o, n, r)
                : r.push({ file: i, reason: "base64NotAllowed" })
              : Lq(i, { allowBase64: t.allowBase64 })
                ? n.push(o)
                : r.push({ file: i, reason: "invalidBase64" }))
      }),
      [n, r]
    )
  },
  R1 = m.forwardRef(({ className: e, keys: t, ...n }, r) => {
    const o = t.map((s) => zR(s)),
      i = o.map((s) => s.readable).join(" + ")
    return h.jsx("span", {
      "aria-label": i,
      className: q("inline-flex items-center gap-0.5", e),
      ...n,
      ref: r,
      children: o.map((s) =>
        h.jsx(
          "kbd",
          {
            className: q(
              "inline-block min-w-2.5 text-center align-baseline font-sans text-xs font-medium capitalize text-[rgb(156,157,160)]",
              e
            ),
            ...n,
            ref: r,
            children: s.symbol,
          },
          s.symbol
        )
      ),
    })
  })
R1.displayName = "ShortcutKey"
const Fq = [
    {
      label: "Normal Text",
      element: "span",
      className: "grow",
      shortcuts: ["mod", "alt", "0"],
    },
    {
      label: "Heading 1",
      element: "h1",
      level: 1,
      className: "m-0 grow text-3xl font-extrabold",
      shortcuts: ["mod", "alt", "1"],
    },
    {
      label: "Heading 2",
      element: "h2",
      level: 2,
      className: "m-0 grow text-xl font-bold",
      shortcuts: ["mod", "alt", "2"],
    },
    {
      label: "Heading 3",
      element: "h3",
      level: 3,
      className: "m-0 grow text-lg font-semibold",
      shortcuts: ["mod", "alt", "3"],
    },
    {
      label: "Heading 4",
      element: "h4",
      level: 4,
      className: "m-0 grow text-base font-semibold",
      shortcuts: ["mod", "alt", "4"],
    },
    {
      label: "Heading 5",
      element: "h5",
      level: 5,
      className: "m-0 grow text-sm font-normal",
      shortcuts: ["mod", "alt", "5"],
    },
    {
      label: "Heading 6",
      element: "h6",
      level: 6,
      className: "m-0 grow text-sm font-normal",
      shortcuts: ["mod", "alt", "6"],
    },
  ],
  UR = m.memo(
    ({
      editor: e,
      activeLevels: t = [1, 2, 3, 4, 5, 6],
      size: n,
      variant: r,
    }) => {
      const o = m.useMemo(
          () => Fq.filter((a) => !a.level || t.includes(a.level)),
          [t]
        ),
        i = m.useCallback(
          (a) => {
            a
              ? e.chain().focus().toggleHeading({ level: a }).run()
              : e.chain().focus().setParagraph().run()
          },
          [e]
        ),
        s = m.useCallback(
          ({ label: a, element: l, level: c, className: u, shortcuts: d }) =>
            h.jsxs(
              ym,
              {
                onClick: () => i(c),
                className: q(
                  "flex flex-row items-center justify-between gap-4",
                  {
                    "bg-accent": c
                      ? e.isActive("heading", { level: c })
                      : e.isActive("paragraph"),
                  }
                ),
                "aria-label": a,
                children: [
                  h.jsx(l, { className: u, children: a }),
                  h.jsx(R1, { keys: d }),
                ],
              },
              a
            ),
          [e, i]
        )
      return h.jsxs(M1, {
        children: [
          h.jsx(O1, {
            asChild: !0,
            children: h.jsxs(Er, {
              isActive: e.isActive("heading"),
              tooltip: "Text styles",
              "aria-label": "Text styles",
              pressed: e.isActive("heading"),
              className: "w-12",
              disabled: e.isActive("codeBlock"),
              size: n,
              variant: r,
              children: [
                h.jsx(QK, { className: "size-5" }),
                h.jsx(Fu, { className: "size-5" }),
              ],
            }),
          }),
          h.jsx(vm, {
            align: "start",
            className: "w-full",
            children: o.map(s),
          }),
        ],
      })
    }
  )
UR.displayName = "SectionOne"
const I1 = ({
    editor: e,
    actions: t,
    activeActions: n = t.map((c) => c.value),
    mainActionCount: r = 0,
    dropdownIcon: o,
    dropdownTooltip: i = "More options",
    dropdownClassName: s = "w-12",
    size: a,
    variant: l,
  }) => {
    const { mainActions: c, dropdownActions: u } = m.useMemo(() => {
        const g = t
          .filter((v) => n.includes(v.value))
          .sort((v, b) => n.indexOf(v.value) - n.indexOf(b.value))
        return { mainActions: g.slice(0, r), dropdownActions: g.slice(r) }
      }, [t, n, r]),
      d = m.useCallback(
        (g) =>
          h.jsx(
            Er,
            {
              onClick: () => g.action(e),
              disabled: !g.canExecute(e),
              isActive: g.isActive(e),
              tooltip: `${g.label} ${g.shortcuts.map((v) => zR(v).symbol).join(" ")}`,
              "aria-label": g.label,
              size: a,
              variant: l,
              children: g.icon,
            },
            g.label
          ),
        [e, a, l]
      ),
      f = m.useCallback(
        (g) =>
          h.jsxs(
            ym,
            {
              onClick: () => g.action(e),
              disabled: !g.canExecute(e),
              className: q("flex flex-row items-center justify-between gap-4", {
                "bg-accent": g.isActive(e),
              }),
              "aria-label": g.label,
              children: [
                h.jsx("span", { className: "grow", children: g.label }),
                h.jsx(R1, { keys: g.shortcuts }),
              ],
            },
            g.label
          ),
        [e]
      ),
      p = m.useMemo(() => u.some((g) => g.isActive(e)), [u, e])
    return h.jsxs(h.Fragment, {
      children: [
        c.map(d),
        u.length > 0 &&
          h.jsxs(M1, {
            children: [
              h.jsx(O1, {
                asChild: !0,
                children: h.jsx(Er, {
                  isActive: p,
                  tooltip: i,
                  "aria-label": i,
                  className: q(s),
                  size: a,
                  variant: l,
                  children: o || h.jsx(Fu, { className: "size-5" }),
                }),
              }),
              h.jsx(vm, {
                align: "start",
                className: "w-full",
                children: u.map(f),
              }),
            ],
          }),
      ],
    })
  },
  nS = [
    {
      value: "bold",
      label: "Bold",
      icon: h.jsx(KK, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleBold().run(),
      isActive: (e) => e.isActive("bold"),
      canExecute: (e) =>
        e.can().chain().focus().toggleBold().run() && !e.isActive("codeBlock"),
      shortcuts: ["mod", "B"],
    },
    {
      value: "italic",
      label: "Italic",
      icon: h.jsx(qK, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleItalic().run(),
      isActive: (e) => e.isActive("italic"),
      canExecute: (e) =>
        e.can().chain().focus().toggleItalic().run() &&
        !e.isActive("codeBlock"),
      shortcuts: ["mod", "I"],
    },
    {
      value: "underline",
      label: "Underline",
      icon: h.jsx(vG, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleUnderline().run(),
      isActive: (e) => e.isActive("underline"),
      canExecute: (e) =>
        e.can().chain().focus().toggleUnderline().run() &&
        !e.isActive("codeBlock"),
      shortcuts: ["mod", "U"],
    },
    {
      value: "strikethrough",
      label: "Strikethrough",
      icon: h.jsx(dG, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleStrike().run(),
      isActive: (e) => e.isActive("strike"),
      canExecute: (e) =>
        e.can().chain().focus().toggleStrike().run() &&
        !e.isActive("codeBlock"),
      shortcuts: ["mod", "shift", "S"],
    },
    {
      value: "code",
      label: "Code",
      icon: h.jsx(UA, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleCode().run(),
      isActive: (e) => e.isActive("code"),
      canExecute: (e) =>
        e.can().chain().focus().toggleCode().run() && !e.isActive("codeBlock"),
      shortcuts: ["mod", "E"],
    },
    {
      value: "clearFormatting",
      label: "Clear formatting",
      icon: h.jsx(pG, { className: "size-5" }),
      action: (e) => e.chain().focus().unsetAllMarks().run(),
      isActive: () => !1,
      canExecute: (e) =>
        e.can().chain().focus().unsetAllMarks().run() &&
        !e.isActive("codeBlock"),
      shortcuts: ["mod", "\\"],
    },
  ],
  VR = ({
    editor: e,
    activeActions: t = nS.map((i) => i.value),
    mainActionCount: n = 2,
    size: r,
    variant: o,
  }) =>
    h.jsx(I1, {
      editor: e,
      actions: nS,
      activeActions: t,
      mainActionCount: n,
      dropdownIcon: h.jsx(VA, { className: "size-5" }),
      dropdownTooltip: "More formatting",
      dropdownClassName: "w-8",
      size: r,
      variant: o,
    })
VR.displayName = "SectionTwo"
var D1 = "Popover",
  [HR, nne] = Wn(D1, [gl]),
  Vu = gl(),
  [zq, Bi] = HR(D1),
  WR = (e) => {
    const {
        __scopePopover: t,
        children: n,
        open: r,
        defaultOpen: o,
        onOpenChange: i,
        modal: s = !1,
      } = e,
      a = Vu(t),
      l = m.useRef(null),
      [c, u] = m.useState(!1),
      [d = !1, f] = Ir({ prop: r, defaultProp: o, onChange: i })
    return h.jsx(vb, {
      ...a,
      children: h.jsx(zq, {
        scope: t,
        contentId: fi(),
        triggerRef: l,
        open: d,
        onOpenChange: f,
        onOpenToggle: m.useCallback(() => f((p) => !p), [f]),
        hasCustomAnchor: c,
        onCustomAnchorAdd: m.useCallback(() => u(!0), []),
        onCustomAnchorRemove: m.useCallback(() => u(!1), []),
        modal: s,
        children: n,
      }),
    })
  }
WR.displayName = D1
var KR = "PopoverAnchor",
  Uq = m.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      o = Bi(KR, n),
      i = Vu(n),
      { onCustomAnchorAdd: s, onCustomAnchorRemove: a } = o
    return (
      m.useEffect(() => (s(), () => a()), [s, a]),
      h.jsx(Nh, { ...i, ...r, ref: t })
    )
  })
Uq.displayName = KR
var GR = "PopoverTrigger",
  qR = m.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      o = Bi(GR, n),
      i = Vu(n),
      s = tt(t, o.triggerRef),
      a = h.jsx(Le.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": JR(o.open),
        ...r,
        ref: s,
        onClick: ge(e.onClick, o.onOpenToggle),
      })
    return o.hasCustomAnchor ? a : h.jsx(Nh, { asChild: !0, ...i, children: a })
  })
qR.displayName = GR
var L1 = "PopoverPortal",
  [Vq, Hq] = HR(L1, { forceMount: void 0 }),
  ZR = (e) => {
    const { __scopePopover: t, forceMount: n, children: r, container: o } = e,
      i = Bi(L1, t)
    return h.jsx(Vq, {
      scope: t,
      forceMount: n,
      children: h.jsx(Kn, {
        present: n || i.open,
        children: h.jsx(Th, { asChild: !0, container: o, children: r }),
      }),
    })
  }
ZR.displayName = L1
var sl = "PopoverContent",
  YR = m.forwardRef((e, t) => {
    const n = Hq(sl, e.__scopePopover),
      { forceMount: r = n.forceMount, ...o } = e,
      i = Bi(sl, e.__scopePopover)
    return h.jsx(Kn, {
      present: r || i.open,
      children: i.modal
        ? h.jsx(Wq, { ...o, ref: t })
        : h.jsx(Kq, { ...o, ref: t }),
    })
  })
YR.displayName = sl
var Wq = m.forwardRef((e, t) => {
    const n = Bi(sl, e.__scopePopover),
      r = m.useRef(null),
      o = tt(t, r),
      i = m.useRef(!1)
    return (
      m.useEffect(() => {
        const s = r.current
        if (s) return $h(s)
      }, []),
      h.jsx(Sb, {
        as: An,
        allowPinchZoom: !0,
        children: h.jsx(XR, {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: ge(e.onCloseAutoFocus, (s) => {
            var a
            s.preventDefault(),
              i.current || (a = n.triggerRef.current) == null || a.focus()
          }),
          onPointerDownOutside: ge(
            e.onPointerDownOutside,
            (s) => {
              const a = s.detail.originalEvent,
                l = a.button === 0 && a.ctrlKey === !0,
                c = a.button === 2 || l
              i.current = c
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: ge(e.onFocusOutside, (s) => s.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
        }),
      })
    )
  }),
  Kq = m.forwardRef((e, t) => {
    const n = Bi(sl, e.__scopePopover),
      r = m.useRef(!1),
      o = m.useRef(!1)
    return h.jsx(XR, {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (i) => {
        var s, a
        ;(s = e.onCloseAutoFocus) == null || s.call(e, i),
          i.defaultPrevented ||
            (r.current || (a = n.triggerRef.current) == null || a.focus(),
            i.preventDefault()),
          (r.current = !1),
          (o.current = !1)
      },
      onInteractOutside: (i) => {
        var l, c
        ;(l = e.onInteractOutside) == null || l.call(e, i),
          i.defaultPrevented ||
            ((r.current = !0),
            i.detail.originalEvent.type === "pointerdown" && (o.current = !0))
        const s = i.target
        ;((c = n.triggerRef.current) == null ? void 0 : c.contains(s)) &&
          i.preventDefault(),
          i.detail.originalEvent.type === "focusin" &&
            o.current &&
            i.preventDefault()
      },
    })
  }),
  XR = m.forwardRef((e, t) => {
    const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: s,
        onEscapeKeyDown: a,
        onPointerDownOutside: l,
        onFocusOutside: c,
        onInteractOutside: u,
        ...d
      } = e,
      f = Bi(sl, n),
      p = Vu(n)
    return (
      wb(),
      h.jsx(Lh, {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        children: h.jsx(ku, {
          asChild: !0,
          disableOutsidePointerEvents: s,
          onInteractOutside: u,
          onEscapeKeyDown: a,
          onPointerDownOutside: l,
          onFocusOutside: c,
          onDismiss: () => f.onOpenChange(!1),
          children: h.jsx(yb, {
            "data-state": JR(f.open),
            role: "dialog",
            id: f.contentId,
            ...p,
            ...d,
            ref: t,
            style: {
              ...d.style,
              "--radix-popover-content-transform-origin":
                "var(--radix-popper-transform-origin)",
              "--radix-popover-content-available-width":
                "var(--radix-popper-available-width)",
              "--radix-popover-content-available-height":
                "var(--radix-popper-available-height)",
              "--radix-popover-trigger-width":
                "var(--radix-popper-anchor-width)",
              "--radix-popover-trigger-height":
                "var(--radix-popper-anchor-height)",
            },
          }),
        }),
      })
    )
  }),
  QR = "PopoverClose",
  Gq = m.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      o = Bi(QR, n)
    return h.jsx(Le.button, {
      type: "button",
      ...r,
      ref: t,
      onClick: ge(e.onClick, () => o.onOpenChange(!1)),
    })
  })
Gq.displayName = QR
var qq = "PopoverArrow",
  Zq = m.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      o = Vu(n)
    return h.jsx(bb, { ...o, ...r, ref: t })
  })
Zq.displayName = qq
function JR(e) {
  return e ? "open" : "closed"
}
var Yq = WR,
  Xq = qR,
  Qq = ZR,
  eI = YR
const tI = Yq,
  nI = Xq,
  P1 = m.forwardRef(
    ({ className: e, align: t = "center", sideOffset: n = 4, ...r }, o) =>
      h.jsx(Qq, {
        children: h.jsx(eI, {
          ref: o,
          align: t,
          sideOffset: n,
          className: q(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            e
          ),
          ...r,
        }),
      })
  )
P1.displayName = eI.displayName
var El = "ToggleGroup",
  [rI, rne] = Wn(El, [vl]),
  oI = vl(),
  $1 = G.forwardRef((e, t) => {
    const { type: n, ...r } = e
    if (n === "single") {
      const o = r
      return h.jsx(Jq, { ...o, ref: t })
    }
    if (n === "multiple") {
      const o = r
      return h.jsx(eZ, { ...o, ref: t })
    }
    throw new Error(`Missing prop \`type\` expected on \`${El}\``)
  })
$1.displayName = El
var [iI, sI] = rI(El),
  Jq = G.forwardRef((e, t) => {
    const { value: n, defaultValue: r, onValueChange: o = () => {}, ...i } = e,
      [s, a] = Ir({ prop: n, defaultProp: r, onChange: o })
    return h.jsx(iI, {
      scope: e.__scopeToggleGroup,
      type: "single",
      value: s ? [s] : [],
      onItemActivate: a,
      onItemDeactivate: G.useCallback(() => a(""), [a]),
      children: h.jsx(aI, { ...i, ref: t }),
    })
  }),
  eZ = G.forwardRef((e, t) => {
    const { value: n, defaultValue: r, onValueChange: o = () => {}, ...i } = e,
      [s = [], a] = Ir({ prop: n, defaultProp: r, onChange: o }),
      l = G.useCallback((u) => a((d = []) => [...d, u]), [a]),
      c = G.useCallback((u) => a((d = []) => d.filter((f) => f !== u)), [a])
    return h.jsx(iI, {
      scope: e.__scopeToggleGroup,
      type: "multiple",
      value: s,
      onItemActivate: l,
      onItemDeactivate: c,
      children: h.jsx(aI, { ...i, ref: t }),
    })
  })
$1.displayName = El
var [tZ, nZ] = rI(El),
  aI = G.forwardRef((e, t) => {
    const {
        __scopeToggleGroup: n,
        disabled: r = !1,
        rovingFocus: o = !0,
        orientation: i,
        dir: s,
        loop: a = !0,
        ...l
      } = e,
      c = oI(n),
      u = Hh(s),
      d = { role: "group", dir: u, ...l }
    return h.jsx(tZ, {
      scope: n,
      rovingFocus: o,
      disabled: r,
      children: o
        ? h.jsx(Ib, {
            asChild: !0,
            ...c,
            orientation: i,
            dir: u,
            loop: a,
            children: h.jsx(Le.div, { ...d, ref: t }),
          })
        : h.jsx(Le.div, { ...d, ref: t }),
    })
  }),
  bp = "ToggleGroupItem",
  lI = G.forwardRef((e, t) => {
    const n = sI(bp, e.__scopeToggleGroup),
      r = nZ(bp, e.__scopeToggleGroup),
      o = oI(e.__scopeToggleGroup),
      i = n.value.includes(e.value),
      s = r.disabled || e.disabled,
      a = { ...e, pressed: i, disabled: s },
      l = G.useRef(null)
    return r.rovingFocus
      ? h.jsx(Db, {
          asChild: !0,
          ...o,
          focusable: !s,
          active: i,
          ref: l,
          children: h.jsx(rS, { ...a, ref: t }),
        })
      : h.jsx(rS, { ...a, ref: t })
  })
lI.displayName = bp
var rS = G.forwardRef((e, t) => {
    const { __scopeToggleGroup: n, value: r, ...o } = e,
      i = sI(bp, n),
      s = { role: "radio", "aria-checked": e.pressed, "aria-pressed": void 0 },
      a = i.type === "single" ? s : void 0
    return h.jsx(A1, {
      ...a,
      ...o,
      ref: t,
      onPressedChange: (l) => {
        l ? i.onItemActivate(r) : i.onItemDeactivate(r)
      },
    })
  }),
  cI = $1,
  uI = lI
const dI = m.createContext({ size: "default", variant: "default" }),
  fI = m.forwardRef(
    ({ className: e, variant: t, size: n, children: r, ...o }, i) =>
      h.jsx(cI, {
        ref: i,
        className: q("flex items-center justify-center gap-1", e),
        ...o,
        children: h.jsx(dI.Provider, {
          value: { variant: t, size: n },
          children: r,
        }),
      })
  )
fI.displayName = cI.displayName
const pI = m.forwardRef(
  ({ className: e, children: t, variant: n, size: r, ...o }, i) => {
    const s = m.useContext(dI)
    return h.jsx(uI, {
      ref: i,
      className: q(jR({ variant: s.variant || n, size: s.size || r }), e),
      ...o,
      children: t,
    })
  }
)
pI.displayName = uI.displayName
const rZ = () => {
    const [e, t] = m.useState(!1)
    return (
      m.useEffect(() => {
        const n = window.matchMedia("(prefers-color-scheme: dark)")
        t(n.matches)
        const r = (o) => {
          const i = o.matches
          t(i)
        }
        return (
          n.addEventListener("change", r),
          () => {
            n.removeEventListener("change", r)
          }
        )
      }, []),
      e
    )
  },
  oZ = [
    {
      label: "Palette 1",
      inverse: "hsl(var(--background))",
      colors: [
        { cssVar: "hsl(var(--foreground))", label: "Default" },
        { cssVar: "var(--mt-accent-bold-blue)", label: "Bold blue" },
        { cssVar: "var(--mt-accent-bold-teal)", label: "Bold teal" },
        { cssVar: "var(--mt-accent-bold-green)", label: "Bold green" },
        { cssVar: "var(--mt-accent-bold-orange)", label: "Bold orange" },
        { cssVar: "var(--mt-accent-bold-red)", label: "Bold red" },
        { cssVar: "var(--mt-accent-bold-purple)", label: "Bold purple" },
      ],
    },
    {
      label: "Palette 2",
      inverse: "hsl(var(--background))",
      colors: [
        { cssVar: "var(--mt-accent-gray)", label: "Gray" },
        { cssVar: "var(--mt-accent-blue)", label: "Blue" },
        { cssVar: "var(--mt-accent-teal)", label: "Teal" },
        { cssVar: "var(--mt-accent-green)", label: "Green" },
        { cssVar: "var(--mt-accent-orange)", label: "Orange" },
        { cssVar: "var(--mt-accent-red)", label: "Red" },
        { cssVar: "var(--mt-accent-purple)", label: "Purple" },
      ],
    },
    {
      label: "Palette 3",
      inverse: "hsl(var(--foreground))",
      colors: [
        {
          cssVar: "hsl(var(--background))",
          label: "White",
          darkLabel: "Black",
        },
        { cssVar: "var(--mt-accent-blue-subtler)", label: "Blue subtle" },
        { cssVar: "var(--mt-accent-teal-subtler)", label: "Teal subtle" },
        { cssVar: "var(--mt-accent-green-subtler)", label: "Green subtle" },
        { cssVar: "var(--mt-accent-yellow-subtler)", label: "Yellow subtle" },
        { cssVar: "var(--mt-accent-red-subtler)", label: "Red subtle" },
        { cssVar: "var(--mt-accent-purple-subtler)", label: "Purple subtle" },
      ],
    },
  ],
  hI = m.memo(({ color: e, isSelected: t, inverse: n, onClick: r }) => {
    const i = rZ() && e.darkLabel ? e.darkLabel : e.label
    return h.jsxs(Ih, {
      children: [
        h.jsx(Dh, {
          asChild: !0,
          children: h.jsx(pI, {
            tabIndex: 0,
            className: "relative size-7 rounded-md p-0",
            value: e.cssVar,
            "aria-label": i,
            style: { backgroundColor: e.cssVar },
            onClick: (s) => {
              s.preventDefault(), r(e.cssVar)
            },
            children:
              t &&
              h.jsx(RK, {
                className: "absolute inset-0 m-auto size-6",
                style: { color: n },
              }),
          }),
        }),
        h.jsx(Tu, { side: "bottom", children: h.jsx("p", { children: i }) }),
      ],
    })
  })
hI.displayName = "MemoizedColorButton"
const mI = m.memo(
  ({ palette: e, selectedColor: t, inverse: n, onColorChange: r }) =>
    h.jsx(fI, {
      type: "single",
      value: t,
      onValueChange: (o) => {
        o && r(o)
      },
      className: "gap-1.5",
      children: e.colors.map((o, i) =>
        h.jsx(
          hI,
          { inverse: n, color: o, isSelected: t === o.cssVar, onClick: r },
          i
        )
      ),
    })
)
mI.displayName = "MemoizedColorPicker"
const gI = ({ editor: e, size: t, variant: n }) => {
  var a
  const r =
      ((a = e.getAttributes("textStyle")) == null ? void 0 : a.color) ||
      "hsl(var(--foreground))",
    [o, i] = m.useState(r),
    s = m.useCallback(
      (l) => {
        i(l), e.chain().setColor(l).run()
      },
      [e]
    )
  return (
    m.useEffect(() => {
      i(r)
    }, [r]),
    h.jsxs(tI, {
      children: [
        h.jsx(nI, {
          asChild: !0,
          children: h.jsxs(Er, {
            tooltip: "Text color",
            "aria-label": "Text color",
            className: "w-12",
            size: t,
            variant: n,
            children: [
              h.jsxs("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                className: "size-5",
                style: { color: o },
                children: [
                  h.jsx("path", { d: "M4 20h16" }),
                  h.jsx("path", { d: "m6 16 6-12 6 12" }),
                  h.jsx("path", { d: "M8 12h8" }),
                ],
              }),
              h.jsx(Fu, { className: "size-5" }),
            ],
          }),
        }),
        h.jsx(P1, {
          align: "start",
          className: "w-full",
          children: h.jsx("div", {
            className: "space-y-1.5",
            children: oZ.map((l, c) =>
              h.jsx(
                mI,
                {
                  palette: l,
                  inverse: l.inverse,
                  selectedColor: o,
                  onColorChange: s,
                },
                c
              )
            ),
          }),
        }),
      ],
    })
  )
}
gI.displayName = "SectionThree"
const oS = [
    {
      value: "orderedList",
      label: "Numbered list",
      icon: h.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        height: "20px",
        viewBox: "0 -960 960 960",
        width: "20px",
        fill: "currentColor",
        children: h.jsx("path", {
          d: "M144-144v-48h96v-24h-48v-48h48v-24h-96v-48h120q10.2 0 17.1 6.9 6.9 6.9 6.9 17.1v48q0 10.2-6.9 17.1-6.9 6.9-17.1 6.9 10.2 0 17.1 6.9 6.9 6.9 6.9 17.1v48q0 10.2-6.9 17.1-6.9 6.9-17.1 6.9H144Zm0-240v-96q0-10.2 6.9-17.1 6.9-6.9 17.1-6.9h72v-24h-96v-48h120q10.2 0 17.1 6.9 6.9 6.9 6.9 17.1v72q0 10.2-6.9 17.1-6.9 6.9-17.1 6.9h-72v24h96v48H144Zm48-240v-144h-48v-48h96v192h-48Zm168 384v-72h456v72H360Zm0-204v-72h456v72H360Zm0-204v-72h456v72H360Z",
        }),
      }),
      isActive: (e) => e.isActive("orderedList"),
      action: (e) => e.chain().focus().toggleOrderedList().run(),
      canExecute: (e) => e.can().chain().focus().toggleOrderedList().run(),
      shortcuts: ["mod", "shift", "7"],
    },
    {
      value: "bulletList",
      label: "Bullet list",
      icon: h.jsx(HA, { className: "size-5" }),
      isActive: (e) => e.isActive("bulletList"),
      action: (e) => e.chain().focus().toggleBulletList().run(),
      canExecute: (e) => e.can().chain().focus().toggleBulletList().run(),
      shortcuts: ["mod", "shift", "8"],
    },
    {
      value: "taskList",
      label: "Todo list",
      icon: h.jsx(pL, { className: "size-5" }),
      isActive: (e) => e.isActive("taskList"),
      action: (e) => e.chain().focus().toggleTaskList().run(),
      canExecute: (e) => e.can().chain().focus().toggleTaskList().run(),
      shortcuts: ["mod", "shift", "9"],
    },
  ],
  vI = ({
    editor: e,
    activeActions: t = oS.map((i) => i.value),
    mainActionCount: n = 0,
    size: r,
    variant: o,
  }) =>
    h.jsx(I1, {
      editor: e,
      actions: oS,
      activeActions: t,
      mainActionCount: n,
      dropdownIcon: h.jsxs(h.Fragment, {
        children: [
          h.jsx(HA, { className: "size-5" }),
          h.jsx(Fu, { className: "size-5" }),
        ],
      }),
      dropdownTooltip: "Lists",
      size: r,
      variant: o,
    })
vI.displayName = "SectionFour"
var B1 = "Switch",
  [iZ, one] = Wn(B1),
  [sZ, aZ] = iZ(B1),
  yI = m.forwardRef((e, t) => {
    const {
        __scopeSwitch: n,
        name: r,
        checked: o,
        defaultChecked: i,
        required: s,
        disabled: a,
        value: l = "on",
        onCheckedChange: c,
        form: u,
        ...d
      } = e,
      [f, p] = m.useState(null),
      g = tt(t, (E) => p(E)),
      v = m.useRef(!1),
      b = f ? u || !!f.closest("form") : !0,
      [y = !1, x] = Ir({ prop: o, defaultProp: i, onChange: c })
    return h.jsxs(sZ, {
      scope: n,
      checked: y,
      disabled: a,
      children: [
        h.jsx(Le.button, {
          type: "button",
          role: "switch",
          "aria-checked": y,
          "aria-required": s,
          "data-state": wI(y),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: l,
          ...d,
          ref: g,
          onClick: ge(e.onClick, (E) => {
            x((w) => !w),
              b &&
                ((v.current = E.isPropagationStopped()),
                v.current || E.stopPropagation())
          }),
        }),
        b &&
          h.jsx(lZ, {
            control: f,
            bubbles: !v.current,
            name: r,
            value: l,
            checked: y,
            required: s,
            disabled: a,
            form: u,
            style: { transform: "translateX(-100%)" },
          }),
      ],
    })
  })
yI.displayName = B1
var bI = "SwitchThumb",
  xI = m.forwardRef((e, t) => {
    const { __scopeSwitch: n, ...r } = e,
      o = aZ(bI, n)
    return h.jsx(Le.span, {
      "data-state": wI(o.checked),
      "data-disabled": o.disabled ? "" : void 0,
      ...r,
      ref: t,
    })
  })
xI.displayName = bI
var lZ = (e) => {
  const { control: t, checked: n, bubbles: r = !0, ...o } = e,
    i = m.useRef(null),
    s = Lb(n),
    a = kh(t)
  return (
    m.useEffect(() => {
      const l = i.current,
        c = window.HTMLInputElement.prototype,
        d = Object.getOwnPropertyDescriptor(c, "checked").set
      if (s !== n && d) {
        const f = new Event("click", { bubbles: r })
        d.call(l, n), l.dispatchEvent(f)
      }
    }, [s, n, r]),
    h.jsx("input", {
      type: "checkbox",
      "aria-hidden": !0,
      defaultChecked: n,
      ...o,
      tabIndex: -1,
      ref: i,
      style: {
        ...e.style,
        ...a,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0,
      },
    })
  )
}
function wI(e) {
  return e ? "checked" : "unchecked"
}
var EI = yI,
  cZ = xI
const CI = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(EI, {
    className: q(
      "peer inline-flex h-[24px] w-[44px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      e
    ),
    ...t,
    ref: n,
    children: h.jsx(cZ, {
      className: q(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      ),
    }),
  })
)
CI.displayName = EI.displayName
const j1 = m.forwardRef(
  (
    {
      onSave: e,
      defaultIsNewTab: t,
      defaultUrl: n,
      defaultText: r,
      className: o,
    },
    i
  ) => {
    const s = m.useRef(null),
      [a, l] = m.useState(n || ""),
      [c, u] = m.useState(r || ""),
      [d, f] = m.useState(t || !1),
      p = m.useCallback(
        (g) => {
          g.preventDefault(),
            s.current &&
              (Array.from(s.current.querySelectorAll("input")).every((b) =>
                b.checkValidity()
              )
                ? e(a, c, d)
                : s.current.querySelectorAll("input").forEach((b) => {
                    b.checkValidity() || b.reportValidity()
                  }))
        },
        [e, a, c, d]
      )
    return (
      m.useImperativeHandle(i, () => s.current),
      h.jsx("div", {
        ref: s,
        children: h.jsxs("div", {
          className: q("space-y-4", o),
          children: [
            h.jsxs("div", {
              className: "space-y-1",
              children: [
                h.jsx(Aa, { children: "URL" }),
                h.jsx(St, {
                  type: "url",
                  required: !0,
                  placeholder: "Enter URL",
                  value: a,
                  onChange: (g) => l(g.target.value),
                }),
              ],
            }),
            h.jsxs("div", {
              className: "space-y-1",
              children: [
                h.jsx(Aa, { children: "Display Text (optional)" }),
                h.jsx(St, {
                  type: "text",
                  placeholder: "Enter display text",
                  value: c,
                  onChange: (g) => u(g.target.value),
                }),
              ],
            }),
            h.jsxs("div", {
              className: "flex items-center space-x-2",
              children: [
                h.jsx(Aa, { children: "Open in New Tab" }),
                h.jsx(CI, { checked: d, onCheckedChange: f }),
              ],
            }),
            h.jsx("div", {
              className: "flex justify-end space-x-2",
              children: h.jsx(et, {
                type: "button",
                onClick: p,
                children: "Save",
              }),
            }),
          ],
        }),
      })
    )
  }
)
j1.displayName = "LinkEditBlock"
const uZ = ({ editor: e, size: t, variant: n }) => {
    const [r, o] = m.useState(!1),
      { from: i, to: s } = e.state.selection,
      a = e.state.doc.textBetween(i, s, " "),
      l = m.useCallback(
        (c, u, d) => {
          e
            .chain()
            .focus()
            .extendMarkRange("link")
            .insertContent({
              type: "text",
              text: u || c,
              marks: [
                { type: "link", attrs: { href: c, target: d ? "_blank" : "" } },
              ],
            })
            .setLink({ href: c })
            .run(),
            e.commands.enter()
        },
        [e]
      )
    return h.jsxs(tI, {
      open: r,
      onOpenChange: o,
      children: [
        h.jsx(nI, {
          asChild: !0,
          children: h.jsx(Er, {
            isActive: e.isActive("link"),
            tooltip: "Link",
            "aria-label": "Insert link",
            disabled: e.isActive("codeBlock"),
            size: t,
            variant: n,
            children: h.jsx(dL, { className: "size-5" }),
          }),
        }),
        h.jsx(P1, {
          className: "w-full min-w-80",
          align: "end",
          side: "bottom",
          children: h.jsx(j1, { onSave: l, defaultText: a }),
        }),
      ],
    })
  },
  dZ = ({ editor: e, close: t }) => {
    const n = m.useRef(null),
      [r, o] = m.useState(""),
      i = m.useCallback(() => {
        var l
        ;(l = n.current) == null || l.click()
      }, []),
      s = m.useCallback(
        async (l) => {
          const c = l.target.files
          if (!(c != null && c.length)) return
          await (async () => {
            const d = [],
              f = Array.from(c)
            for (const p of f) d.push({ src: p })
            e.commands.setImages(d)
          })(),
            t()
        },
        [e, t]
      ),
      a = m.useCallback(
        (l) => {
          l.preventDefault(),
            l.stopPropagation(),
            r && (e.commands.setImages([{ src: r }]), t())
        },
        [e, r, t]
      )
    return h.jsxs("form", {
      onSubmit: a,
      className: "space-y-6",
      children: [
        h.jsxs("div", {
          className: "space-y-1",
          children: [
            h.jsx(Aa, {
              htmlFor: "image-link",
              children: "Attach an image link",
            }),
            h.jsxs("div", {
              className: "flex",
              children: [
                h.jsx(St, {
                  id: "image-link",
                  type: "url",
                  required: !0,
                  placeholder: "https://example.com",
                  value: r,
                  className: "grow",
                  onChange: (l) => o(l.target.value),
                }),
                h.jsx(et, {
                  type: "submit",
                  className: "ml-2",
                  children: "Submit",
                }),
              ],
            }),
          ],
        }),
        h.jsx(et, {
          type: "button",
          className: "w-full",
          onClick: i,
          children: "Upload from your computer",
        }),
        h.jsx("input", {
          type: "file",
          accept: "image/*",
          ref: n,
          multiple: !0,
          className: "hidden",
          onChange: s,
        }),
      ],
    })
  },
  fZ = ({ editor: e, size: t, variant: n }) => {
    const [r, o] = m.useState(!1)
    return h.jsxs(Au, {
      open: r,
      onOpenChange: o,
      children: [
        h.jsx(Ru, {
          asChild: !0,
          children: h.jsx(Er, {
            isActive: e.isActive("image"),
            tooltip: "Image",
            "aria-label": "Image",
            size: t,
            variant: n,
            children: h.jsx(aL, { className: "size-5" }),
          }),
        }),
        h.jsxs(yl, {
          className: "sm:max-w-lg",
          children: [
            h.jsxs(bl, {
              children: [
                h.jsx(xl, { children: "Select image" }),
                h.jsx(Hb, {
                  className: "sr-only",
                  children: "Upload an image from your computer",
                }),
              ],
            }),
            h.jsx(dZ, { editor: e, close: () => o(!1) }),
          ],
        }),
      ],
    })
  },
  iS = [
    {
      value: "codeBlock",
      label: "Code block",
      icon: h.jsx(UA, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleCodeBlock().run(),
      isActive: (e) => e.isActive("codeBlock"),
      canExecute: (e) => e.can().chain().focus().toggleCodeBlock().run(),
      shortcuts: ["mod", "alt", "C"],
    },
    {
      value: "blockquote",
      label: "Blockquote",
      icon: h.jsx(aG, { className: "size-5" }),
      action: (e) => e.chain().focus().toggleBlockquote().run(),
      isActive: (e) => e.isActive("blockquote"),
      canExecute: (e) => e.can().chain().focus().toggleBlockquote().run(),
      shortcuts: ["mod", "shift", "B"],
    },
    {
      value: "horizontalRule",
      label: "Divider",
      icon: h.jsx(jK, { className: "size-5" }),
      action: (e) => e.chain().focus().setHorizontalRule().run(),
      isActive: () => !1,
      canExecute: (e) => e.can().chain().focus().setHorizontalRule().run(),
      shortcuts: ["mod", "alt", "-"],
    },
  ],
  SI = ({
    editor: e,
    activeActions: t = iS.map((i) => i.value),
    mainActionCount: n = 0,
    size: r,
    variant: o,
  }) =>
    h.jsxs(h.Fragment, {
      children: [
        h.jsx(uZ, { editor: e, size: r, variant: o }),
        h.jsx(fZ, { editor: e, size: r, variant: o }),
        h.jsx(I1, {
          editor: e,
          actions: iS,
          activeActions: t,
          mainActionCount: n,
          dropdownIcon: h.jsxs(h.Fragment, {
            children: [
              h.jsx(iG, { className: "size-5" }),
              h.jsx(Fu, { className: "size-5" }),
            ],
          }),
          dropdownTooltip: "Insert elements",
          size: r,
          variant: o,
        }),
      ],
    })
SI.displayName = "SectionFive"
const pZ = ({ url: e, onClear: t, onEdit: n }) => {
    const [r, o] = m.useState("Copy"),
      i = m.useCallback(
        (a) => {
          a.preventDefault(),
            navigator.clipboard
              .writeText(e)
              .then(() => {
                o("Copied!"), setTimeout(() => o("Copy"), 1e3)
              })
              .catch(console.error)
        },
        [e]
      ),
      s = m.useCallback(() => {
        window.open(e, "_blank", "noopener,noreferrer")
      }, [e])
    return h.jsx("div", {
      className:
        "flex h-10 overflow-hidden rounded bg-background p-2 shadow-lg",
      children: h.jsxs("div", {
        className: "inline-flex items-center gap-1",
        children: [
          h.jsx(Er, {
            tooltip: "Edit link",
            onClick: n,
            className: "w-auto px-2",
            children: "Edit link",
          }),
          h.jsx(bo, { orientation: "vertical" }),
          h.jsx(Er, {
            tooltip: "Open link in a new tab",
            onClick: s,
            children: h.jsx(HK, { className: "size-4" }),
          }),
          h.jsx(bo, { orientation: "vertical" }),
          h.jsx(Er, {
            tooltip: "Clear link",
            onClick: t,
            children: h.jsx(nG, { className: "size-4" }),
          }),
          h.jsx(bo, { orientation: "vertical" }),
          h.jsx(Er, {
            tooltip: r,
            onClick: i,
            tooltipOptions: {
              onPointerDownOutside: (a) => {
                a.target === a.currentTarget && a.preventDefault()
              },
            },
            children: h.jsx($K, { className: "size-4" }),
          }),
        ],
      }),
    })
  },
  hZ = ({ editor: e }) => {
    const [t, n] = m.useState(!1),
      [r, o] = m.useState({ href: "", target: "" }),
      [i, s] = m.useState(""),
      a = m.useCallback(() => {
        const { from: f, to: p } = e.state.selection,
          { href: g, target: v } = e.getAttributes("link"),
          b = e.state.doc.textBetween(f, p, " ")
        o({ href: g, target: v }), s(b)
      }, [e]),
      l = m.useCallback(
        ({ editor: f, from: p, to: g }) => {
          if (p === g) return !1
          const { href: v } = f.getAttributes("link")
          return !f.isActive("link") || !f.isEditable ? !1 : v ? (a(), !0) : !1
        },
        [a]
      ),
      c = m.useCallback(() => {
        n(!0)
      }, []),
      u = m.useCallback(
        (f, p, g) => {
          e
            .chain()
            .focus()
            .extendMarkRange("link")
            .insertContent({
              type: "text",
              text: p || f,
              marks: [
                { type: "link", attrs: { href: f, target: g ? "_blank" : "" } },
              ],
            })
            .setLink({ href: f, target: g ? "_blank" : "" })
            .run(),
            n(!1),
            a()
        },
        [e, a]
      ),
      d = m.useCallback(() => {
        e.chain().focus().extendMarkRange("link").unsetLink().run(), n(!1), a()
      }, [e, a])
    return h.jsx(EK, {
      editor: e,
      shouldShow: l,
      tippyOptions: { placement: "bottom-start", onHidden: () => n(!1) },
      children: t
        ? h.jsx(j1, {
            defaultUrl: r.href,
            defaultText: i,
            defaultIsNewTab: r.target === "_blank",
            onSave: u,
            className:
              "w-full min-w-80 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none",
          })
        : h.jsx(pZ, { onClear: d, url: r.href, onEdit: c }),
    })
  },
  mZ = ct.create({
    name: "placeholder",
    addOptions() {
      return {
        emptyEditorClass: "is-editor-empty",
        emptyNodeClass: "is-empty",
        placeholder: "Write something ",
        showOnlyWhenEditable: !0,
        showOnlyCurrent: !0,
        includeChildren: !1,
      }
    },
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("placeholder"),
          props: {
            decorations: ({ doc: e, selection: t }) => {
              const n =
                  this.editor.isEditable || !this.options.showOnlyWhenEditable,
                { anchor: r } = t,
                o = []
              if (!n) return null
              const i = this.editor.isEmpty
              return (
                e.descendants((s, a) => {
                  const l = r >= a && r <= a + s.nodeSize,
                    c = !s.isLeaf && fm(s)
                  if ((l || !this.options.showOnlyCurrent) && c) {
                    const u = [this.options.emptyNodeClass]
                    i && u.push(this.options.emptyEditorClass)
                    const d = pn.node(a, a + s.nodeSize, {
                      class: u.join(" "),
                      "data-placeholder":
                        typeof this.options.placeholder == "function"
                          ? this.options.placeholder({
                              editor: this.editor,
                              node: s,
                              pos: a,
                              hasAnchor: l,
                            })
                          : this.options.placeholder,
                    })
                    o.push(d)
                  }
                  return this.options.includeChildren
                }),
                mt.create(e, o)
              )
            },
          },
        }),
      ]
    },
  }),
  gZ = (e) => {
    if (!e.children.length) return
    const t = e.querySelectorAll("span")
    t &&
      t.forEach((n) => {
        var r, o
        const i = n.getAttribute("style"),
          s =
            (o =
              (r = n.parentElement) === null || r === void 0
                ? void 0
                : r.closest("span")) === null || o === void 0
              ? void 0
              : o.getAttribute("style")
        n.setAttribute("style", `${s};${i}`)
      })
  },
  vZ = Rr.create({
    name: "textStyle",
    priority: 101,
    addOptions() {
      return { HTMLAttributes: {}, mergeNestedSpanStyles: !1 }
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (e) =>
            e.hasAttribute("style")
              ? (this.options.mergeNestedSpanStyles && gZ(e), {})
              : !1,
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["span", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        removeEmptyTextStyle:
          () =>
          ({ tr: e }) => {
            const { selection: t } = e
            return (
              e.doc.nodesBetween(t.from, t.to, (n, r) => {
                if (n.isTextblock) return !0
                n.marks
                  .filter((o) => o.type === this.type)
                  .some((o) => Object.values(o.attrs).some((i) => !!i)) ||
                  e.removeMark(r, r + n.nodeSize, this.type)
              }),
              !0
            )
          },
      }
    },
  }),
  yZ = (e) => vt({ find: /--$/, replace: e != null ? e : "" }),
  bZ = (e) => vt({ find: /\.\.\.$/, replace: e != null ? e : "" }),
  xZ = (e) =>
    vt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
      replace: e != null ? e : "",
    }),
  wZ = (e) => vt({ find: /"$/, replace: e != null ? e : "" }),
  EZ = (e) =>
    vt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
      replace: e != null ? e : "",
    }),
  CZ = (e) => vt({ find: /'$/, replace: e != null ? e : "" }),
  SZ = (e) => vt({ find: /<-$/, replace: e != null ? e : "" }),
  _Z = (e) => vt({ find: /->$/, replace: e != null ? e : "" }),
  kZ = (e) => vt({ find: /\(c\)$/, replace: e != null ? e : "" }),
  NZ = (e) => vt({ find: /\(tm\)$/, replace: e != null ? e : "" }),
  TZ = (e) => vt({ find: /\(sm\)$/, replace: e != null ? e : "" }),
  MZ = (e) => vt({ find: /\(r\)$/, replace: e != null ? e : "" }),
  OZ = (e) => vt({ find: /(?:^|\s)(1\/2)\s$/, replace: e != null ? e : "" }),
  AZ = (e) => vt({ find: /\+\/-$/, replace: e != null ? e : "" }),
  RZ = (e) => vt({ find: /!=$/, replace: e != null ? e : "" }),
  IZ = (e) => vt({ find: /<<$/, replace: e != null ? e : "" }),
  DZ = (e) => vt({ find: />>$/, replace: e != null ? e : "" }),
  LZ = (e) => vt({ find: /\d+\s?([*x])\s?\d+$/, replace: e != null ? e : "" }),
  PZ = (e) => vt({ find: /\^2$/, replace: e != null ? e : "" }),
  $Z = (e) => vt({ find: /\^3$/, replace: e != null ? e : "" }),
  BZ = (e) => vt({ find: /(?:^|\s)(1\/4)\s$/, replace: e != null ? e : "" }),
  jZ = (e) => vt({ find: /(?:^|\s)(3\/4)\s$/, replace: e != null ? e : "" }),
  FZ = ct.create({
    name: "typography",
    addOptions() {
      return {
        closeDoubleQuote: "",
        closeSingleQuote: "",
        copyright: "",
        ellipsis: "",
        emDash: "",
        laquo: "",
        leftArrow: "",
        multiplication: "",
        notEqual: "",
        oneHalf: "",
        oneQuarter: "",
        openDoubleQuote: "",
        openSingleQuote: "",
        plusMinus: "",
        raquo: "",
        registeredTrademark: "",
        rightArrow: "",
        servicemark: "",
        superscriptThree: "",
        superscriptTwo: "",
        threeQuarters: "",
        trademark: "",
      }
    },
    addInputRules() {
      const e = []
      return (
        this.options.emDash !== !1 && e.push(yZ(this.options.emDash)),
        this.options.ellipsis !== !1 && e.push(bZ(this.options.ellipsis)),
        this.options.openDoubleQuote !== !1 &&
          e.push(xZ(this.options.openDoubleQuote)),
        this.options.closeDoubleQuote !== !1 &&
          e.push(wZ(this.options.closeDoubleQuote)),
        this.options.openSingleQuote !== !1 &&
          e.push(EZ(this.options.openSingleQuote)),
        this.options.closeSingleQuote !== !1 &&
          e.push(CZ(this.options.closeSingleQuote)),
        this.options.leftArrow !== !1 && e.push(SZ(this.options.leftArrow)),
        this.options.rightArrow !== !1 && e.push(_Z(this.options.rightArrow)),
        this.options.copyright !== !1 && e.push(kZ(this.options.copyright)),
        this.options.trademark !== !1 && e.push(NZ(this.options.trademark)),
        this.options.servicemark !== !1 && e.push(TZ(this.options.servicemark)),
        this.options.registeredTrademark !== !1 &&
          e.push(MZ(this.options.registeredTrademark)),
        this.options.oneHalf !== !1 && e.push(OZ(this.options.oneHalf)),
        this.options.plusMinus !== !1 && e.push(AZ(this.options.plusMinus)),
        this.options.notEqual !== !1 && e.push(RZ(this.options.notEqual)),
        this.options.laquo !== !1 && e.push(IZ(this.options.laquo)),
        this.options.raquo !== !1 && e.push(DZ(this.options.raquo)),
        this.options.multiplication !== !1 &&
          e.push(LZ(this.options.multiplication)),
        this.options.superscriptTwo !== !1 &&
          e.push(PZ(this.options.superscriptTwo)),
        this.options.superscriptThree !== !1 &&
          e.push($Z(this.options.superscriptThree)),
        this.options.oneQuarter !== !1 && e.push(BZ(this.options.oneQuarter)),
        this.options.threeQuarters !== !1 &&
          e.push(jZ(this.options.threeQuarters)),
        e
      )
    },
  }),
  zZ = Rr.create({
    name: "underline",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: "u" },
        {
          style: "text-decoration",
          consuming: !1,
          getAttrs: (e) => (e.includes("underline") ? {} : !1),
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["u", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setUnderline:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleUnderline:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetUnderline:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline(),
      }
    },
  }),
  UZ = /^\s*>\s$/,
  VZ = Rn.create({
    name: "blockquote",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    content: "block+",
    group: "block",
    defining: !0,
    parseHTML() {
      return [{ tag: "blockquote" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["blockquote", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setBlockquote:
          () =>
          ({ commands: e }) =>
            e.wrapIn(this.name),
        toggleBlockquote:
          () =>
          ({ commands: e }) =>
            e.toggleWrap(this.name),
        unsetBlockquote:
          () =>
          ({ commands: e }) =>
            e.lift(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() }
    },
    addInputRules() {
      return [tl({ find: UZ, type: this.type })]
    },
  }),
  HZ = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
  WZ = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
  KZ = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
  GZ = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
  qZ = Rr.create({
    name: "bold",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: "strong" },
        { tag: "b", getAttrs: (e) => e.style.fontWeight !== "normal" && null },
        {
          style: "font-weight=400",
          clearMark: (e) => e.type.name === this.name,
        },
        {
          style: "font-weight",
          getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null,
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["strong", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setBold:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleBold:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetBold:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold(),
      }
    },
    addInputRules() {
      return [
        el({ find: HZ, type: this.type }),
        el({ find: KZ, type: this.type }),
      ]
    },
    addPasteRules() {
      return [
        Ts({ find: WZ, type: this.type }),
        Ts({ find: GZ, type: this.type }),
      ]
    },
  }),
  ZZ = "listItem",
  sS = "textStyle",
  aS = /^\s*([-+*])\s$/,
  YZ = Rn.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: !1,
        keepAttributes: !1,
      }
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`
    },
    parseHTML() {
      return [{ tag: "ul" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["ul", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        toggleBulletList:
          () =>
          ({ commands: e, chain: t }) =>
            this.options.keepAttributes
              ? t()
                  .toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  )
                  .updateAttributes(ZZ, this.editor.getAttributes(sS))
                  .run()
              : e.toggleList(
                  this.name,
                  this.options.itemTypeName,
                  this.options.keepMarks
                ),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() }
    },
    addInputRules() {
      let e = tl({ find: aS, type: this.type })
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (e = tl({
            find: aS,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(sS),
            editor: this.editor,
          })),
        [e]
      )
    },
  }),
  XZ = /(^|[^`])`([^`]+)`(?!`)/,
  QZ = /(^|[^`])`([^`]+)`(?!`)/g,
  JZ = Rr.create({
    name: "code",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    excludes: "_",
    code: !0,
    exitable: !0,
    parseHTML() {
      return [{ tag: "code" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["code", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setCode:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleCode:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetCode:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-e": () => this.editor.commands.toggleCode() }
    },
    addInputRules() {
      return [el({ find: XZ, type: this.type })]
    },
    addPasteRules() {
      return [Ts({ find: QZ, type: this.type })]
    },
  }),
  eY = /^```([a-z]+)?[\s\n]$/,
  tY = /^~~~([a-z]+)?[\s\n]$/,
  _I = Rn.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: !0,
        exitOnArrowDown: !0,
        defaultLanguage: null,
        HTMLAttributes: {},
      }
    },
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    addAttributes() {
      return {
        language: {
          default: this.options.defaultLanguage,
          parseHTML: (e) => {
            var t
            const { languageClassPrefix: n } = this.options,
              i = [
                ...(((t = e.firstElementChild) === null || t === void 0
                  ? void 0
                  : t.classList) || []),
              ]
                .filter((s) => s.startsWith(n))
                .map((s) => s.replace(n, ""))[0]
            return i || null
          },
          rendered: !1,
        },
      }
    },
    parseHTML() {
      return [{ tag: "pre", preserveWhitespace: "full" }]
    },
    renderHTML({ node: e, HTMLAttributes: t }) {
      return [
        "pre",
        lt(this.options.HTMLAttributes, t),
        [
          "code",
          {
            class: e.attrs.language
              ? this.options.languageClassPrefix + e.attrs.language
              : null,
          },
          0,
        ],
      ]
    },
    addCommands() {
      return {
        setCodeBlock:
          (e) =>
          ({ commands: t }) =>
            t.setNode(this.name, e),
        toggleCodeBlock:
          (e) =>
          ({ commands: t }) =>
            t.toggleNode(this.name, "paragraph", e),
      }
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        Backspace: () => {
          const { empty: e, $anchor: t } = this.editor.state.selection,
            n = t.pos === 1
          return !e || t.parent.type.name !== this.name
            ? !1
            : n || !t.parent.textContent.length
              ? this.editor.commands.clearNodes()
              : !1
        },
        Enter: ({ editor: e }) => {
          if (!this.options.exitOnTripleEnter) return !1
          const { state: t } = e,
            { selection: n } = t,
            { $from: r, empty: o } = n
          if (!o || r.parent.type !== this.type) return !1
          const i = r.parentOffset === r.parent.nodeSize - 2,
            s = r.parent.textContent.endsWith(`

`)
          return !i || !s
            ? !1
            : e
                .chain()
                .command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0))
                .exitCode()
                .run()
        },
        ArrowDown: ({ editor: e }) => {
          if (!this.options.exitOnArrowDown) return !1
          const { state: t } = e,
            { selection: n, doc: r } = t,
            { $from: o, empty: i } = n
          if (
            !i ||
            o.parent.type !== this.type ||
            !(o.parentOffset === o.parent.nodeSize - 2)
          )
            return !1
          const a = o.after()
          return a === void 0
            ? !1
            : r.nodeAt(a)
              ? e.commands.command(
                  ({ tr: c }) => (c.setSelection(Ne.near(r.resolve(a))), !0)
                )
              : e.commands.exitCode()
        },
      }
    },
    addInputRules() {
      return [
        $y({
          find: eY,
          type: this.type,
          getAttributes: (e) => ({ language: e[1] }),
        }),
        $y({
          find: tY,
          type: this.type,
          getAttributes: (e) => ({ language: e[1] }),
        }),
      ]
    },
    addProseMirrorPlugins() {
      return [
        new rt({
          key: new At("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (e, t) => {
              if (!t.clipboardData || this.editor.isActive(this.type.name))
                return !1
              const n = t.clipboardData.getData("text/plain"),
                r = t.clipboardData.getData("vscode-editor-data"),
                o = r ? JSON.parse(r) : void 0,
                i = o == null ? void 0 : o.mode
              if (!n || !i) return !1
              const { tr: s, schema: a } = e.state,
                l = a.text(
                  n.replace(
                    /\r\n?/g,
                    `
`
                  )
                )
              return (
                s.replaceSelectionWith(this.type.create({ language: i }, l)),
                s.selection.$from.parent.type !== this.type &&
                  s.setSelection(
                    _e.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))
                  ),
                s.setMeta("paste", !0),
                e.dispatch(s),
                !0
              )
            },
          },
        }),
      ]
    },
  }),
  nY = Rn.create({ name: "doc", topNode: !0, content: "block+" })
function rY(e = {}) {
  return new rt({
    view(t) {
      return new oY(t, e)
    },
  })
}
class oY {
  constructor(t, n) {
    var r
    ;(this.editorView = t),
      (this.cursorPos = null),
      (this.element = null),
      (this.timeout = -1),
      (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
      (this.color = n.color === !1 ? void 0 : n.color || "black"),
      (this.class = n.class),
      (this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
        let i = (s) => {
          this[o](s)
        }
        return t.dom.addEventListener(o, i), { name: o, handler: i }
      }))
  }
  destroy() {
    this.handlers.forEach(({ name: t, handler: n }) =>
      this.editorView.dom.removeEventListener(t, n)
    )
  }
  update(t, n) {
    this.cursorPos != null &&
      n.doc != t.state.doc &&
      (this.cursorPos > t.state.doc.content.size
        ? this.setCursor(null)
        : this.updateOverlay())
  }
  setCursor(t) {
    t != this.cursorPos &&
      ((this.cursorPos = t),
      t == null
        ? (this.element.parentNode.removeChild(this.element),
          (this.element = null))
        : this.updateOverlay())
  }
  updateOverlay() {
    let t = this.editorView.state.doc.resolve(this.cursorPos),
      n = !t.parent.inlineContent,
      r
    if (n) {
      let a = t.nodeBefore,
        l = t.nodeAfter
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0))
        if (c) {
          let u = c.getBoundingClientRect(),
            d = a ? u.bottom : u.top
          a &&
            l &&
            (d =
              (d +
                this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect()
                  .top) /
              2),
            (r = {
              left: u.left,
              right: u.right,
              top: d - this.width / 2,
              bottom: d + this.width / 2,
            })
        }
      }
    }
    if (!r) {
      let a = this.editorView.coordsAtPos(this.cursorPos)
      r = {
        left: a.left - this.width / 2,
        right: a.left + this.width / 2,
        top: a.top,
        bottom: a.bottom,
      }
    }
    let o = this.editorView.dom.offsetParent
    this.element ||
      ((this.element = o.appendChild(document.createElement("div"))),
      this.class && (this.element.className = this.class),
      (this.element.style.cssText =
        "position: absolute; z-index: 50; pointer-events: none;"),
      this.color && (this.element.style.backgroundColor = this.color)),
      this.element.classList.toggle("prosemirror-dropcursor-block", n),
      this.element.classList.toggle("prosemirror-dropcursor-inline", !n)
    let i, s
    if (!o || (o == document.body && getComputedStyle(o).position == "static"))
      (i = -pageXOffset), (s = -pageYOffset)
    else {
      let a = o.getBoundingClientRect()
      ;(i = a.left - o.scrollLeft), (s = a.top - o.scrollTop)
    }
    ;(this.element.style.left = r.left - i + "px"),
      (this.element.style.top = r.top - s + "px"),
      (this.element.style.width = r.right - r.left + "px"),
      (this.element.style.height = r.bottom - r.top + "px")
  }
  scheduleRemoval(t) {
    clearTimeout(this.timeout),
      (this.timeout = setTimeout(() => this.setCursor(null), t))
  }
  dragover(t) {
    if (!this.editorView.editable) return
    let n = this.editorView.posAtCoords({ left: t.clientX, top: t.clientY }),
      r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
      o = r && r.type.spec.disableDropCursor,
      i = typeof o == "function" ? o(this.editorView, n, t) : o
    if (n && !i) {
      let s = n.pos
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = fO(this.editorView.state.doc, s, this.editorView.dragging.slice)
        a != null && (s = a)
      }
      this.setCursor(s), this.scheduleRemoval(5e3)
    }
  }
  dragend() {
    this.scheduleRemoval(20)
  }
  drop() {
    this.scheduleRemoval(20)
  }
  dragleave(t) {
    ;(t.target == this.editorView.dom ||
      !this.editorView.dom.contains(t.relatedTarget)) &&
      this.setCursor(null)
  }
}
const iY = ct.create({
  name: "dropCursor",
  addOptions() {
    return { color: "currentColor", width: 1, class: void 0 }
  },
  addProseMirrorPlugins() {
    return [rY(this.options)]
  },
})
class gt extends Ne {
  constructor(t) {
    super(t, t)
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head))
    return gt.valid(r) ? new gt(r) : Ne.near(r)
  }
  content() {
    return oe.empty
  }
  eq(t) {
    return t instanceof gt && t.head == this.head
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head }
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON")
    return new gt(t.resolve(n.pos))
  }
  getBookmark() {
    return new F1(this.anchor)
  }
  static valid(t) {
    let n = t.parent
    if (n.isTextblock || !sY(t) || !aY(t)) return !1
    let r = n.type.spec.allowGapCursor
    if (r != null) return r
    let o = n.contentMatchAt(t.index()).defaultType
    return o && o.isTextblock
  }
  static findGapCursorFrom(t, n, r = !1) {
    e: for (;;) {
      if (!r && gt.valid(t)) return t
      let o = t.pos,
        i = null
      for (let s = t.depth; ; s--) {
        let a = t.node(s)
        if (n > 0 ? t.indexAfter(s) < a.childCount : t.index(s) > 0) {
          i = a.child(n > 0 ? t.indexAfter(s) : t.index(s) - 1)
          break
        } else if (s == 0) return null
        o += n
        let l = t.doc.resolve(o)
        if (gt.valid(l)) return l
      }
      for (;;) {
        let s = n > 0 ? i.firstChild : i.lastChild
        if (!s) {
          if (i.isAtom && !i.isText && !ye.isSelectable(i)) {
            ;(t = t.doc.resolve(o + i.nodeSize * n)), (r = !1)
            continue e
          }
          break
        }
        ;(i = s), (o += n)
        let a = t.doc.resolve(o)
        if (gt.valid(a)) return a
      }
      return null
    }
  }
}
gt.prototype.visible = !1
gt.findFrom = gt.findGapCursorFrom
Ne.jsonID("gapcursor", gt)
class F1 {
  constructor(t) {
    this.pos = t
  }
  map(t) {
    return new F1(t.map(this.pos))
  }
  resolve(t) {
    let n = t.resolve(this.pos)
    return gt.valid(n) ? new gt(n) : Ne.near(n)
  }
}
function sY(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.index(t),
      r = e.node(t)
    if (n == 0) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let o = r.child(n - 1); ; o = o.lastChild) {
      if (
        (o.childCount == 0 && !o.inlineContent) ||
        o.isAtom ||
        o.type.spec.isolating
      )
        return !0
      if (o.inlineContent) return !1
    }
  }
  return !0
}
function aY(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.indexAfter(t),
      r = e.node(t)
    if (n == r.childCount) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let o = r.child(n); ; o = o.firstChild) {
      if (
        (o.childCount == 0 && !o.inlineContent) ||
        o.isAtom ||
        o.type.spec.isolating
      )
        return !0
      if (o.inlineContent) return !1
    }
  }
  return !0
}
function lY() {
  return new rt({
    props: {
      decorations: fY,
      createSelectionBetween(e, t, n) {
        return t.pos == n.pos && gt.valid(n) ? new gt(n) : null
      },
      handleClick: uY,
      handleKeyDown: cY,
      handleDOMEvents: { beforeinput: dY },
    },
  })
}
const cY = JO({
  ArrowLeft: Ad("horiz", -1),
  ArrowRight: Ad("horiz", 1),
  ArrowUp: Ad("vert", -1),
  ArrowDown: Ad("vert", 1),
})
function Ad(e, t) {
  const n = e == "vert" ? (t > 0 ? "down" : "up") : t > 0 ? "right" : "left"
  return function (r, o, i) {
    let s = r.selection,
      a = t > 0 ? s.$to : s.$from,
      l = s.empty
    if (s instanceof _e) {
      if (!i.endOfTextblock(n) || a.depth == 0) return !1
      ;(l = !1), (a = r.doc.resolve(t > 0 ? a.after() : a.before()))
    }
    let c = gt.findGapCursorFrom(a, t, l)
    return c ? (o && o(r.tr.setSelection(new gt(c))), !0) : !1
  }
}
function uY(e, t, n) {
  if (!e || !e.editable) return !1
  let r = e.state.doc.resolve(t)
  if (!gt.valid(r)) return !1
  let o = e.posAtCoords({ left: n.clientX, top: n.clientY })
  return o && o.inside > -1 && ye.isSelectable(e.state.doc.nodeAt(o.inside))
    ? !1
    : (e.dispatch(e.state.tr.setSelection(new gt(r))), !0)
}
function dY(e, t) {
  if (
    t.inputType != "insertCompositionText" ||
    !(e.state.selection instanceof gt)
  )
    return !1
  let { $from: n } = e.state.selection,
    r = n.parent
      .contentMatchAt(n.index())
      .findWrapping(e.state.schema.nodes.text)
  if (!r) return !1
  let o = Z.empty
  for (let s = r.length - 1; s >= 0; s--)
    o = Z.from(r[s].createAndFill(null, o))
  let i = e.state.tr.replace(n.pos, n.pos, new oe(o, 0, 0))
  return i.setSelection(_e.near(i.doc.resolve(n.pos + 1))), e.dispatch(i), !1
}
function fY(e) {
  if (!(e.selection instanceof gt)) return null
  let t = document.createElement("div")
  return (
    (t.className = "ProseMirror-gapcursor"),
    mt.create(e.doc, [pn.widget(e.selection.head, t, { key: "gapcursor" })])
  )
}
const pY = ct.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [lY()]
    },
    extendNodeSchema(e) {
      var t
      const n = { name: e.name, options: e.options, storage: e.storage }
      return {
        allowGapCursor:
          (t = Oe(ce(e, "allowGapCursor", n))) !== null && t !== void 0
            ? t
            : null,
      }
    },
  }),
  hY = Rn.create({
    name: "hardBreak",
    addOptions() {
      return { keepMarks: !0, HTMLAttributes: {} }
    },
    inline: !0,
    group: "inline",
    selectable: !1,
    linebreakReplacement: !0,
    parseHTML() {
      return [{ tag: "br" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["br", lt(this.options.HTMLAttributes, e)]
    },
    renderText() {
      return `
`
    },
    addCommands() {
      return {
        setHardBreak:
          () =>
          ({ commands: e, chain: t, state: n, editor: r }) =>
            e.first([
              () => e.exitCode(),
              () =>
                e.command(() => {
                  const { selection: o, storedMarks: i } = n
                  if (o.$from.parent.type.spec.isolating) return !1
                  const { keepMarks: s } = this.options,
                    { splittableMarks: a } = r.extensionManager,
                    l = i || (o.$to.parentOffset && o.$from.marks())
                  return t()
                    .insertContent({ type: this.name })
                    .command(({ tr: c, dispatch: u }) => {
                      if (u && l && s) {
                        const d = l.filter((f) => a.includes(f.type.name))
                        c.ensureMarks(d)
                      }
                      return !0
                    })
                    .run()
                }),
            ]),
      }
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak(),
      }
    },
  }),
  mY = Rn.create({
    name: "heading",
    addOptions() {
      return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} }
    },
    content: "inline*",
    group: "block",
    defining: !0,
    addAttributes() {
      return { level: { default: 1, rendered: !1 } }
    },
    parseHTML() {
      return this.options.levels.map((e) => ({
        tag: `h${e}`,
        attrs: { level: e },
      }))
    },
    renderHTML({ node: e, HTMLAttributes: t }) {
      return [
        `h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`,
        lt(this.options.HTMLAttributes, t),
        0,
      ]
    },
    addCommands() {
      return {
        setHeading:
          (e) =>
          ({ commands: t }) =>
            this.options.levels.includes(e.level)
              ? t.setNode(this.name, e)
              : !1,
        toggleHeading:
          (e) =>
          ({ commands: t }) =>
            this.options.levels.includes(e.level)
              ? t.toggleNode(this.name, "paragraph", e)
              : !1,
      }
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce(
        (e, t) => ({
          ...e,
          [`Mod-Alt-${t}`]: () =>
            this.editor.commands.toggleHeading({ level: t }),
        }),
        {}
      )
    },
    addInputRules() {
      return this.options.levels.map((e) =>
        $y({
          find: new RegExp(
            `^(#{${Math.min(...this.options.levels)},${e}})\\s$`
          ),
          type: this.type,
          getAttributes: { level: e },
        })
      )
    },
  })
var xp = 200,
  jt = function () {}
jt.prototype.append = function (t) {
  return t.length
    ? ((t = jt.from(t)),
      (!this.length && t) ||
        (t.length < xp && this.leafAppend(t)) ||
        (this.length < xp && t.leafPrepend(this)) ||
        this.appendInner(t))
    : this
}
jt.prototype.prepend = function (t) {
  return t.length ? jt.from(t).append(this) : this
}
jt.prototype.appendInner = function (t) {
  return new gY(this, t)
}
jt.prototype.slice = function (t, n) {
  return (
    t === void 0 && (t = 0),
    n === void 0 && (n = this.length),
    t >= n
      ? jt.empty
      : this.sliceInner(Math.max(0, t), Math.min(this.length, n))
  )
}
jt.prototype.get = function (t) {
  if (!(t < 0 || t >= this.length)) return this.getInner(t)
}
jt.prototype.forEach = function (t, n, r) {
  n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r
      ? this.forEachInner(t, n, r, 0)
      : this.forEachInvertedInner(t, n, r, 0)
}
jt.prototype.map = function (t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length)
  var o = []
  return (
    this.forEach(
      function (i, s) {
        return o.push(t(i, s))
      },
      n,
      r
    ),
    o
  )
}
jt.from = function (t) {
  return t instanceof jt ? t : t && t.length ? new kI(t) : jt.empty
}
var kI = (function (e) {
  function t(r) {
    e.call(this), (this.values = r)
  }
  e && (t.__proto__ = e),
    (t.prototype = Object.create(e && e.prototype)),
    (t.prototype.constructor = t)
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } }
  return (
    (t.prototype.flatten = function () {
      return this.values
    }),
    (t.prototype.sliceInner = function (o, i) {
      return o == 0 && i == this.length ? this : new t(this.values.slice(o, i))
    }),
    (t.prototype.getInner = function (o) {
      return this.values[o]
    }),
    (t.prototype.forEachInner = function (o, i, s, a) {
      for (var l = i; l < s; l++) if (o(this.values[l], a + l) === !1) return !1
    }),
    (t.prototype.forEachInvertedInner = function (o, i, s, a) {
      for (var l = i - 1; l >= s; l--)
        if (o(this.values[l], a + l) === !1) return !1
    }),
    (t.prototype.leafAppend = function (o) {
      if (this.length + o.length <= xp)
        return new t(this.values.concat(o.flatten()))
    }),
    (t.prototype.leafPrepend = function (o) {
      if (this.length + o.length <= xp)
        return new t(o.flatten().concat(this.values))
    }),
    (n.length.get = function () {
      return this.values.length
    }),
    (n.depth.get = function () {
      return 0
    }),
    Object.defineProperties(t.prototype, n),
    t
  )
})(jt)
jt.empty = new kI([])
var gY = (function (e) {
  function t(n, r) {
    e.call(this),
      (this.left = n),
      (this.right = r),
      (this.length = n.length + r.length),
      (this.depth = Math.max(n.depth, r.depth) + 1)
  }
  return (
    e && (t.__proto__ = e),
    (t.prototype = Object.create(e && e.prototype)),
    (t.prototype.constructor = t),
    (t.prototype.flatten = function () {
      return this.left.flatten().concat(this.right.flatten())
    }),
    (t.prototype.getInner = function (r) {
      return r < this.left.length
        ? this.left.get(r)
        : this.right.get(r - this.left.length)
    }),
    (t.prototype.forEachInner = function (r, o, i, s) {
      var a = this.left.length
      if (
        (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === !1) ||
        (i > a &&
          this.right.forEachInner(
            r,
            Math.max(o - a, 0),
            Math.min(this.length, i) - a,
            s + a
          ) === !1)
      )
        return !1
    }),
    (t.prototype.forEachInvertedInner = function (r, o, i, s) {
      var a = this.left.length
      if (
        (o > a &&
          this.right.forEachInvertedInner(
            r,
            o - a,
            Math.max(i, a) - a,
            s + a
          ) === !1) ||
        (i < a &&
          this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === !1)
      )
        return !1
    }),
    (t.prototype.sliceInner = function (r, o) {
      if (r == 0 && o == this.length) return this
      var i = this.left.length
      return o <= i
        ? this.left.slice(r, o)
        : r >= i
          ? this.right.slice(r - i, o - i)
          : this.left.slice(r, i).append(this.right.slice(0, o - i))
    }),
    (t.prototype.leafAppend = function (r) {
      var o = this.right.leafAppend(r)
      if (o) return new t(this.left, o)
    }),
    (t.prototype.leafPrepend = function (r) {
      var o = this.left.leafPrepend(r)
      if (o) return new t(o, this.right)
    }),
    (t.prototype.appendInner = function (r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
        ? new t(this.left, new t(this.right, r))
        : new t(this, r)
    }),
    t
  )
})(jt)
const vY = 500
class br {
  constructor(t, n) {
    ;(this.items = t), (this.eventCount = n)
  }
  popEvent(t, n) {
    if (this.eventCount == 0) return null
    let r = this.items.length
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r
        break
      }
    let o, i
    n && ((o = this.remapping(r, this.items.length)), (i = o.maps.length))
    let s = t.tr,
      a,
      l,
      c = [],
      u = []
    return (
      this.items.forEach(
        (d, f) => {
          if (!d.step) {
            o || ((o = this.remapping(r, f + 1)), (i = o.maps.length)),
              i--,
              u.push(d)
            return
          }
          if (o) {
            u.push(new Br(d.map))
            let p = d.step.map(o.slice(i)),
              g
            p &&
              s.maybeStep(p).doc &&
              ((g = s.mapping.maps[s.mapping.maps.length - 1]),
              c.push(new Br(g, void 0, void 0, c.length + u.length))),
              i--,
              g && o.appendMap(g, i)
          } else s.maybeStep(d.step)
          if (d.selection)
            return (
              (a = o ? d.selection.map(o.slice(i)) : d.selection),
              (l = new br(
                this.items.slice(0, r).append(u.reverse().concat(c)),
                this.eventCount - 1
              )),
              !1
            )
        },
        this.items.length,
        0
      ),
      { remaining: l, transform: s, selection: a }
    )
  }
  addTransform(t, n, r, o) {
    let i = [],
      s = this.eventCount,
      a = this.items,
      l = !o && a.length ? a.get(a.length - 1) : null
    for (let u = 0; u < t.steps.length; u++) {
      let d = t.steps[u].invert(t.docs[u]),
        f = new Br(t.mapping.maps[u], d, n),
        p
      ;(p = l && l.merge(f)) &&
        ((f = p), u ? i.pop() : (a = a.slice(0, a.length - 1))),
        i.push(f),
        n && (s++, (n = void 0)),
        o || (l = f)
    }
    let c = s - r.depth
    return c > bY && ((a = yY(a, c)), (s -= c)), new br(a.append(i), s)
  }
  remapping(t, n) {
    let r = new ru()
    return (
      this.items.forEach(
        (o, i) => {
          let s =
            o.mirrorOffset != null && i - o.mirrorOffset >= t
              ? r.maps.length - o.mirrorOffset
              : void 0
          r.appendMap(o.map, s)
        },
        t,
        n
      ),
      r
    )
  }
  addMaps(t) {
    return this.eventCount == 0
      ? this
      : new br(this.items.append(t.map((n) => new Br(n))), this.eventCount)
  }
  rebased(t, n) {
    if (!this.eventCount) return this
    let r = [],
      o = Math.max(0, this.items.length - n),
      i = t.mapping,
      s = t.steps.length,
      a = this.eventCount
    this.items.forEach((f) => {
      f.selection && a--
    }, o)
    let l = n
    this.items.forEach((f) => {
      let p = i.getMirror(--l)
      if (p == null) return
      s = Math.min(s, p)
      let g = i.maps[p]
      if (f.step) {
        let v = t.steps[p].invert(t.docs[p]),
          b = f.selection && f.selection.map(i.slice(l + 1, p))
        b && a++, r.push(new Br(g, v, b))
      } else r.push(new Br(g))
    }, o)
    let c = []
    for (let f = n; f < s; f++) c.push(new Br(i.maps[f]))
    let u = this.items.slice(0, o).append(c).append(r),
      d = new br(u, a)
    return (
      d.emptyItemCount() > vY && (d = d.compress(this.items.length - r.length)),
      d
    )
  }
  emptyItemCount() {
    let t = 0
    return (
      this.items.forEach((n) => {
        n.step || t++
      }),
      t
    )
  }
  compress(t = this.items.length) {
    let n = this.remapping(0, t),
      r = n.maps.length,
      o = [],
      i = 0
    return (
      this.items.forEach(
        (s, a) => {
          if (a >= t) o.push(s), s.selection && i++
          else if (s.step) {
            let l = s.step.map(n.slice(r)),
              c = l && l.getMap()
            if ((r--, c && n.appendMap(c, r), l)) {
              let u = s.selection && s.selection.map(n.slice(r))
              u && i++
              let d = new Br(c.invert(), l, u),
                f,
                p = o.length - 1
              ;(f = o.length && o[p].merge(d)) ? (o[p] = f) : o.push(d)
            }
          } else s.map && r--
        },
        this.items.length,
        0
      ),
      new br(jt.from(o.reverse()), i)
    )
  }
}
br.empty = new br(jt.empty, 0)
function yY(e, t) {
  let n
  return (
    e.forEach((r, o) => {
      if (r.selection && t-- == 0) return (n = o), !1
    }),
    e.slice(n)
  )
}
class Br {
  constructor(t, n, r, o) {
    ;(this.map = t),
      (this.step = n),
      (this.selection = r),
      (this.mirrorOffset = o)
  }
  merge(t) {
    if (this.step && t.step && !t.selection) {
      let n = t.step.merge(this.step)
      if (n) return new Br(n.getMap().invert(), n, this.selection)
    }
  }
}
class Ho {
  constructor(t, n, r, o, i) {
    ;(this.done = t),
      (this.undone = n),
      (this.prevRanges = r),
      (this.prevTime = o),
      (this.prevComposition = i)
  }
}
const bY = 20
function xY(e, t, n, r) {
  let o = n.getMeta(cs),
    i
  if (o) return o.historyState
  n.getMeta(CY) && (e = new Ho(e.done, e.undone, null, 0, -1))
  let s = n.getMeta("appendedTransaction")
  if (n.steps.length == 0) return e
  if (s && s.getMeta(cs))
    return s.getMeta(cs).redo
      ? new Ho(
          e.done.addTransform(n, void 0, r, cf(t)),
          e.undone,
          lS(n.mapping.maps),
          e.prevTime,
          e.prevComposition
        )
      : new Ho(
          e.done,
          e.undone.addTransform(n, void 0, r, cf(t)),
          null,
          e.prevTime,
          e.prevComposition
        )
  if (
    n.getMeta("addToHistory") !== !1 &&
    !(s && s.getMeta("addToHistory") === !1)
  ) {
    let a = n.getMeta("composition"),
      l =
        e.prevTime == 0 ||
        (!s &&
          e.prevComposition != a &&
          (e.prevTime < (n.time || 0) - r.newGroupDelay ||
            !wY(n, e.prevRanges))),
      c = s ? Ug(e.prevRanges, n.mapping) : lS(n.mapping.maps)
    return new Ho(
      e.done.addTransform(n, l ? t.selection.getBookmark() : void 0, r, cf(t)),
      br.empty,
      c,
      n.time,
      a == null ? e.prevComposition : a
    )
  } else
    return (i = n.getMeta("rebased"))
      ? new Ho(
          e.done.rebased(n, i),
          e.undone.rebased(n, i),
          Ug(e.prevRanges, n.mapping),
          e.prevTime,
          e.prevComposition
        )
      : new Ho(
          e.done.addMaps(n.mapping.maps),
          e.undone.addMaps(n.mapping.maps),
          Ug(e.prevRanges, n.mapping),
          e.prevTime,
          e.prevComposition
        )
}
function wY(e, t) {
  if (!t) return !1
  if (!e.docChanged) return !0
  let n = !1
  return (
    e.mapping.maps[0].forEach((r, o) => {
      for (let i = 0; i < t.length; i += 2)
        r <= t[i + 1] && o >= t[i] && (n = !0)
    }),
    n
  )
}
function lS(e) {
  let t = []
  for (let n = e.length - 1; n >= 0 && t.length == 0; n--)
    e[n].forEach((r, o, i, s) => t.push(i, s))
  return t
}
function Ug(e, t) {
  if (!e) return null
  let n = []
  for (let r = 0; r < e.length; r += 2) {
    let o = t.map(e[r], 1),
      i = t.map(e[r + 1], -1)
    o <= i && n.push(o, i)
  }
  return n
}
function EY(e, t, n) {
  let r = cf(t),
    o = cs.get(t).spec.config,
    i = (n ? e.undone : e.done).popEvent(t, r)
  if (!i) return null
  let s = i.selection.resolve(i.transform.doc),
    a = (n ? e.done : e.undone).addTransform(
      i.transform,
      t.selection.getBookmark(),
      o,
      r
    ),
    l = new Ho(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1)
  return i.transform.setSelection(s).setMeta(cs, { redo: n, historyState: l })
}
let Vg = !1,
  cS = null
function cf(e) {
  let t = e.plugins
  if (cS != t) {
    ;(Vg = !1), (cS = t)
    for (let n = 0; n < t.length; n++)
      if (t[n].spec.historyPreserveItems) {
        Vg = !0
        break
      }
  }
  return Vg
}
const cs = new At("history"),
  CY = new At("closeHistory")
function SY(e = {}) {
  return (
    (e = { depth: e.depth || 100, newGroupDelay: e.newGroupDelay || 500 }),
    new rt({
      key: cs,
      state: {
        init() {
          return new Ho(br.empty, br.empty, null, 0, -1)
        },
        apply(t, n, r) {
          return xY(n, r, t, e)
        },
      },
      config: e,
      props: {
        handleDOMEvents: {
          beforeinput(t, n) {
            let r = n.inputType,
              o = r == "historyUndo" ? TI : r == "historyRedo" ? MI : null
            return o ? (n.preventDefault(), o(t.state, t.dispatch)) : !1
          },
        },
      },
    })
  )
}
function NI(e, t) {
  return (n, r) => {
    let o = cs.getState(n)
    if (!o || (e ? o.undone : o.done).eventCount == 0) return !1
    if (r) {
      let i = EY(o, n, e)
      i && r(t ? i.scrollIntoView() : i)
    }
    return !0
  }
}
const TI = NI(!1, !0),
  MI = NI(!0, !0),
  _Y = ct.create({
    name: "history",
    addOptions() {
      return { depth: 100, newGroupDelay: 500 }
    },
    addCommands() {
      return {
        undo:
          () =>
          ({ state: e, dispatch: t }) =>
            TI(e, t),
        redo:
          () =>
          ({ state: e, dispatch: t }) =>
            MI(e, t),
      }
    },
    addProseMirrorPlugins() {
      return [SY(this.options)]
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        "Mod-": () => this.editor.commands.undo(),
        "Shift-Mod-": () => this.editor.commands.redo(),
      }
    },
  }),
  OI = Rn.create({
    name: "horizontalRule",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    group: "block",
    parseHTML() {
      return [{ tag: "hr" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["hr", lt(this.options.HTMLAttributes, e)]
    },
    addCommands() {
      return {
        setHorizontalRule:
          () =>
          ({ chain: e, state: t }) => {
            const { selection: n } = t,
              { $from: r, $to: o } = n,
              i = e()
            return (
              r.parentOffset === 0
                ? i.insertContentAt(
                    { from: Math.max(r.pos - 1, 0), to: o.pos },
                    { type: this.name }
                  )
                : vA(n)
                  ? i.insertContentAt(o.pos, { type: this.name })
                  : i.insertContent({ type: this.name }),
              i
                .command(({ tr: s, dispatch: a }) => {
                  var l
                  if (a) {
                    const { $to: c } = s.selection,
                      u = c.end()
                    if (c.nodeAfter)
                      c.nodeAfter.isTextblock
                        ? s.setSelection(_e.create(s.doc, c.pos + 1))
                        : c.nodeAfter.isBlock
                          ? s.setSelection(ye.create(s.doc, c.pos))
                          : s.setSelection(_e.create(s.doc, c.pos))
                    else {
                      const d =
                        (l = c.parent.type.contentMatch.defaultType) === null ||
                        l === void 0
                          ? void 0
                          : l.create()
                      d &&
                        (s.insert(u, d),
                        s.setSelection(_e.create(s.doc, u + 1)))
                    }
                    s.scrollIntoView()
                  }
                  return !0
                })
                .run()
            )
          },
      }
    },
    addInputRules() {
      return [yA({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })]
    },
  }),
  kY = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
  NY = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
  TY = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
  MY = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
  OY = Rr.create({
    name: "italic",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: "em" },
        { tag: "i", getAttrs: (e) => e.style.fontStyle !== "normal" && null },
        {
          style: "font-style=normal",
          clearMark: (e) => e.type.name === this.name,
        },
        { style: "font-style=italic" },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["em", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setItalic:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleItalic:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetItalic:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic(),
      }
    },
    addInputRules() {
      return [
        el({ find: kY, type: this.type }),
        el({ find: TY, type: this.type }),
      ]
    },
    addPasteRules() {
      return [
        Ts({ find: NY, type: this.type }),
        Ts({ find: MY, type: this.type }),
      ]
    },
  }),
  AY = Rn.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList",
      }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
      return [{ tag: "li" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["li", lt(this.options.HTMLAttributes, e), 0]
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
      }
    },
  }),
  RY = "listItem",
  uS = "textStyle",
  dS = /^(\d+)\.\s$/,
  IY = Rn.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: !1,
        keepAttributes: !1,
      }
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (e) =>
            e.hasAttribute("start")
              ? parseInt(e.getAttribute("start") || "", 10)
              : 1,
        },
        type: { default: null, parseHTML: (e) => e.getAttribute("type") },
      }
    },
    parseHTML() {
      return [{ tag: "ol" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      const { start: t, ...n } = e
      return t === 1
        ? ["ol", lt(this.options.HTMLAttributes, n), 0]
        : ["ol", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        toggleOrderedList:
          () =>
          ({ commands: e, chain: t }) =>
            this.options.keepAttributes
              ? t()
                  .toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  )
                  .updateAttributes(RY, this.editor.getAttributes(uS))
                  .run()
              : e.toggleList(
                  this.name,
                  this.options.itemTypeName,
                  this.options.keepMarks
                ),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() }
    },
    addInputRules() {
      let e = tl({
        find: dS,
        type: this.type,
        getAttributes: (t) => ({ start: +t[1] }),
        joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
      })
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (e = tl({
            find: dS,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (t) => ({
              start: +t[1],
              ...this.editor.getAttributes(uS),
            }),
            joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
            editor: this.editor,
          })),
        [e]
      )
    },
  }),
  DY = Rn.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return { HTMLAttributes: {} }
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [{ tag: "p" }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["p", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setParagraph:
          () =>
          ({ commands: e }) =>
            e.setNode(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-Alt-0": () => this.editor.commands.setParagraph() }
    },
  }),
  LY = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
  PY = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
  $Y = Rr.create({
    name: "strike",
    addOptions() {
      return { HTMLAttributes: {} }
    },
    parseHTML() {
      return [
        { tag: "s" },
        { tag: "del" },
        { tag: "strike" },
        {
          style: "text-decoration",
          consuming: !1,
          getAttrs: (e) => (e.includes("line-through") ? {} : !1),
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["s", lt(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
      return {
        setStrike:
          () =>
          ({ commands: e }) =>
            e.setMark(this.name),
        toggleStrike:
          () =>
          ({ commands: e }) =>
            e.toggleMark(this.name),
        unsetStrike:
          () =>
          ({ commands: e }) =>
            e.unsetMark(this.name),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() }
    },
    addInputRules() {
      return [el({ find: LY, type: this.type })]
    },
    addPasteRules() {
      return [Ts({ find: PY, type: this.type })]
    },
  }),
  BY = Rn.create({ name: "text", group: "inline" }),
  jY = ct.create({
    name: "starterKit",
    addExtensions() {
      const e = []
      return (
        this.options.bold !== !1 && e.push(qZ.configure(this.options.bold)),
        this.options.blockquote !== !1 &&
          e.push(VZ.configure(this.options.blockquote)),
        this.options.bulletList !== !1 &&
          e.push(YZ.configure(this.options.bulletList)),
        this.options.code !== !1 && e.push(JZ.configure(this.options.code)),
        this.options.codeBlock !== !1 &&
          e.push(_I.configure(this.options.codeBlock)),
        this.options.document !== !1 &&
          e.push(nY.configure(this.options.document)),
        this.options.dropcursor !== !1 &&
          e.push(iY.configure(this.options.dropcursor)),
        this.options.gapcursor !== !1 &&
          e.push(pY.configure(this.options.gapcursor)),
        this.options.hardBreak !== !1 &&
          e.push(hY.configure(this.options.hardBreak)),
        this.options.heading !== !1 &&
          e.push(mY.configure(this.options.heading)),
        this.options.history !== !1 &&
          e.push(_Y.configure(this.options.history)),
        this.options.horizontalRule !== !1 &&
          e.push(OI.configure(this.options.horizontalRule)),
        this.options.italic !== !1 && e.push(OY.configure(this.options.italic)),
        this.options.listItem !== !1 &&
          e.push(AY.configure(this.options.listItem)),
        this.options.orderedList !== !1 &&
          e.push(IY.configure(this.options.orderedList)),
        this.options.paragraph !== !1 &&
          e.push(DY.configure(this.options.paragraph)),
        this.options.strike !== !1 && e.push($Y.configure(this.options.strike)),
        this.options.text !== !1 && e.push(BY.configure(this.options.text)),
        e
      )
    },
  })
function FY(e) {
  if (!e || typeof document > "u") return
  let t = document.head || document.getElementsByTagName("head")[0],
    n = document.createElement("style")
  ;(n.type = "text/css"),
    t.appendChild(n),
    n.styleSheet
      ? (n.styleSheet.cssText = e)
      : n.appendChild(document.createTextNode(e))
}
Array(12).fill(0)
let Ky = 1
class zY {
  constructor() {
    ;(this.subscribe = (t) => (
      this.subscribers.push(t),
      () => {
        const n = this.subscribers.indexOf(t)
        this.subscribers.splice(n, 1)
      }
    )),
      (this.publish = (t) => {
        this.subscribers.forEach((n) => n(t))
      }),
      (this.addToast = (t) => {
        this.publish(t), (this.toasts = [...this.toasts, t])
      }),
      (this.create = (t) => {
        var n
        const { message: r, ...o } = t,
          i =
            typeof (t == null ? void 0 : t.id) == "number" ||
            ((n = t.id) == null ? void 0 : n.length) > 0
              ? t.id
              : Ky++,
          s = this.toasts.find((l) => l.id === i),
          a = t.dismissible === void 0 ? !0 : t.dismissible
        return (
          this.dismissedToasts.has(i) && this.dismissedToasts.delete(i),
          s
            ? (this.toasts = this.toasts.map((l) =>
                l.id === i
                  ? (this.publish({ ...l, ...t, id: i, title: r }),
                    { ...l, ...t, id: i, dismissible: a, title: r })
                  : l
              ))
            : this.addToast({ title: r, ...o, dismissible: a, id: i }),
          i
        )
      }),
      (this.dismiss = (t) => (
        t
          ? (this.dismissedToasts.add(t),
            requestAnimationFrame(() =>
              this.subscribers.forEach((n) => n({ id: t, dismiss: !0 }))
            ))
          : this.toasts.forEach((n) => {
              this.subscribers.forEach((r) => r({ id: n.id, dismiss: !0 }))
            }),
        t
      )),
      (this.message = (t, n) => this.create({ ...n, message: t })),
      (this.error = (t, n) => this.create({ ...n, message: t, type: "error" })),
      (this.success = (t, n) =>
        this.create({ ...n, type: "success", message: t })),
      (this.info = (t, n) => this.create({ ...n, type: "info", message: t })),
      (this.warning = (t, n) =>
        this.create({ ...n, type: "warning", message: t })),
      (this.loading = (t, n) =>
        this.create({ ...n, type: "loading", message: t })),
      (this.promise = (t, n) => {
        if (!n) return
        let r
        n.loading !== void 0 &&
          (r = this.create({
            ...n,
            promise: t,
            type: "loading",
            message: n.loading,
            description:
              typeof n.description != "function" ? n.description : void 0,
          }))
        const o = Promise.resolve(t instanceof Function ? t() : t)
        let i = r !== void 0,
          s
        const a = o
            .then(async (c) => {
              if (((s = ["resolve", c]), G.isValidElement(c)))
                (i = !1), this.create({ id: r, type: "default", message: c })
              else if (VY(c) && !c.ok) {
                i = !1
                const d =
                    typeof n.error == "function"
                      ? await n.error(`HTTP error! status: ${c.status}`)
                      : n.error,
                  f =
                    typeof n.description == "function"
                      ? await n.description(`HTTP error! status: ${c.status}`)
                      : n.description,
                  g =
                    typeof d == "object" && !G.isValidElement(d)
                      ? d
                      : { message: d }
                this.create({ id: r, type: "error", description: f, ...g })
              } else if (c instanceof Error) {
                i = !1
                const d =
                    typeof n.error == "function" ? await n.error(c) : n.error,
                  f =
                    typeof n.description == "function"
                      ? await n.description(c)
                      : n.description,
                  g =
                    typeof d == "object" && !G.isValidElement(d)
                      ? d
                      : { message: d }
                this.create({ id: r, type: "error", description: f, ...g })
              } else if (n.success !== void 0) {
                i = !1
                const d =
                    typeof n.success == "function"
                      ? await n.success(c)
                      : n.success,
                  f =
                    typeof n.description == "function"
                      ? await n.description(c)
                      : n.description,
                  g =
                    typeof d == "object" && !G.isValidElement(d)
                      ? d
                      : { message: d }
                this.create({ id: r, type: "success", description: f, ...g })
              }
            })
            .catch(async (c) => {
              if (((s = ["reject", c]), n.error !== void 0)) {
                i = !1
                const u =
                    typeof n.error == "function" ? await n.error(c) : n.error,
                  d =
                    typeof n.description == "function"
                      ? await n.description(c)
                      : n.description,
                  p =
                    typeof u == "object" && !G.isValidElement(u)
                      ? u
                      : { message: u }
                this.create({ id: r, type: "error", description: d, ...p })
              }
            })
            .finally(() => {
              i && (this.dismiss(r), (r = void 0)),
                n.finally == null || n.finally.call(n)
            }),
          l = () =>
            new Promise((c, u) =>
              a.then(() => (s[0] === "reject" ? u(s[1]) : c(s[1]))).catch(u)
            )
        return typeof r != "string" && typeof r != "number"
          ? { unwrap: l }
          : Object.assign(r, { unwrap: l })
      }),
      (this.custom = (t, n) => {
        const r = (n == null ? void 0 : n.id) || Ky++
        return this.create({ jsx: t(r), id: r, ...n }), r
      }),
      (this.getActiveToasts = () =>
        this.toasts.filter((t) => !this.dismissedToasts.has(t.id))),
      (this.subscribers = []),
      (this.toasts = []),
      (this.dismissedToasts = new Set())
  }
}
const Yn = new zY(),
  UY = (e, t) => {
    const n = (t == null ? void 0 : t.id) || Ky++
    return Yn.addToast({ title: e, ...t, id: n }), n
  },
  VY = (e) =>
    e &&
    typeof e == "object" &&
    "ok" in e &&
    typeof e.ok == "boolean" &&
    "status" in e &&
    typeof e.status == "number",
  HY = UY,
  WY = () => Yn.toasts,
  KY = () => Yn.getActiveToasts(),
  Rd = Object.assign(
    HY,
    {
      success: Yn.success,
      info: Yn.info,
      warning: Yn.warning,
      error: Yn.error,
      custom: Yn.custom,
      message: Yn.message,
      promise: Yn.promise,
      dismiss: Yn.dismiss,
      loading: Yn.loading,
    },
    { getHistory: WY, getToasts: KY }
  )
FY(
  "[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}[data-sonner-toaster][data-lifted=true]{transform:translateY(-8px)}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}"
)
function GY(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e
}
function AI(e) {
  return (
    e instanceof Map
      ? (e.clear =
          e.delete =
          e.set =
            function () {
              throw new Error("map is read-only")
            })
      : e instanceof Set &&
        (e.add =
          e.clear =
          e.delete =
            function () {
              throw new Error("set is read-only")
            }),
    Object.freeze(e),
    Object.getOwnPropertyNames(e).forEach((t) => {
      const n = e[t],
        r = typeof n
      ;(r === "object" || r === "function") && !Object.isFrozen(n) && AI(n)
    }),
    e
  )
}
let fS = class {
  constructor(t) {
    t.data === void 0 && (t.data = {}),
      (this.data = t.data),
      (this.isMatchIgnored = !1)
  }
  ignoreMatch() {
    this.isMatchIgnored = !0
  }
}
function RI(e) {
  return e
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#x27;")
}
function ni(e, ...t) {
  const n = Object.create(null)
  for (const r in e) n[r] = e[r]
  return (
    t.forEach(function (r) {
      for (const o in r) n[o] = r[o]
    }),
    n
  )
}
const qY = "</span>",
  pS = (e) => !!e.scope,
  ZY = (e, { prefix: t }) => {
    if (e.startsWith("language:")) return e.replace("language:", "language-")
    if (e.includes(".")) {
      const n = e.split(".")
      return [
        `${t}${n.shift()}`,
        ...n.map((r, o) => `${r}${"_".repeat(o + 1)}`),
      ].join(" ")
    }
    return `${t}${e}`
  }
let YY = class {
  constructor(t, n) {
    ;(this.buffer = ""), (this.classPrefix = n.classPrefix), t.walk(this)
  }
  addText(t) {
    this.buffer += RI(t)
  }
  openNode(t) {
    if (!pS(t)) return
    const n = ZY(t.scope, { prefix: this.classPrefix })
    this.span(n)
  }
  closeNode(t) {
    pS(t) && (this.buffer += qY)
  }
  value() {
    return this.buffer
  }
  span(t) {
    this.buffer += `<span class="${t}">`
  }
}
const hS = (e = {}) => {
  const t = { children: [] }
  return Object.assign(t, e), t
}
let XY = class II {
    constructor() {
      ;(this.rootNode = hS()), (this.stack = [this.rootNode])
    }
    get top() {
      return this.stack[this.stack.length - 1]
    }
    get root() {
      return this.rootNode
    }
    add(t) {
      this.top.children.push(t)
    }
    openNode(t) {
      const n = hS({ scope: t })
      this.add(n), this.stack.push(n)
    }
    closeNode() {
      if (this.stack.length > 1) return this.stack.pop()
    }
    closeAllNodes() {
      for (; this.closeNode(); );
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4)
    }
    walk(t) {
      return this.constructor._walk(t, this.rootNode)
    }
    static _walk(t, n) {
      return (
        typeof n == "string"
          ? t.addText(n)
          : n.children &&
            (t.openNode(n),
            n.children.forEach((r) => this._walk(t, r)),
            t.closeNode(n)),
        t
      )
    }
    static _collapse(t) {
      typeof t != "string" &&
        t.children &&
        (t.children.every((n) => typeof n == "string")
          ? (t.children = [t.children.join("")])
          : t.children.forEach((n) => {
              II._collapse(n)
            }))
    }
  },
  QY = class extends XY {
    constructor(t) {
      super(), (this.options = t)
    }
    addText(t) {
      t !== "" && this.add(t)
    }
    startScope(t) {
      this.openNode(t)
    }
    endScope() {
      this.closeNode()
    }
    __addSublanguage(t, n) {
      const r = t.root
      n && (r.scope = `language:${n}`), this.add(r)
    }
    toHTML() {
      return new YY(this, this.options).value()
    }
    finalize() {
      return this.closeAllNodes(), !0
    }
  }
function hu(e) {
  return e ? (typeof e == "string" ? e : e.source) : null
}
function DI(e) {
  return js("(?=", e, ")")
}
function JY(e) {
  return js("(?:", e, ")*")
}
function eX(e) {
  return js("(?:", e, ")?")
}
function js(...e) {
  return e.map((n) => hu(n)).join("")
}
function tX(e) {
  const t = e[e.length - 1]
  return typeof t == "object" && t.constructor === Object
    ? (e.splice(e.length - 1, 1), t)
    : {}
}
function z1(...e) {
  return "(" + (tX(e).capture ? "" : "?:") + e.map((r) => hu(r)).join("|") + ")"
}
function LI(e) {
  return new RegExp(e.toString() + "|").exec("").length - 1
}
function nX(e, t) {
  const n = e && e.exec(t)
  return n && n.index === 0
}
const rX = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
function U1(e, { joinWith: t }) {
  let n = 0
  return e
    .map((r) => {
      n += 1
      const o = n
      let i = hu(r),
        s = ""
      for (; i.length > 0; ) {
        const a = rX.exec(i)
        if (!a) {
          s += i
          break
        }
        ;(s += i.substring(0, a.index)),
          (i = i.substring(a.index + a[0].length)),
          a[0][0] === "\\" && a[1]
            ? (s += "\\" + String(Number(a[1]) + o))
            : ((s += a[0]), a[0] === "(" && n++)
      }
      return s
    })
    .map((r) => `(${r})`)
    .join(t)
}
const oX = /\b\B/,
  PI = "[a-zA-Z]\\w*",
  V1 = "[a-zA-Z_]\\w*",
  $I = "\\b\\d+(\\.\\d+)?",
  BI = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",
  jI = "\\b(0b[01]+)",
  iX =
    "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
  sX = (e = {}) => {
    const t = /^#![ ]*\//
    return (
      e.binary && (e.begin = js(t, /.*\b/, e.binary, /\b.*/)),
      ni(
        {
          scope: "meta",
          begin: t,
          end: /$/,
          relevance: 0,
          "on:begin": (n, r) => {
            n.index !== 0 && r.ignoreMatch()
          },
        },
        e
      )
    )
  },
  mu = { begin: "\\\\[\\s\\S]", relevance: 0 },
  aX = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [mu],
  },
  lX = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [mu],
  },
  cX = {
    begin:
      /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
  },
  bm = function (e, t, n = {}) {
    const r = ni({ scope: "comment", begin: e, end: t, contains: [] }, n)
    r.contains.push({
      scope: "doctag",
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0,
    })
    const o = z1(
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      /[A-Za-z]+[-][a-z]+/,
      /[A-Za-z][a-z]{2,}/
    )
    return (
      r.contains.push({
        begin: js(/[ ]+/, "(", o, /[.]?[:]?([.][ ]|[ ])/, "){3}"),
      }),
      r
    )
  },
  uX = bm("//", "$"),
  dX = bm("/\\*", "\\*/"),
  fX = bm("#", "$"),
  pX = { scope: "number", begin: $I, relevance: 0 },
  hX = { scope: "number", begin: BI, relevance: 0 },
  mX = { scope: "number", begin: jI, relevance: 0 },
  gX = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [mu, { begin: /\[/, end: /\]/, relevance: 0, contains: [mu] }],
  },
  vX = { scope: "title", begin: PI, relevance: 0 },
  yX = { scope: "title", begin: V1, relevance: 0 },
  bX = { begin: "\\.\\s*" + V1, relevance: 0 },
  xX = function (e) {
    return Object.assign(e, {
      "on:begin": (t, n) => {
        n.data._beginMatch = t[1]
      },
      "on:end": (t, n) => {
        n.data._beginMatch !== t[1] && n.ignoreMatch()
      },
    })
  }
var Id = Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: aX,
  BACKSLASH_ESCAPE: mu,
  BINARY_NUMBER_MODE: mX,
  BINARY_NUMBER_RE: jI,
  COMMENT: bm,
  C_BLOCK_COMMENT_MODE: dX,
  C_LINE_COMMENT_MODE: uX,
  C_NUMBER_MODE: hX,
  C_NUMBER_RE: BI,
  END_SAME_AS_BEGIN: xX,
  HASH_COMMENT_MODE: fX,
  IDENT_RE: PI,
  MATCH_NOTHING_RE: oX,
  METHOD_GUARD: bX,
  NUMBER_MODE: pX,
  NUMBER_RE: $I,
  PHRASAL_WORDS_MODE: cX,
  QUOTE_STRING_MODE: lX,
  REGEXP_MODE: gX,
  RE_STARTERS_RE: iX,
  SHEBANG: sX,
  TITLE_MODE: vX,
  UNDERSCORE_IDENT_RE: V1,
  UNDERSCORE_TITLE_MODE: yX,
})
function wX(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch()
}
function EX(e, t) {
  e.className !== void 0 && ((e.scope = e.className), delete e.className)
}
function CX(e, t) {
  t &&
    e.beginKeywords &&
    ((e.begin =
      "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)"),
    (e.__beforeBegin = wX),
    (e.keywords = e.keywords || e.beginKeywords),
    delete e.beginKeywords,
    e.relevance === void 0 && (e.relevance = 0))
}
function SX(e, t) {
  Array.isArray(e.illegal) && (e.illegal = z1(...e.illegal))
}
function _X(e, t) {
  if (e.match) {
    if (e.begin || e.end)
      throw new Error("begin & end are not supported with match")
    ;(e.begin = e.match), delete e.match
  }
}
function kX(e, t) {
  e.relevance === void 0 && (e.relevance = 1)
}
const NX = (e, t) => {
    if (!e.beforeMatch) return
    if (e.starts) throw new Error("beforeMatch cannot be used with starts")
    const n = Object.assign({}, e)
    Object.keys(e).forEach((r) => {
      delete e[r]
    }),
      (e.keywords = n.keywords),
      (e.begin = js(n.beforeMatch, DI(n.begin))),
      (e.starts = {
        relevance: 0,
        contains: [Object.assign(n, { endsParent: !0 })],
      }),
      (e.relevance = 0),
      delete n.beforeMatch
  },
  TX = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value",
  ],
  MX = "keyword"
function FI(e, t, n = MX) {
  const r = Object.create(null)
  return (
    typeof e == "string"
      ? o(n, e.split(" "))
      : Array.isArray(e)
        ? o(n, e)
        : Object.keys(e).forEach(function (i) {
            Object.assign(r, FI(e[i], t, i))
          }),
    r
  )
  function o(i, s) {
    t && (s = s.map((a) => a.toLowerCase())),
      s.forEach(function (a) {
        const l = a.split("|")
        r[l[0]] = [i, OX(l[0], l[1])]
      })
  }
}
function OX(e, t) {
  return t ? Number(t) : AX(e) ? 0 : 1
}
function AX(e) {
  return TX.includes(e.toLowerCase())
}
const mS = {},
  us = (e) => {
    console.error(e)
  },
  gS = (e, ...t) => {
    console.log(`WARN: ${e}`, ...t)
  },
  Qs = (e, t) => {
    mS[`${e}/${t}`] ||
      (console.log(`Deprecated as of ${e}. ${t}`), (mS[`${e}/${t}`] = !0))
  },
  wp = new Error()
function zI(e, t, { key: n }) {
  let r = 0
  const o = e[n],
    i = {},
    s = {}
  for (let a = 1; a <= t.length; a++)
    (s[a + r] = o[a]), (i[a + r] = !0), (r += LI(t[a - 1]))
  ;(e[n] = s), (e[n]._emit = i), (e[n]._multi = !0)
}
function RX(e) {
  if (Array.isArray(e.begin)) {
    if (e.skip || e.excludeBegin || e.returnBegin)
      throw (
        (us(
          "skip, excludeBegin, returnBegin not compatible with beginScope: {}"
        ),
        wp)
      )
    if (typeof e.beginScope != "object" || e.beginScope === null)
      throw (us("beginScope must be object"), wp)
    zI(e, e.begin, { key: "beginScope" }),
      (e.begin = U1(e.begin, { joinWith: "" }))
  }
}
function IX(e) {
  if (Array.isArray(e.end)) {
    if (e.skip || e.excludeEnd || e.returnEnd)
      throw (
        (us("skip, excludeEnd, returnEnd not compatible with endScope: {}"), wp)
      )
    if (typeof e.endScope != "object" || e.endScope === null)
      throw (us("endScope must be object"), wp)
    zI(e, e.end, { key: "endScope" }), (e.end = U1(e.end, { joinWith: "" }))
  }
}
function DX(e) {
  e.scope &&
    typeof e.scope == "object" &&
    e.scope !== null &&
    ((e.beginScope = e.scope), delete e.scope)
}
function LX(e) {
  DX(e),
    typeof e.beginScope == "string" && (e.beginScope = { _wrap: e.beginScope }),
    typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }),
    RX(e),
    IX(e)
}
function PX(e) {
  function t(s, a) {
    return new RegExp(
      hu(s),
      "m" +
        (e.case_insensitive ? "i" : "") +
        (e.unicodeRegex ? "u" : "") +
        (a ? "g" : "")
    )
  }
  class n {
    constructor() {
      ;(this.matchIndexes = {}),
        (this.regexes = []),
        (this.matchAt = 1),
        (this.position = 0)
    }
    addRule(a, l) {
      ;(l.position = this.position++),
        (this.matchIndexes[this.matchAt] = l),
        this.regexes.push([l, a]),
        (this.matchAt += LI(a) + 1)
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null)
      const a = this.regexes.map((l) => l[1])
      ;(this.matcherRe = t(U1(a, { joinWith: "|" }), !0)), (this.lastIndex = 0)
    }
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex
      const l = this.matcherRe.exec(a)
      if (!l) return null
      const c = l.findIndex((d, f) => f > 0 && d !== void 0),
        u = this.matchIndexes[c]
      return l.splice(0, c), Object.assign(l, u)
    }
  }
  class r {
    constructor() {
      ;(this.rules = []),
        (this.multiRegexes = []),
        (this.count = 0),
        (this.lastIndex = 0),
        (this.regexIndex = 0)
    }
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a]
      const l = new n()
      return (
        this.rules.slice(a).forEach(([c, u]) => l.addRule(c, u)),
        l.compile(),
        (this.multiRegexes[a] = l),
        l
      )
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0
    }
    considerAll() {
      this.regexIndex = 0
    }
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++
    }
    exec(a) {
      const l = this.getMatcher(this.regexIndex)
      l.lastIndex = this.lastIndex
      let c = l.exec(a)
      if (
        this.resumingScanAtSamePosition() &&
        !(c && c.index === this.lastIndex)
      ) {
        const u = this.getMatcher(0)
        ;(u.lastIndex = this.lastIndex + 1), (c = u.exec(a))
      }
      return (
        c &&
          ((this.regexIndex += c.position + 1),
          this.regexIndex === this.count && this.considerAll()),
        c
      )
    }
  }
  function o(s) {
    const a = new r()
    return (
      s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })),
      s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }),
      s.illegal && a.addRule(s.illegal, { type: "illegal" }),
      a
    )
  }
  function i(s, a) {
    const l = s
    if (s.isCompiled) return l
    ;[EX, _X, LX, NX].forEach((u) => u(s, a)),
      e.compilerExtensions.forEach((u) => u(s, a)),
      (s.__beforeBegin = null),
      [CX, SX, kX].forEach((u) => u(s, a)),
      (s.isCompiled = !0)
    let c = null
    return (
      typeof s.keywords == "object" &&
        s.keywords.$pattern &&
        ((s.keywords = Object.assign({}, s.keywords)),
        (c = s.keywords.$pattern),
        delete s.keywords.$pattern),
      (c = c || /\w+/),
      s.keywords && (s.keywords = FI(s.keywords, e.case_insensitive)),
      (l.keywordPatternRe = t(c, !0)),
      a &&
        (s.begin || (s.begin = /\B|\b/),
        (l.beginRe = t(l.begin)),
        !s.end && !s.endsWithParent && (s.end = /\B|\b/),
        s.end && (l.endRe = t(l.end)),
        (l.terminatorEnd = hu(l.end) || ""),
        s.endsWithParent &&
          a.terminatorEnd &&
          (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)),
      s.illegal && (l.illegalRe = t(s.illegal)),
      s.contains || (s.contains = []),
      (s.contains = [].concat(
        ...s.contains.map(function (u) {
          return $X(u === "self" ? s : u)
        })
      )),
      s.contains.forEach(function (u) {
        i(u, l)
      }),
      s.starts && i(s.starts, a),
      (l.matcher = o(l)),
      l
    )
  }
  if (
    (e.compilerExtensions || (e.compilerExtensions = []),
    e.contains && e.contains.includes("self"))
  )
    throw new Error(
      "ERR: contains `self` is not supported at the top-level of a language.  See documentation."
    )
  return (e.classNameAliases = ni(e.classNameAliases || {})), i(e)
}
function UI(e) {
  return e ? e.endsWithParent || UI(e.starts) : !1
}
function $X(e) {
  return (
    e.variants &&
      !e.cachedVariants &&
      (e.cachedVariants = e.variants.map(function (t) {
        return ni(e, { variants: null }, t)
      })),
    e.cachedVariants
      ? e.cachedVariants
      : UI(e)
        ? ni(e, { starts: e.starts ? ni(e.starts) : null })
        : Object.isFrozen(e)
          ? ni(e)
          : e
  )
}
var BX = "11.10.0"
let jX = class extends Error {
  constructor(t, n) {
    super(t), (this.name = "HTMLInjectionError"), (this.html = n)
  }
}
const Hg = RI,
  vS = ni,
  yS = Symbol("nomatch"),
  FX = 7,
  VI = function (e) {
    const t = Object.create(null),
      n = Object.create(null),
      r = []
    let o = !0
    const i =
        "Could not find the language '{}', did you forget to load/include a language module?",
      s = { disableAutodetect: !0, name: "Plain text", contains: [] }
    let a = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      __emitter: QY,
    }
    function l(O) {
      return a.noHighlightRe.test(O)
    }
    function c(O) {
      let _ = O.className + " "
      _ += O.parentNode ? O.parentNode.className : ""
      const A = a.languageDetectRe.exec(_)
      if (A) {
        const P = R(A[1])
        return (
          P ||
            (gS(i.replace("{}", A[1])),
            gS("Falling back to no-highlight mode for this block.", O)),
          P ? A[1] : "no-highlight"
        )
      }
      return _.split(/\s+/).find((P) => l(P) || R(P))
    }
    function u(O, _, A) {
      let P = "",
        H = ""
      typeof _ == "object"
        ? ((P = O), (A = _.ignoreIllegals), (H = _.language))
        : (Qs("10.7.0", "highlight(lang, code, ...args) has been deprecated."),
          Qs(
            "10.7.0",
            `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`
          ),
          (H = O),
          (P = _)),
        A === void 0 && (A = !0)
      const X = { code: P, language: H }
      ee("before:highlight", X)
      const ae = X.result ? X.result : d(X.language, X.code, A)
      return (ae.code = X.code), ee("after:highlight", ae), ae
    }
    function d(O, _, A, P) {
      const H = Object.create(null)
      function X(T, L) {
        return T.keywords[L]
      }
      function ae() {
        if (!me.keywords) {
          fe.addText(k)
          return
        }
        let T = 0
        me.keywordPatternRe.lastIndex = 0
        let L = me.keywordPatternRe.exec(k),
          K = ""
        for (; L; ) {
          K += k.substring(T, L.index)
          const ie = be.case_insensitive ? L[0].toLowerCase() : L[0],
            Se = X(me, ie)
          if (Se) {
            const [an, oo] = Se
            if (
              (fe.addText(K),
              (K = ""),
              (H[ie] = (H[ie] || 0) + 1),
              H[ie] <= FX && (D += oo),
              an.startsWith("_"))
            )
              K += L[0]
            else {
              const z = be.classNameAliases[an] || an
              xe(L[0], z)
            }
          } else K += L[0]
          ;(T = me.keywordPatternRe.lastIndex),
            (L = me.keywordPatternRe.exec(k))
        }
        ;(K += k.substring(T)), fe.addText(K)
      }
      function ve() {
        if (k === "") return
        let T = null
        if (typeof me.subLanguage == "string") {
          if (!t[me.subLanguage]) {
            fe.addText(k)
            return
          }
          ;(T = d(me.subLanguage, k, !0, $e[me.subLanguage])),
            ($e[me.subLanguage] = T._top)
        } else T = p(k, me.subLanguage.length ? me.subLanguage : null)
        me.relevance > 0 && (D += T.relevance),
          fe.__addSublanguage(T._emitter, T.language)
      }
      function he() {
        me.subLanguage != null ? ve() : ae(), (k = "")
      }
      function xe(T, L) {
        T !== "" && (fe.startScope(L), fe.addText(T), fe.endScope())
      }
      function Ae(T, L) {
        let K = 1
        const ie = L.length - 1
        for (; K <= ie; ) {
          if (!T._emit[K]) {
            K++
            continue
          }
          const Se = be.classNameAliases[T[K]] || T[K],
            an = L[K]
          Se ? xe(an, Se) : ((k = an), ae(), (k = "")), K++
        }
      }
      function je(T, L) {
        return (
          T.scope &&
            typeof T.scope == "string" &&
            fe.openNode(be.classNameAliases[T.scope] || T.scope),
          T.beginScope &&
            (T.beginScope._wrap
              ? (xe(
                  k,
                  be.classNameAliases[T.beginScope._wrap] || T.beginScope._wrap
                ),
                (k = ""))
              : T.beginScope._multi && (Ae(T.beginScope, L), (k = ""))),
          (me = Object.create(T, { parent: { value: me } })),
          me
        )
      }
      function Fe(T, L, K) {
        let ie = nX(T.endRe, K)
        if (ie) {
          if (T["on:end"]) {
            const Se = new fS(T)
            T["on:end"](L, Se), Se.isMatchIgnored && (ie = !1)
          }
          if (ie) {
            for (; T.endsParent && T.parent; ) T = T.parent
            return T
          }
        }
        if (T.endsWithParent) return Fe(T.parent, L, K)
      }
      function Ze(T) {
        return me.matcher.regexIndex === 0 ? ((k += T[0]), 1) : (($ = !0), 0)
      }
      function dt(T) {
        const L = T[0],
          K = T.rule,
          ie = new fS(K),
          Se = [K.__beforeBegin, K["on:begin"]]
        for (const an of Se)
          if (an && (an(T, ie), ie.isMatchIgnored)) return Ze(L)
        return (
          K.skip
            ? (k += L)
            : (K.excludeBegin && (k += L),
              he(),
              !K.returnBegin && !K.excludeBegin && (k = L)),
          je(K, T),
          K.returnBegin ? 0 : L.length
        )
      }
      function kt(T) {
        const L = T[0],
          K = _.substring(T.index),
          ie = Fe(me, T, K)
        if (!ie) return yS
        const Se = me
        me.endScope && me.endScope._wrap
          ? (he(), xe(L, me.endScope._wrap))
          : me.endScope && me.endScope._multi
            ? (he(), Ae(me.endScope, T))
            : Se.skip
              ? (k += L)
              : (Se.returnEnd || Se.excludeEnd || (k += L),
                he(),
                Se.excludeEnd && (k = L))
        do
          me.scope && fe.closeNode(),
            !me.skip && !me.subLanguage && (D += me.relevance),
            (me = me.parent)
        while (me !== ie.parent)
        return ie.starts && je(ie.starts, T), Se.returnEnd ? 0 : L.length
      }
      function ft() {
        const T = []
        for (let L = me; L !== be; L = L.parent) L.scope && T.unshift(L.scope)
        T.forEach((L) => fe.openNode(L))
      }
      let Et = {}
      function He(T, L) {
        const K = L && L[0]
        if (((k += T), K == null)) return he(), 0
        if (
          Et.type === "begin" &&
          L.type === "end" &&
          Et.index === L.index &&
          K === ""
        ) {
          if (((k += _.slice(L.index, L.index + 1)), !o)) {
            const ie = new Error(`0 width match regex (${O})`)
            throw ((ie.languageName = O), (ie.badRule = Et.rule), ie)
          }
          return 1
        }
        if (((Et = L), L.type === "begin")) return dt(L)
        if (L.type === "illegal" && !A) {
          const ie = new Error(
            'Illegal lexeme "' +
              K +
              '" for mode "' +
              (me.scope || "<unnamed>") +
              '"'
          )
          throw ((ie.mode = me), ie)
        } else if (L.type === "end") {
          const ie = kt(L)
          if (ie !== yS) return ie
        }
        if (L.type === "illegal" && K === "") return 1
        if (te > 1e5 && te > L.index * 3)
          throw new Error(
            "potential infinite loop, way more iterations than matches"
          )
        return (k += K), K.length
      }
      const be = R(O)
      if (!be)
        throw (
          (us(i.replace("{}", O)), new Error('Unknown language: "' + O + '"'))
        )
      const yt = PX(be)
      let ue = "",
        me = P || yt
      const $e = {},
        fe = new a.__emitter(a)
      ft()
      let k = "",
        D = 0,
        F = 0,
        te = 0,
        $ = !1
      try {
        if (be.__emitTokens) be.__emitTokens(_, fe)
        else {
          for (me.matcher.considerAll(); ; ) {
            te++,
              $ ? ($ = !1) : me.matcher.considerAll(),
              (me.matcher.lastIndex = F)
            const T = me.matcher.exec(_)
            if (!T) break
            const L = _.substring(F, T.index),
              K = He(L, T)
            F = T.index + K
          }
          He(_.substring(F))
        }
        return (
          fe.finalize(),
          (ue = fe.toHTML()),
          {
            language: O,
            value: ue,
            relevance: D,
            illegal: !1,
            _emitter: fe,
            _top: me,
          }
        )
      } catch (T) {
        if (T.message && T.message.includes("Illegal"))
          return {
            language: O,
            value: Hg(_),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: T.message,
              index: F,
              context: _.slice(F - 100, F + 100),
              mode: T.mode,
              resultSoFar: ue,
            },
            _emitter: fe,
          }
        if (o)
          return {
            language: O,
            value: Hg(_),
            illegal: !1,
            relevance: 0,
            errorRaised: T,
            _emitter: fe,
            _top: me,
          }
        throw T
      }
    }
    function f(O) {
      const _ = {
        value: Hg(O),
        illegal: !1,
        relevance: 0,
        _top: s,
        _emitter: new a.__emitter(a),
      }
      return _._emitter.addText(O), _
    }
    function p(O, _) {
      _ = _ || a.languages || Object.keys(t)
      const A = f(O),
        P = _.filter(R)
          .filter(V)
          .map((he) => d(he, O, !1))
      P.unshift(A)
      const H = P.sort((he, xe) => {
          if (he.relevance !== xe.relevance) return xe.relevance - he.relevance
          if (he.language && xe.language) {
            if (R(he.language).supersetOf === xe.language) return 1
            if (R(xe.language).supersetOf === he.language) return -1
          }
          return 0
        }),
        [X, ae] = H,
        ve = X
      return (ve.secondBest = ae), ve
    }
    function g(O, _, A) {
      const P = (_ && n[_]) || A
      O.classList.add("hljs"), O.classList.add(`language-${P}`)
    }
    function v(O) {
      let _ = null
      const A = c(O)
      if (l(A)) return
      if (
        (ee("before:highlightElement", { el: O, language: A }),
        O.dataset.highlighted)
      ) {
        console.log(
          "Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",
          O
        )
        return
      }
      if (
        O.children.length > 0 &&
        (a.ignoreUnescapedHTML ||
          (console.warn(
            "One of your code blocks includes unescaped HTML. This is a potentially serious security risk."
          ),
          console.warn(
            "https://github.com/highlightjs/highlight.js/wiki/security"
          ),
          console.warn("The element with unescaped HTML:"),
          console.warn(O)),
        a.throwUnescapedHTML)
      )
        throw new jX(
          "One of your code blocks includes unescaped HTML.",
          O.innerHTML
        )
      _ = O
      const P = _.textContent,
        H = A ? u(P, { language: A, ignoreIllegals: !0 }) : p(P)
      ;(O.innerHTML = H.value),
        (O.dataset.highlighted = "yes"),
        g(O, A, H.language),
        (O.result = {
          language: H.language,
          re: H.relevance,
          relevance: H.relevance,
        }),
        H.secondBest &&
          (O.secondBest = {
            language: H.secondBest.language,
            relevance: H.secondBest.relevance,
          }),
        ee("after:highlightElement", { el: O, result: H, text: P })
    }
    function b(O) {
      a = vS(a, O)
    }
    const y = () => {
      w(),
        Qs("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.")
    }
    function x() {
      w(),
        Qs(
          "10.6.0",
          "initHighlightingOnLoad() deprecated.  Use highlightAll() now."
        )
    }
    let E = !1
    function w() {
      if (document.readyState === "loading") {
        E = !0
        return
      }
      document.querySelectorAll(a.cssSelector).forEach(v)
    }
    function C() {
      E && w()
    }
    typeof window < "u" &&
      window.addEventListener &&
      window.addEventListener("DOMContentLoaded", C, !1)
    function S(O, _) {
      let A = null
      try {
        A = _(e)
      } catch (P) {
        if (
          (us(
            "Language definition for '{}' could not be registered.".replace(
              "{}",
              O
            )
          ),
          o)
        )
          us(P)
        else throw P
        A = s
      }
      A.name || (A.name = O),
        (t[O] = A),
        (A.rawDefinition = _.bind(null, e)),
        A.aliases && B(A.aliases, { languageName: O })
    }
    function M(O) {
      delete t[O]
      for (const _ of Object.keys(n)) n[_] === O && delete n[_]
    }
    function N() {
      return Object.keys(t)
    }
    function R(O) {
      return (O = (O || "").toLowerCase()), t[O] || t[n[O]]
    }
    function B(O, { languageName: _ }) {
      typeof O == "string" && (O = [O]),
        O.forEach((A) => {
          n[A.toLowerCase()] = _
        })
    }
    function V(O) {
      const _ = R(O)
      return _ && !_.disableAutodetect
    }
    function j(O) {
      O["before:highlightBlock"] &&
        !O["before:highlightElement"] &&
        (O["before:highlightElement"] = (_) => {
          O["before:highlightBlock"](Object.assign({ block: _.el }, _))
        }),
        O["after:highlightBlock"] &&
          !O["after:highlightElement"] &&
          (O["after:highlightElement"] = (_) => {
            O["after:highlightBlock"](Object.assign({ block: _.el }, _))
          })
    }
    function U(O) {
      j(O), r.push(O)
    }
    function W(O) {
      const _ = r.indexOf(O)
      _ !== -1 && r.splice(_, 1)
    }
    function ee(O, _) {
      const A = O
      r.forEach(function (P) {
        P[A] && P[A](_)
      })
    }
    function I(O) {
      return (
        Qs("10.7.0", "highlightBlock will be removed entirely in v12.0"),
        Qs("10.7.0", "Please use highlightElement now."),
        v(O)
      )
    }
    Object.assign(e, {
      highlight: u,
      highlightAuto: p,
      highlightAll: w,
      highlightElement: v,
      highlightBlock: I,
      configure: b,
      initHighlighting: y,
      initHighlightingOnLoad: x,
      registerLanguage: S,
      unregisterLanguage: M,
      listLanguages: N,
      getLanguage: R,
      registerAliases: B,
      autoDetection: V,
      inherit: vS,
      addPlugin: U,
      removePlugin: W,
    }),
      (e.debugMode = function () {
        o = !1
      }),
      (e.safeMode = function () {
        o = !0
      }),
      (e.versionString = BX),
      (e.regex = {
        concat: js,
        lookahead: DI,
        either: z1,
        optional: eX,
        anyNumberOfTimes: JY,
      })
    for (const O in Id) typeof Id[O] == "object" && AI(Id[O])
    return Object.assign(e, Id), e
  },
  al = VI({})
al.newInstance = () => VI({})
var zX = al
al.HighlightJS = al
al.default = al
var UX = GY(zX)
function HI(e, t = []) {
  return e
    .map((n) => {
      const r = [...t, ...(n.properties ? n.properties.className : [])]
      return n.children ? HI(n.children, r) : { text: n.value, classes: r }
    })
    .flat()
}
function bS(e) {
  return e.value || e.children || []
}
function VX(e) {
  return !!UX.getLanguage(e)
}
function xS({ doc: e, name: t, lowlight: n, defaultLanguage: r }) {
  const o = []
  return (
    Ly(e, (i) => i.type.name === t).forEach((i) => {
      var s
      let a = i.pos + 1
      const l = i.node.attrs.language || r,
        c = n.listLanguages(),
        u =
          l &&
          (c.includes(l) ||
            VX(l) ||
            (!((s = n.registered) === null || s === void 0) && s.call(n, l)))
            ? bS(n.highlight(l, i.node.textContent))
            : bS(n.highlightAuto(i.node.textContent))
      HI(u).forEach((d) => {
        const f = a + d.text.length
        if (d.classes.length) {
          const p = pn.inline(a, f, { class: d.classes.join(" ") })
          o.push(p)
        }
        a = f
      })
    }),
    mt.create(e, o)
  )
}
function HX(e) {
  return typeof e == "function"
}
function WX({ name: e, lowlight: t, defaultLanguage: n }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((o) => HX(t[o])))
    throw Error(
      "You should provide an instance of lowlight to use the code-block-lowlight extension"
    )
  const r = new rt({
    key: new At("lowlight"),
    state: {
      init: (o, { doc: i }) =>
        xS({ doc: i, name: e, lowlight: t, defaultLanguage: n }),
      apply: (o, i, s, a) => {
        const l = s.selection.$head.parent.type.name,
          c = a.selection.$head.parent.type.name,
          u = Ly(s.doc, (f) => f.type.name === e),
          d = Ly(a.doc, (f) => f.type.name === e)
        return o.docChanged &&
          ([l, c].includes(e) ||
            d.length !== u.length ||
            o.steps.some(
              (f) =>
                f.from !== void 0 &&
                f.to !== void 0 &&
                u.some(
                  (p) => p.pos >= f.from && p.pos + p.node.nodeSize <= f.to
                )
            ))
          ? xS({ doc: o.doc, name: e, lowlight: t, defaultLanguage: n })
          : i.map(o.mapping, o.doc)
      },
    },
    props: {
      decorations(o) {
        return r.getState(o)
      },
    },
  })
  return r
}
const KX = _I.extend({
  addOptions() {
    var e
    return {
      ...((e = this.parent) === null || e === void 0 ? void 0 : e.call(this)),
      lowlight: {},
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {},
    }
  },
  addProseMirrorPlugins() {
    var e
    return [
      ...(((e = this.parent) === null || e === void 0
        ? void 0
        : e.call(this)) || []),
      WX({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage,
      }),
    ]
  },
})
function GX(e) {
  const t = e.regex,
    n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
    r = "decltype\\(auto\\)",
    o = "[a-zA-Z_]\\w*::",
    i = "<[^<>]+>",
    s =
      "(?!struct)(" +
      r +
      "|" +
      t.optional(o) +
      "[a-zA-Z_]\\w*" +
      t.optional(i) +
      ")",
    a = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" },
    l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)",
    c = {
      className: "string",
      variants: [
        {
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e.BACKSLASH_ESCAPE],
        },
        { begin: "(u8?|U|L)?'(" + l + "|.)", end: "'", illegal: "." },
        e.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/,
        }),
      ],
    },
    u = {
      className: "number",
      variants: [
        {
          begin:
            "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)",
        },
        {
          begin:
            "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)",
        },
      ],
      relevance: 0,
    },
    d = {
      className: "meta",
      begin: /#\s*[a-z]+\b/,
      end: /$/,
      keywords: {
        keyword:
          "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include",
      },
      contains: [
        { begin: /\\\n/, relevance: 0 },
        e.inherit(c, { className: "string" }),
        { className: "string", begin: /<.*?>/ },
        n,
        e.C_BLOCK_COMMENT_MODE,
      ],
    },
    f = { className: "title", begin: t.optional(o) + e.IDENT_RE, relevance: 0 },
    p = t.optional(o) + e.IDENT_RE + "\\s*\\(",
    g = [
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "break",
      "case",
      "catch",
      "class",
      "co_await",
      "co_return",
      "co_yield",
      "compl",
      "concept",
      "const_cast|10",
      "consteval",
      "constexpr",
      "constinit",
      "continue",
      "decltype",
      "default",
      "delete",
      "do",
      "dynamic_cast|10",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "final",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "override",
      "private",
      "protected",
      "public",
      "reflexpr",
      "register",
      "reinterpret_cast|10",
      "requires",
      "return",
      "sizeof",
      "static_assert",
      "static_cast|10",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "transaction_safe",
      "transaction_safe_dynamic",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "union",
      "using",
      "virtual",
      "volatile",
      "while",
      "xor",
      "xor_eq",
    ],
    v = [
      "bool",
      "char",
      "char16_t",
      "char32_t",
      "char8_t",
      "double",
      "float",
      "int",
      "long",
      "short",
      "void",
      "wchar_t",
      "unsigned",
      "signed",
      "const",
      "static",
    ],
    b = [
      "any",
      "auto_ptr",
      "barrier",
      "binary_semaphore",
      "bitset",
      "complex",
      "condition_variable",
      "condition_variable_any",
      "counting_semaphore",
      "deque",
      "false_type",
      "flat_map",
      "flat_set",
      "future",
      "imaginary",
      "initializer_list",
      "istringstream",
      "jthread",
      "latch",
      "lock_guard",
      "multimap",
      "multiset",
      "mutex",
      "optional",
      "ostringstream",
      "packaged_task",
      "pair",
      "promise",
      "priority_queue",
      "queue",
      "recursive_mutex",
      "recursive_timed_mutex",
      "scoped_lock",
      "set",
      "shared_future",
      "shared_lock",
      "shared_mutex",
      "shared_timed_mutex",
      "shared_ptr",
      "stack",
      "string_view",
      "stringstream",
      "timed_mutex",
      "thread",
      "true_type",
      "tuple",
      "unique_lock",
      "unique_ptr",
      "unordered_map",
      "unordered_multimap",
      "unordered_multiset",
      "unordered_set",
      "variant",
      "vector",
      "weak_ptr",
      "wstring",
      "wstring_view",
    ],
    y = [
      "abort",
      "abs",
      "acos",
      "apply",
      "as_const",
      "asin",
      "atan",
      "atan2",
      "calloc",
      "ceil",
      "cerr",
      "cin",
      "clog",
      "cos",
      "cosh",
      "cout",
      "declval",
      "endl",
      "exchange",
      "exit",
      "exp",
      "fabs",
      "floor",
      "fmod",
      "forward",
      "fprintf",
      "fputs",
      "free",
      "frexp",
      "fscanf",
      "future",
      "invoke",
      "isalnum",
      "isalpha",
      "iscntrl",
      "isdigit",
      "isgraph",
      "islower",
      "isprint",
      "ispunct",
      "isspace",
      "isupper",
      "isxdigit",
      "labs",
      "launder",
      "ldexp",
      "log",
      "log10",
      "make_pair",
      "make_shared",
      "make_shared_for_overwrite",
      "make_tuple",
      "make_unique",
      "malloc",
      "memchr",
      "memcmp",
      "memcpy",
      "memset",
      "modf",
      "move",
      "pow",
      "printf",
      "putchar",
      "puts",
      "realloc",
      "scanf",
      "sin",
      "sinh",
      "snprintf",
      "sprintf",
      "sqrt",
      "sscanf",
      "std",
      "stderr",
      "stdin",
      "stdout",
      "strcat",
      "strchr",
      "strcmp",
      "strcpy",
      "strcspn",
      "strlen",
      "strncat",
      "strncmp",
      "strncpy",
      "strpbrk",
      "strrchr",
      "strspn",
      "strstr",
      "swap",
      "tan",
      "tanh",
      "terminate",
      "to_underlying",
      "tolower",
      "toupper",
      "vfprintf",
      "visit",
      "vprintf",
      "vsprintf",
    ],
    w = {
      type: v,
      keyword: g,
      literal: ["NULL", "false", "nullopt", "nullptr", "true"],
      built_in: ["_Pragma"],
      _type_hints: b,
    },
    C = {
      className: "function.dispatch",
      relevance: 0,
      keywords: { _hint: y },
      begin: t.concat(
        /\b/,
        /(?!decltype)/,
        /(?!if)/,
        /(?!for)/,
        /(?!switch)/,
        /(?!while)/,
        e.IDENT_RE,
        t.lookahead(/(<[^<>]+>|)\s*\(/)
      ),
    },
    S = [C, d, a, n, e.C_BLOCK_COMMENT_MODE, u, c],
    M = {
      variants: [
        { begin: /=/, end: /;/ },
        { begin: /\(/, end: /\)/ },
        { beginKeywords: "new throw return else", end: /;/ },
      ],
      keywords: w,
      contains: S.concat([
        {
          begin: /\(/,
          end: /\)/,
          keywords: w,
          contains: S.concat(["self"]),
          relevance: 0,
        },
      ]),
      relevance: 0,
    },
    N = {
      className: "function",
      begin: "(" + s + "[\\*&\\s]+)+" + p,
      returnBegin: !0,
      end: /[{;=]/,
      excludeEnd: !0,
      keywords: w,
      illegal: /[^\w\s\*&:<>.]/,
      contains: [
        { begin: r, keywords: w, relevance: 0 },
        { begin: p, returnBegin: !0, contains: [f], relevance: 0 },
        { begin: /::/, relevance: 0 },
        { begin: /:/, endsWithParent: !0, contains: [c, u] },
        { relevance: 0, match: /,/ },
        {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: w,
          relevance: 0,
          contains: [
            n,
            e.C_BLOCK_COMMENT_MODE,
            c,
            u,
            a,
            {
              begin: /\(/,
              end: /\)/,
              keywords: w,
              relevance: 0,
              contains: ["self", n, e.C_BLOCK_COMMENT_MODE, c, u, a],
            },
          ],
        },
        a,
        n,
        e.C_BLOCK_COMMENT_MODE,
        d,
      ],
    }
  return {
    name: "C++",
    aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
    keywords: w,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(M, N, C, S, [
      d,
      {
        begin:
          "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
        end: ">",
        keywords: w,
        contains: ["self", a],
      },
      { begin: e.IDENT_RE + "::", keywords: w },
      {
        match: [
          /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
          /\s+/,
          /\w+/,
        ],
        className: { 1: "keyword", 3: "title.class" },
      },
    ]),
  }
}
function qX(e) {
  const t = {
      type: ["boolean", "byte", "word", "String"],
      built_in: [
        "KeyboardController",
        "MouseController",
        "SoftwareSerial",
        "EthernetServer",
        "EthernetClient",
        "LiquidCrystal",
        "RobotControl",
        "GSMVoiceCall",
        "EthernetUDP",
        "EsploraTFT",
        "HttpClient",
        "RobotMotor",
        "WiFiClient",
        "GSMScanner",
        "FileSystem",
        "Scheduler",
        "GSMServer",
        "YunClient",
        "YunServer",
        "IPAddress",
        "GSMClient",
        "GSMModem",
        "Keyboard",
        "Ethernet",
        "Console",
        "GSMBand",
        "Esplora",
        "Stepper",
        "Process",
        "WiFiUDP",
        "GSM_SMS",
        "Mailbox",
        "USBHost",
        "Firmata",
        "PImage",
        "Client",
        "Server",
        "GSMPIN",
        "FileIO",
        "Bridge",
        "Serial",
        "EEPROM",
        "Stream",
        "Mouse",
        "Audio",
        "Servo",
        "File",
        "Task",
        "GPRS",
        "WiFi",
        "Wire",
        "TFT",
        "GSM",
        "SPI",
        "SD",
      ],
      _hints: [
        "setup",
        "loop",
        "runShellCommandAsynchronously",
        "analogWriteResolution",
        "retrieveCallingNumber",
        "printFirmwareVersion",
        "analogReadResolution",
        "sendDigitalPortPair",
        "noListenOnLocalhost",
        "readJoystickButton",
        "setFirmwareVersion",
        "readJoystickSwitch",
        "scrollDisplayRight",
        "getVoiceCallStatus",
        "scrollDisplayLeft",
        "writeMicroseconds",
        "delayMicroseconds",
        "beginTransmission",
        "getSignalStrength",
        "runAsynchronously",
        "getAsynchronously",
        "listenOnLocalhost",
        "getCurrentCarrier",
        "readAccelerometer",
        "messageAvailable",
        "sendDigitalPorts",
        "lineFollowConfig",
        "countryNameWrite",
        "runShellCommand",
        "readStringUntil",
        "rewindDirectory",
        "readTemperature",
        "setClockDivider",
        "readLightSensor",
        "endTransmission",
        "analogReference",
        "detachInterrupt",
        "countryNameRead",
        "attachInterrupt",
        "encryptionType",
        "readBytesUntil",
        "robotNameWrite",
        "readMicrophone",
        "robotNameRead",
        "cityNameWrite",
        "userNameWrite",
        "readJoystickY",
        "readJoystickX",
        "mouseReleased",
        "openNextFile",
        "scanNetworks",
        "noInterrupts",
        "digitalWrite",
        "beginSpeaker",
        "mousePressed",
        "isActionDone",
        "mouseDragged",
        "displayLogos",
        "noAutoscroll",
        "addParameter",
        "remoteNumber",
        "getModifiers",
        "keyboardRead",
        "userNameRead",
        "waitContinue",
        "processInput",
        "parseCommand",
        "printVersion",
        "readNetworks",
        "writeMessage",
        "blinkVersion",
        "cityNameRead",
        "readMessage",
        "setDataMode",
        "parsePacket",
        "isListening",
        "setBitOrder",
        "beginPacket",
        "isDirectory",
        "motorsWrite",
        "drawCompass",
        "digitalRead",
        "clearScreen",
        "serialEvent",
        "rightToLeft",
        "setTextSize",
        "leftToRight",
        "requestFrom",
        "keyReleased",
        "compassRead",
        "analogWrite",
        "interrupts",
        "WiFiServer",
        "disconnect",
        "playMelody",
        "parseFloat",
        "autoscroll",
        "getPINUsed",
        "setPINUsed",
        "setTimeout",
        "sendAnalog",
        "readSlider",
        "analogRead",
        "beginWrite",
        "createChar",
        "motorsStop",
        "keyPressed",
        "tempoWrite",
        "readButton",
        "subnetMask",
        "debugPrint",
        "macAddress",
        "writeGreen",
        "randomSeed",
        "attachGPRS",
        "readString",
        "sendString",
        "remotePort",
        "releaseAll",
        "mouseMoved",
        "background",
        "getXChange",
        "getYChange",
        "answerCall",
        "getResult",
        "voiceCall",
        "endPacket",
        "constrain",
        "getSocket",
        "writeJSON",
        "getButton",
        "available",
        "connected",
        "findUntil",
        "readBytes",
        "exitValue",
        "readGreen",
        "writeBlue",
        "startLoop",
        "IPAddress",
        "isPressed",
        "sendSysex",
        "pauseMode",
        "gatewayIP",
        "setCursor",
        "getOemKey",
        "tuneWrite",
        "noDisplay",
        "loadImage",
        "switchPIN",
        "onRequest",
        "onReceive",
        "changePIN",
        "playFile",
        "noBuffer",
        "parseInt",
        "overflow",
        "checkPIN",
        "knobRead",
        "beginTFT",
        "bitClear",
        "updateIR",
        "bitWrite",
        "position",
        "writeRGB",
        "highByte",
        "writeRed",
        "setSpeed",
        "readBlue",
        "noStroke",
        "remoteIP",
        "transfer",
        "shutdown",
        "hangCall",
        "beginSMS",
        "endWrite",
        "attached",
        "maintain",
        "noCursor",
        "checkReg",
        "checkPUK",
        "shiftOut",
        "isValid",
        "shiftIn",
        "pulseIn",
        "connect",
        "println",
        "localIP",
        "pinMode",
        "getIMEI",
        "display",
        "noBlink",
        "process",
        "getBand",
        "running",
        "beginSD",
        "drawBMP",
        "lowByte",
        "setBand",
        "release",
        "bitRead",
        "prepare",
        "pointTo",
        "readRed",
        "setMode",
        "noFill",
        "remove",
        "listen",
        "stroke",
        "detach",
        "attach",
        "noTone",
        "exists",
        "buffer",
        "height",
        "bitSet",
        "circle",
        "config",
        "cursor",
        "random",
        "IRread",
        "setDNS",
        "endSMS",
        "getKey",
        "micros",
        "millis",
        "begin",
        "print",
        "write",
        "ready",
        "flush",
        "width",
        "isPIN",
        "blink",
        "clear",
        "press",
        "mkdir",
        "rmdir",
        "close",
        "point",
        "yield",
        "image",
        "BSSID",
        "click",
        "delay",
        "read",
        "text",
        "move",
        "peek",
        "beep",
        "rect",
        "line",
        "open",
        "seek",
        "fill",
        "size",
        "turn",
        "stop",
        "home",
        "find",
        "step",
        "tone",
        "sqrt",
        "RSSI",
        "SSID",
        "end",
        "bit",
        "tan",
        "cos",
        "sin",
        "pow",
        "map",
        "abs",
        "max",
        "min",
        "get",
        "run",
        "put",
      ],
      literal: [
        "DIGITAL_MESSAGE",
        "FIRMATA_STRING",
        "ANALOG_MESSAGE",
        "REPORT_DIGITAL",
        "REPORT_ANALOG",
        "INPUT_PULLUP",
        "SET_PIN_MODE",
        "INTERNAL2V56",
        "SYSTEM_RESET",
        "LED_BUILTIN",
        "INTERNAL1V1",
        "SYSEX_START",
        "INTERNAL",
        "EXTERNAL",
        "DEFAULT",
        "OUTPUT",
        "INPUT",
        "HIGH",
        "LOW",
      ],
    },
    n = GX(e),
    r = n.keywords
  return (
    (r.type = [...r.type, ...t.type]),
    (r.literal = [...r.literal, ...t.literal]),
    (r.built_in = [...r.built_in, ...t.built_in]),
    (r._hints = t._hints),
    (n.name = "Arduino"),
    (n.aliases = ["ino"]),
    (n.supersetOf = "cpp"),
    n
  )
}
function ZX(e) {
  const t = e.regex,
    n = {},
    r = {
      begin: /\$\{/,
      end: /\}/,
      contains: ["self", { begin: /:-/, contains: [n] }],
    }
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: t.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") },
      r,
    ],
  })
  const o = {
      className: "subst",
      begin: /\$\(/,
      end: /\)/,
      contains: [e.BACKSLASH_ESCAPE],
    },
    i = e.inherit(e.COMMENT(), {
      match: [/(^|\s)/, /#.*$/],
      scope: { 2: "comment" },
    }),
    s = {
      begin: /<<-?\s*(?=\w+)/,
      starts: {
        contains: [
          e.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string",
          }),
        ],
      },
    },
    a = {
      className: "string",
      begin: /"/,
      end: /"/,
      contains: [e.BACKSLASH_ESCAPE, n, o],
    }
  o.contains.push(a)
  const l = { match: /\\"/ },
    c = { className: "string", begin: /'/, end: /'/ },
    u = { match: /\\'/ },
    d = {
      begin: /\$?\(\(/,
      end: /\)\)/,
      contains: [
        { begin: /\d+#[0-9a-f]+/, className: "number" },
        e.NUMBER_MODE,
        n,
      ],
    },
    f = ["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"],
    p = e.SHEBANG({ binary: `(${f.join("|")})`, relevance: 10 }),
    g = {
      className: "function",
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: !0,
      contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0,
    },
    v = [
      "if",
      "then",
      "else",
      "elif",
      "fi",
      "time",
      "for",
      "while",
      "until",
      "in",
      "do",
      "done",
      "case",
      "esac",
      "coproc",
      "function",
      "select",
    ],
    b = ["true", "false"],
    y = { match: /(\/[a-z._-]+)+/ },
    x = [
      "break",
      "cd",
      "continue",
      "eval",
      "exec",
      "exit",
      "export",
      "getopts",
      "hash",
      "pwd",
      "readonly",
      "return",
      "shift",
      "test",
      "times",
      "trap",
      "umask",
      "unset",
    ],
    E = [
      "alias",
      "bind",
      "builtin",
      "caller",
      "command",
      "declare",
      "echo",
      "enable",
      "help",
      "let",
      "local",
      "logout",
      "mapfile",
      "printf",
      "read",
      "readarray",
      "source",
      "sudo",
      "type",
      "typeset",
      "ulimit",
      "unalias",
    ],
    w = [
      "autoload",
      "bg",
      "bindkey",
      "bye",
      "cap",
      "chdir",
      "clone",
      "comparguments",
      "compcall",
      "compctl",
      "compdescribe",
      "compfiles",
      "compgroups",
      "compquote",
      "comptags",
      "comptry",
      "compvalues",
      "dirs",
      "disable",
      "disown",
      "echotc",
      "echoti",
      "emulate",
      "fc",
      "fg",
      "float",
      "functions",
      "getcap",
      "getln",
      "history",
      "integer",
      "jobs",
      "kill",
      "limit",
      "log",
      "noglob",
      "popd",
      "print",
      "pushd",
      "pushln",
      "rehash",
      "sched",
      "setcap",
      "setopt",
      "stat",
      "suspend",
      "ttyctl",
      "unfunction",
      "unhash",
      "unlimit",
      "unsetopt",
      "vared",
      "wait",
      "whence",
      "where",
      "which",
      "zcompile",
      "zformat",
      "zftp",
      "zle",
      "zmodload",
      "zparseopts",
      "zprof",
      "zpty",
      "zregexparse",
      "zsocket",
      "zstyle",
      "ztcp",
    ],
    C = [
      "chcon",
      "chgrp",
      "chown",
      "chmod",
      "cp",
      "dd",
      "df",
      "dir",
      "dircolors",
      "ln",
      "ls",
      "mkdir",
      "mkfifo",
      "mknod",
      "mktemp",
      "mv",
      "realpath",
      "rm",
      "rmdir",
      "shred",
      "sync",
      "touch",
      "truncate",
      "vdir",
      "b2sum",
      "base32",
      "base64",
      "cat",
      "cksum",
      "comm",
      "csplit",
      "cut",
      "expand",
      "fmt",
      "fold",
      "head",
      "join",
      "md5sum",
      "nl",
      "numfmt",
      "od",
      "paste",
      "ptx",
      "pr",
      "sha1sum",
      "sha224sum",
      "sha256sum",
      "sha384sum",
      "sha512sum",
      "shuf",
      "sort",
      "split",
      "sum",
      "tac",
      "tail",
      "tr",
      "tsort",
      "unexpand",
      "uniq",
      "wc",
      "arch",
      "basename",
      "chroot",
      "date",
      "dirname",
      "du",
      "echo",
      "env",
      "expr",
      "factor",
      "groups",
      "hostid",
      "id",
      "link",
      "logname",
      "nice",
      "nohup",
      "nproc",
      "pathchk",
      "pinky",
      "printenv",
      "printf",
      "pwd",
      "readlink",
      "runcon",
      "seq",
      "sleep",
      "stat",
      "stdbuf",
      "stty",
      "tee",
      "test",
      "timeout",
      "tty",
      "uname",
      "unlink",
      "uptime",
      "users",
      "who",
      "whoami",
      "yes",
    ]
  return {
    name: "Bash",
    aliases: ["sh", "zsh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: v,
      literal: b,
      built_in: [...x, ...E, "set", "shopt", ...w, ...C],
    },
    contains: [p, e.SHEBANG(), g, d, i, s, y, a, l, c, u, n],
  }
}
function YX(e) {
  const t = e.regex,
    n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
    r = "decltype\\(auto\\)",
    o = "[a-zA-Z_]\\w*::",
    i = "<[^<>]+>",
    s = "(" + r + "|" + t.optional(o) + "[a-zA-Z_]\\w*" + t.optional(i) + ")",
    a = {
      className: "type",
      variants: [
        { begin: "\\b[a-z\\d_]*_t\\b" },
        { match: /\batomic_[a-z]{3,6}\b/ },
      ],
    },
    l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)",
    c = {
      className: "string",
      variants: [
        {
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e.BACKSLASH_ESCAPE],
        },
        { begin: "(u8?|U|L)?'(" + l + "|.)", end: "'", illegal: "." },
        e.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/,
        }),
      ],
    },
    u = {
      className: "number",
      variants: [
        { match: /\b(0b[01']+)/ },
        {
          match:
            /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/,
        },
        {
          match:
            /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/,
        },
        { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ },
      ],
      relevance: 0,
    },
    d = {
      className: "meta",
      begin: /#\s*[a-z]+\b/,
      end: /$/,
      keywords: {
        keyword:
          "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include",
      },
      contains: [
        { begin: /\\\n/, relevance: 0 },
        e.inherit(c, { className: "string" }),
        { className: "string", begin: /<.*?>/ },
        n,
        e.C_BLOCK_COMMENT_MODE,
      ],
    },
    f = { className: "title", begin: t.optional(o) + e.IDENT_RE, relevance: 0 },
    p = t.optional(o) + e.IDENT_RE + "\\s*\\(",
    b = {
      keyword: [
        "asm",
        "auto",
        "break",
        "case",
        "continue",
        "default",
        "do",
        "else",
        "enum",
        "extern",
        "for",
        "fortran",
        "goto",
        "if",
        "inline",
        "register",
        "restrict",
        "return",
        "sizeof",
        "typeof",
        "typeof_unqual",
        "struct",
        "switch",
        "typedef",
        "union",
        "volatile",
        "while",
        "_Alignas",
        "_Alignof",
        "_Atomic",
        "_Generic",
        "_Noreturn",
        "_Static_assert",
        "_Thread_local",
        "alignas",
        "alignof",
        "noreturn",
        "static_assert",
        "thread_local",
        "_Pragma",
      ],
      type: [
        "float",
        "double",
        "signed",
        "unsigned",
        "int",
        "short",
        "long",
        "char",
        "void",
        "_Bool",
        "_BitInt",
        "_Complex",
        "_Imaginary",
        "_Decimal32",
        "_Decimal64",
        "_Decimal96",
        "_Decimal128",
        "_Decimal64x",
        "_Decimal128x",
        "_Float16",
        "_Float32",
        "_Float64",
        "_Float128",
        "_Float32x",
        "_Float64x",
        "_Float128x",
        "const",
        "static",
        "constexpr",
        "complex",
        "bool",
        "imaginary",
      ],
      literal: "true false NULL",
      built_in:
        "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",
    },
    y = [d, a, n, e.C_BLOCK_COMMENT_MODE, u, c],
    x = {
      variants: [
        { begin: /=/, end: /;/ },
        { begin: /\(/, end: /\)/ },
        { beginKeywords: "new throw return else", end: /;/ },
      ],
      keywords: b,
      contains: y.concat([
        {
          begin: /\(/,
          end: /\)/,
          keywords: b,
          contains: y.concat(["self"]),
          relevance: 0,
        },
      ]),
      relevance: 0,
    },
    E = {
      begin: "(" + s + "[\\*&\\s]+)+" + p,
      returnBegin: !0,
      end: /[{;=]/,
      excludeEnd: !0,
      keywords: b,
      illegal: /[^\w\s\*&:<>.]/,
      contains: [
        { begin: r, keywords: b, relevance: 0 },
        {
          begin: p,
          returnBegin: !0,
          contains: [e.inherit(f, { className: "title.function" })],
          relevance: 0,
        },
        { relevance: 0, match: /,/ },
        {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: b,
          relevance: 0,
          contains: [
            n,
            e.C_BLOCK_COMMENT_MODE,
            c,
            u,
            a,
            {
              begin: /\(/,
              end: /\)/,
              keywords: b,
              relevance: 0,
              contains: ["self", n, e.C_BLOCK_COMMENT_MODE, c, u, a],
            },
          ],
        },
        a,
        n,
        e.C_BLOCK_COMMENT_MODE,
        d,
      ],
    }
  return {
    name: "C",
    aliases: ["h"],
    keywords: b,
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(x, E, y, [
      d,
      { begin: e.IDENT_RE + "::", keywords: b },
      {
        className: "class",
        beginKeywords: "enum class struct union",
        end: /[{;:<>=]/,
        contains: [{ beginKeywords: "final class struct" }, e.TITLE_MODE],
      },
    ]),
    exports: { preprocessor: d, strings: c, keywords: b },
  }
}
function XX(e) {
  const t = e.regex,
    n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
    r = "decltype\\(auto\\)",
    o = "[a-zA-Z_]\\w*::",
    i = "<[^<>]+>",
    s =
      "(?!struct)(" +
      r +
      "|" +
      t.optional(o) +
      "[a-zA-Z_]\\w*" +
      t.optional(i) +
      ")",
    a = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" },
    l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)",
    c = {
      className: "string",
      variants: [
        {
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e.BACKSLASH_ESCAPE],
        },
        { begin: "(u8?|U|L)?'(" + l + "|.)", end: "'", illegal: "." },
        e.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/,
        }),
      ],
    },
    u = {
      className: "number",
      variants: [
        {
          begin:
            "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)",
        },
        {
          begin:
            "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)",
        },
      ],
      relevance: 0,
    },
    d = {
      className: "meta",
      begin: /#\s*[a-z]+\b/,
      end: /$/,
      keywords: {
        keyword:
          "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include",
      },
      contains: [
        { begin: /\\\n/, relevance: 0 },
        e.inherit(c, { className: "string" }),
        { className: "string", begin: /<.*?>/ },
        n,
        e.C_BLOCK_COMMENT_MODE,
      ],
    },
    f = { className: "title", begin: t.optional(o) + e.IDENT_RE, relevance: 0 },
    p = t.optional(o) + e.IDENT_RE + "\\s*\\(",
    g = [
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "break",
      "case",
      "catch",
      "class",
      "co_await",
      "co_return",
      "co_yield",
      "compl",
      "concept",
      "const_cast|10",
      "consteval",
      "constexpr",
      "constinit",
      "continue",
      "decltype",
      "default",
      "delete",
      "do",
      "dynamic_cast|10",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "final",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "override",
      "private",
      "protected",
      "public",
      "reflexpr",
      "register",
      "reinterpret_cast|10",
      "requires",
      "return",
      "sizeof",
      "static_assert",
      "static_cast|10",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "transaction_safe",
      "transaction_safe_dynamic",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "union",
      "using",
      "virtual",
      "volatile",
      "while",
      "xor",
      "xor_eq",
    ],
    v = [
      "bool",
      "char",
      "char16_t",
      "char32_t",
      "char8_t",
      "double",
      "float",
      "int",
      "long",
      "short",
      "void",
      "wchar_t",
      "unsigned",
      "signed",
      "const",
      "static",
    ],
    b = [
      "any",
      "auto_ptr",
      "barrier",
      "binary_semaphore",
      "bitset",
      "complex",
      "condition_variable",
      "condition_variable_any",
      "counting_semaphore",
      "deque",
      "false_type",
      "flat_map",
      "flat_set",
      "future",
      "imaginary",
      "initializer_list",
      "istringstream",
      "jthread",
      "latch",
      "lock_guard",
      "multimap",
      "multiset",
      "mutex",
      "optional",
      "ostringstream",
      "packaged_task",
      "pair",
      "promise",
      "priority_queue",
      "queue",
      "recursive_mutex",
      "recursive_timed_mutex",
      "scoped_lock",
      "set",
      "shared_future",
      "shared_lock",
      "shared_mutex",
      "shared_timed_mutex",
      "shared_ptr",
      "stack",
      "string_view",
      "stringstream",
      "timed_mutex",
      "thread",
      "true_type",
      "tuple",
      "unique_lock",
      "unique_ptr",
      "unordered_map",
      "unordered_multimap",
      "unordered_multiset",
      "unordered_set",
      "variant",
      "vector",
      "weak_ptr",
      "wstring",
      "wstring_view",
    ],
    y = [
      "abort",
      "abs",
      "acos",
      "apply",
      "as_const",
      "asin",
      "atan",
      "atan2",
      "calloc",
      "ceil",
      "cerr",
      "cin",
      "clog",
      "cos",
      "cosh",
      "cout",
      "declval",
      "endl",
      "exchange",
      "exit",
      "exp",
      "fabs",
      "floor",
      "fmod",
      "forward",
      "fprintf",
      "fputs",
      "free",
      "frexp",
      "fscanf",
      "future",
      "invoke",
      "isalnum",
      "isalpha",
      "iscntrl",
      "isdigit",
      "isgraph",
      "islower",
      "isprint",
      "ispunct",
      "isspace",
      "isupper",
      "isxdigit",
      "labs",
      "launder",
      "ldexp",
      "log",
      "log10",
      "make_pair",
      "make_shared",
      "make_shared_for_overwrite",
      "make_tuple",
      "make_unique",
      "malloc",
      "memchr",
      "memcmp",
      "memcpy",
      "memset",
      "modf",
      "move",
      "pow",
      "printf",
      "putchar",
      "puts",
      "realloc",
      "scanf",
      "sin",
      "sinh",
      "snprintf",
      "sprintf",
      "sqrt",
      "sscanf",
      "std",
      "stderr",
      "stdin",
      "stdout",
      "strcat",
      "strchr",
      "strcmp",
      "strcpy",
      "strcspn",
      "strlen",
      "strncat",
      "strncmp",
      "strncpy",
      "strpbrk",
      "strrchr",
      "strspn",
      "strstr",
      "swap",
      "tan",
      "tanh",
      "terminate",
      "to_underlying",
      "tolower",
      "toupper",
      "vfprintf",
      "visit",
      "vprintf",
      "vsprintf",
    ],
    w = {
      type: v,
      keyword: g,
      literal: ["NULL", "false", "nullopt", "nullptr", "true"],
      built_in: ["_Pragma"],
      _type_hints: b,
    },
    C = {
      className: "function.dispatch",
      relevance: 0,
      keywords: { _hint: y },
      begin: t.concat(
        /\b/,
        /(?!decltype)/,
        /(?!if)/,
        /(?!for)/,
        /(?!switch)/,
        /(?!while)/,
        e.IDENT_RE,
        t.lookahead(/(<[^<>]+>|)\s*\(/)
      ),
    },
    S = [C, d, a, n, e.C_BLOCK_COMMENT_MODE, u, c],
    M = {
      variants: [
        { begin: /=/, end: /;/ },
        { begin: /\(/, end: /\)/ },
        { beginKeywords: "new throw return else", end: /;/ },
      ],
      keywords: w,
      contains: S.concat([
        {
          begin: /\(/,
          end: /\)/,
          keywords: w,
          contains: S.concat(["self"]),
          relevance: 0,
        },
      ]),
      relevance: 0,
    },
    N = {
      className: "function",
      begin: "(" + s + "[\\*&\\s]+)+" + p,
      returnBegin: !0,
      end: /[{;=]/,
      excludeEnd: !0,
      keywords: w,
      illegal: /[^\w\s\*&:<>.]/,
      contains: [
        { begin: r, keywords: w, relevance: 0 },
        { begin: p, returnBegin: !0, contains: [f], relevance: 0 },
        { begin: /::/, relevance: 0 },
        { begin: /:/, endsWithParent: !0, contains: [c, u] },
        { relevance: 0, match: /,/ },
        {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: w,
          relevance: 0,
          contains: [
            n,
            e.C_BLOCK_COMMENT_MODE,
            c,
            u,
            a,
            {
              begin: /\(/,
              end: /\)/,
              keywords: w,
              relevance: 0,
              contains: ["self", n, e.C_BLOCK_COMMENT_MODE, c, u, a],
            },
          ],
        },
        a,
        n,
        e.C_BLOCK_COMMENT_MODE,
        d,
      ],
    }
  return {
    name: "C++",
    aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
    keywords: w,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(M, N, C, S, [
      d,
      {
        begin:
          "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
        end: ">",
        keywords: w,
        contains: ["self", a],
      },
      { begin: e.IDENT_RE + "::", keywords: w },
      {
        match: [
          /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
          /\s+/,
          /\w+/,
        ],
        className: { 1: "keyword", 3: "title.class" },
      },
    ]),
  }
}
function QX(e) {
  const t = [
      "bool",
      "byte",
      "char",
      "decimal",
      "delegate",
      "double",
      "dynamic",
      "enum",
      "float",
      "int",
      "long",
      "nint",
      "nuint",
      "object",
      "sbyte",
      "short",
      "string",
      "ulong",
      "uint",
      "ushort",
    ],
    n = [
      "public",
      "private",
      "protected",
      "static",
      "internal",
      "protected",
      "abstract",
      "async",
      "extern",
      "override",
      "unsafe",
      "virtual",
      "new",
      "sealed",
      "partial",
    ],
    r = ["default", "false", "null", "true"],
    o = [
      "abstract",
      "as",
      "base",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "do",
      "else",
      "event",
      "explicit",
      "extern",
      "finally",
      "fixed",
      "for",
      "foreach",
      "goto",
      "if",
      "implicit",
      "in",
      "interface",
      "internal",
      "is",
      "lock",
      "namespace",
      "new",
      "operator",
      "out",
      "override",
      "params",
      "private",
      "protected",
      "public",
      "readonly",
      "record",
      "ref",
      "return",
      "scoped",
      "sealed",
      "sizeof",
      "stackalloc",
      "static",
      "struct",
      "switch",
      "this",
      "throw",
      "try",
      "typeof",
      "unchecked",
      "unsafe",
      "using",
      "virtual",
      "void",
      "volatile",
      "while",
    ],
    i = [
      "add",
      "alias",
      "and",
      "ascending",
      "args",
      "async",
      "await",
      "by",
      "descending",
      "dynamic",
      "equals",
      "file",
      "from",
      "get",
      "global",
      "group",
      "init",
      "into",
      "join",
      "let",
      "nameof",
      "not",
      "notnull",
      "on",
      "or",
      "orderby",
      "partial",
      "record",
      "remove",
      "required",
      "scoped",
      "select",
      "set",
      "unmanaged",
      "value|0",
      "var",
      "when",
      "where",
      "with",
      "yield",
    ],
    s = { keyword: o.concat(i), built_in: t, literal: r },
    a = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }),
    l = {
      className: "number",
      variants: [
        { begin: "\\b(0b[01']+)" },
        {
          begin:
            "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)",
        },
        {
          begin:
            "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
        },
      ],
      relevance: 0,
    },
    c = {
      className: "string",
      begin: /"""("*)(?!")(.|\n)*?"""\1/,
      relevance: 1,
    },
    u = {
      className: "string",
      begin: '@"',
      end: '"',
      contains: [{ begin: '""' }],
    },
    d = e.inherit(u, { illegal: /\n/ }),
    f = { className: "subst", begin: /\{/, end: /\}/, keywords: s },
    p = e.inherit(f, { illegal: /\n/ }),
    g = {
      className: "string",
      begin: /\$"/,
      end: '"',
      illegal: /\n/,
      contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, e.BACKSLASH_ESCAPE, p],
    },
    v = {
      className: "string",
      begin: /\$@"/,
      end: '"',
      contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, f],
    },
    b = e.inherit(v, {
      illegal: /\n/,
      contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, p],
    })
  ;(f.contains = [
    v,
    g,
    u,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    l,
    e.C_BLOCK_COMMENT_MODE,
  ]),
    (p.contains = [
      b,
      g,
      d,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      l,
      e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ }),
    ])
  const y = { variants: [c, v, g, u, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE] },
    x = { begin: "<", end: ">", contains: [{ beginKeywords: "in out" }, a] },
    E =
      e.IDENT_RE +
      "(<" +
      e.IDENT_RE +
      "(\\s*,\\s*" +
      e.IDENT_RE +
      ")*>)?(\\[\\])?",
    w = { begin: "@" + e.IDENT_RE, relevance: 0 }
  return {
    name: "C#",
    aliases: ["cs", "c#"],
    keywords: s,
    illegal: /::/,
    contains: [
      e.COMMENT("///", "$", {
        returnBegin: !0,
        contains: [
          {
            className: "doctag",
            variants: [
              { begin: "///", relevance: 0 },
              { begin: "<!--|-->" },
              { begin: "</?", end: ">" },
            ],
          },
        ],
      }),
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: {
          keyword:
            "if else elif endif define undef warning error line region endregion pragma checksum",
        },
      },
      y,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          a,
          x,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE,
        ],
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [a, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [a, x, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
      },
      {
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [{ className: "string", begin: /"/, end: /"/ }],
      },
      { beginKeywords: "new return throw await else", relevance: 0 },
      {
        className: "function",
        begin: "(" + E + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: s,
        contains: [
          { beginKeywords: n.join(" "), relevance: 0 },
          {
            begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [e.TITLE_MODE, x],
            relevance: 0,
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: s,
            relevance: 0,
            contains: [y, l, e.C_BLOCK_COMMENT_MODE],
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE,
        ],
      },
      w,
    ],
  }
}
const JX = (e) => ({
    IMPORTANT: { scope: "meta", begin: "!important" },
    BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
    },
    FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin:
        e.NUMBER_RE +
        "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0,
    },
    CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
  }),
  eQ = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "optgroup",
    "option",
    "p",
    "picture",
    "q",
    "quote",
    "samp",
    "section",
    "select",
    "source",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video",
  ],
  tQ = [
    "defs",
    "g",
    "marker",
    "mask",
    "pattern",
    "svg",
    "switch",
    "symbol",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feFlood",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence",
    "linearGradient",
    "radialGradient",
    "stop",
    "circle",
    "ellipse",
    "image",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect",
    "text",
    "use",
    "textPath",
    "tspan",
    "foreignObject",
    "clipPath",
  ],
  nQ = [...eQ, ...tQ],
  rQ = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    "min-width",
    "max-width",
    "min-height",
    "max-height",
  ]
    .sort()
    .reverse(),
  oQ = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    "host",
    "host-context",
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    "nth-child",
    "nth-col",
    "nth-last-child",
    "nth-last-col",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where",
  ]
    .sort()
    .reverse(),
  iQ = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error",
  ]
    .sort()
    .reverse(),
  sQ = [
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-align",
    "box-decoration-break",
    "box-direction",
    "box-flex",
    "box-flex-group",
    "box-lines",
    "box-ordinal-group",
    "box-orient",
    "box-pack",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "cx",
    "cy",
    "direction",
    "display",
    "dominant-baseline",
    "empty-cells",
    "enable-background",
    "field-sizing",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flood-color",
    "flood-opacity",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-smooth",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "initial-letter",
    "initial-letter-align",
    "inline-size",
    "inset",
    "inset-area",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "kerning",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-height",
    "line-height-step",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "masonry-auto-flow",
    "math-depth",
    "math-shift",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overlay",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "place-items",
    "place-self",
    "pointer-events",
    "position",
    "position-anchor",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "r",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "rotate",
    "row-gap",
    "ruby-align",
    "ruby-position",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "speak",
    "speak-as",
    "src",
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "touch-action",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-modify",
    "user-select",
    "vector-effect",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "white-space-collapse",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "x",
    "y",
    "z-index",
    "zoom",
  ]
    .sort()
    .reverse()
function aQ(e) {
  const t = e.regex,
    n = JX(e),
    r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ },
    o = "and or not only",
    i = /@-?\w[\w]*(-\w+)*/,
    s = "[a-zA-Z-][a-zA-Z0-9_-]*",
    a = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: { keyframePosition: "selector-tag" },
    contains: [
      n.BLOCK_COMMENT,
      r,
      n.CSS_NUMBER_MODE,
      { className: "selector-id", begin: /#[A-Za-z0-9_-]+/, relevance: 0 },
      { className: "selector-class", begin: "\\." + s, relevance: 0 },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + oQ.join("|") + ")" },
          { begin: ":(:)?(" + iQ.join("|") + ")" },
        ],
      },
      n.CSS_VARIABLE,
      { className: "attribute", begin: "\\b(" + sQ.join("|") + ")\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...a,
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            keywords: { built_in: "url data-uri" },
            contains: [
              ...a,
              {
                className: "string",
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0,
              },
            ],
          },
          n.FUNCTION_DISPATCH,
        ],
      },
      {
        begin: t.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        contains: [
          { className: "keyword", begin: i },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: o,
              attribute: rQ.join(" "),
            },
            contains: [
              { begin: /[a-z-]+(?=:)/, className: "attribute" },
              ...a,
              n.CSS_NUMBER_MODE,
            ],
          },
        ],
      },
      { className: "selector-tag", begin: "\\b(" + nQ.join("|") + ")\\b" },
    ],
  }
}
function lQ(e) {
  const t = e.regex
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: t.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        ),
      },
      {
        className: "comment",
        variants: [
          {
            begin: t.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/,
          },
          { match: /^\*{15}$/ },
        ],
      },
      { className: "addition", begin: /^\+/, end: /$/ },
      { className: "deletion", begin: /^-/, end: /$/ },
      { className: "addition", begin: /^!/, end: /$/ },
    ],
  }
}
function cQ(e) {
  const i = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var",
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune",
    ],
    literal: ["true", "false", "iota", "nil"],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete",
    ],
  }
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: i,
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          { begin: "`", end: "`" },
        ],
      },
      {
        className: "number",
        variants: [
          {
            match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
            relevance: 0,
          },
          {
            match:
              /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
            relevance: 0,
          },
          { match: /-?\b0[oO](_?[0-7])*i?/, relevance: 0 },
          { match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 },
          {
            match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
            relevance: 0,
          },
        ],
      },
      { begin: /:=/ },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          e.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: i,
            illegal: /["']/,
          },
        ],
      },
    ],
  }
}
function uQ(e) {
  const t = e.regex,
    n = /[_A-Za-z][_0-9A-Za-z]*/
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on",
      ],
      literal: ["true", "false", "null"],
    },
    contains: [
      e.HASH_COMMENT_MODE,
      e.QUOTE_STRING_MODE,
      e.NUMBER_MODE,
      { scope: "punctuation", match: /[.]{3}/, relevance: 0 },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0,
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0,
      },
      { scope: "meta", match: /@\w+/, excludeEnd: !0 },
      {
        scope: "symbol",
        begin: t.concat(n, t.lookahead(/\s*:/)),
        relevance: 0,
      },
    ],
    illegal: [/[;<']/, /BEGIN/],
  }
}
function dQ(e) {
  const t = e.regex,
    n = {
      className: "number",
      relevance: 0,
      variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: e.NUMBER_RE }],
    },
    r = e.COMMENT()
  r.variants = [
    { begin: /;/, end: /$/ },
    { begin: /#/, end: /$/ },
  ]
  const o = {
      className: "variable",
      variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }],
    },
    i = { className: "literal", begin: /\bon|off|true|false|yes|no\b/ },
    s = {
      className: "string",
      contains: [e.BACKSLASH_ESCAPE],
      variants: [
        { begin: "'''", end: "'''", relevance: 10 },
        { begin: '"""', end: '"""', relevance: 10 },
        { begin: '"', end: '"' },
        { begin: "'", end: "'" },
      ],
    },
    a = {
      begin: /\[/,
      end: /\]/,
      contains: [r, i, o, s, n, "self"],
      relevance: 0,
    },
    l = /[A-Za-z0-9_-]+/,
    c = /"(\\"|[^"])*"/,
    u = /'[^']*'/,
    d = t.either(l, c, u),
    f = t.concat(d, "(\\s*\\.\\s*", d, ")*", t.lookahead(/\s*=\s*[^#\s]/))
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      { className: "section", begin: /\[+/, end: /\]+/ },
      {
        begin: f,
        className: "attr",
        starts: { end: /$/, contains: [r, a, i, o, s, n] },
      },
    ],
  }
}
var oa = "[0-9](_*[0-9])*",
  Dd = `\\.(${oa})`,
  Ld = "[0-9a-fA-F](_*[0-9a-fA-F])*",
  wS = {
    className: "number",
    variants: [
      { begin: `(\\b(${oa})((${Dd})|\\.)?|(${Dd}))[eE][+-]?(${oa})[fFdD]?\\b` },
      { begin: `\\b(${oa})((${Dd})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${Dd})[fFdD]?\\b` },
      { begin: `\\b(${oa})[fFdD]\\b` },
      {
        begin: `\\b0[xX]((${Ld})\\.?|(${Ld})?\\.(${Ld}))[pP][+-]?(${oa})[fFdD]?\\b`,
      },
      { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
      { begin: `\\b0[xX](${Ld})[lL]?\\b` },
      { begin: "\\b0(_*[0-7])*[lL]?\\b" },
      { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" },
    ],
    relevance: 0,
  }
function WI(e, t, n) {
  return n === -1 ? "" : e.replace(t, (r) => WI(e, t, n - 1))
}
function fQ(e) {
  const t = e.regex,
    n = "[-a-zA-Z_$][-a-zA-Z_$0-9]*",
    r = n + WI("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2),
    l = {
      keyword: [
        "synchronized",
        "abstract",
        "private",
        "var",
        "static",
        "if",
        "const ",
        "for",
        "while",
        "strictfp",
        "finally",
        "protected",
        "import",
        "native",
        "final",
        "void",
        "enum",
        "else",
        "break",
        "transient",
        "catch",
        "instanceof",
        "volatile",
        "case",
        "assert",
        "package",
        "default",
        "public",
        "try",
        "switch",
        "continue",
        "throws",
        "protected",
        "public",
        "private",
        "module",
        "requires",
        "exports",
        "do",
        "sealed",
        "yield",
        "permits",
        "goto",
        "when",
      ],
      literal: ["false", "true", "null"],
      type: [
        "char",
        "boolean",
        "long",
        "float",
        "int",
        "byte",
        "short",
        "double",
      ],
      built_in: ["super", "this"],
    },
    c = {
      className: "meta",
      begin: "@" + n,
      contains: [{ begin: /\(/, end: /\)/, contains: ["self"] }],
    },
    u = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      keywords: l,
      relevance: 0,
      contains: [e.C_BLOCK_COMMENT_MODE],
      endsParent: !0,
    }
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      e.COMMENT("/\\*\\*", "\\*/", {
        relevance: 0,
        contains: [
          { begin: /\w+@/, relevance: 0 },
          { className: "doctag", begin: "@[A-Za-z]+" },
        ],
      }),
      { begin: /import java\.[a-z]+\./, keywords: "import", relevance: 2 },
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [e.BACKSLASH_ESCAPE],
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, n],
        className: { 1: "keyword", 3: "title.class" },
      },
      { match: /non-sealed/, scope: "keyword" },
      {
        begin: [t.concat(/(?!else)/, n), /\s+/, n, /\s+/, /=(?!=)/],
        className: { 1: "type", 3: "variable", 5: "operator" },
      },
      {
        begin: [/record/, /\s+/, n],
        className: { 1: "keyword", 3: "title.class" },
        contains: [u, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
      },
      { beginKeywords: "new throw return else", relevance: 0 },
      {
        begin: ["(?:" + r + "\\s+)", e.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              c,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              wS,
              e.C_BLOCK_COMMENT_MODE,
            ],
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE,
        ],
      },
      wS,
      c,
    ],
  }
}
const ES = "[A-Za-z$_][0-9A-Za-z$_]*",
  pQ = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends",
    "using",
  ],
  hQ = ["true", "false", "null", "undefined", "NaN", "Infinity"],
  KI = [
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    "Math",
    "Date",
    "Number",
    "BigInt",
    "String",
    "RegExp",
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    "Reflect",
    "Proxy",
    "Intl",
    "WebAssembly",
  ],
  GI = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError",
  ],
  qI = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape",
  ],
  mQ = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "sessionStorage",
    "module",
    "global",
  ],
  gQ = [].concat(qI, KI, GI)
function vQ(e) {
  const t = e.regex,
    n = (_, { after: A }) => {
      const P = "</" + _[0].slice(1)
      return _.input.indexOf(P, A) !== -1
    },
    r = ES,
    o = { begin: "<>", end: "</>" },
    i = /<[A-Za-z0-9\\._:-]+\s*\/>/,
    s = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (_, A) => {
        const P = _[0].length + _.index,
          H = _.input[P]
        if (H === "<" || H === ",") {
          A.ignoreMatch()
          return
        }
        H === ">" && (n(_, { after: P }) || A.ignoreMatch())
        let X
        const ae = _.input.substring(P)
        if ((X = ae.match(/^\s*=/))) {
          A.ignoreMatch()
          return
        }
        if ((X = ae.match(/^\s+extends\s+/)) && X.index === 0) {
          A.ignoreMatch()
          return
        }
      },
    },
    a = {
      $pattern: ES,
      keyword: pQ,
      literal: hQ,
      built_in: gQ,
      "variable.language": mQ,
    },
    l = "[0-9](_?[0-9])*",
    c = `\\.(${l})`,
    u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
    d = {
      className: "number",
      variants: [
        { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
        { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
        { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        { begin: "\\b0[0-7]+n?\\b" },
      ],
      relevance: 0,
    },
    f = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: a,
      contains: [],
    },
    p = {
      begin: ".?html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [e.BACKSLASH_ESCAPE, f],
        subLanguage: "xml",
      },
    },
    g = {
      begin: ".?css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [e.BACKSLASH_ESCAPE, f],
        subLanguage: "css",
      },
    },
    v = {
      begin: ".?gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [e.BACKSLASH_ESCAPE, f],
        subLanguage: "graphql",
      },
    },
    b = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [e.BACKSLASH_ESCAPE, f],
    },
    x = {
      className: "comment",
      variants: [
        e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                { className: "doctag", begin: "@[A-Za-z]+" },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0,
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0,
                },
                { begin: /(?=[^\n])\s/, relevance: 0 },
              ],
            },
          ],
        }),
        e.C_BLOCK_COMMENT_MODE,
        e.C_LINE_COMMENT_MODE,
      ],
    },
    E = [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      g,
      v,
      b,
      { match: /\$\d+/ },
      d,
    ]
  f.contains = E.concat({
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: ["self"].concat(E),
  })
  const w = [].concat(x, f.contains),
    C = w.concat([
      {
        begin: /(\s*)\(/,
        end: /\)/,
        keywords: a,
        contains: ["self"].concat(w),
      },
    ]),
    S = {
      className: "params",
      begin: /(\s*)\(/,
      end: /\)/,
      excludeBegin: !0,
      excludeEnd: !0,
      keywords: a,
      contains: C,
    },
    M = {
      variants: [
        {
          match: [
            /class/,
            /\s+/,
            r,
            /\s+/,
            /extends/,
            /\s+/,
            t.concat(r, "(", t.concat(/\./, r), ")*"),
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited",
          },
        },
        {
          match: [/class/, /\s+/, r],
          scope: { 1: "keyword", 3: "title.class" },
        },
      ],
    },
    N = {
      relevance: 0,
      match: t.either(
        /\bJSON/,
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      ),
      className: "title.class",
      keywords: { _: [...KI, ...GI] },
    },
    R = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/,
    },
    B = {
      variants: [
        { match: [/function/, /\s+/, r, /(?=\s*\()/] },
        { match: [/function/, /\s*(?=\()/] },
      ],
      className: { 1: "keyword", 3: "title.function" },
      label: "func.def",
      contains: [S],
      illegal: /%/,
    },
    V = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant",
    }
  function j(_) {
    return t.concat("(?!", _.join("|"), ")")
  }
  const U = {
      match: t.concat(
        /\b/,
        j([...qI, "super", "import"].map((_) => `${_}\\s*\\(`)),
        r,
        t.lookahead(/\s*\(/)
      ),
      className: "title.function",
      relevance: 0,
    },
    W = {
      begin: t.concat(/\./, t.lookahead(t.concat(r, /(?![0-9A-Za-z$_(])/))),
      end: r,
      excludeBegin: !0,
      keywords: "prototype",
      className: "property",
      relevance: 0,
    },
    ee = {
      match: [/get|set/, /\s+/, r, /(?=\()/],
      className: { 1: "keyword", 3: "title.function" },
      contains: [{ begin: /\(\)/ }, S],
    },
    I =
      "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" +
      e.UNDERSCORE_IDENT_RE +
      ")\\s*=>",
    O = {
      match: [
        /const|var|let/,
        /\s+/,
        r,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        t.lookahead(I),
      ],
      keywords: "async",
      className: { 1: "keyword", 3: "title.function" },
      contains: [S],
    }
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    exports: { PARAMS_CONTAINS: C, CLASS_REFERENCE: N },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
      R,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      g,
      v,
      b,
      x,
      { match: /\$\d+/ },
      d,
      N,
      { scope: "attr", match: r + t.lookahead(":"), relevance: 0 },
      O,
      {
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          x,
          e.REGEXP_MODE,
          {
            className: "function",
            begin: I,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                  { className: null, begin: /\(\s*\)/, skip: !0 },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: C,
                  },
                ],
              },
            ],
          },
          { begin: /,/, relevance: 0 },
          { match: /\s+/, relevance: 0 },
          {
            variants: [
              { begin: o.begin, end: o.end },
              { match: i },
              { begin: s.begin, "on:begin": s.isTrulyOpeningTag, end: s.end },
            ],
            subLanguage: "xml",
            contains: [
              { begin: s.begin, end: s.end, skip: !0, contains: ["self"] },
            ],
          },
        ],
      },
      B,
      { beginKeywords: "while if switch catch for" },
      {
        begin:
          "\\b(?!function)" +
          e.UNDERSCORE_IDENT_RE +
          "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: !0,
        label: "func.def",
        contains: [
          S,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" }),
        ],
      },
      { match: /\.\.\./, relevance: 0 },
      W,
      { match: "\\$" + r, relevance: 0 },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [S],
      },
      U,
      V,
      M,
      ee,
      { match: /\$[(.]/ },
    ],
  }
}
function yQ(e) {
  const t = {
      className: "attr",
      begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
      relevance: 1.01,
    },
    n = { match: /[{}[\],:]/, className: "punctuation", relevance: 0 },
    r = ["true", "false", "null"],
    o = { scope: "literal", beginKeywords: r.join(" ") }
  return {
    name: "JSON",
    aliases: ["jsonc"],
    keywords: { literal: r },
    contains: [
      t,
      n,
      e.QUOTE_STRING_MODE,
      o,
      e.C_NUMBER_MODE,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
    ],
    illegal: "\\S",
  }
}
var ia = "[0-9](_*[0-9])*",
  Pd = `\\.(${ia})`,
  $d = "[0-9a-fA-F](_*[0-9a-fA-F])*",
  bQ = {
    className: "number",
    variants: [
      { begin: `(\\b(${ia})((${Pd})|\\.)?|(${Pd}))[eE][+-]?(${ia})[fFdD]?\\b` },
      { begin: `\\b(${ia})((${Pd})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${Pd})[fFdD]?\\b` },
      { begin: `\\b(${ia})[fFdD]\\b` },
      {
        begin: `\\b0[xX]((${$d})\\.?|(${$d})?\\.(${$d}))[pP][+-]?(${ia})[fFdD]?\\b`,
      },
      { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
      { begin: `\\b0[xX](${$d})[lL]?\\b` },
      { begin: "\\b0(_*[0-7])*[lL]?\\b" },
      { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" },
    ],
    relevance: 0,
  }
function xQ(e) {
  const t = {
      keyword:
        "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
      built_in:
        "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
      literal: "true false null",
    },
    n = {
      className: "keyword",
      begin: /\b(break|continue|return|this)\b/,
      starts: { contains: [{ className: "symbol", begin: /@\w+/ }] },
    },
    r = { className: "symbol", begin: e.UNDERSCORE_IDENT_RE + "@" },
    o = {
      className: "subst",
      begin: /\$\{/,
      end: /\}/,
      contains: [e.C_NUMBER_MODE],
    },
    i = { className: "variable", begin: "\\$" + e.UNDERSCORE_IDENT_RE },
    s = {
      className: "string",
      variants: [
        { begin: '"""', end: '"""(?=[^"])', contains: [i, o] },
        { begin: "'", end: "'", illegal: /\n/, contains: [e.BACKSLASH_ESCAPE] },
        {
          begin: '"',
          end: '"',
          illegal: /\n/,
          contains: [e.BACKSLASH_ESCAPE, i, o],
        },
      ],
    }
  o.contains.push(s)
  const a = {
      className: "meta",
      begin:
        "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" +
        e.UNDERSCORE_IDENT_RE +
        ")?",
    },
    l = {
      className: "meta",
      begin: "@" + e.UNDERSCORE_IDENT_RE,
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          contains: [e.inherit(s, { className: "string" }), "self"],
        },
      ],
    },
    c = bQ,
    u = e.COMMENT("/\\*", "\\*/", { contains: [e.C_BLOCK_COMMENT_MODE] }),
    d = {
      variants: [
        { className: "type", begin: e.UNDERSCORE_IDENT_RE },
        { begin: /\(/, end: /\)/, contains: [] },
      ],
    },
    f = d
  return (
    (f.variants[1].contains = [d]),
    (d.variants[1].contains = [f]),
    {
      name: "Kotlin",
      aliases: ["kt", "kts"],
      keywords: t,
      contains: [
        e.COMMENT("/\\*\\*", "\\*/", {
          relevance: 0,
          contains: [{ className: "doctag", begin: "@[A-Za-z]+" }],
        }),
        e.C_LINE_COMMENT_MODE,
        u,
        n,
        r,
        a,
        l,
        {
          className: "function",
          beginKeywords: "fun",
          end: "[(]|$",
          returnBegin: !0,
          excludeEnd: !0,
          keywords: t,
          relevance: 5,
          contains: [
            {
              begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
              returnBegin: !0,
              relevance: 0,
              contains: [e.UNDERSCORE_TITLE_MODE],
            },
            {
              className: "type",
              begin: /</,
              end: />/,
              keywords: "reified",
              relevance: 0,
            },
            {
              className: "params",
              begin: /\(/,
              end: /\)/,
              endsParent: !0,
              keywords: t,
              relevance: 0,
              contains: [
                {
                  begin: /:/,
                  end: /[=,\/]/,
                  endsWithParent: !0,
                  contains: [d, e.C_LINE_COMMENT_MODE, u],
                  relevance: 0,
                },
                e.C_LINE_COMMENT_MODE,
                u,
                a,
                l,
                s,
                e.C_NUMBER_MODE,
              ],
            },
            u,
          ],
        },
        {
          begin: [/class|interface|trait/, /\s+/, e.UNDERSCORE_IDENT_RE],
          beginScope: { 3: "title.class" },
          keywords: "class interface trait",
          end: /[:\{(]|$/,
          excludeEnd: !0,
          illegal: "extends implements",
          contains: [
            { beginKeywords: "public protected internal private constructor" },
            e.UNDERSCORE_TITLE_MODE,
            {
              className: "type",
              begin: /</,
              end: />/,
              excludeBegin: !0,
              excludeEnd: !0,
              relevance: 0,
            },
            {
              className: "type",
              begin: /[,:]\s*/,
              end: /[<\(,){\s]|$/,
              excludeBegin: !0,
              returnEnd: !0,
            },
            a,
            l,
          ],
        },
        s,
        {
          className: "meta",
          begin: "^#!/usr/bin/env",
          end: "$",
          illegal: `
`,
        },
        c,
      ],
    }
  )
}
const wQ = (e) => ({
    IMPORTANT: { scope: "meta", begin: "!important" },
    BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
    },
    FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin:
        e.NUMBER_RE +
        "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0,
    },
    CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
  }),
  EQ = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "optgroup",
    "option",
    "p",
    "picture",
    "q",
    "quote",
    "samp",
    "section",
    "select",
    "source",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video",
  ],
  CQ = [
    "defs",
    "g",
    "marker",
    "mask",
    "pattern",
    "svg",
    "switch",
    "symbol",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feFlood",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence",
    "linearGradient",
    "radialGradient",
    "stop",
    "circle",
    "ellipse",
    "image",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect",
    "text",
    "use",
    "textPath",
    "tspan",
    "foreignObject",
    "clipPath",
  ],
  SQ = [...EQ, ...CQ],
  _Q = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    "min-width",
    "max-width",
    "min-height",
    "max-height",
  ]
    .sort()
    .reverse(),
  ZI = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    "host",
    "host-context",
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    "nth-child",
    "nth-col",
    "nth-last-child",
    "nth-last-col",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where",
  ]
    .sort()
    .reverse(),
  YI = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error",
  ]
    .sort()
    .reverse(),
  kQ = [
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-align",
    "box-decoration-break",
    "box-direction",
    "box-flex",
    "box-flex-group",
    "box-lines",
    "box-ordinal-group",
    "box-orient",
    "box-pack",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "cx",
    "cy",
    "direction",
    "display",
    "dominant-baseline",
    "empty-cells",
    "enable-background",
    "field-sizing",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flood-color",
    "flood-opacity",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-smooth",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "initial-letter",
    "initial-letter-align",
    "inline-size",
    "inset",
    "inset-area",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "kerning",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-height",
    "line-height-step",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "masonry-auto-flow",
    "math-depth",
    "math-shift",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overlay",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "place-items",
    "place-self",
    "pointer-events",
    "position",
    "position-anchor",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "r",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "rotate",
    "row-gap",
    "ruby-align",
    "ruby-position",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "speak",
    "speak-as",
    "src",
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "touch-action",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-modify",
    "user-select",
    "vector-effect",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "white-space-collapse",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "x",
    "y",
    "z-index",
    "zoom",
  ]
    .sort()
    .reverse(),
  NQ = ZI.concat(YI).sort().reverse()
function TQ(e) {
  const t = wQ(e),
    n = NQ,
    r = "and or not only",
    o = "[\\w-]+",
    i = "(" + o + "|@\\{" + o + "\\})",
    s = [],
    a = [],
    l = function (E) {
      return { className: "string", begin: "~?" + E + ".*?" + E }
    },
    c = function (E, w, C) {
      return { className: E, begin: w, relevance: C }
    },
    u = { $pattern: /[a-z-]+/, keyword: r, attribute: _Q.join(" ") },
    d = { begin: "\\(", end: "\\)", contains: a, keywords: u, relevance: 0 }
  a.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    t.CSS_NUMBER_MODE,
    {
      begin: "(url|data-uri)\\(",
      starts: { className: "string", end: "[\\)\\n]", excludeEnd: !0 },
    },
    t.HEXCOLOR,
    d,
    c("variable", "@@?" + o, 10),
    c("variable", "@\\{" + o + "\\}"),
    c("built_in", "~?`[^`]*?`"),
    {
      className: "attribute",
      begin: o + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0,
    },
    t.IMPORTANT,
    { beginKeywords: "and not" },
    t.FUNCTION_DISPATCH
  )
  const f = a.concat({ begin: /\{/, end: /\}/, contains: s }),
    p = {
      beginKeywords: "when",
      endsWithParent: !0,
      contains: [{ beginKeywords: "and not" }].concat(a),
    },
    g = {
      begin: i + "\\s*:",
      returnBegin: !0,
      end: /[;}]/,
      relevance: 0,
      contains: [
        { begin: /-(webkit|moz|ms|o)-/ },
        t.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + kQ.join("|") + ")\\b",
          end: /(?=:)/,
          starts: {
            endsWithParent: !0,
            illegal: "[<=$]",
            relevance: 0,
            contains: a,
          },
        },
      ],
    },
    v = {
      className: "keyword",
      begin:
        "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
      starts: {
        end: "[;{}]",
        keywords: u,
        returnEnd: !0,
        contains: a,
        relevance: 0,
      },
    },
    b = {
      className: "variable",
      variants: [
        { begin: "@" + o + "\\s*:", relevance: 15 },
        { begin: "@" + o },
      ],
      starts: { end: "[;}]", returnEnd: !0, contains: f },
    },
    y = {
      variants: [
        { begin: "[\\.#:&\\[>]", end: "[;{}]" },
        { begin: i, end: /\{/ },
      ],
      returnBegin: !0,
      returnEnd: !0,
      illegal: `[<='$"]`,
      relevance: 0,
      contains: [
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        p,
        c("keyword", "all\\b"),
        c("variable", "@\\{" + o + "\\}"),
        { begin: "\\b(" + SQ.join("|") + ")\\b", className: "selector-tag" },
        t.CSS_NUMBER_MODE,
        c("selector-tag", i, 0),
        c("selector-id", "#" + i),
        c("selector-class", "\\." + i, 0),
        c("selector-tag", "&", 0),
        t.ATTRIBUTE_SELECTOR_MODE,
        { className: "selector-pseudo", begin: ":(" + ZI.join("|") + ")" },
        { className: "selector-pseudo", begin: ":(:)?(" + YI.join("|") + ")" },
        { begin: /\(/, end: /\)/, relevance: 0, contains: f },
        { begin: "!important" },
        t.FUNCTION_DISPATCH,
      ],
    },
    x = { begin: o + `:(:)?(${n.join("|")})`, returnBegin: !0, contains: [y] }
  return (
    s.push(
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      v,
      b,
      x,
      g,
      y,
      p,
      t.FUNCTION_DISPATCH
    ),
    { name: "Less", case_insensitive: !0, illegal: `[=>'/<($"]`, contains: s }
  )
}
function MQ(e) {
  const t = "\\[=*\\[",
    n = "\\]=*\\]",
    r = { begin: t, end: n, contains: ["self"] },
    o = [
      e.COMMENT("--(?!" + t + ")", "$"),
      e.COMMENT("--" + t, n, { contains: [r], relevance: 10 }),
    ]
  return {
    name: "Lua",
    aliases: ["pluto"],
    keywords: {
      $pattern: e.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword:
        "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove",
    },
    contains: o.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          e.inherit(e.TITLE_MODE, {
            begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*",
          }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: o,
          },
        ].concat(o),
      },
      e.C_NUMBER_MODE,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      { className: "string", begin: t, end: n, contains: [r], relevance: 5 },
    ]),
  }
}
function OQ(e) {
  const t = {
      className: "variable",
      variants: [
        {
          begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
          contains: [e.BACKSLASH_ESCAPE],
        },
        { begin: /\$[@%<?\^\+\*]/ },
      ],
    },
    n = {
      className: "string",
      begin: /"/,
      end: /"/,
      contains: [e.BACKSLASH_ESCAPE, t],
    },
    r = {
      className: "variable",
      begin: /\$\([\w-]+\s/,
      end: /\)/,
      keywords: {
        built_in:
          "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value",
      },
      contains: [t, n],
    },
    o = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" },
    i = {
      className: "meta",
      begin: /^\.PHONY:/,
      end: /$/,
      keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" },
    },
    s = { className: "section", begin: /^[^\s]+:/, end: /$/, contains: [t] }
  return {
    name: "Makefile",
    aliases: ["mk", "mak", "make"],
    keywords: {
      $pattern: /[\w-]+/,
      keyword:
        "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath",
    },
    contains: [e.HASH_COMMENT_MODE, t, n, r, o, i, s],
  }
}
function AQ(e) {
  const t = e.regex,
    n = { begin: /<\/?[A-Za-z_]/, end: ">", subLanguage: "xml", relevance: 0 },
    r = { begin: "^[-\\*]{3,}", end: "$" },
    o = {
      className: "code",
      variants: [
        { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
        { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
        { begin: "```", end: "```+[ ]*$" },
        { begin: "~~~", end: "~~~+[ ]*$" },
        { begin: "`.+?`" },
        {
          begin: "(?=^( {4}|\\t))",
          contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }],
          relevance: 0,
        },
      ],
    },
    i = {
      className: "bullet",
      begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
      end: "\\s+",
      excludeEnd: !0,
    },
    s = {
      begin: /^\[[^\n]+\]:/,
      returnBegin: !0,
      contains: [
        {
          className: "symbol",
          begin: /\[/,
          end: /\]/,
          excludeBegin: !0,
          excludeEnd: !0,
        },
        { className: "link", begin: /:\s*/, end: /$/, excludeBegin: !0 },
      ],
    },
    a = /[A-Za-z][A-Za-z0-9+.-]*/,
    l = {
      variants: [
        { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
        {
          begin:
            /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
          relevance: 2,
        },
        { begin: t.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/), relevance: 2 },
        { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
        { begin: /\[.*?\]\(.*?\)/, relevance: 0 },
      ],
      returnBegin: !0,
      contains: [
        { match: /\[(?=\])/ },
        {
          className: "string",
          relevance: 0,
          begin: "\\[",
          end: "\\]",
          excludeBegin: !0,
          returnEnd: !0,
        },
        {
          className: "link",
          relevance: 0,
          begin: "\\]\\(",
          end: "\\)",
          excludeBegin: !0,
          excludeEnd: !0,
        },
        {
          className: "symbol",
          relevance: 0,
          begin: "\\]\\[",
          end: "\\]",
          excludeBegin: !0,
          excludeEnd: !0,
        },
      ],
    },
    c = {
      className: "strong",
      contains: [],
      variants: [
        { begin: /_{2}(?!\s)/, end: /_{2}/ },
        { begin: /\*{2}(?!\s)/, end: /\*{2}/ },
      ],
    },
    u = {
      className: "emphasis",
      contains: [],
      variants: [
        { begin: /\*(?![*\s])/, end: /\*/ },
        { begin: /_(?![_\s])/, end: /_/, relevance: 0 },
      ],
    },
    d = e.inherit(c, { contains: [] }),
    f = e.inherit(u, { contains: [] })
  c.contains.push(f), u.contains.push(d)
  let p = [n, l]
  return (
    [c, u, d, f].forEach((y) => {
      y.contains = y.contains.concat(p)
    }),
    (p = p.concat(c, u)),
    {
      name: "Markdown",
      aliases: ["md", "mkdown", "mkd"],
      contains: [
        {
          className: "section",
          variants: [
            { begin: "^#{1,6}", end: "$", contains: p },
            {
              begin: "(?=^.+?\\n[=-]{2,}$)",
              contains: [
                { begin: "^[=-]*$" },
                { begin: "^", end: "\\n", contains: p },
              ],
            },
          ],
        },
        n,
        i,
        c,
        u,
        { className: "quote", begin: "^>\\s+", contains: p, end: "$" },
        o,
        r,
        l,
        s,
        {
          scope: "literal",
          match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/,
        },
      ],
    }
  )
}
function RQ(e) {
  const t = {
      className: "built_in",
      begin:
        "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+",
    },
    n = /[a-zA-Z@][a-zA-Z0-9_]*/,
    a = {
      "variable.language": ["this", "super"],
      $pattern: n,
      keyword: [
        "while",
        "export",
        "sizeof",
        "typedef",
        "const",
        "struct",
        "for",
        "union",
        "volatile",
        "static",
        "mutable",
        "if",
        "do",
        "return",
        "goto",
        "enum",
        "else",
        "break",
        "extern",
        "asm",
        "case",
        "default",
        "register",
        "explicit",
        "typename",
        "switch",
        "continue",
        "inline",
        "readonly",
        "assign",
        "readwrite",
        "self",
        "@synchronized",
        "id",
        "typeof",
        "nonatomic",
        "IBOutlet",
        "IBAction",
        "strong",
        "weak",
        "copy",
        "in",
        "out",
        "inout",
        "bycopy",
        "byref",
        "oneway",
        "__strong",
        "__weak",
        "__block",
        "__autoreleasing",
        "@private",
        "@protected",
        "@public",
        "@try",
        "@property",
        "@end",
        "@throw",
        "@catch",
        "@finally",
        "@autoreleasepool",
        "@synthesize",
        "@dynamic",
        "@selector",
        "@optional",
        "@required",
        "@encode",
        "@package",
        "@import",
        "@defs",
        "@compatibility_alias",
        "__bridge",
        "__bridge_transfer",
        "__bridge_retained",
        "__bridge_retain",
        "__covariant",
        "__contravariant",
        "__kindof",
        "_Nonnull",
        "_Nullable",
        "_Null_unspecified",
        "__FUNCTION__",
        "__PRETTY_FUNCTION__",
        "__attribute__",
        "getter",
        "setter",
        "retain",
        "unsafe_unretained",
        "nonnull",
        "nullable",
        "null_unspecified",
        "null_resettable",
        "class",
        "instancetype",
        "NS_DESIGNATED_INITIALIZER",
        "NS_UNAVAILABLE",
        "NS_REQUIRES_SUPER",
        "NS_RETURNS_INNER_POINTER",
        "NS_INLINE",
        "NS_AVAILABLE",
        "NS_DEPRECATED",
        "NS_ENUM",
        "NS_OPTIONS",
        "NS_SWIFT_UNAVAILABLE",
        "NS_ASSUME_NONNULL_BEGIN",
        "NS_ASSUME_NONNULL_END",
        "NS_REFINED_FOR_SWIFT",
        "NS_SWIFT_NAME",
        "NS_SWIFT_NOTHROW",
        "NS_DURING",
        "NS_HANDLER",
        "NS_ENDHANDLER",
        "NS_VALUERETURN",
        "NS_VOIDRETURN",
      ],
      literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"],
      built_in: [
        "dispatch_once_t",
        "dispatch_queue_t",
        "dispatch_sync",
        "dispatch_async",
        "dispatch_once",
      ],
      type: [
        "int",
        "float",
        "char",
        "unsigned",
        "signed",
        "short",
        "long",
        "double",
        "wchar_t",
        "unichar",
        "void",
        "bool",
        "BOOL",
        "id|0",
        "_Bool",
      ],
    },
    l = {
      $pattern: n,
      keyword: ["@interface", "@class", "@protocol", "@implementation"],
    }
  return {
    name: "Objective-C",
    aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
    keywords: a,
    illegal: "</",
    contains: [
      t,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      e.C_NUMBER_MODE,
      e.QUOTE_STRING_MODE,
      e.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [e.BACKSLASH_ESCAPE],
          },
        ],
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: {
          keyword:
            "if else elif endif define undef warning error line pragma ifdef ifndef include",
        },
        contains: [
          { begin: /\\\n/, relevance: 0 },
          e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
          { className: "string", begin: /<.*?>/, end: /$/, illegal: "\\n" },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE,
        ],
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [e.UNDERSCORE_TITLE_MODE],
      },
      { begin: "\\." + e.UNDERSCORE_IDENT_RE, relevance: 0 },
    ],
  }
}
function IQ(e) {
  const t = e.regex,
    n = [
      "abs",
      "accept",
      "alarm",
      "and",
      "atan2",
      "bind",
      "binmode",
      "bless",
      "break",
      "caller",
      "chdir",
      "chmod",
      "chomp",
      "chop",
      "chown",
      "chr",
      "chroot",
      "class",
      "close",
      "closedir",
      "connect",
      "continue",
      "cos",
      "crypt",
      "dbmclose",
      "dbmopen",
      "defined",
      "delete",
      "die",
      "do",
      "dump",
      "each",
      "else",
      "elsif",
      "endgrent",
      "endhostent",
      "endnetent",
      "endprotoent",
      "endpwent",
      "endservent",
      "eof",
      "eval",
      "exec",
      "exists",
      "exit",
      "exp",
      "fcntl",
      "field",
      "fileno",
      "flock",
      "for",
      "foreach",
      "fork",
      "format",
      "formline",
      "getc",
      "getgrent",
      "getgrgid",
      "getgrnam",
      "gethostbyaddr",
      "gethostbyname",
      "gethostent",
      "getlogin",
      "getnetbyaddr",
      "getnetbyname",
      "getnetent",
      "getpeername",
      "getpgrp",
      "getpriority",
      "getprotobyname",
      "getprotobynumber",
      "getprotoent",
      "getpwent",
      "getpwnam",
      "getpwuid",
      "getservbyname",
      "getservbyport",
      "getservent",
      "getsockname",
      "getsockopt",
      "given",
      "glob",
      "gmtime",
      "goto",
      "grep",
      "gt",
      "hex",
      "if",
      "index",
      "int",
      "ioctl",
      "join",
      "keys",
      "kill",
      "last",
      "lc",
      "lcfirst",
      "length",
      "link",
      "listen",
      "local",
      "localtime",
      "log",
      "lstat",
      "lt",
      "ma",
      "map",
      "method",
      "mkdir",
      "msgctl",
      "msgget",
      "msgrcv",
      "msgsnd",
      "my",
      "ne",
      "next",
      "no",
      "not",
      "oct",
      "open",
      "opendir",
      "or",
      "ord",
      "our",
      "pack",
      "package",
      "pipe",
      "pop",
      "pos",
      "print",
      "printf",
      "prototype",
      "push",
      "q|0",
      "qq",
      "quotemeta",
      "qw",
      "qx",
      "rand",
      "read",
      "readdir",
      "readline",
      "readlink",
      "readpipe",
      "recv",
      "redo",
      "ref",
      "rename",
      "require",
      "reset",
      "return",
      "reverse",
      "rewinddir",
      "rindex",
      "rmdir",
      "say",
      "scalar",
      "seek",
      "seekdir",
      "select",
      "semctl",
      "semget",
      "semop",
      "send",
      "setgrent",
      "sethostent",
      "setnetent",
      "setpgrp",
      "setpriority",
      "setprotoent",
      "setpwent",
      "setservent",
      "setsockopt",
      "shift",
      "shmctl",
      "shmget",
      "shmread",
      "shmwrite",
      "shutdown",
      "sin",
      "sleep",
      "socket",
      "socketpair",
      "sort",
      "splice",
      "split",
      "sprintf",
      "sqrt",
      "srand",
      "stat",
      "state",
      "study",
      "sub",
      "substr",
      "symlink",
      "syscall",
      "sysopen",
      "sysread",
      "sysseek",
      "system",
      "syswrite",
      "tell",
      "telldir",
      "tie",
      "tied",
      "time",
      "times",
      "tr",
      "truncate",
      "uc",
      "ucfirst",
      "umask",
      "undef",
      "unless",
      "unlink",
      "unpack",
      "unshift",
      "untie",
      "until",
      "use",
      "utime",
      "values",
      "vec",
      "wait",
      "waitpid",
      "wantarray",
      "warn",
      "when",
      "while",
      "write",
      "x|0",
      "xor",
      "y|0",
    ],
    r = /[dualxmsipngr]{0,12}/,
    o = { $pattern: /[\w.]+/, keyword: n.join(" ") },
    i = { className: "subst", begin: "[$@]\\{", end: "\\}", keywords: o },
    s = { begin: /->\{/, end: /\}/ },
    a = { scope: "attr", match: /\s+:\s*\w+(\s*\(.*?\))?/ },
    l = {
      scope: "variable",
      variants: [
        { begin: /\$\d/ },
        {
          begin: t.concat(
            /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
            "(?![A-Za-z])(?![@$%])"
          ),
        },
        { begin: /[$%@](?!")[^\s\w{=]|\$=/, relevance: 0 },
      ],
      contains: [a],
    },
    c = {
      className: "number",
      variants: [
        { match: /0?\.[0-9][0-9_]+\b/ },
        { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
        { match: /\b0[0-7][0-7_]*\b/ },
        { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
        { match: /\b0b[0-1][0-1_]*\b/ },
      ],
      relevance: 0,
    },
    u = [e.BACKSLASH_ESCAPE, i, l],
    d = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/],
    f = (v, b, y = "\\1") => {
      const x = y === "\\1" ? y : t.concat(y, b)
      return t.concat(
        t.concat("(?:", v, ")"),
        b,
        /(?:\\.|[^\\\/])*?/,
        x,
        /(?:\\.|[^\\\/])*?/,
        y,
        r
      )
    },
    p = (v, b, y) =>
      t.concat(t.concat("(?:", v, ")"), b, /(?:\\.|[^\\\/])*?/, y, r),
    g = [
      l,
      e.HASH_COMMENT_MODE,
      e.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }),
      s,
      {
        className: "string",
        contains: u,
        variants: [
          { begin: "q[qwxr]?\\s*\\(", end: "\\)", relevance: 5 },
          { begin: "q[qwxr]?\\s*\\[", end: "\\]", relevance: 5 },
          { begin: "q[qwxr]?\\s*\\{", end: "\\}", relevance: 5 },
          { begin: "q[qwxr]?\\s*\\|", end: "\\|", relevance: 5 },
          { begin: "q[qwxr]?\\s*<", end: ">", relevance: 5 },
          { begin: "qw\\s+q", end: "q", relevance: 5 },
          { begin: "'", end: "'", contains: [e.BACKSLASH_ESCAPE] },
          { begin: '"', end: '"' },
          { begin: "`", end: "`", contains: [e.BACKSLASH_ESCAPE] },
          { begin: /\{\w+\}/, relevance: 0 },
          { begin: "-?\\w+\\s*=>", relevance: 0 },
        ],
      },
      c,
      {
        begin:
          "(\\/\\/|" +
          e.RE_STARTERS_RE +
          "|\\b(split|return|print|reverse|grep)\\b)\\s*",
        keywords: "split return print reverse grep",
        relevance: 0,
        contains: [
          e.HASH_COMMENT_MODE,
          {
            className: "regexp",
            variants: [
              { begin: f("s|tr|y", t.either(...d, { capture: !0 })) },
              { begin: f("s|tr|y", "\\(", "\\)") },
              { begin: f("s|tr|y", "\\[", "\\]") },
              { begin: f("s|tr|y", "\\{", "\\}") },
            ],
            relevance: 2,
          },
          {
            className: "regexp",
            variants: [
              { begin: /(m|qr)\/\//, relevance: 0 },
              { begin: p("(?:m|qr)?", /\//, /\//) },
              { begin: p("m|qr", t.either(...d, { capture: !0 }), /\1/) },
              { begin: p("m|qr", /\(/, /\)/) },
              { begin: p("m|qr", /\[/, /\]/) },
              { begin: p("m|qr", /\{/, /\}/) },
            ],
          },
        ],
      },
      {
        className: "function",
        beginKeywords: "sub method",
        end: "(\\s*\\(.*?\\))?[;{]",
        excludeEnd: !0,
        relevance: 5,
        contains: [e.TITLE_MODE, a],
      },
      {
        className: "class",
        beginKeywords: "class",
        end: "[;{]",
        excludeEnd: !0,
        relevance: 5,
        contains: [e.TITLE_MODE, a, c],
      },
      { begin: "-\\w\\b", relevance: 0 },
      {
        begin: "^__DATA__$",
        end: "^__END__$",
        subLanguage: "mojolicious",
        contains: [{ begin: "^@@.*", end: "$", className: "comment" }],
      },
    ]
  return (
    (i.contains = g),
    (s.contains = g),
    { name: "Perl", aliases: ["pl", "pm"], keywords: o, contains: g }
  )
}
function DQ(e) {
  const t = e.regex,
    n = /(?![A-Za-z0-9])(?![$])/,
    r = t.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, n),
    o = t.concat(
      /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
      n
    ),
    i = t.concat(/[A-Z]+/, n),
    s = { scope: "variable", match: "\\$+" + r },
    a = {
      scope: "meta",
      variants: [
        { begin: /<\?php/, relevance: 10 },
        { begin: /<\?=/ },
        { begin: /<\?/, relevance: 0.1 },
        { begin: /\?>/ },
      ],
    },
    l = {
      scope: "subst",
      variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }],
    },
    c = e.inherit(e.APOS_STRING_MODE, { illegal: null }),
    u = e.inherit(e.QUOTE_STRING_MODE, {
      illegal: null,
      contains: e.QUOTE_STRING_MODE.contains.concat(l),
    }),
    d = {
      begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
      end: /[ \t]*(\w+)\b/,
      contains: e.QUOTE_STRING_MODE.contains.concat(l),
      "on:begin": (W, ee) => {
        ee.data._beginMatch = W[1] || W[2]
      },
      "on:end": (W, ee) => {
        ee.data._beginMatch !== W[1] && ee.ignoreMatch()
      },
    },
    f = e.END_SAME_AS_BEGIN({
      begin: /<<<[ \t]*'(\w+)'\n/,
      end: /[ \t]*(\w+)\b/,
    }),
    p = `[ 	
]`,
    g = { scope: "string", variants: [u, c, d, f] },
    v = {
      scope: "number",
      variants: [
        { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
        { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
        { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
        {
          begin:
            "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?",
        },
      ],
      relevance: 0,
    },
    b = ["false", "null", "true"],
    y = [
      "__CLASS__",
      "__DIR__",
      "__FILE__",
      "__FUNCTION__",
      "__COMPILER_HALT_OFFSET__",
      "__LINE__",
      "__METHOD__",
      "__NAMESPACE__",
      "__TRAIT__",
      "die",
      "echo",
      "exit",
      "include",
      "include_once",
      "print",
      "require",
      "require_once",
      "array",
      "abstract",
      "and",
      "as",
      "binary",
      "bool",
      "boolean",
      "break",
      "callable",
      "case",
      "catch",
      "class",
      "clone",
      "const",
      "continue",
      "declare",
      "default",
      "do",
      "double",
      "else",
      "elseif",
      "empty",
      "enddeclare",
      "endfor",
      "endforeach",
      "endif",
      "endswitch",
      "endwhile",
      "enum",
      "eval",
      "extends",
      "final",
      "finally",
      "float",
      "for",
      "foreach",
      "from",
      "global",
      "goto",
      "if",
      "implements",
      "instanceof",
      "insteadof",
      "int",
      "integer",
      "interface",
      "isset",
      "iterable",
      "list",
      "match|0",
      "mixed",
      "new",
      "never",
      "object",
      "or",
      "private",
      "protected",
      "public",
      "readonly",
      "real",
      "return",
      "string",
      "switch",
      "throw",
      "trait",
      "try",
      "unset",
      "use",
      "var",
      "void",
      "while",
      "xor",
      "yield",
    ],
    x = [
      "Error|0",
      "AppendIterator",
      "ArgumentCountError",
      "ArithmeticError",
      "ArrayIterator",
      "ArrayObject",
      "AssertionError",
      "BadFunctionCallException",
      "BadMethodCallException",
      "CachingIterator",
      "CallbackFilterIterator",
      "CompileError",
      "Countable",
      "DirectoryIterator",
      "DivisionByZeroError",
      "DomainException",
      "EmptyIterator",
      "ErrorException",
      "Exception",
      "FilesystemIterator",
      "FilterIterator",
      "GlobIterator",
      "InfiniteIterator",
      "InvalidArgumentException",
      "IteratorIterator",
      "LengthException",
      "LimitIterator",
      "LogicException",
      "MultipleIterator",
      "NoRewindIterator",
      "OutOfBoundsException",
      "OutOfRangeException",
      "OuterIterator",
      "OverflowException",
      "ParentIterator",
      "ParseError",
      "RangeException",
      "RecursiveArrayIterator",
      "RecursiveCachingIterator",
      "RecursiveCallbackFilterIterator",
      "RecursiveDirectoryIterator",
      "RecursiveFilterIterator",
      "RecursiveIterator",
      "RecursiveIteratorIterator",
      "RecursiveRegexIterator",
      "RecursiveTreeIterator",
      "RegexIterator",
      "RuntimeException",
      "SeekableIterator",
      "SplDoublyLinkedList",
      "SplFileInfo",
      "SplFileObject",
      "SplFixedArray",
      "SplHeap",
      "SplMaxHeap",
      "SplMinHeap",
      "SplObjectStorage",
      "SplObserver",
      "SplPriorityQueue",
      "SplQueue",
      "SplStack",
      "SplSubject",
      "SplTempFileObject",
      "TypeError",
      "UnderflowException",
      "UnexpectedValueException",
      "UnhandledMatchError",
      "ArrayAccess",
      "BackedEnum",
      "Closure",
      "Fiber",
      "Generator",
      "Iterator",
      "IteratorAggregate",
      "Serializable",
      "Stringable",
      "Throwable",
      "Traversable",
      "UnitEnum",
      "WeakReference",
      "WeakMap",
      "Directory",
      "__PHP_Incomplete_Class",
      "parent",
      "php_user_filter",
      "self",
      "static",
      "stdClass",
    ],
    w = {
      keyword: y,
      literal: ((W) => {
        const ee = []
        return (
          W.forEach((I) => {
            ee.push(I),
              I.toLowerCase() === I
                ? ee.push(I.toUpperCase())
                : ee.push(I.toLowerCase())
          }),
          ee
        )
      })(b),
      built_in: x,
    },
    C = (W) => W.map((ee) => ee.replace(/\|\d+$/, "")),
    S = {
      variants: [
        {
          match: [
            /new/,
            t.concat(p, "+"),
            t.concat("(?!", C(x).join("\\b|"), "\\b)"),
            o,
          ],
          scope: { 1: "keyword", 4: "title.class" },
        },
      ],
    },
    M = t.concat(r, "\\b(?!\\()"),
    N = {
      variants: [
        {
          match: [t.concat(/::/, t.lookahead(/(?!class\b)/)), M],
          scope: { 2: "variable.constant" },
        },
        { match: [/::/, /class/], scope: { 2: "variable.language" } },
        {
          match: [o, t.concat(/::/, t.lookahead(/(?!class\b)/)), M],
          scope: { 1: "title.class", 3: "variable.constant" },
        },
        {
          match: [o, t.concat("::", t.lookahead(/(?!class\b)/))],
          scope: { 1: "title.class" },
        },
        {
          match: [o, /::/, /class/],
          scope: { 1: "title.class", 3: "variable.language" },
        },
      ],
    },
    R = {
      scope: "attr",
      match: t.concat(r, t.lookahead(":"), t.lookahead(/(?!::)/)),
    },
    B = {
      relevance: 0,
      begin: /\(/,
      end: /\)/,
      keywords: w,
      contains: [R, s, N, e.C_BLOCK_COMMENT_MODE, g, v, S],
    },
    V = {
      relevance: 0,
      match: [
        /\b/,
        t.concat(
          "(?!fn\\b|function\\b|",
          C(y).join("\\b|"),
          "|",
          C(x).join("\\b|"),
          "\\b)"
        ),
        r,
        t.concat(p, "*"),
        t.lookahead(/(?=\()/),
      ],
      scope: { 3: "title.function.invoke" },
      contains: [B],
    }
  B.contains.push(V)
  const j = [R, N, e.C_BLOCK_COMMENT_MODE, g, v, S],
    U = {
      begin: t.concat(/#\[\s*\\?/, t.either(o, i)),
      beginScope: "meta",
      end: /]/,
      endScope: "meta",
      keywords: { literal: b, keyword: ["new", "array"] },
      contains: [
        {
          begin: /\[/,
          end: /]/,
          keywords: { literal: b, keyword: ["new", "array"] },
          contains: ["self", ...j],
        },
        ...j,
        { scope: "meta", variants: [{ match: o }, { match: i }] },
      ],
    }
  return {
    case_insensitive: !1,
    keywords: w,
    contains: [
      U,
      e.HASH_COMMENT_MODE,
      e.COMMENT("//", "$"),
      e.COMMENT("/\\*", "\\*/", {
        contains: [{ scope: "doctag", match: "@[A-Za-z]+" }],
      }),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: e.MATCH_NOTHING_RE,
          contains: [{ match: /\?>/, scope: "meta", endsParent: !0 }],
        },
      },
      a,
      { scope: "variable.language", match: /\$this\b/ },
      s,
      V,
      N,
      {
        match: [/const/, /\s/, r],
        scope: { 1: "keyword", 3: "variable.constant" },
      },
      S,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          e.UNDERSCORE_TITLE_MODE,
          { begin: "=>", endsParent: !0 },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: w,
            contains: ["self", U, s, N, e.C_BLOCK_COMMENT_MODE, g, v],
          },
        ],
      },
      {
        scope: "class",
        variants: [
          { beginKeywords: "enum", illegal: /[($"]/ },
          { beginKeywords: "class interface trait", illegal: /[:($"]/ },
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          e.UNDERSCORE_TITLE_MODE,
        ],
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [
          e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" }),
        ],
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          { match: /\b(as|const|function)\b/, scope: "keyword" },
          e.UNDERSCORE_TITLE_MODE,
        ],
      },
      g,
      v,
    ],
  }
}
function LQ(e) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          { begin: "/\\*", end: "\\*/", skip: !0 },
          { begin: 'b"', end: '"', skip: !0 },
          { begin: "b'", end: "'", skip: !0 },
          e.inherit(e.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0,
          }),
          e.inherit(e.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0,
          }),
        ],
      },
    ],
  }
}
function PQ(e) {
  return { name: "Plain text", aliases: ["text", "txt"], disableAutodetect: !0 }
}
function $Q(e) {
  const t = e.regex,
    n = /[\p{XID_Start}_]\p{XID_Continue}*/u,
    r = [
      "and",
      "as",
      "assert",
      "async",
      "await",
      "break",
      "case",
      "class",
      "continue",
      "def",
      "del",
      "elif",
      "else",
      "except",
      "finally",
      "for",
      "from",
      "global",
      "if",
      "import",
      "in",
      "is",
      "lambda",
      "match",
      "nonlocal|10",
      "not",
      "or",
      "pass",
      "raise",
      "return",
      "try",
      "while",
      "with",
      "yield",
    ],
    a = {
      $pattern: /[A-Za-z]\w+|__\w+__/,
      keyword: r,
      built_in: [
        "__import__",
        "abs",
        "all",
        "any",
        "ascii",
        "bin",
        "bool",
        "breakpoint",
        "bytearray",
        "bytes",
        "callable",
        "chr",
        "classmethod",
        "compile",
        "complex",
        "delattr",
        "dict",
        "dir",
        "divmod",
        "enumerate",
        "eval",
        "exec",
        "filter",
        "float",
        "format",
        "frozenset",
        "getattr",
        "globals",
        "hasattr",
        "hash",
        "help",
        "hex",
        "id",
        "input",
        "int",
        "isinstance",
        "issubclass",
        "iter",
        "len",
        "list",
        "locals",
        "map",
        "max",
        "memoryview",
        "min",
        "next",
        "object",
        "oct",
        "open",
        "ord",
        "pow",
        "print",
        "property",
        "range",
        "repr",
        "reversed",
        "round",
        "set",
        "setattr",
        "slice",
        "sorted",
        "staticmethod",
        "str",
        "sum",
        "super",
        "tuple",
        "type",
        "vars",
        "zip",
      ],
      literal: [
        "__debug__",
        "Ellipsis",
        "False",
        "None",
        "NotImplemented",
        "True",
      ],
      type: [
        "Any",
        "Callable",
        "Coroutine",
        "Dict",
        "List",
        "Literal",
        "Generic",
        "Optional",
        "Sequence",
        "Set",
        "Tuple",
        "Type",
        "Union",
      ],
    },
    l = { className: "meta", begin: /^(>>>|\.\.\.) / },
    c = {
      className: "subst",
      begin: /\{/,
      end: /\}/,
      keywords: a,
      illegal: /#/,
    },
    u = { begin: /\{\{/, relevance: 0 },
    d = {
      className: "string",
      contains: [e.BACKSLASH_ESCAPE],
      variants: [
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
          end: /'''/,
          contains: [e.BACKSLASH_ESCAPE, l],
          relevance: 10,
        },
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
          end: /"""/,
          contains: [e.BACKSLASH_ESCAPE, l],
          relevance: 10,
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'''/,
          end: /'''/,
          contains: [e.BACKSLASH_ESCAPE, l, u, c],
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"""/,
          end: /"""/,
          contains: [e.BACKSLASH_ESCAPE, l, u, c],
        },
        { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
        { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
        { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
        { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'/,
          end: /'/,
          contains: [e.BACKSLASH_ESCAPE, u, c],
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"/,
          end: /"/,
          contains: [e.BACKSLASH_ESCAPE, u, c],
        },
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE,
      ],
    },
    f = "[0-9](_?[0-9])*",
    p = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`,
    g = `\\b|${r.join("|")}`,
    v = {
      className: "number",
      relevance: 0,
      variants: [
        { begin: `(\\b(${f})|(${p}))[eE][+-]?(${f})[jJ]?(?=${g})` },
        { begin: `(${p})[jJ]?` },
        { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${g})` },
        { begin: `\\b0[bB](_?[01])+[lL]?(?=${g})` },
        { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${g})` },
        { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${g})` },
        { begin: `\\b(${f})[jJ](?=${g})` },
      ],
    },
    b = {
      className: "comment",
      begin: t.lookahead(/# type:/),
      end: /$/,
      keywords: a,
      contains: [
        { begin: /# type:/ },
        { begin: /#/, end: /\b\B/, endsWithParent: !0 },
      ],
    },
    y = {
      className: "params",
      variants: [
        { className: "", begin: /\(\s*\)/, skip: !0 },
        {
          begin: /\(/,
          end: /\)/,
          excludeBegin: !0,
          excludeEnd: !0,
          keywords: a,
          contains: ["self", l, v, d, e.HASH_COMMENT_MODE],
        },
      ],
    }
  return (
    (c.contains = [d, v, l]),
    {
      name: "Python",
      aliases: ["py", "gyp", "ipython"],
      unicodeRegex: !0,
      keywords: a,
      illegal: /(<\/|\?)|=>/,
      contains: [
        l,
        v,
        { scope: "variable.language", match: /\bself\b/ },
        { beginKeywords: "if", relevance: 0 },
        { match: /\bor\b/, scope: "keyword" },
        d,
        b,
        e.HASH_COMMENT_MODE,
        {
          match: [/\bdef/, /\s+/, n],
          scope: { 1: "keyword", 3: "title.function" },
          contains: [y],
        },
        {
          variants: [
            { match: [/\bclass/, /\s+/, n, /\s*/, /\(\s*/, n, /\s*\)/] },
            { match: [/\bclass/, /\s+/, n] },
          ],
          scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" },
        },
        {
          className: "meta",
          begin: /^[\t ]*@/,
          end: /(?=#)|$/,
          contains: [v, y, d],
        },
      ],
    }
  )
}
function BQ(e) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: { end: / |$/, starts: { end: "$", subLanguage: "python" } },
        variants: [{ begin: /^>>>(?=[ ]|$)/ }, { begin: /^\.\.\.(?=[ ]|$)/ }],
      },
    ],
  }
}
function jQ(e) {
  const t = e.regex,
    n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/,
    r = t.either(
      /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
      /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
      /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
    ),
    o = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/,
    i = t.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/)
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal:
        "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in:
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm",
    },
    contains: [
      e.COMMENT(/#'/, /$/, {
        contains: [
          {
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: t.lookahead(t.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
              endsParent: !0,
            },
          },
          {
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [{ match: n }, { match: /`(?:\\.|[^`\\])+`/ }],
                endsParent: !0,
              },
            ],
          },
          { scope: "doctag", match: /@[a-zA-Z]+/ },
          { scope: "keyword", match: /\\[a-zA-Z]+/ },
        ],
      }),
      e.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [e.BACKSLASH_ESCAPE],
        variants: [
          e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }),
          e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }),
          e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }),
          e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }),
          e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }),
          e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }),
          { begin: '"', end: '"', relevance: 0 },
          { begin: "'", end: "'", relevance: 0 },
        ],
      },
      {
        relevance: 0,
        variants: [
          { scope: { 1: "operator", 2: "number" }, match: [o, r] },
          { scope: { 1: "operator", 2: "number" }, match: [/%[^%]*%/, r] },
          { scope: { 1: "punctuation", 2: "number" }, match: [i, r] },
          { scope: { 2: "number" }, match: [/[^a-zA-Z0-9._]|^/, r] },
        ],
      },
      { scope: { 3: "operator" }, match: [n, /\s+/, /<-/, /\s+/] },
      {
        scope: "operator",
        relevance: 0,
        variants: [{ match: o }, { match: /%[^%]*%/ }],
      },
      { scope: "punctuation", relevance: 0, match: i },
      { begin: "`", end: "`", contains: [{ begin: /\\./ }] },
    ],
  }
}
function FQ(e) {
  const t = e.regex,
    n =
      "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)",
    r = t.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/),
    o = t.concat(r, /(::\w+)*/),
    s = {
      "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"],
      "variable.language": ["self", "super"],
      keyword: [
        "alias",
        "and",
        "begin",
        "BEGIN",
        "break",
        "case",
        "class",
        "defined",
        "do",
        "else",
        "elsif",
        "end",
        "END",
        "ensure",
        "for",
        "if",
        "in",
        "module",
        "next",
        "not",
        "or",
        "redo",
        "require",
        "rescue",
        "retry",
        "return",
        "then",
        "undef",
        "unless",
        "until",
        "when",
        "while",
        "yield",
        ...[
          "include",
          "extend",
          "prepend",
          "public",
          "private",
          "protected",
          "raise",
          "throw",
        ],
      ],
      built_in: [
        "proc",
        "lambda",
        "attr_accessor",
        "attr_reader",
        "attr_writer",
        "define_method",
        "private_constant",
        "module_function",
      ],
      literal: ["true", "false", "nil"],
    },
    a = { className: "doctag", begin: "@[A-Za-z]+" },
    l = { begin: "#<", end: ">" },
    c = [
      e.COMMENT("#", "$", { contains: [a] }),
      e.COMMENT("^=begin", "^=end", { contains: [a], relevance: 10 }),
      e.COMMENT("^__END__", e.MATCH_NOTHING_RE),
    ],
    u = { className: "subst", begin: /#\{/, end: /\}/, keywords: s },
    d = {
      className: "string",
      contains: [e.BACKSLASH_ESCAPE, u],
      variants: [
        { begin: /'/, end: /'/ },
        { begin: /"/, end: /"/ },
        { begin: /`/, end: /`/ },
        { begin: /%[qQwWx]?\(/, end: /\)/ },
        { begin: /%[qQwWx]?\[/, end: /\]/ },
        { begin: /%[qQwWx]?\{/, end: /\}/ },
        { begin: /%[qQwWx]?</, end: />/ },
        { begin: /%[qQwWx]?\//, end: /\// },
        { begin: /%[qQwWx]?%/, end: /%/ },
        { begin: /%[qQwWx]?-/, end: /-/ },
        { begin: /%[qQwWx]?\|/, end: /\|/ },
        { begin: /\B\?(\\\d{1,3})/ },
        { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
        { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
        { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
        { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
        { begin: /\B\?\\?\S/ },
        {
          begin: t.concat(
            /<<[-~]?'?/,
            t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
          ),
          contains: [
            e.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              contains: [e.BACKSLASH_ESCAPE, u],
            }),
          ],
        },
      ],
    },
    f = "[1-9](_?[0-9])*|0",
    p = "[0-9](_?[0-9])*",
    g = {
      className: "number",
      relevance: 0,
      variants: [
        { begin: `\\b(${f})(\\.(${p}))?([eE][+-]?(${p})|r)?i?\\b` },
        { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
        { begin: "\\b0(_?[0-7])+r?i?\\b" },
      ],
    },
    v = {
      variants: [
        { match: /\(\)/ },
        {
          className: "params",
          begin: /\(/,
          end: /(?=\))/,
          excludeBegin: !0,
          endsParent: !0,
          keywords: s,
        },
      ],
    },
    S = [
      d,
      {
        variants: [
          { match: [/class\s+/, o, /\s+<\s+/, o] },
          { match: [/\b(class|module)\s+/, o] },
        ],
        scope: { 2: "title.class", 4: "title.class.inherited" },
        keywords: s,
      },
      {
        match: [/(include|extend)\s+/, o],
        scope: { 2: "title.class" },
        keywords: s,
      },
      { relevance: 0, match: [o, /\.new[. (]/], scope: { 1: "title.class" } },
      {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant",
      },
      { relevance: 0, match: r, scope: "title.class" },
      {
        match: [/def/, /\s+/, n],
        scope: { 1: "keyword", 3: "title.function" },
        contains: [v],
      },
      { begin: e.IDENT_RE + "::" },
      {
        className: "symbol",
        begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
        relevance: 0,
      },
      {
        className: "symbol",
        begin: ":(?!\\s)",
        contains: [d, { begin: n }],
        relevance: 0,
      },
      g,
      {
        className: "variable",
        begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])",
      },
      {
        className: "params",
        begin: /\|(?!=)/,
        end: /\|/,
        excludeBegin: !0,
        excludeEnd: !0,
        relevance: 0,
        keywords: s,
      },
      {
        begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
        keywords: "unless",
        contains: [
          {
            className: "regexp",
            contains: [e.BACKSLASH_ESCAPE, u],
            illegal: /\n/,
            variants: [
              { begin: "/", end: "/[a-z]*" },
              { begin: /%r\{/, end: /\}[a-z]*/ },
              { begin: "%r\\(", end: "\\)[a-z]*" },
              { begin: "%r!", end: "![a-z]*" },
              { begin: "%r\\[", end: "\\][a-z]*" },
            ],
          },
        ].concat(l, c),
        relevance: 0,
      },
    ].concat(l, c)
  ;(u.contains = S), (v.contains = S)
  const M = "[>?]>",
    N = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]",
    R = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>",
    B = [
      { begin: /^\s*=>/, starts: { end: "$", contains: S } },
      {
        className: "meta.prompt",
        begin: "^(" + M + "|" + N + "|" + R + ")(?=[ ])",
        starts: { end: "$", keywords: s, contains: S },
      },
    ]
  return (
    c.unshift(l),
    {
      name: "Ruby",
      aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
      keywords: s,
      illegal: /\/\*/,
      contains: [e.SHEBANG({ binary: "ruby" })].concat(B).concat(c).concat(S),
    }
  )
}
function zQ(e) {
  const t = e.regex,
    n = /(r#)?/,
    r = t.concat(n, e.UNDERSCORE_IDENT_RE),
    o = t.concat(n, e.IDENT_RE),
    i = {
      className: "title.function.invoke",
      relevance: 0,
      begin: t.concat(
        /\b/,
        /(?!let|for|while|if|else|match\b)/,
        o,
        t.lookahead(/\s*\(/)
      ),
    },
    s = "([ui](8|16|32|64|128|size)|f(32|64))?",
    a = [
      "abstract",
      "as",
      "async",
      "await",
      "become",
      "box",
      "break",
      "const",
      "continue",
      "crate",
      "do",
      "dyn",
      "else",
      "enum",
      "extern",
      "false",
      "final",
      "fn",
      "for",
      "if",
      "impl",
      "in",
      "let",
      "loop",
      "macro",
      "match",
      "mod",
      "move",
      "mut",
      "override",
      "priv",
      "pub",
      "ref",
      "return",
      "self",
      "Self",
      "static",
      "struct",
      "super",
      "trait",
      "true",
      "try",
      "type",
      "typeof",
      "union",
      "unsafe",
      "unsized",
      "use",
      "virtual",
      "where",
      "while",
      "yield",
    ],
    l = ["true", "false", "Some", "None", "Ok", "Err"],
    c = [
      "drop ",
      "Copy",
      "Send",
      "Sized",
      "Sync",
      "Drop",
      "Fn",
      "FnMut",
      "FnOnce",
      "ToOwned",
      "Clone",
      "Debug",
      "PartialEq",
      "PartialOrd",
      "Eq",
      "Ord",
      "AsRef",
      "AsMut",
      "Into",
      "From",
      "Default",
      "Iterator",
      "Extend",
      "IntoIterator",
      "DoubleEndedIterator",
      "ExactSizeIterator",
      "SliceConcatExt",
      "ToString",
      "assert!",
      "assert_eq!",
      "bitflags!",
      "bytes!",
      "cfg!",
      "col!",
      "concat!",
      "concat_idents!",
      "debug_assert!",
      "debug_assert_eq!",
      "env!",
      "eprintln!",
      "panic!",
      "file!",
      "format!",
      "format_args!",
      "include_bytes!",
      "include_str!",
      "line!",
      "local_data_key!",
      "module_path!",
      "option_env!",
      "print!",
      "println!",
      "select!",
      "stringify!",
      "try!",
      "unimplemented!",
      "unreachable!",
      "vec!",
      "write!",
      "writeln!",
      "macro_rules!",
      "assert_ne!",
      "debug_assert_ne!",
    ],
    u = [
      "i8",
      "i16",
      "i32",
      "i64",
      "i128",
      "isize",
      "u8",
      "u16",
      "u32",
      "u64",
      "u128",
      "usize",
      "f32",
      "f64",
      "str",
      "char",
      "bool",
      "Box",
      "Option",
      "Result",
      "String",
      "Vec",
    ]
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: e.IDENT_RE + "!?",
      type: u,
      keyword: a,
      literal: l,
      built_in: c,
    },
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      e.inherit(e.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
      { className: "symbol", begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/ },
      {
        scope: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          {
            begin: /b?'/,
            end: /'/,
            contains: [
              { scope: "char.escape", match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/ },
            ],
          },
        ],
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + s },
          { begin: "\\b0o([0-7_]+)" + s },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + s },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s },
        ],
        relevance: 0,
      },
      {
        begin: [/fn/, /\s+/, r],
        className: { 1: "keyword", 3: "title.function" },
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [e.BACKSLASH_ESCAPE],
          },
        ],
      },
      {
        begin: [/let/, /\s+/, /(?:mut\s+)?/, r],
        className: { 1: "keyword", 3: "keyword", 4: "variable" },
      },
      {
        begin: [/for/, /\s+/, r, /\s+/, /in/],
        className: { 1: "keyword", 3: "variable", 5: "keyword" },
      },
      {
        begin: [/type/, /\s+/, r],
        className: { 1: "keyword", 3: "title.class" },
      },
      {
        begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, r],
        className: { 1: "keyword", 3: "title.class" },
      },
      {
        begin: e.IDENT_RE + "::",
        keywords: { keyword: "Self", built_in: c, type: u },
      },
      { className: "punctuation", begin: "->" },
      i,
    ],
  }
}
const UQ = (e) => ({
    IMPORTANT: { scope: "meta", begin: "!important" },
    BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
    },
    FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin:
        e.NUMBER_RE +
        "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0,
    },
    CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
  }),
  VQ = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "optgroup",
    "option",
    "p",
    "picture",
    "q",
    "quote",
    "samp",
    "section",
    "select",
    "source",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video",
  ],
  HQ = [
    "defs",
    "g",
    "marker",
    "mask",
    "pattern",
    "svg",
    "switch",
    "symbol",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feFlood",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence",
    "linearGradient",
    "radialGradient",
    "stop",
    "circle",
    "ellipse",
    "image",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect",
    "text",
    "use",
    "textPath",
    "tspan",
    "foreignObject",
    "clipPath",
  ],
  WQ = [...VQ, ...HQ],
  KQ = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    "min-width",
    "max-width",
    "min-height",
    "max-height",
  ]
    .sort()
    .reverse(),
  GQ = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    "host",
    "host-context",
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    "nth-child",
    "nth-col",
    "nth-last-child",
    "nth-last-col",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where",
  ]
    .sort()
    .reverse(),
  qQ = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error",
  ]
    .sort()
    .reverse(),
  ZQ = [
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-align",
    "box-decoration-break",
    "box-direction",
    "box-flex",
    "box-flex-group",
    "box-lines",
    "box-ordinal-group",
    "box-orient",
    "box-pack",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "cx",
    "cy",
    "direction",
    "display",
    "dominant-baseline",
    "empty-cells",
    "enable-background",
    "field-sizing",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flood-color",
    "flood-opacity",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-smooth",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "initial-letter",
    "initial-letter-align",
    "inline-size",
    "inset",
    "inset-area",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "kerning",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-height",
    "line-height-step",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "masonry-auto-flow",
    "math-depth",
    "math-shift",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overlay",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "place-items",
    "place-self",
    "pointer-events",
    "position",
    "position-anchor",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "r",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "rotate",
    "row-gap",
    "ruby-align",
    "ruby-position",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "speak",
    "speak-as",
    "src",
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "touch-action",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-modify",
    "user-select",
    "vector-effect",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "white-space-collapse",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "x",
    "y",
    "z-index",
    "zoom",
  ]
    .sort()
    .reverse()
function YQ(e) {
  const t = UQ(e),
    n = qQ,
    r = GQ,
    o = "@[a-z-]+",
    i = "and or not only",
    a = {
      className: "variable",
      begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
      relevance: 0,
    }
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      t.CSS_NUMBER_MODE,
      { className: "selector-id", begin: "#[A-Za-z0-9_-]+", relevance: 0 },
      { className: "selector-class", begin: "\\.[A-Za-z0-9_-]+", relevance: 0 },
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + WQ.join("|") + ")\\b",
        relevance: 0,
      },
      { className: "selector-pseudo", begin: ":(" + r.join("|") + ")" },
      { className: "selector-pseudo", begin: ":(:)?(" + n.join("|") + ")" },
      a,
      { begin: /\(/, end: /\)/, contains: [t.CSS_NUMBER_MODE] },
      t.CSS_VARIABLE,
      { className: "attribute", begin: "\\b(" + ZQ.join("|") + ")\\b" },
      {
        begin:
          "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b",
      },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          t.BLOCK_COMMENT,
          a,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.IMPORTANT,
          t.FUNCTION_DISPATCH,
        ],
      },
      {
        begin: "@(page|font-face)",
        keywords: { $pattern: o, keyword: "@page @font-face" },
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: { $pattern: /[a-z-]+/, keyword: i, attribute: KQ.join(" ") },
        contains: [
          { begin: o, className: "keyword" },
          { begin: /[a-z-]+(?=:)/, className: "attribute" },
          a,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE,
        ],
      },
      t.FUNCTION_DISPATCH,
    ],
  }
}
function XQ(e) {
  return {
    name: "Shell Session",
    aliases: ["console", "shellsession"],
    contains: [
      {
        className: "meta.prompt",
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: { end: /[^\\](?=\s*$)/, subLanguage: "bash" },
      },
    ],
  }
}
function QQ(e) {
  const t = e.regex,
    n = e.COMMENT("--", "$"),
    r = {
      scope: "string",
      variants: [{ begin: /'/, end: /'/, contains: [{ match: /''/ }] }],
    },
    o = { begin: /"/, end: /"/, contains: [{ match: /""/ }] },
    i = ["true", "false", "unknown"],
    s = [
      "double precision",
      "large object",
      "with timezone",
      "without timezone",
    ],
    a = [
      "bigint",
      "binary",
      "blob",
      "boolean",
      "char",
      "character",
      "clob",
      "date",
      "dec",
      "decfloat",
      "decimal",
      "float",
      "int",
      "integer",
      "interval",
      "nchar",
      "nclob",
      "national",
      "numeric",
      "real",
      "row",
      "smallint",
      "time",
      "timestamp",
      "varchar",
      "varying",
      "varbinary",
    ],
    l = ["add", "asc", "collation", "desc", "final", "first", "last", "view"],
    c = [
      "abs",
      "acos",
      "all",
      "allocate",
      "alter",
      "and",
      "any",
      "are",
      "array",
      "array_agg",
      "array_max_cardinality",
      "as",
      "asensitive",
      "asin",
      "asymmetric",
      "at",
      "atan",
      "atomic",
      "authorization",
      "avg",
      "begin",
      "begin_frame",
      "begin_partition",
      "between",
      "bigint",
      "binary",
      "blob",
      "boolean",
      "both",
      "by",
      "call",
      "called",
      "cardinality",
      "cascaded",
      "case",
      "cast",
      "ceil",
      "ceiling",
      "char",
      "char_length",
      "character",
      "character_length",
      "check",
      "classifier",
      "clob",
      "close",
      "coalesce",
      "collate",
      "collect",
      "column",
      "commit",
      "condition",
      "connect",
      "constraint",
      "contains",
      "convert",
      "copy",
      "corr",
      "corresponding",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "create",
      "cross",
      "cube",
      "cume_dist",
      "current",
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_row",
      "current_schema",
      "current_time",
      "current_timestamp",
      "current_path",
      "current_role",
      "current_transform_group_for_type",
      "current_user",
      "cursor",
      "cycle",
      "date",
      "day",
      "deallocate",
      "dec",
      "decimal",
      "decfloat",
      "declare",
      "default",
      "define",
      "delete",
      "dense_rank",
      "deref",
      "describe",
      "deterministic",
      "disconnect",
      "distinct",
      "double",
      "drop",
      "dynamic",
      "each",
      "element",
      "else",
      "empty",
      "end",
      "end_frame",
      "end_partition",
      "end-exec",
      "equals",
      "escape",
      "every",
      "except",
      "exec",
      "execute",
      "exists",
      "exp",
      "external",
      "extract",
      "false",
      "fetch",
      "filter",
      "first_value",
      "float",
      "floor",
      "for",
      "foreign",
      "frame_row",
      "free",
      "from",
      "full",
      "function",
      "fusion",
      "get",
      "global",
      "grant",
      "group",
      "grouping",
      "groups",
      "having",
      "hold",
      "hour",
      "identity",
      "in",
      "indicator",
      "initial",
      "inner",
      "inout",
      "insensitive",
      "insert",
      "int",
      "integer",
      "intersect",
      "intersection",
      "interval",
      "into",
      "is",
      "join",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "language",
      "large",
      "last_value",
      "lateral",
      "lead",
      "leading",
      "left",
      "like",
      "like_regex",
      "listagg",
      "ln",
      "local",
      "localtime",
      "localtimestamp",
      "log",
      "log10",
      "lower",
      "match",
      "match_number",
      "match_recognize",
      "matches",
      "max",
      "member",
      "merge",
      "method",
      "min",
      "minute",
      "mod",
      "modifies",
      "module",
      "month",
      "multiset",
      "national",
      "natural",
      "nchar",
      "nclob",
      "new",
      "no",
      "none",
      "normalize",
      "not",
      "nth_value",
      "ntile",
      "null",
      "nullif",
      "numeric",
      "octet_length",
      "occurrences_regex",
      "of",
      "offset",
      "old",
      "omit",
      "on",
      "one",
      "only",
      "open",
      "or",
      "order",
      "out",
      "outer",
      "over",
      "overlaps",
      "overlay",
      "parameter",
      "partition",
      "pattern",
      "per",
      "percent",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "period",
      "portion",
      "position",
      "position_regex",
      "power",
      "precedes",
      "precision",
      "prepare",
      "primary",
      "procedure",
      "ptf",
      "range",
      "rank",
      "reads",
      "real",
      "recursive",
      "ref",
      "references",
      "referencing",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "release",
      "result",
      "return",
      "returns",
      "revoke",
      "right",
      "rollback",
      "rollup",
      "row",
      "row_number",
      "rows",
      "running",
      "savepoint",
      "scope",
      "scroll",
      "search",
      "second",
      "seek",
      "select",
      "sensitive",
      "session_user",
      "set",
      "show",
      "similar",
      "sin",
      "sinh",
      "skip",
      "smallint",
      "some",
      "specific",
      "specifictype",
      "sql",
      "sqlexception",
      "sqlstate",
      "sqlwarning",
      "sqrt",
      "start",
      "static",
      "stddev_pop",
      "stddev_samp",
      "submultiset",
      "subset",
      "substring",
      "substring_regex",
      "succeeds",
      "sum",
      "symmetric",
      "system",
      "system_time",
      "system_user",
      "table",
      "tablesample",
      "tan",
      "tanh",
      "then",
      "time",
      "timestamp",
      "timezone_hour",
      "timezone_minute",
      "to",
      "trailing",
      "translate",
      "translate_regex",
      "translation",
      "treat",
      "trigger",
      "trim",
      "trim_array",
      "true",
      "truncate",
      "uescape",
      "union",
      "unique",
      "unknown",
      "unnest",
      "update",
      "upper",
      "user",
      "using",
      "value",
      "values",
      "value_of",
      "var_pop",
      "var_samp",
      "varbinary",
      "varchar",
      "varying",
      "versioning",
      "when",
      "whenever",
      "where",
      "width_bucket",
      "window",
      "with",
      "within",
      "without",
      "year",
    ],
    u = [
      "abs",
      "acos",
      "array_agg",
      "asin",
      "atan",
      "avg",
      "cast",
      "ceil",
      "ceiling",
      "coalesce",
      "corr",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "cume_dist",
      "dense_rank",
      "deref",
      "element",
      "exp",
      "extract",
      "first_value",
      "floor",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "last_value",
      "lead",
      "listagg",
      "ln",
      "log",
      "log10",
      "lower",
      "max",
      "min",
      "mod",
      "nth_value",
      "ntile",
      "nullif",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "position",
      "position_regex",
      "power",
      "rank",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "row_number",
      "sin",
      "sinh",
      "sqrt",
      "stddev_pop",
      "stddev_samp",
      "substring",
      "substring_regex",
      "sum",
      "tan",
      "tanh",
      "translate",
      "translate_regex",
      "treat",
      "trim",
      "trim_array",
      "unnest",
      "upper",
      "value_of",
      "var_pop",
      "var_samp",
      "width_bucket",
    ],
    d = [
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_schema",
      "current_transform_group_for_type",
      "current_user",
      "session_user",
      "system_time",
      "system_user",
      "current_time",
      "localtime",
      "current_timestamp",
      "localtimestamp",
    ],
    f = [
      "create table",
      "insert into",
      "primary key",
      "foreign key",
      "not null",
      "alter table",
      "add constraint",
      "grouping sets",
      "on overflow",
      "character set",
      "respect nulls",
      "ignore nulls",
      "nulls first",
      "nulls last",
      "depth first",
      "breadth first",
    ],
    p = u,
    g = [...c, ...l].filter((C) => !u.includes(C)),
    v = { scope: "variable", match: /@[a-z0-9][a-z0-9_]*/ },
    b = {
      scope: "operator",
      match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
      relevance: 0,
    },
    y = {
      match: t.concat(/\b/, t.either(...p), /\s*\(/),
      relevance: 0,
      keywords: { built_in: p },
    }
  function x(C) {
    return t.concat(
      /\b/,
      t.either(...C.map((S) => S.replace(/\s+/, "\\s+"))),
      /\b/
    )
  }
  const E = { scope: "keyword", match: x(f), relevance: 0 }
  function w(C, { exceptions: S, when: M } = {}) {
    const N = M
    return (
      (S = S || []),
      C.map((R) =>
        R.match(/\|\d+$/) || S.includes(R) ? R : N(R) ? `${R}|0` : R
      )
    )
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: w(g, { when: (C) => C.length < 3 }),
      literal: i,
      type: a,
      built_in: d,
    },
    contains: [
      { scope: "type", match: x(s) },
      E,
      y,
      v,
      r,
      o,
      e.C_NUMBER_MODE,
      e.C_BLOCK_COMMENT_MODE,
      n,
      b,
    ],
  }
}
function XI(e) {
  return e ? (typeof e == "string" ? e : e.source) : null
}
function $l(e) {
  return We("(?=", e, ")")
}
function We(...e) {
  return e.map((n) => XI(n)).join("")
}
function JQ(e) {
  const t = e[e.length - 1]
  return typeof t == "object" && t.constructor === Object
    ? (e.splice(e.length - 1, 1), t)
    : {}
}
function un(...e) {
  return "(" + (JQ(e).capture ? "" : "?:") + e.map((r) => XI(r)).join("|") + ")"
}
const H1 = (e) => We(/\b/, e, /\w$/.test(e) ? /\b/ : /\B/),
  eJ = ["Protocol", "Type"].map(H1),
  CS = ["init", "self"].map(H1),
  tJ = ["Any", "Self"],
  Wg = [
    "actor",
    "any",
    "associatedtype",
    "async",
    "await",
    /as\?/,
    /as!/,
    "as",
    "borrowing",
    "break",
    "case",
    "catch",
    "class",
    "consume",
    "consuming",
    "continue",
    "convenience",
    "copy",
    "default",
    "defer",
    "deinit",
    "didSet",
    "distributed",
    "do",
    "dynamic",
    "each",
    "else",
    "enum",
    "extension",
    "fallthrough",
    /fileprivate\(set\)/,
    "fileprivate",
    "final",
    "for",
    "func",
    "get",
    "guard",
    "if",
    "import",
    "indirect",
    "infix",
    /init\?/,
    /init!/,
    "inout",
    /internal\(set\)/,
    "internal",
    "in",
    "is",
    "isolated",
    "nonisolated",
    "lazy",
    "let",
    "macro",
    "mutating",
    "nonmutating",
    /open\(set\)/,
    "open",
    "operator",
    "optional",
    "override",
    "package",
    "postfix",
    "precedencegroup",
    "prefix",
    /private\(set\)/,
    "private",
    "protocol",
    /public\(set\)/,
    "public",
    "repeat",
    "required",
    "rethrows",
    "return",
    "set",
    "some",
    "static",
    "struct",
    "subscript",
    "super",
    "switch",
    "throws",
    "throw",
    /try\?/,
    /try!/,
    "try",
    "typealias",
    /unowned\(safe\)/,
    /unowned\(unsafe\)/,
    "unowned",
    "var",
    "weak",
    "where",
    "while",
    "willSet",
  ],
  SS = ["false", "nil", "true"],
  nJ = [
    "assignment",
    "associativity",
    "higherThan",
    "left",
    "lowerThan",
    "none",
    "right",
  ],
  rJ = [
    "#colorLiteral",
    "#column",
    "#dsohandle",
    "#else",
    "#elseif",
    "#endif",
    "#error",
    "#file",
    "#fileID",
    "#fileLiteral",
    "#filePath",
    "#function",
    "#if",
    "#imageLiteral",
    "#keyPath",
    "#line",
    "#selector",
    "#sourceLocation",
    "#warning",
  ],
  _S = [
    "abs",
    "all",
    "any",
    "assert",
    "assertionFailure",
    "debugPrint",
    "dump",
    "fatalError",
    "getVaList",
    "isKnownUniquelyReferenced",
    "max",
    "min",
    "numericCast",
    "pointwiseMax",
    "pointwiseMin",
    "precondition",
    "preconditionFailure",
    "print",
    "readLine",
    "repeatElement",
    "sequence",
    "stride",
    "swap",
    "swift_unboxFromSwiftValueWithType",
    "transcode",
    "type",
    "unsafeBitCast",
    "unsafeDowncast",
    "withExtendedLifetime",
    "withUnsafeMutablePointer",
    "withUnsafePointer",
    "withVaList",
    "withoutActuallyEscaping",
    "zip",
  ],
  QI = un(
    /[/=\-+!*%<>&|^~?]/,
    /[\u00A1-\u00A7]/,
    /[\u00A9\u00AB]/,
    /[\u00AC\u00AE]/,
    /[\u00B0\u00B1]/,
    /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
    /[\u2016-\u2017]/,
    /[\u2020-\u2027]/,
    /[\u2030-\u203E]/,
    /[\u2041-\u2053]/,
    /[\u2055-\u205E]/,
    /[\u2190-\u23FF]/,
    /[\u2500-\u2775]/,
    /[\u2794-\u2BFF]/,
    /[\u2E00-\u2E7F]/,
    /[\u3001-\u3003]/,
    /[\u3008-\u3020]/,
    /[\u3030]/
  ),
  JI = un(
    QI,
    /[\u0300-\u036F]/,
    /[\u1DC0-\u1DFF]/,
    /[\u20D0-\u20FF]/,
    /[\uFE00-\uFE0F]/,
    /[\uFE20-\uFE2F]/
  ),
  Kg = We(QI, JI, "*"),
  eD = un(
    /[a-zA-Z_]/,
    /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
    /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
    /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
    /[\u1E00-\u1FFF]/,
    /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
    /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
    /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
    /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
    /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
    /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  ),
  Ep = un(eD, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/),
  Pr = We(eD, Ep, "*"),
  Bd = We(/[A-Z]/, Ep, "*"),
  oJ = [
    "attached",
    "autoclosure",
    We(/convention\(/, un("swift", "block", "c"), /\)/),
    "discardableResult",
    "dynamicCallable",
    "dynamicMemberLookup",
    "escaping",
    "freestanding",
    "frozen",
    "GKInspectable",
    "IBAction",
    "IBDesignable",
    "IBInspectable",
    "IBOutlet",
    "IBSegueAction",
    "inlinable",
    "main",
    "nonobjc",
    "NSApplicationMain",
    "NSCopying",
    "NSManaged",
    We(/objc\(/, Pr, /\)/),
    "objc",
    "objcMembers",
    "propertyWrapper",
    "requires_stored_property_inits",
    "resultBuilder",
    "Sendable",
    "testable",
    "UIApplicationMain",
    "unchecked",
    "unknown",
    "usableFromInline",
    "warn_unqualified_access",
  ],
  iJ = [
    "iOS",
    "iOSApplicationExtension",
    "macOS",
    "macOSApplicationExtension",
    "macCatalyst",
    "macCatalystApplicationExtension",
    "watchOS",
    "watchOSApplicationExtension",
    "tvOS",
    "tvOSApplicationExtension",
    "swift",
  ]
function sJ(e) {
  const t = { match: /\s+/, relevance: 0 },
    n = e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
    r = [e.C_LINE_COMMENT_MODE, n],
    o = { match: [/\./, un(...eJ, ...CS)], className: { 2: "keyword" } },
    i = { match: We(/\./, un(...Wg)), relevance: 0 },
    s = Wg.filter((be) => typeof be == "string").concat(["_|0"]),
    a = Wg.filter((be) => typeof be != "string")
      .concat(tJ)
      .map(H1),
    l = { variants: [{ className: "keyword", match: un(...a, ...CS) }] },
    c = { $pattern: un(/\b\w+/, /#\w+/), keyword: s.concat(rJ), literal: SS },
    u = [o, i, l],
    d = { match: We(/\./, un(..._S)), relevance: 0 },
    f = { className: "built_in", match: We(/\b/, un(..._S), /(?=\()/) },
    p = [d, f],
    g = { match: /->/, relevance: 0 },
    v = {
      className: "operator",
      relevance: 0,
      variants: [{ match: Kg }, { match: `\\.(\\.|${JI})+` }],
    },
    b = [g, v],
    y = "([0-9]_*)+",
    x = "([0-9a-fA-F]_*)+",
    E = {
      className: "number",
      relevance: 0,
      variants: [
        { match: `\\b(${y})(\\.(${y}))?([eE][+-]?(${y}))?\\b` },
        { match: `\\b0x(${x})(\\.(${x}))?([pP][+-]?(${y}))?\\b` },
        { match: /\b0o([0-7]_*)+\b/ },
        { match: /\b0b([01]_*)+\b/ },
      ],
    },
    w = (be = "") => ({
      className: "subst",
      variants: [
        { match: We(/\\/, be, /[0\\tnr"']/) },
        { match: We(/\\/, be, /u\{[0-9a-fA-F]{1,8}\}/) },
      ],
    }),
    C = (be = "") => ({
      className: "subst",
      match: We(/\\/, be, /[\t ]*(?:[\r\n]|\r\n)/),
    }),
    S = (be = "") => ({
      className: "subst",
      label: "interpol",
      begin: We(/\\/, be, /\(/),
      end: /\)/,
    }),
    M = (be = "") => ({
      begin: We(be, /"""/),
      end: We(/"""/, be),
      contains: [w(be), C(be), S(be)],
    }),
    N = (be = "") => ({
      begin: We(be, /"/),
      end: We(/"/, be),
      contains: [w(be), S(be)],
    }),
    R = {
      className: "string",
      variants: [
        M(),
        M("#"),
        M("##"),
        M("###"),
        N(),
        N("#"),
        N("##"),
        N("###"),
      ],
    },
    B = [
      e.BACKSLASH_ESCAPE,
      { begin: /\[/, end: /\]/, relevance: 0, contains: [e.BACKSLASH_ESCAPE] },
    ],
    V = { begin: /\/[^\s](?=[^/\n]*\/)/, end: /\//, contains: B },
    j = (be) => {
      const yt = We(be, /\//),
        ue = We(/\//, be)
      return {
        begin: yt,
        end: ue,
        contains: [...B, { scope: "comment", begin: `#(?!.*${ue})`, end: /$/ }],
      }
    },
    U = { scope: "regexp", variants: [j("###"), j("##"), j("#"), V] },
    W = { match: We(/`/, Pr, /`/) },
    ee = { className: "variable", match: /\$\d+/ },
    I = { className: "variable", match: `\\$${Ep}+` },
    O = [W, ee, I],
    _ = {
      match: /(@|#(un)?)available/,
      scope: "keyword",
      starts: {
        contains: [
          { begin: /\(/, end: /\)/, keywords: iJ, contains: [...b, E, R] },
        ],
      },
    },
    A = { scope: "keyword", match: We(/@/, un(...oJ), $l(un(/\(/, /\s+/))) },
    P = { scope: "meta", match: We(/@/, Pr) },
    H = [_, A, P],
    X = {
      match: $l(/\b[A-Z]/),
      relevance: 0,
      contains: [
        {
          className: "type",
          match: We(
            /(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/,
            Ep,
            "+"
          ),
        },
        { className: "type", match: Bd, relevance: 0 },
        { match: /[?!]+/, relevance: 0 },
        { match: /\.\.\./, relevance: 0 },
        { match: We(/\s+&\s+/, $l(Bd)), relevance: 0 },
      ],
    },
    ae = {
      begin: /</,
      end: />/,
      keywords: c,
      contains: [...r, ...u, ...H, g, X],
    }
  X.contains.push(ae)
  const ve = { match: We(Pr, /\s*:/), keywords: "_|0", relevance: 0 },
    he = {
      begin: /\(/,
      end: /\)/,
      relevance: 0,
      keywords: c,
      contains: ["self", ve, ...r, U, ...u, ...p, ...b, E, R, ...O, ...H, X],
    },
    xe = { begin: /</, end: />/, keywords: "repeat each", contains: [...r, X] },
    Ae = {
      begin: un($l(We(Pr, /\s*:/)), $l(We(Pr, /\s+/, Pr, /\s*:/))),
      end: /:/,
      relevance: 0,
      contains: [
        { className: "keyword", match: /\b_\b/ },
        { className: "params", match: Pr },
      ],
    },
    je = {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: [Ae, ...r, ...u, ...b, E, R, ...H, X, he],
      endsParent: !0,
      illegal: /["']/,
    },
    Fe = {
      match: [/(func|macro)/, /\s+/, un(W.match, Pr, Kg)],
      className: { 1: "keyword", 3: "title.function" },
      contains: [xe, je, t],
      illegal: [/\[/, /%/],
    },
    Ze = {
      match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
      className: { 1: "keyword" },
      contains: [xe, je, t],
      illegal: /\[|%/,
    },
    dt = {
      match: [/operator/, /\s+/, Kg],
      className: { 1: "keyword", 3: "title" },
    },
    kt = {
      begin: [/precedencegroup/, /\s+/, Bd],
      className: { 1: "keyword", 3: "title" },
      contains: [X],
      keywords: [...nJ, ...SS],
      end: /}/,
    },
    ft = {
      match: [/class\b/, /\s+/, /func\b/, /\s+/, /\b[A-Za-z_][A-Za-z0-9_]*\b/],
      scope: { 1: "keyword", 3: "keyword", 5: "title.function" },
    },
    Et = {
      match: [/class\b/, /\s+/, /var\b/],
      scope: { 1: "keyword", 3: "keyword" },
    },
    He = {
      begin: [/(struct|protocol|class|extension|enum|actor)/, /\s+/, Pr, /\s*/],
      beginScope: { 1: "keyword", 3: "title.class" },
      keywords: c,
      contains: [
        xe,
        ...u,
        {
          begin: /:/,
          end: /\{/,
          keywords: c,
          contains: [{ scope: "title.class.inherited", match: Bd }, ...u],
          relevance: 0,
        },
      ],
    }
  for (const be of R.variants) {
    const yt = be.contains.find((me) => me.label === "interpol")
    yt.keywords = c
    const ue = [...u, ...p, ...b, E, R, ...O]
    yt.contains = [...ue, { begin: /\(/, end: /\)/, contains: ["self", ...ue] }]
  }
  return {
    name: "Swift",
    keywords: c,
    contains: [
      ...r,
      Fe,
      Ze,
      ft,
      Et,
      He,
      dt,
      kt,
      { beginKeywords: "import", end: /$/, contains: [...r], relevance: 0 },
      U,
      ...u,
      ...p,
      ...b,
      E,
      R,
      ...O,
      ...H,
      X,
      he,
    ],
  }
}
const Cp = "[A-Za-z$_][0-9A-Za-z$_]*",
  tD = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends",
    "using",
  ],
  nD = ["true", "false", "null", "undefined", "NaN", "Infinity"],
  rD = [
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    "Math",
    "Date",
    "Number",
    "BigInt",
    "String",
    "RegExp",
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    "Reflect",
    "Proxy",
    "Intl",
    "WebAssembly",
  ],
  oD = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError",
  ],
  iD = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape",
  ],
  sD = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "sessionStorage",
    "module",
    "global",
  ],
  aD = [].concat(iD, rD, oD)
function aJ(e) {
  const t = e.regex,
    n = (_, { after: A }) => {
      const P = "</" + _[0].slice(1)
      return _.input.indexOf(P, A) !== -1
    },
    r = Cp,
    o = { begin: "<>", end: "</>" },
    i = /<[A-Za-z0-9\\._:-]+\s*\/>/,
    s = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (_, A) => {
        const P = _[0].length + _.index,
          H = _.input[P]
        if (H === "<" || H === ",") {
          A.ignoreMatch()
          return
        }
        H === ">" && (n(_, { after: P }) || A.ignoreMatch())
        let X
        const ae = _.input.substring(P)
        if ((X = ae.match(/^\s*=/))) {
          A.ignoreMatch()
          return
        }
        if ((X = ae.match(/^\s+extends\s+/)) && X.index === 0) {
          A.ignoreMatch()
          return
        }
      },
    },
    a = {
      $pattern: Cp,
      keyword: tD,
      literal: nD,
      built_in: aD,
      "variable.language": sD,
    },
    l = "[0-9](_?[0-9])*",
    c = `\\.(${l})`,
    u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
    d = {
      className: "number",
      variants: [
        { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
        { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
        { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        { begin: "\\b0[0-7]+n?\\b" },
      ],
      relevance: 0,
    },
    f = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: a,
      contains: [],
    },
    p = {
      begin: ".?html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [e.BACKSLASH_ESCAPE, f],
        subLanguage: "xml",
      },
    },
    g = {
      begin: ".?css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [e.BACKSLASH_ESCAPE, f],
        subLanguage: "css",
      },
    },
    v = {
      begin: ".?gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [e.BACKSLASH_ESCAPE, f],
        subLanguage: "graphql",
      },
    },
    b = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [e.BACKSLASH_ESCAPE, f],
    },
    x = {
      className: "comment",
      variants: [
        e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                { className: "doctag", begin: "@[A-Za-z]+" },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0,
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0,
                },
                { begin: /(?=[^\n])\s/, relevance: 0 },
              ],
            },
          ],
        }),
        e.C_BLOCK_COMMENT_MODE,
        e.C_LINE_COMMENT_MODE,
      ],
    },
    E = [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      g,
      v,
      b,
      { match: /\$\d+/ },
      d,
    ]
  f.contains = E.concat({
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: ["self"].concat(E),
  })
  const w = [].concat(x, f.contains),
    C = w.concat([
      {
        begin: /(\s*)\(/,
        end: /\)/,
        keywords: a,
        contains: ["self"].concat(w),
      },
    ]),
    S = {
      className: "params",
      begin: /(\s*)\(/,
      end: /\)/,
      excludeBegin: !0,
      excludeEnd: !0,
      keywords: a,
      contains: C,
    },
    M = {
      variants: [
        {
          match: [
            /class/,
            /\s+/,
            r,
            /\s+/,
            /extends/,
            /\s+/,
            t.concat(r, "(", t.concat(/\./, r), ")*"),
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited",
          },
        },
        {
          match: [/class/, /\s+/, r],
          scope: { 1: "keyword", 3: "title.class" },
        },
      ],
    },
    N = {
      relevance: 0,
      match: t.either(
        /\bJSON/,
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      ),
      className: "title.class",
      keywords: { _: [...rD, ...oD] },
    },
    R = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/,
    },
    B = {
      variants: [
        { match: [/function/, /\s+/, r, /(?=\s*\()/] },
        { match: [/function/, /\s*(?=\()/] },
      ],
      className: { 1: "keyword", 3: "title.function" },
      label: "func.def",
      contains: [S],
      illegal: /%/,
    },
    V = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant",
    }
  function j(_) {
    return t.concat("(?!", _.join("|"), ")")
  }
  const U = {
      match: t.concat(
        /\b/,
        j([...iD, "super", "import"].map((_) => `${_}\\s*\\(`)),
        r,
        t.lookahead(/\s*\(/)
      ),
      className: "title.function",
      relevance: 0,
    },
    W = {
      begin: t.concat(/\./, t.lookahead(t.concat(r, /(?![0-9A-Za-z$_(])/))),
      end: r,
      excludeBegin: !0,
      keywords: "prototype",
      className: "property",
      relevance: 0,
    },
    ee = {
      match: [/get|set/, /\s+/, r, /(?=\()/],
      className: { 1: "keyword", 3: "title.function" },
      contains: [{ begin: /\(\)/ }, S],
    },
    I =
      "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" +
      e.UNDERSCORE_IDENT_RE +
      ")\\s*=>",
    O = {
      match: [
        /const|var|let/,
        /\s+/,
        r,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        t.lookahead(I),
      ],
      keywords: "async",
      className: { 1: "keyword", 3: "title.function" },
      contains: [S],
    }
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    exports: { PARAMS_CONTAINS: C, CLASS_REFERENCE: N },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
      R,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      g,
      v,
      b,
      x,
      { match: /\$\d+/ },
      d,
      N,
      { scope: "attr", match: r + t.lookahead(":"), relevance: 0 },
      O,
      {
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          x,
          e.REGEXP_MODE,
          {
            className: "function",
            begin: I,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                  { className: null, begin: /\(\s*\)/, skip: !0 },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: C,
                  },
                ],
              },
            ],
          },
          { begin: /,/, relevance: 0 },
          { match: /\s+/, relevance: 0 },
          {
            variants: [
              { begin: o.begin, end: o.end },
              { match: i },
              { begin: s.begin, "on:begin": s.isTrulyOpeningTag, end: s.end },
            ],
            subLanguage: "xml",
            contains: [
              { begin: s.begin, end: s.end, skip: !0, contains: ["self"] },
            ],
          },
        ],
      },
      B,
      { beginKeywords: "while if switch catch for" },
      {
        begin:
          "\\b(?!function)" +
          e.UNDERSCORE_IDENT_RE +
          "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: !0,
        label: "func.def",
        contains: [
          S,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" }),
        ],
      },
      { match: /\.\.\./, relevance: 0 },
      W,
      { match: "\\$" + r, relevance: 0 },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [S],
      },
      U,
      V,
      M,
      ee,
      { match: /\$[(.]/ },
    ],
  }
}
function lJ(e) {
  const t = e.regex,
    n = aJ(e),
    r = Cp,
    o = [
      "any",
      "void",
      "number",
      "boolean",
      "string",
      "object",
      "never",
      "symbol",
      "bigint",
      "unknown",
    ],
    i = {
      begin: [/namespace/, /\s+/, e.IDENT_RE],
      beginScope: { 1: "keyword", 3: "title.class" },
    },
    s = {
      beginKeywords: "interface",
      end: /\{/,
      excludeEnd: !0,
      keywords: { keyword: "interface extends", built_in: o },
      contains: [n.exports.CLASS_REFERENCE],
    },
    a = { className: "meta", relevance: 10, begin: /^\s*['"]use strict['"]/ },
    l = [
      "type",
      "interface",
      "public",
      "private",
      "protected",
      "implements",
      "declare",
      "abstract",
      "readonly",
      "enum",
      "override",
      "satisfies",
    ],
    c = {
      $pattern: Cp,
      keyword: tD.concat(l),
      literal: nD,
      built_in: aD.concat(o),
      "variable.language": sD,
    },
    u = { className: "meta", begin: "@" + r },
    d = (v, b, y) => {
      const x = v.contains.findIndex((E) => E.label === b)
      if (x === -1) throw new Error("can not find mode to replace")
      v.contains.splice(x, 1, y)
    }
  Object.assign(n.keywords, c), n.exports.PARAMS_CONTAINS.push(u)
  const f = n.contains.find((v) => v.scope === "attr"),
    p = Object.assign({}, f, { match: t.concat(r, t.lookahead(/\s*\?:/)) })
  n.exports.PARAMS_CONTAINS.push([n.exports.CLASS_REFERENCE, f, p]),
    (n.contains = n.contains.concat([u, i, s, p])),
    d(n, "shebang", e.SHEBANG()),
    d(n, "use_strict", a)
  const g = n.contains.find((v) => v.label === "func.def")
  return (
    (g.relevance = 0),
    Object.assign(n, {
      name: "TypeScript",
      aliases: ["ts", "tsx", "mts", "cts"],
    }),
    n
  )
}
function cJ(e) {
  const t = e.regex,
    n = { className: "string", begin: /"(""|[^/n])"C\b/ },
    r = {
      className: "string",
      begin: /"/,
      end: /"/,
      illegal: /\n/,
      contains: [{ begin: /""/ }],
    },
    o = /\d{1,2}\/\d{1,2}\/\d{4}/,
    i = /\d{4}-\d{1,2}-\d{1,2}/,
    s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/,
    a = /\d{1,2}(:\d{1,2}){1,2}/,
    l = {
      className: "literal",
      variants: [
        { begin: t.concat(/# */, t.either(i, o), / *#/) },
        { begin: t.concat(/# */, a, / *#/) },
        { begin: t.concat(/# */, s, / *#/) },
        { begin: t.concat(/# */, t.either(i, o), / +/, t.either(s, a), / *#/) },
      ],
    },
    c = {
      className: "number",
      relevance: 0,
      variants: [
        {
          begin:
            /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/,
        },
        { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ },
        { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ },
        { begin: /&O[0-7_]+((U?[SIL])|[%&])?/ },
        { begin: /&B[01_]+((U?[SIL])|[%&])?/ },
      ],
    },
    u = { className: "label", begin: /^\w+:/ },
    d = e.COMMENT(/'''/, /$/, {
      contains: [{ className: "doctag", begin: /<\/?/, end: />/ }],
    }),
    f = e.COMMENT(null, /$/, {
      variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }],
    })
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword:
        "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in:
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",
      type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",
      literal: "true false nothing",
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      r,
      l,
      c,
      u,
      d,
      f,
      {
        className: "meta",
        begin:
          /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: {
          keyword:
            "const disable else elseif enable end externalsource if region then",
        },
        contains: [f],
      },
    ],
  }
}
function uJ(e) {
  e.regex
  const t = e.COMMENT(/\(;/, /;\)/)
  t.contains.push("self")
  const n = e.COMMENT(/;;/, /$/),
    r = [
      "anyfunc",
      "block",
      "br",
      "br_if",
      "br_table",
      "call",
      "call_indirect",
      "data",
      "drop",
      "elem",
      "else",
      "end",
      "export",
      "func",
      "global.get",
      "global.set",
      "local.get",
      "local.set",
      "local.tee",
      "get_global",
      "get_local",
      "global",
      "if",
      "import",
      "local",
      "loop",
      "memory",
      "memory.grow",
      "memory.size",
      "module",
      "mut",
      "nop",
      "offset",
      "param",
      "result",
      "return",
      "select",
      "set_global",
      "set_local",
      "start",
      "table",
      "tee_local",
      "then",
      "type",
      "unreachable",
    ],
    o = {
      begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
      className: { 1: "keyword", 3: "title.function" },
    },
    i = { className: "variable", begin: /\$[\w_]+/ },
    s = { match: /(\((?!;)|\))+/, className: "punctuation", relevance: 0 },
    a = {
      className: "number",
      relevance: 0,
      match:
        /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
    },
    l = { match: /(i32|i64|f32|f64)(?!\.)/, className: "type" },
    c = {
      className: "keyword",
      match:
        /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/,
    }
  return {
    name: "WebAssembly",
    keywords: { $pattern: /[\w.]+/, keyword: r },
    contains: [
      n,
      t,
      {
        match: [/(?:offset|align)/, /\s*/, /=/],
        className: { 1: "keyword", 3: "operator" },
      },
      i,
      s,
      o,
      e.QUOTE_STRING_MODE,
      l,
      c,
      a,
    ],
  }
}
function dJ(e) {
  const t = e.regex,
    n = t.concat(
      /[\p{L}_]/u,
      t.optional(/[\p{L}0-9_.-]*:/u),
      /[\p{L}0-9_.-]*/u
    ),
    r = /[\p{L}0-9._:-]+/u,
    o = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ },
    i = {
      begin: /\s/,
      contains: [
        { className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ },
      ],
    },
    s = e.inherit(i, { begin: /\(/, end: /\)/ }),
    a = e.inherit(e.APOS_STRING_MODE, { className: "string" }),
    l = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
    c = {
      endsWithParent: !0,
      illegal: /</,
      relevance: 0,
      contains: [
        { className: "attr", begin: r, relevance: 0 },
        {
          begin: /=\s*/,
          relevance: 0,
          contains: [
            {
              className: "string",
              endsParent: !0,
              variants: [
                { begin: /"/, end: /"/, contains: [o] },
                { begin: /'/, end: /'/, contains: [o] },
                { begin: /[^\s"'=<>`]+/ },
              ],
            },
          ],
        },
      ],
    }
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg",
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          i,
          l,
          a,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [i, s, l, a],
              },
            ],
          },
        ],
      },
      e.COMMENT(/<!--/, /-->/, { relevance: 10 }),
      { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
      o,
      {
        className: "meta",
        end: /\?>/,
        variants: [
          { begin: /<\?xml/, relevance: 10, contains: [l] },
          { begin: /<\?[a-z][a-z0-9]+/ },
        ],
      },
      {
        className: "tag",
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: ["css", "xml"],
        },
      },
      {
        className: "tag",
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: ["javascript", "handlebars", "xml"],
        },
      },
      { className: "tag", begin: /<>|<\/>/ },
      {
        className: "tag",
        begin: t.concat(
          /</,
          t.lookahead(t.concat(n, t.either(/\/>/, />/, /\s/)))
        ),
        end: /\/?>/,
        contains: [{ className: "name", begin: n, relevance: 0, starts: c }],
      },
      {
        className: "tag",
        begin: t.concat(/<\//, t.lookahead(t.concat(n, />/))),
        contains: [
          { className: "name", begin: n, relevance: 0 },
          { begin: />/, relevance: 0, endsParent: !0 },
        ],
      },
    ],
  }
}
function fJ(e) {
  const t = "true false yes no null",
    n = "[\\w#;/?:@&=+$,.~*'()[\\]]+",
    r = {
      className: "attr",
      variants: [
        { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
        { begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/ },
        { begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/ },
      ],
    },
    o = {
      className: "template-variable",
      variants: [
        { begin: /\{\{/, end: /\}\}/ },
        { begin: /%\{/, end: /\}/ },
      ],
    },
    i = {
      className: "string",
      relevance: 0,
      begin: /'/,
      end: /'/,
      contains: [{ match: /''/, scope: "char.escape", relevance: 0 }],
    },
    s = {
      className: "string",
      relevance: 0,
      variants: [{ begin: /"/, end: /"/ }, { begin: /\S+/ }],
      contains: [e.BACKSLASH_ESCAPE, o],
    },
    a = e.inherit(s, {
      variants: [
        { begin: /'/, end: /'/, contains: [{ begin: /''/, relevance: 0 }] },
        { begin: /"/, end: /"/ },
        { begin: /[^\s,{}[\]]+/ },
      ],
    }),
    l = "[0-9]{4}(-[0-9][0-9]){0,2}",
    c = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?",
    u = "(\\.[0-9]*)?",
    d = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?",
    f = { className: "number", begin: "\\b" + l + c + u + d + "\\b" },
    p = {
      end: ",",
      endsWithParent: !0,
      excludeEnd: !0,
      keywords: t,
      relevance: 0,
    },
    g = { begin: /\{/, end: /\}/, contains: [p], illegal: "\\n", relevance: 0 },
    v = {
      begin: "\\[",
      end: "\\]",
      contains: [p],
      illegal: "\\n",
      relevance: 0,
    },
    b = [
      r,
      { className: "meta", begin: "^---\\s*$", relevance: 10 },
      {
        className: "string",
        begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*",
      },
      {
        begin: "<%[%=-]?",
        end: "[%-]?%>",
        subLanguage: "ruby",
        excludeBegin: !0,
        excludeEnd: !0,
        relevance: 0,
      },
      { className: "type", begin: "!\\w+!" + n },
      { className: "type", begin: "!<" + n + ">" },
      { className: "type", begin: "!" + n },
      { className: "type", begin: "!!" + n },
      { className: "meta", begin: "&" + e.UNDERSCORE_IDENT_RE + "$" },
      { className: "meta", begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$" },
      { className: "bullet", begin: "-(?=[ ]|$)", relevance: 0 },
      e.HASH_COMMENT_MODE,
      { beginKeywords: t, keywords: { literal: t } },
      f,
      { className: "number", begin: e.C_NUMBER_RE + "\\b", relevance: 0 },
      g,
      v,
      i,
      s,
    ],
    y = [...b]
  return (
    y.pop(),
    y.push(a),
    (p.contains = y),
    { name: "YAML", case_insensitive: !0, aliases: ["yml"], contains: b }
  )
}
const pJ = {
  arduino: qX,
  bash: ZX,
  c: YX,
  cpp: XX,
  csharp: QX,
  css: aQ,
  diff: lQ,
  go: cQ,
  graphql: uQ,
  ini: dQ,
  java: fQ,
  javascript: vQ,
  json: yQ,
  kotlin: xQ,
  less: TQ,
  lua: MQ,
  makefile: OQ,
  markdown: AQ,
  objectivec: RQ,
  perl: IQ,
  php: DQ,
  "php-template": LQ,
  plaintext: PQ,
  python: $Q,
  "python-repl": BQ,
  r: jQ,
  ruby: FQ,
  rust: zQ,
  scss: YQ,
  shell: XQ,
  sql: QQ,
  swift: sJ,
  typescript: lJ,
  vbnet: cJ,
  wasm: uJ,
  xml: dJ,
  yaml: fJ,
}
function lD(e) {
  return (
    e instanceof Map
      ? (e.clear =
          e.delete =
          e.set =
            function () {
              throw new Error("map is read-only")
            })
      : e instanceof Set &&
        (e.add =
          e.clear =
          e.delete =
            function () {
              throw new Error("set is read-only")
            }),
    Object.freeze(e),
    Object.getOwnPropertyNames(e).forEach((t) => {
      const n = e[t],
        r = typeof n
      ;(r === "object" || r === "function") && !Object.isFrozen(n) && lD(n)
    }),
    e
  )
}
class kS {
  constructor(t) {
    t.data === void 0 && (t.data = {}),
      (this.data = t.data),
      (this.isMatchIgnored = !1)
  }
  ignoreMatch() {
    this.isMatchIgnored = !0
  }
}
function cD(e) {
  return e
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#x27;")
}
function ri(e, ...t) {
  const n = Object.create(null)
  for (const r in e) n[r] = e[r]
  return (
    t.forEach(function (r) {
      for (const o in r) n[o] = r[o]
    }),
    n
  )
}
const hJ = "</span>",
  NS = (e) => !!e.scope,
  mJ = (e, { prefix: t }) => {
    if (e.startsWith("language:")) return e.replace("language:", "language-")
    if (e.includes(".")) {
      const n = e.split(".")
      return [
        `${t}${n.shift()}`,
        ...n.map((r, o) => `${r}${"_".repeat(o + 1)}`),
      ].join(" ")
    }
    return `${t}${e}`
  }
class gJ {
  constructor(t, n) {
    ;(this.buffer = ""), (this.classPrefix = n.classPrefix), t.walk(this)
  }
  addText(t) {
    this.buffer += cD(t)
  }
  openNode(t) {
    if (!NS(t)) return
    const n = mJ(t.scope, { prefix: this.classPrefix })
    this.span(n)
  }
  closeNode(t) {
    NS(t) && (this.buffer += hJ)
  }
  value() {
    return this.buffer
  }
  span(t) {
    this.buffer += `<span class="${t}">`
  }
}
const TS = (e = {}) => {
  const t = { children: [] }
  return Object.assign(t, e), t
}
class W1 {
  constructor() {
    ;(this.rootNode = TS()), (this.stack = [this.rootNode])
  }
  get top() {
    return this.stack[this.stack.length - 1]
  }
  get root() {
    return this.rootNode
  }
  add(t) {
    this.top.children.push(t)
  }
  openNode(t) {
    const n = TS({ scope: t })
    this.add(n), this.stack.push(n)
  }
  closeNode() {
    if (this.stack.length > 1) return this.stack.pop()
  }
  closeAllNodes() {
    for (; this.closeNode(); );
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4)
  }
  walk(t) {
    return this.constructor._walk(t, this.rootNode)
  }
  static _walk(t, n) {
    return (
      typeof n == "string"
        ? t.addText(n)
        : n.children &&
          (t.openNode(n),
          n.children.forEach((r) => this._walk(t, r)),
          t.closeNode(n)),
      t
    )
  }
  static _collapse(t) {
    typeof t != "string" &&
      t.children &&
      (t.children.every((n) => typeof n == "string")
        ? (t.children = [t.children.join("")])
        : t.children.forEach((n) => {
            W1._collapse(n)
          }))
  }
}
class vJ extends W1 {
  constructor(t) {
    super(), (this.options = t)
  }
  addText(t) {
    t !== "" && this.add(t)
  }
  startScope(t) {
    this.openNode(t)
  }
  endScope() {
    this.closeNode()
  }
  __addSublanguage(t, n) {
    const r = t.root
    n && (r.scope = `language:${n}`), this.add(r)
  }
  toHTML() {
    return new gJ(this, this.options).value()
  }
  finalize() {
    return this.closeAllNodes(), !0
  }
}
function gu(e) {
  return e ? (typeof e == "string" ? e : e.source) : null
}
function uD(e) {
  return Fs("(?=", e, ")")
}
function yJ(e) {
  return Fs("(?:", e, ")*")
}
function bJ(e) {
  return Fs("(?:", e, ")?")
}
function Fs(...e) {
  return e.map((n) => gu(n)).join("")
}
function xJ(e) {
  const t = e[e.length - 1]
  return typeof t == "object" && t.constructor === Object
    ? (e.splice(e.length - 1, 1), t)
    : {}
}
function K1(...e) {
  return "(" + (xJ(e).capture ? "" : "?:") + e.map((r) => gu(r)).join("|") + ")"
}
function dD(e) {
  return new RegExp(e.toString() + "|").exec("").length - 1
}
function wJ(e, t) {
  const n = e && e.exec(t)
  return n && n.index === 0
}
const EJ = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
function G1(e, { joinWith: t }) {
  let n = 0
  return e
    .map((r) => {
      n += 1
      const o = n
      let i = gu(r),
        s = ""
      for (; i.length > 0; ) {
        const a = EJ.exec(i)
        if (!a) {
          s += i
          break
        }
        ;(s += i.substring(0, a.index)),
          (i = i.substring(a.index + a[0].length)),
          a[0][0] === "\\" && a[1]
            ? (s += "\\" + String(Number(a[1]) + o))
            : ((s += a[0]), a[0] === "(" && n++)
      }
      return s
    })
    .map((r) => `(${r})`)
    .join(t)
}
const CJ = /\b\B/,
  fD = "[a-zA-Z]\\w*",
  q1 = "[a-zA-Z_]\\w*",
  pD = "\\b\\d+(\\.\\d+)?",
  hD = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",
  mD = "\\b(0b[01]+)",
  SJ =
    "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
  _J = (e = {}) => {
    const t = /^#![ ]*\//
    return (
      e.binary && (e.begin = Fs(t, /.*\b/, e.binary, /\b.*/)),
      ri(
        {
          scope: "meta",
          begin: t,
          end: /$/,
          relevance: 0,
          "on:begin": (n, r) => {
            n.index !== 0 && r.ignoreMatch()
          },
        },
        e
      )
    )
  },
  vu = { begin: "\\\\[\\s\\S]", relevance: 0 },
  kJ = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [vu],
  },
  NJ = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [vu],
  },
  TJ = {
    begin:
      /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
  },
  xm = function (e, t, n = {}) {
    const r = ri({ scope: "comment", begin: e, end: t, contains: [] }, n)
    r.contains.push({
      scope: "doctag",
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0,
    })
    const o = K1(
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      /[A-Za-z]+[-][a-z]+/,
      /[A-Za-z][a-z]{2,}/
    )
    return (
      r.contains.push({
        begin: Fs(/[ ]+/, "(", o, /[.]?[:]?([.][ ]|[ ])/, "){3}"),
      }),
      r
    )
  },
  MJ = xm("//", "$"),
  OJ = xm("/\\*", "\\*/"),
  AJ = xm("#", "$"),
  RJ = { scope: "number", begin: pD, relevance: 0 },
  IJ = { scope: "number", begin: hD, relevance: 0 },
  DJ = { scope: "number", begin: mD, relevance: 0 },
  LJ = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [vu, { begin: /\[/, end: /\]/, relevance: 0, contains: [vu] }],
  },
  PJ = { scope: "title", begin: fD, relevance: 0 },
  $J = { scope: "title", begin: q1, relevance: 0 },
  BJ = { begin: "\\.\\s*" + q1, relevance: 0 },
  jJ = function (e) {
    return Object.assign(e, {
      "on:begin": (t, n) => {
        n.data._beginMatch = t[1]
      },
      "on:end": (t, n) => {
        n.data._beginMatch !== t[1] && n.ignoreMatch()
      },
    })
  }
var jd = Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: kJ,
  BACKSLASH_ESCAPE: vu,
  BINARY_NUMBER_MODE: DJ,
  BINARY_NUMBER_RE: mD,
  COMMENT: xm,
  C_BLOCK_COMMENT_MODE: OJ,
  C_LINE_COMMENT_MODE: MJ,
  C_NUMBER_MODE: IJ,
  C_NUMBER_RE: hD,
  END_SAME_AS_BEGIN: jJ,
  HASH_COMMENT_MODE: AJ,
  IDENT_RE: fD,
  MATCH_NOTHING_RE: CJ,
  METHOD_GUARD: BJ,
  NUMBER_MODE: RJ,
  NUMBER_RE: pD,
  PHRASAL_WORDS_MODE: TJ,
  QUOTE_STRING_MODE: NJ,
  REGEXP_MODE: LJ,
  RE_STARTERS_RE: SJ,
  SHEBANG: _J,
  TITLE_MODE: PJ,
  UNDERSCORE_IDENT_RE: q1,
  UNDERSCORE_TITLE_MODE: $J,
})
function FJ(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch()
}
function zJ(e, t) {
  e.className !== void 0 && ((e.scope = e.className), delete e.className)
}
function UJ(e, t) {
  t &&
    e.beginKeywords &&
    ((e.begin =
      "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)"),
    (e.__beforeBegin = FJ),
    (e.keywords = e.keywords || e.beginKeywords),
    delete e.beginKeywords,
    e.relevance === void 0 && (e.relevance = 0))
}
function VJ(e, t) {
  Array.isArray(e.illegal) && (e.illegal = K1(...e.illegal))
}
function HJ(e, t) {
  if (e.match) {
    if (e.begin || e.end)
      throw new Error("begin & end are not supported with match")
    ;(e.begin = e.match), delete e.match
  }
}
function WJ(e, t) {
  e.relevance === void 0 && (e.relevance = 1)
}
const KJ = (e, t) => {
    if (!e.beforeMatch) return
    if (e.starts) throw new Error("beforeMatch cannot be used with starts")
    const n = Object.assign({}, e)
    Object.keys(e).forEach((r) => {
      delete e[r]
    }),
      (e.keywords = n.keywords),
      (e.begin = Fs(n.beforeMatch, uD(n.begin))),
      (e.starts = {
        relevance: 0,
        contains: [Object.assign(n, { endsParent: !0 })],
      }),
      (e.relevance = 0),
      delete n.beforeMatch
  },
  GJ = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value",
  ],
  qJ = "keyword"
function gD(e, t, n = qJ) {
  const r = Object.create(null)
  return (
    typeof e == "string"
      ? o(n, e.split(" "))
      : Array.isArray(e)
        ? o(n, e)
        : Object.keys(e).forEach(function (i) {
            Object.assign(r, gD(e[i], t, i))
          }),
    r
  )
  function o(i, s) {
    t && (s = s.map((a) => a.toLowerCase())),
      s.forEach(function (a) {
        const l = a.split("|")
        r[l[0]] = [i, ZJ(l[0], l[1])]
      })
  }
}
function ZJ(e, t) {
  return t ? Number(t) : YJ(e) ? 0 : 1
}
function YJ(e) {
  return GJ.includes(e.toLowerCase())
}
const MS = {},
  ds = (e) => {
    console.error(e)
  },
  OS = (e, ...t) => {
    console.log(`WARN: ${e}`, ...t)
  },
  Js = (e, t) => {
    MS[`${e}/${t}`] ||
      (console.log(`Deprecated as of ${e}. ${t}`), (MS[`${e}/${t}`] = !0))
  },
  Sp = new Error()
function vD(e, t, { key: n }) {
  let r = 0
  const o = e[n],
    i = {},
    s = {}
  for (let a = 1; a <= t.length; a++)
    (s[a + r] = o[a]), (i[a + r] = !0), (r += dD(t[a - 1]))
  ;(e[n] = s), (e[n]._emit = i), (e[n]._multi = !0)
}
function XJ(e) {
  if (Array.isArray(e.begin)) {
    if (e.skip || e.excludeBegin || e.returnBegin)
      throw (
        (ds(
          "skip, excludeBegin, returnBegin not compatible with beginScope: {}"
        ),
        Sp)
      )
    if (typeof e.beginScope != "object" || e.beginScope === null)
      throw (ds("beginScope must be object"), Sp)
    vD(e, e.begin, { key: "beginScope" }),
      (e.begin = G1(e.begin, { joinWith: "" }))
  }
}
function QJ(e) {
  if (Array.isArray(e.end)) {
    if (e.skip || e.excludeEnd || e.returnEnd)
      throw (
        (ds("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Sp)
      )
    if (typeof e.endScope != "object" || e.endScope === null)
      throw (ds("endScope must be object"), Sp)
    vD(e, e.end, { key: "endScope" }), (e.end = G1(e.end, { joinWith: "" }))
  }
}
function JJ(e) {
  e.scope &&
    typeof e.scope == "object" &&
    e.scope !== null &&
    ((e.beginScope = e.scope), delete e.scope)
}
function eee(e) {
  JJ(e),
    typeof e.beginScope == "string" && (e.beginScope = { _wrap: e.beginScope }),
    typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }),
    XJ(e),
    QJ(e)
}
function tee(e) {
  function t(s, a) {
    return new RegExp(
      gu(s),
      "m" +
        (e.case_insensitive ? "i" : "") +
        (e.unicodeRegex ? "u" : "") +
        (a ? "g" : "")
    )
  }
  class n {
    constructor() {
      ;(this.matchIndexes = {}),
        (this.regexes = []),
        (this.matchAt = 1),
        (this.position = 0)
    }
    addRule(a, l) {
      ;(l.position = this.position++),
        (this.matchIndexes[this.matchAt] = l),
        this.regexes.push([l, a]),
        (this.matchAt += dD(a) + 1)
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null)
      const a = this.regexes.map((l) => l[1])
      ;(this.matcherRe = t(G1(a, { joinWith: "|" }), !0)), (this.lastIndex = 0)
    }
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex
      const l = this.matcherRe.exec(a)
      if (!l) return null
      const c = l.findIndex((d, f) => f > 0 && d !== void 0),
        u = this.matchIndexes[c]
      return l.splice(0, c), Object.assign(l, u)
    }
  }
  class r {
    constructor() {
      ;(this.rules = []),
        (this.multiRegexes = []),
        (this.count = 0),
        (this.lastIndex = 0),
        (this.regexIndex = 0)
    }
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a]
      const l = new n()
      return (
        this.rules.slice(a).forEach(([c, u]) => l.addRule(c, u)),
        l.compile(),
        (this.multiRegexes[a] = l),
        l
      )
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0
    }
    considerAll() {
      this.regexIndex = 0
    }
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++
    }
    exec(a) {
      const l = this.getMatcher(this.regexIndex)
      l.lastIndex = this.lastIndex
      let c = l.exec(a)
      if (
        this.resumingScanAtSamePosition() &&
        !(c && c.index === this.lastIndex)
      ) {
        const u = this.getMatcher(0)
        ;(u.lastIndex = this.lastIndex + 1), (c = u.exec(a))
      }
      return (
        c &&
          ((this.regexIndex += c.position + 1),
          this.regexIndex === this.count && this.considerAll()),
        c
      )
    }
  }
  function o(s) {
    const a = new r()
    return (
      s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })),
      s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }),
      s.illegal && a.addRule(s.illegal, { type: "illegal" }),
      a
    )
  }
  function i(s, a) {
    const l = s
    if (s.isCompiled) return l
    ;[zJ, HJ, eee, KJ].forEach((u) => u(s, a)),
      e.compilerExtensions.forEach((u) => u(s, a)),
      (s.__beforeBegin = null),
      [UJ, VJ, WJ].forEach((u) => u(s, a)),
      (s.isCompiled = !0)
    let c = null
    return (
      typeof s.keywords == "object" &&
        s.keywords.$pattern &&
        ((s.keywords = Object.assign({}, s.keywords)),
        (c = s.keywords.$pattern),
        delete s.keywords.$pattern),
      (c = c || /\w+/),
      s.keywords && (s.keywords = gD(s.keywords, e.case_insensitive)),
      (l.keywordPatternRe = t(c, !0)),
      a &&
        (s.begin || (s.begin = /\B|\b/),
        (l.beginRe = t(l.begin)),
        !s.end && !s.endsWithParent && (s.end = /\B|\b/),
        s.end && (l.endRe = t(l.end)),
        (l.terminatorEnd = gu(l.end) || ""),
        s.endsWithParent &&
          a.terminatorEnd &&
          (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)),
      s.illegal && (l.illegalRe = t(s.illegal)),
      s.contains || (s.contains = []),
      (s.contains = [].concat(
        ...s.contains.map(function (u) {
          return nee(u === "self" ? s : u)
        })
      )),
      s.contains.forEach(function (u) {
        i(u, l)
      }),
      s.starts && i(s.starts, a),
      (l.matcher = o(l)),
      l
    )
  }
  if (
    (e.compilerExtensions || (e.compilerExtensions = []),
    e.contains && e.contains.includes("self"))
  )
    throw new Error(
      "ERR: contains `self` is not supported at the top-level of a language.  See documentation."
    )
  return (e.classNameAliases = ri(e.classNameAliases || {})), i(e)
}
function yD(e) {
  return e ? e.endsWithParent || yD(e.starts) : !1
}
function nee(e) {
  return (
    e.variants &&
      !e.cachedVariants &&
      (e.cachedVariants = e.variants.map(function (t) {
        return ri(e, { variants: null }, t)
      })),
    e.cachedVariants
      ? e.cachedVariants
      : yD(e)
        ? ri(e, { starts: e.starts ? ri(e.starts) : null })
        : Object.isFrozen(e)
          ? ri(e)
          : e
  )
}
var ree = "11.11.1"
class oee extends Error {
  constructor(t, n) {
    super(t), (this.name = "HTMLInjectionError"), (this.html = n)
  }
}
const Gg = cD,
  AS = ri,
  RS = Symbol("nomatch"),
  iee = 7,
  bD = function (e) {
    const t = Object.create(null),
      n = Object.create(null),
      r = []
    let o = !0
    const i =
        "Could not find the language '{}', did you forget to load/include a language module?",
      s = { disableAutodetect: !0, name: "Plain text", contains: [] }
    let a = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      __emitter: vJ,
    }
    function l(I) {
      return a.noHighlightRe.test(I)
    }
    function c(I) {
      let O = I.className + " "
      O += I.parentNode ? I.parentNode.className : ""
      const _ = a.languageDetectRe.exec(O)
      if (_) {
        const A = N(_[1])
        return (
          A ||
            (OS(i.replace("{}", _[1])),
            OS("Falling back to no-highlight mode for this block.", I)),
          A ? _[1] : "no-highlight"
        )
      }
      return O.split(/\s+/).find((A) => l(A) || N(A))
    }
    function u(I, O, _) {
      let A = "",
        P = ""
      typeof O == "object"
        ? ((A = I), (_ = O.ignoreIllegals), (P = O.language))
        : (Js("10.7.0", "highlight(lang, code, ...args) has been deprecated."),
          Js(
            "10.7.0",
            `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`
          ),
          (P = I),
          (A = O)),
        _ === void 0 && (_ = !0)
      const H = { code: A, language: P }
      W("before:highlight", H)
      const X = H.result ? H.result : d(H.language, H.code, _)
      return (X.code = H.code), W("after:highlight", X), X
    }
    function d(I, O, _, A) {
      const P = Object.create(null)
      function H($, T) {
        return $.keywords[T]
      }
      function X() {
        if (!ue.keywords) {
          $e.addText(fe)
          return
        }
        let $ = 0
        ue.keywordPatternRe.lastIndex = 0
        let T = ue.keywordPatternRe.exec(fe),
          L = ""
        for (; T; ) {
          L += fe.substring($, T.index)
          const K = He.case_insensitive ? T[0].toLowerCase() : T[0],
            ie = H(ue, K)
          if (ie) {
            const [Se, an] = ie
            if (
              ($e.addText(L),
              (L = ""),
              (P[K] = (P[K] || 0) + 1),
              P[K] <= iee && (k += an),
              Se.startsWith("_"))
            )
              L += T[0]
            else {
              const oo = He.classNameAliases[Se] || Se
              he(T[0], oo)
            }
          } else L += T[0]
          ;($ = ue.keywordPatternRe.lastIndex),
            (T = ue.keywordPatternRe.exec(fe))
        }
        ;(L += fe.substring($)), $e.addText(L)
      }
      function ae() {
        if (fe === "") return
        let $ = null
        if (typeof ue.subLanguage == "string") {
          if (!t[ue.subLanguage]) {
            $e.addText(fe)
            return
          }
          ;($ = d(ue.subLanguage, fe, !0, me[ue.subLanguage])),
            (me[ue.subLanguage] = $._top)
        } else $ = p(fe, ue.subLanguage.length ? ue.subLanguage : null)
        ue.relevance > 0 && (k += $.relevance),
          $e.__addSublanguage($._emitter, $.language)
      }
      function ve() {
        ue.subLanguage != null ? ae() : X(), (fe = "")
      }
      function he($, T) {
        $ !== "" && ($e.startScope(T), $e.addText($), $e.endScope())
      }
      function xe($, T) {
        let L = 1
        const K = T.length - 1
        for (; L <= K; ) {
          if (!$._emit[L]) {
            L++
            continue
          }
          const ie = He.classNameAliases[$[L]] || $[L],
            Se = T[L]
          ie ? he(Se, ie) : ((fe = Se), X(), (fe = "")), L++
        }
      }
      function Ae($, T) {
        return (
          $.scope &&
            typeof $.scope == "string" &&
            $e.openNode(He.classNameAliases[$.scope] || $.scope),
          $.beginScope &&
            ($.beginScope._wrap
              ? (he(
                  fe,
                  He.classNameAliases[$.beginScope._wrap] || $.beginScope._wrap
                ),
                (fe = ""))
              : $.beginScope._multi && (xe($.beginScope, T), (fe = ""))),
          (ue = Object.create($, { parent: { value: ue } })),
          ue
        )
      }
      function je($, T, L) {
        let K = wJ($.endRe, L)
        if (K) {
          if ($["on:end"]) {
            const ie = new kS($)
            $["on:end"](T, ie), ie.isMatchIgnored && (K = !1)
          }
          if (K) {
            for (; $.endsParent && $.parent; ) $ = $.parent
            return $
          }
        }
        if ($.endsWithParent) return je($.parent, T, L)
      }
      function Fe($) {
        return ue.matcher.regexIndex === 0 ? ((fe += $[0]), 1) : ((te = !0), 0)
      }
      function Ze($) {
        const T = $[0],
          L = $.rule,
          K = new kS(L),
          ie = [L.__beforeBegin, L["on:begin"]]
        for (const Se of ie)
          if (Se && (Se($, K), K.isMatchIgnored)) return Fe(T)
        return (
          L.skip
            ? (fe += T)
            : (L.excludeBegin && (fe += T),
              ve(),
              !L.returnBegin && !L.excludeBegin && (fe = T)),
          Ae(L, $),
          L.returnBegin ? 0 : T.length
        )
      }
      function dt($) {
        const T = $[0],
          L = O.substring($.index),
          K = je(ue, $, L)
        if (!K) return RS
        const ie = ue
        ue.endScope && ue.endScope._wrap
          ? (ve(), he(T, ue.endScope._wrap))
          : ue.endScope && ue.endScope._multi
            ? (ve(), xe(ue.endScope, $))
            : ie.skip
              ? (fe += T)
              : (ie.returnEnd || ie.excludeEnd || (fe += T),
                ve(),
                ie.excludeEnd && (fe = T))
        do
          ue.scope && $e.closeNode(),
            !ue.skip && !ue.subLanguage && (k += ue.relevance),
            (ue = ue.parent)
        while (ue !== K.parent)
        return K.starts && Ae(K.starts, $), ie.returnEnd ? 0 : T.length
      }
      function kt() {
        const $ = []
        for (let T = ue; T !== He; T = T.parent) T.scope && $.unshift(T.scope)
        $.forEach((T) => $e.openNode(T))
      }
      let ft = {}
      function Et($, T) {
        const L = T && T[0]
        if (((fe += $), L == null)) return ve(), 0
        if (
          ft.type === "begin" &&
          T.type === "end" &&
          ft.index === T.index &&
          L === ""
        ) {
          if (((fe += O.slice(T.index, T.index + 1)), !o)) {
            const K = new Error(`0 width match regex (${I})`)
            throw ((K.languageName = I), (K.badRule = ft.rule), K)
          }
          return 1
        }
        if (((ft = T), T.type === "begin")) return Ze(T)
        if (T.type === "illegal" && !_) {
          const K = new Error(
            'Illegal lexeme "' +
              L +
              '" for mode "' +
              (ue.scope || "<unnamed>") +
              '"'
          )
          throw ((K.mode = ue), K)
        } else if (T.type === "end") {
          const K = dt(T)
          if (K !== RS) return K
        }
        if (T.type === "illegal" && L === "")
          return (
            (fe += `
`),
            1
          )
        if (F > 1e5 && F > T.index * 3)
          throw new Error(
            "potential infinite loop, way more iterations than matches"
          )
        return (fe += L), L.length
      }
      const He = N(I)
      if (!He)
        throw (
          (ds(i.replace("{}", I)), new Error('Unknown language: "' + I + '"'))
        )
      const be = tee(He)
      let yt = "",
        ue = A || be
      const me = {},
        $e = new a.__emitter(a)
      kt()
      let fe = "",
        k = 0,
        D = 0,
        F = 0,
        te = !1
      try {
        if (He.__emitTokens) He.__emitTokens(O, $e)
        else {
          for (ue.matcher.considerAll(); ; ) {
            F++,
              te ? (te = !1) : ue.matcher.considerAll(),
              (ue.matcher.lastIndex = D)
            const $ = ue.matcher.exec(O)
            if (!$) break
            const T = O.substring(D, $.index),
              L = Et(T, $)
            D = $.index + L
          }
          Et(O.substring(D))
        }
        return (
          $e.finalize(),
          (yt = $e.toHTML()),
          {
            language: I,
            value: yt,
            relevance: k,
            illegal: !1,
            _emitter: $e,
            _top: ue,
          }
        )
      } catch ($) {
        if ($.message && $.message.includes("Illegal"))
          return {
            language: I,
            value: Gg(O),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: $.message,
              index: D,
              context: O.slice(D - 100, D + 100),
              mode: $.mode,
              resultSoFar: yt,
            },
            _emitter: $e,
          }
        if (o)
          return {
            language: I,
            value: Gg(O),
            illegal: !1,
            relevance: 0,
            errorRaised: $,
            _emitter: $e,
            _top: ue,
          }
        throw $
      }
    }
    function f(I) {
      const O = {
        value: Gg(I),
        illegal: !1,
        relevance: 0,
        _top: s,
        _emitter: new a.__emitter(a),
      }
      return O._emitter.addText(I), O
    }
    function p(I, O) {
      O = O || a.languages || Object.keys(t)
      const _ = f(I),
        A = O.filter(N)
          .filter(B)
          .map((ve) => d(ve, I, !1))
      A.unshift(_)
      const P = A.sort((ve, he) => {
          if (ve.relevance !== he.relevance) return he.relevance - ve.relevance
          if (ve.language && he.language) {
            if (N(ve.language).supersetOf === he.language) return 1
            if (N(he.language).supersetOf === ve.language) return -1
          }
          return 0
        }),
        [H, X] = P,
        ae = H
      return (ae.secondBest = X), ae
    }
    function g(I, O, _) {
      const A = (O && n[O]) || _
      I.classList.add("hljs"), I.classList.add(`language-${A}`)
    }
    function v(I) {
      let O = null
      const _ = c(I)
      if (l(_)) return
      if (
        (W("before:highlightElement", { el: I, language: _ }),
        I.dataset.highlighted)
      ) {
        console.log(
          "Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",
          I
        )
        return
      }
      if (
        I.children.length > 0 &&
        (a.ignoreUnescapedHTML ||
          (console.warn(
            "One of your code blocks includes unescaped HTML. This is a potentially serious security risk."
          ),
          console.warn(
            "https://github.com/highlightjs/highlight.js/wiki/security"
          ),
          console.warn("The element with unescaped HTML:"),
          console.warn(I)),
        a.throwUnescapedHTML)
      )
        throw new oee(
          "One of your code blocks includes unescaped HTML.",
          I.innerHTML
        )
      O = I
      const A = O.textContent,
        P = _ ? u(A, { language: _, ignoreIllegals: !0 }) : p(A)
      ;(I.innerHTML = P.value),
        (I.dataset.highlighted = "yes"),
        g(I, _, P.language),
        (I.result = {
          language: P.language,
          re: P.relevance,
          relevance: P.relevance,
        }),
        P.secondBest &&
          (I.secondBest = {
            language: P.secondBest.language,
            relevance: P.secondBest.relevance,
          }),
        W("after:highlightElement", { el: I, result: P, text: A })
    }
    function b(I) {
      a = AS(a, I)
    }
    const y = () => {
      w(),
        Js("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.")
    }
    function x() {
      w(),
        Js(
          "10.6.0",
          "initHighlightingOnLoad() deprecated.  Use highlightAll() now."
        )
    }
    let E = !1
    function w() {
      function I() {
        w()
      }
      if (document.readyState === "loading") {
        E || window.addEventListener("DOMContentLoaded", I, !1), (E = !0)
        return
      }
      document.querySelectorAll(a.cssSelector).forEach(v)
    }
    function C(I, O) {
      let _ = null
      try {
        _ = O(e)
      } catch (A) {
        if (
          (ds(
            "Language definition for '{}' could not be registered.".replace(
              "{}",
              I
            )
          ),
          o)
        )
          ds(A)
        else throw A
        _ = s
      }
      _.name || (_.name = I),
        (t[I] = _),
        (_.rawDefinition = O.bind(null, e)),
        _.aliases && R(_.aliases, { languageName: I })
    }
    function S(I) {
      delete t[I]
      for (const O of Object.keys(n)) n[O] === I && delete n[O]
    }
    function M() {
      return Object.keys(t)
    }
    function N(I) {
      return (I = (I || "").toLowerCase()), t[I] || t[n[I]]
    }
    function R(I, { languageName: O }) {
      typeof I == "string" && (I = [I]),
        I.forEach((_) => {
          n[_.toLowerCase()] = O
        })
    }
    function B(I) {
      const O = N(I)
      return O && !O.disableAutodetect
    }
    function V(I) {
      I["before:highlightBlock"] &&
        !I["before:highlightElement"] &&
        (I["before:highlightElement"] = (O) => {
          I["before:highlightBlock"](Object.assign({ block: O.el }, O))
        }),
        I["after:highlightBlock"] &&
          !I["after:highlightElement"] &&
          (I["after:highlightElement"] = (O) => {
            I["after:highlightBlock"](Object.assign({ block: O.el }, O))
          })
    }
    function j(I) {
      V(I), r.push(I)
    }
    function U(I) {
      const O = r.indexOf(I)
      O !== -1 && r.splice(O, 1)
    }
    function W(I, O) {
      const _ = I
      r.forEach(function (A) {
        A[_] && A[_](O)
      })
    }
    function ee(I) {
      return (
        Js("10.7.0", "highlightBlock will be removed entirely in v12.0"),
        Js("10.7.0", "Please use highlightElement now."),
        v(I)
      )
    }
    Object.assign(e, {
      highlight: u,
      highlightAuto: p,
      highlightAll: w,
      highlightElement: v,
      highlightBlock: ee,
      configure: b,
      initHighlighting: y,
      initHighlightingOnLoad: x,
      registerLanguage: C,
      unregisterLanguage: S,
      listLanguages: M,
      getLanguage: N,
      registerAliases: R,
      autoDetection: B,
      inherit: AS,
      addPlugin: j,
      removePlugin: U,
    }),
      (e.debugMode = function () {
        o = !1
      }),
      (e.safeMode = function () {
        o = !0
      }),
      (e.versionString = ree),
      (e.regex = {
        concat: Fs,
        lookahead: uD,
        either: K1,
        optional: bJ,
        anyNumberOfTimes: yJ,
      })
    for (const I in jd) typeof jd[I] == "object" && lD(jd[I])
    return Object.assign(e, jd), e
  },
  ll = bD({})
ll.newInstance = () => bD({})
var see = ll
ll.HighlightJS = ll
ll.default = ll
const aee = n0(see),
  IS = {},
  lee = "hljs-"
function cee(e) {
  const t = aee.newInstance()
  return (
    e && i(e),
    {
      highlight: n,
      highlightAuto: r,
      listLanguages: o,
      register: i,
      registerAlias: s,
      registered: a,
    }
  )
  function n(l, c, u) {
    const d = u || IS,
      f = typeof d.prefix == "string" ? d.prefix : lee
    if (!t.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered")
    t.configure({ __emitter: uee, classPrefix: f })
    const p = t.highlight(c, { ignoreIllegals: !0, language: l })
    if (p.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: p.errorRaised,
      })
    const g = p._emitter.root,
      v = g.data
    return (v.language = p.language), (v.relevance = p.relevance), g
  }
  function r(l, c) {
    const d = (c || IS).subset || o()
    let f = -1,
      p = 0,
      g
    for (; ++f < d.length; ) {
      const v = d[f]
      if (!t.getLanguage(v)) continue
      const b = n(v, l, c)
      b.data &&
        b.data.relevance !== void 0 &&
        b.data.relevance > p &&
        ((p = b.data.relevance), (g = b))
    }
    return (
      g || {
        type: "root",
        children: [],
        data: { language: void 0, relevance: p },
      }
    )
  }
  function o() {
    return t.listLanguages()
  }
  function i(l, c) {
    if (typeof l == "string") t.registerLanguage(l, c)
    else {
      let u
      for (u in l) Object.hasOwn(l, u) && t.registerLanguage(u, l[u])
    }
  }
  function s(l, c) {
    if (typeof l == "string")
      t.registerAliases(typeof c == "string" ? c : [...c], { languageName: l })
    else {
      let u
      for (u in l)
        if (Object.hasOwn(l, u)) {
          const d = l[u]
          t.registerAliases(typeof d == "string" ? d : [...d], {
            languageName: u,
          })
        }
    }
  }
  function a(l) {
    return !!t.getLanguage(l)
  }
}
class uee {
  constructor(t) {
    ;(this.options = t),
      (this.root = {
        type: "root",
        children: [],
        data: { language: void 0, relevance: 0 },
      }),
      (this.stack = [this.root])
  }
  addText(t) {
    if (t === "") return
    const n = this.stack[this.stack.length - 1],
      r = n.children[n.children.length - 1]
    r && r.type === "text"
      ? (r.value += t)
      : n.children.push({ type: "text", value: t })
  }
  startScope(t) {
    this.openNode(String(t))
  }
  endScope() {
    this.closeNode()
  }
  __addSublanguage(t, n) {
    const r = this.stack[this.stack.length - 1],
      o = t.root.children
    n
      ? r.children.push({
          type: "element",
          tagName: "span",
          properties: { className: [n] },
          children: o,
        })
      : r.children.push(...o)
  }
  openNode(t) {
    const n = this,
      r = t.split(".").map(function (s, a) {
        return a ? s + "_".repeat(a) : n.options.classPrefix + s
      }),
      o = this.stack[this.stack.length - 1],
      i = {
        type: "element",
        tagName: "span",
        properties: { className: r },
        children: [],
      }
    o.children.push(i), this.stack.push(i)
  }
  closeNode() {
    this.stack.pop()
  }
  finalize() {}
  toHTML() {
    return ""
  }
}
const dee = KX.extend({
    addOptions() {
      var e
      return {
        ...((e = this.parent) == null ? void 0 : e.call(this)),
        lowlight: cee(pJ),
        defaultLanguage: null,
        HTMLAttributes: { class: "block-node" },
      }
    },
  }),
  fee = ct.create({
    name: "color",
    addOptions() {
      return { types: ["textStyle"] }
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            color: {
              default: null,
              parseHTML: (e) => {
                var t
                return (t = e.style.color) === null || t === void 0
                  ? void 0
                  : t.replace(/['"]+/g, "")
              },
              renderHTML: (e) =>
                e.color ? { style: `color: ${e.color}` } : {},
            },
          },
        },
      ]
    },
    addCommands() {
      return {
        setColor:
          (e) =>
          ({ chain: t }) =>
            t().setMark("textStyle", { color: e }).run(),
        unsetColor:
          () =>
          ({ chain: e }) =>
            e()
              .setMark("textStyle", { color: null })
              .removeEmptyTextStyle()
              .run(),
      }
    },
  }),
  pee = fee.extend({
    addProseMirrorPlugins() {
      var e
      return [
        ...(((e = this.parent) == null ? void 0 : e.call(this)) || []),
        new rt({
          props: {
            handleKeyDown: (t, n) => (
              n.key === "Enter" && this.editor.commands.unsetColor(), !1
            ),
          },
        }),
      ]
    },
  }),
  hee = OI.extend({
    addKeyboardShortcuts() {
      return {
        "Mod-Alt--": () =>
          this.editor.commands.insertContent({ type: this.name }),
      }
    },
  }),
  mee = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,
  gee = Rn.create({
    name: "image",
    addOptions() {
      return { inline: !1, allowBase64: !1, HTMLAttributes: {} }
    },
    inline() {
      return this.options.inline
    },
    group() {
      return this.options.inline ? "inline" : "block"
    },
    draggable: !0,
    addAttributes() {
      return {
        src: { default: null },
        alt: { default: null },
        title: { default: null },
      }
    },
    parseHTML() {
      return [
        {
          tag: this.options.allowBase64
            ? "img[src]"
            : 'img[src]:not([src^="data:"])',
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["img", lt(this.options.HTMLAttributes, e)]
    },
    addCommands() {
      return {
        setImage:
          (e) =>
          ({ commands: t }) =>
            t.insertContent({ type: this.name, attrs: e }),
      }
    },
    addInputRules() {
      return [
        yA({
          find: mee,
          type: this.type,
          getAttributes: (e) => {
            const [, , t, n, r] = e
            return { src: n, alt: t, title: r }
          },
        }),
      ]
    },
  })
function vee({
  initialWidth: e,
  initialHeight: t,
  contentWidth: n,
  contentHeight: r,
  gridInterval: o,
  minWidth: i,
  minHeight: s,
  maxWidth: a,
  onDimensionsChange: l,
}) {
  const [c, u] = m.useState({
      width: Math.max(e != null ? e : i, i),
      height: Math.max(t != null ? t : s, s),
    }),
    [d, f] = m.useState(1 / 0),
    [p, g] = m.useState(0),
    [v, b] = m.useState(c),
    [y, x] = m.useState(),
    E = m.useCallback(
      (N, R) => {
        const B = Math.max(i, Math.min(n != null ? n : i, (o / 100) * R))
        return Math.min(R, Math.max(N, B))
      },
      [o, n, i]
    ),
    w = m.useCallback(
      (N) => {
        N.preventDefault()
        const R = (y === "left" ? p - N.pageX : N.pageX - p) * 2,
          B = (o / 100) * d,
          V = v.width + R,
          j = Math.round(V / B) * B,
          U = E(j, d),
          W = r && n ? r / n : 1
        u({
          width: Math.max(U, i),
          height: Math.max(n ? U * W : r != null ? r : s, s),
        })
      },
      [E, y, d, p, o, r, n, v.width, i, s]
    ),
    C = m.useCallback(
      (N) => {
        N.preventDefault(),
          N.stopPropagation(),
          g(0),
          x(void 0),
          l == null || l(c)
      },
      [l, c]
    ),
    S = m.useCallback(
      (N) => {
        N.key === "Escape" &&
          (N.preventDefault(),
          N.stopPropagation(),
          u({ width: Math.max(v.width, i), height: Math.max(v.height, s) }),
          x(void 0))
      },
      [v, i, s]
    ),
    M = m.useCallback(
      (N) => (R) => {
        R.preventDefault(),
          R.stopPropagation(),
          f(a),
          b({
            width: Math.max(E(c.width, a), i),
            height: Math.max(c.height, s),
          }),
          g(R.pageX),
          x(N)
      },
      [a, E, c.width, c.height, i, s]
    )
  return (
    m.useEffect(() => {
      if (y)
        return (
          document.addEventListener("keydown", S),
          document.addEventListener("pointermove", w),
          document.addEventListener("pointerup", C),
          () => {
            document.removeEventListener("keydown", S),
              document.removeEventListener("pointermove", w),
              document.removeEventListener("pointerup", C)
          }
        )
    }, [y, S, w, C]),
    {
      initiateResize: M,
      isResizing: !!y,
      updateDimensions: u,
      currentWidth: Math.max(c.width, i),
      currentHeight: Math.max(c.height, s),
    }
  )
}
const Gy = m.forwardRef(({ className: e, isResizing: t = !1, ...n }, r) =>
  h.jsx("div", {
    className: q(
      "absolute top-1/2 h-10 max-h-full w-1.5 -translate-y-1/2 transform cursor-col-resize rounded border border-solid border-[var(--mt-transparent-foreground)] bg-[var(--mt-bg-secondary)] p-px transition-all",
      "opacity-0 [backdrop-filter:saturate(1.8)_blur(20px)]",
      { "opacity-80": t, "group-hover/node-image:opacity-80": !t },
      "before:absolute before:inset-y-0 before:-left-1 before:-right-1",
      e
    ),
    ref: r,
    ...n,
  })
)
Gy.displayName = "ResizeHandle"
function yee() {
  return G.createElement(
    "svg",
    {
      "aria-hidden": "true",
      "data-rmiz-btn-unzoom-icon": !0,
      fill: "currentColor",
      focusable: "false",
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
    },
    G.createElement("path", {
      d: "M 14.144531 1.148438 L 9 6.292969 L 9 3 L 8 3 L 8 8 L 13 8 L 13 7 L 9.707031 7 L 14.855469 1.851563 Z M 8 8 L 3 8 L 3 9 L 6.292969 9 L 1.148438 14.144531 L 1.851563 14.855469 L 7 9.707031 L 7 13 L 8 13 Z",
    })
  )
}
function bee() {
  return G.createElement(
    "svg",
    {
      "aria-hidden": "true",
      "data-rmiz-btn-zoom-icon": !0,
      fill: "currentColor",
      focusable: "false",
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
    },
    G.createElement("path", {
      d: "M 9 1 L 9 2 L 12.292969 2 L 2 12.292969 L 2 9 L 1 9 L 1 14 L 6 14 L 6 13 L 2.707031 13 L 13 2.707031 L 13 6 L 14 6 L 14 1 Z",
    })
  )
}
const _p = (e, t) => {
    var n, r
    return (
      e ===
      ((r =
        (n = t == null ? void 0 : t.tagName) == null
          ? void 0
          : n.toUpperCase) == null
        ? void 0
        : r.call(n))
    )
  },
  Z1 = (e) => _p("DIV", e) || _p("SPAN", e),
  kp = (e) => _p("IMG", e),
  DS = (e) => e.complete && e.naturalHeight !== 0,
  uf = (e) => _p("SVG", e),
  xD = ({ height: e, offset: t, width: n }) =>
    Math.min((window.innerWidth - t * 2) / n, (window.innerHeight - t * 2) / e),
  xee = ({
    containerHeight: e,
    containerWidth: t,
    offset: n,
    targetHeight: r,
    targetWidth: o,
  }) => {
    const i = xD({ height: r, offset: n, width: o }),
      s = o > r ? o / t : r / e
    return i > 1 ? s : i * s
  },
  fs = ({
    containerHeight: e,
    containerWidth: t,
    hasScalableSrc: n,
    offset: r,
    targetHeight: o,
    targetWidth: i,
  }) =>
    !e || !t
      ? 1
      : !n && o && i
        ? xee({
            containerHeight: e,
            containerWidth: t,
            offset: r,
            targetHeight: o,
            targetWidth: i,
          })
        : xD({ height: e, offset: r, width: t }),
  wee = /url(?:\(['"]?)(.*?)(?:['"]?\))/,
  LS = (e) => {
    var t
    if (e) {
      if (kp(e)) return e.currentSrc
      if (Z1(e)) {
        const n = window.getComputedStyle(e).backgroundImage
        if (n) return (t = wee.exec(n)) == null ? void 0 : t[1]
      }
    }
  },
  Eee = (e) => {
    var t, n
    if (e)
      return kp(e)
        ? (t = e.alt) != null
          ? t
          : void 0
        : (n = e.getAttribute("aria-label")) != null
          ? n
          : void 0
  },
  Cee = ({
    containerHeight: e,
    containerLeft: t,
    containerTop: n,
    containerWidth: r,
    hasScalableSrc: o,
    offset: i,
    targetHeight: s,
    targetWidth: a,
  }) => {
    const l = fs({
      containerHeight: e,
      containerWidth: r,
      hasScalableSrc: o,
      offset: i,
      targetHeight: s,
      targetWidth: a,
    })
    return {
      top: n,
      left: t,
      width: r * l,
      height: e * l,
      transform: `translate(0,0) scale(${1 / l})`,
    }
  },
  Xn = ({ position: e, relativeNum: t }) => {
    const n = parseFloat(e)
    return e.endsWith("%") ? (t * n) / 100 : n
  },
  See = ({
    containerHeight: e,
    containerLeft: t,
    containerTop: n,
    containerWidth: r,
    hasScalableSrc: o,
    objectFit: i,
    objectPosition: s,
    offset: a,
    targetHeight: l,
    targetWidth: c,
  }) => {
    if (
      (i === "scale-down" &&
        (c <= r && l <= e ? (i = "none") : (i = "contain")),
      i === "cover" || i === "contain")
    ) {
      const u = r / c,
        d = e / l,
        f = i === "cover" ? Math.max(u, d) : Math.min(u, d),
        [p = "50%", g = "50%"] = s.split(" "),
        v = Xn({ position: p, relativeNum: r - c * f }),
        b = Xn({ position: g, relativeNum: e - l * f }),
        y = fs({
          containerHeight: l * f,
          containerWidth: c * f,
          hasScalableSrc: o,
          offset: a,
          targetHeight: l,
          targetWidth: c,
        })
      return {
        top: n + b,
        left: t + v,
        width: c * f * y,
        height: l * f * y,
        transform: `translate(0,0) scale(${1 / y})`,
      }
    } else if (i === "none") {
      const [u = "50%", d = "50%"] = s.split(" "),
        f = Xn({ position: u, relativeNum: r - c }),
        p = Xn({ position: d, relativeNum: e - l }),
        g = fs({
          containerHeight: l,
          containerWidth: c,
          hasScalableSrc: o,
          offset: a,
          targetHeight: l,
          targetWidth: c,
        })
      return {
        top: n + p,
        left: t + f,
        width: c * g,
        height: l * g,
        transform: `translate(0,0) scale(${1 / g})`,
      }
    } else if (i === "fill") {
      const u = r / c,
        d = e / l,
        f = Math.max(u, d),
        p = fs({
          containerHeight: l * f,
          containerWidth: c * f,
          hasScalableSrc: o,
          offset: a,
          targetHeight: l,
          targetWidth: c,
        })
      return {
        width: r * p,
        height: e * p,
        transform: `translate(0,0) scale(${1 / p})`,
      }
    } else return {}
  },
  _ee = ({
    backgroundPosition: e,
    backgroundSize: t,
    containerHeight: n,
    containerLeft: r,
    containerTop: o,
    containerWidth: i,
    hasScalableSrc: s,
    offset: a,
    targetHeight: l,
    targetWidth: c,
  }) => {
    if (t === "cover" || t === "contain") {
      const u = i / c,
        d = n / l,
        f = t === "cover" ? Math.max(u, d) : Math.min(u, d),
        [p = "50%", g = "50%"] = e.split(" "),
        v = Xn({ position: p, relativeNum: i - c * f }),
        b = Xn({ position: g, relativeNum: n - l * f }),
        y = fs({
          containerHeight: l * f,
          containerWidth: c * f,
          hasScalableSrc: s,
          offset: a,
          targetHeight: l,
          targetWidth: c,
        })
      return {
        top: o + b,
        left: r + v,
        width: c * f * y,
        height: l * f * y,
        transform: `translate(0,0) scale(${1 / y})`,
      }
    } else if (t === "auto") {
      const [u = "50%", d = "50%"] = e.split(" "),
        f = Xn({ position: u, relativeNum: i - c }),
        p = Xn({ position: d, relativeNum: n - l }),
        g = fs({
          containerHeight: l,
          containerWidth: c,
          hasScalableSrc: s,
          offset: a,
          targetHeight: l,
          targetWidth: c,
        })
      return {
        top: o + p,
        left: r + f,
        width: c * g,
        height: l * g,
        transform: `translate(0,0) scale(${1 / g})`,
      }
    } else {
      const [u = "50%", d = "50%"] = t.split(" "),
        f = Xn({ position: u, relativeNum: i }),
        p = Xn({ position: d, relativeNum: n }),
        g = f / c,
        v = p / l,
        b = Math.min(g, v),
        [y = "50%", x = "50%"] = e.split(" "),
        E = Xn({ position: y, relativeNum: i - c * b }),
        w = Xn({ position: x, relativeNum: n - l * b }),
        C = fs({
          containerHeight: l * b,
          containerWidth: c * b,
          hasScalableSrc: s,
          offset: a,
          targetHeight: l,
          targetWidth: c,
        })
      return {
        top: o + w,
        left: r + E,
        width: c * b * C,
        height: l * b * C,
        transform: `translate(0,0) scale(${1 / C})`,
      }
    }
  },
  kee = /\.svg$/i,
  Nee = ({
    hasZoomImg: e,
    imgSrc: t,
    isSvg: n,
    isZoomed: r,
    loadedImgEl: o,
    offset: i,
    shouldRefresh: s,
    targetEl: a,
  }) => {
    var y
    const l =
        n ||
        ((y = t == null ? void 0 : t.slice) == null
          ? void 0
          : y.call(t, 0, 18)) === "data:image/svg+xml" ||
        e ||
        !!(t && kee.test(t)),
      c = a.getBoundingClientRect(),
      u = window.getComputedStyle(a),
      d = o != null && Z1(a),
      f = o != null && !d,
      p = Cee({
        containerHeight: c.height,
        containerLeft: c.left,
        containerTop: c.top,
        containerWidth: c.width,
        hasScalableSrc: l,
        offset: i,
        targetHeight: (o == null ? void 0 : o.naturalHeight) || c.height,
        targetWidth: (o == null ? void 0 : o.naturalWidth) || c.width,
      }),
      g = f
        ? See({
            containerHeight: c.height,
            containerLeft: c.left,
            containerTop: c.top,
            containerWidth: c.width,
            hasScalableSrc: l,
            objectFit: u.objectFit,
            objectPosition: u.objectPosition,
            offset: i,
            targetHeight: (o == null ? void 0 : o.naturalHeight) || c.height,
            targetWidth: (o == null ? void 0 : o.naturalWidth) || c.width,
          })
        : void 0,
      v = d
        ? _ee({
            backgroundPosition: u.backgroundPosition,
            backgroundSize: u.backgroundSize,
            containerHeight: c.height,
            containerLeft: c.left,
            containerTop: c.top,
            containerWidth: c.width,
            hasScalableSrc: l,
            offset: i,
            targetHeight: (o == null ? void 0 : o.naturalHeight) || c.height,
            targetWidth: (o == null ? void 0 : o.naturalWidth) || c.width,
          })
        : void 0,
      b = Object.assign({}, p, g, v)
    if (r) {
      const x = window.innerWidth / 2,
        E = window.innerHeight / 2,
        w =
          parseFloat(String(b.left || 0)) +
          parseFloat(String(b.width || 0)) / 2,
        C =
          parseFloat(String(b.top || 0)) +
          parseFloat(String(b.height || 0)) / 2,
        S = x - w,
        M = E - C
      s && (b.transitionDuration = "0.01ms"),
        (b.transform = `translate(${S}px,${M}px) scale(1)`)
    }
    return b
  },
  qg = (e) => {
    if (!e) return {}
    if (uf(e)) {
      const t = e.parentElement,
        n = e.getBoundingClientRect()
      if (t) {
        const r = t.getBoundingClientRect()
        return {
          height: n.height,
          left: r.left - n.left,
          top: r.top - n.top,
          width: n.width,
        }
      } else
        return { height: n.height, left: n.left, width: n.width, top: n.top }
    } else
      return {
        height: e.offsetHeight,
        left: e.offsetLeft,
        width: e.offsetWidth,
        top: e.offsetTop,
      }
  },
  Tee = (e) => {
    const t = "-zoom",
      n = [
        "clip-path",
        "fill",
        "mask",
        "marker-start",
        "marker-mid",
        "marker-end",
      ],
      r = new Map()
    if (e.hasAttribute("id")) {
      const o = e.id,
        i = o + t
      r.set(o, i), (e.id = i)
    }
    e.querySelectorAll("[id]").forEach((o) => {
      const i = o.id,
        s = i + t
      r.set(i, s), (o.id = s)
    }),
      r.forEach((o, i) => {
        const s = `url(#${i})`,
          a = `url(#${o})`,
          l = n.map((c) => `[${c}="${s}"]`).join(", ")
        e.querySelectorAll(l).forEach((c) => {
          n.forEach((u) => {
            c.getAttribute(u) === s && c.setAttribute(u, a)
          })
        })
      }),
      e.querySelectorAll("style").forEach((o) => {
        r.forEach((i, s) => {
          o.textContent &&
            (o.textContent = o.textContent.replaceAll(`#${s}`, `#${i}`))
        })
      })
  },
  Mee = ["img", "svg", '[role="img"]', "[data-zoom]"]
    .map((e) => `${e}:not([aria-hidden="true"])`)
    .join(","),
  PS = { overflow: "", width: "" }
function Oee(e) {
  return G.createElement(wD, { ...e })
}
class wD extends G.Component {
  constructor() {
    super(...arguments),
      (this.state = {
        id: "",
        isZoomImgLoaded: !1,
        loadedImgEl: void 0,
        modalState: "UNLOADED",
        shouldRefresh: !1,
        styleGhost: {},
      }),
      (this.refContent = G.createRef()),
      (this.refDialog = G.createRef()),
      (this.refModalContent = G.createRef()),
      (this.refModalImg = G.createRef()),
      (this.refWrap = G.createRef()),
      (this.imgEl = null),
      (this.isScaling = !1),
      (this.prevBodyAttrs = PS),
      (this.styleModalImg = {}),
      (this.handleModalStateChange = (t) => {
        var r, o, i, s
        const { modalState: n } = this.state
        t !== "LOADING" && n === "LOADING"
          ? (this.loadZoomImg(),
            window.addEventListener("resize", this.handleResize, {
              passive: !0,
            }),
            window.addEventListener("touchstart", this.handleTouchStart, {
              passive: !0,
            }),
            window.addEventListener("touchmove", this.handleTouchMove, {
              passive: !0,
            }),
            window.addEventListener("touchend", this.handleTouchEnd, {
              passive: !0,
            }),
            window.addEventListener("touchcancel", this.handleTouchCancel, {
              passive: !0,
            }),
            document.addEventListener("keydown", this.handleKeyDown, !0))
          : t !== "LOADED" && n === "LOADED"
            ? window.addEventListener("wheel", this.handleWheel, {
                passive: !0,
              })
            : t !== "UNLOADING" && n === "UNLOADING"
              ? (this.ensureImgTransitionEnd(),
                window.removeEventListener("wheel", this.handleWheel),
                window.removeEventListener("touchstart", this.handleTouchStart),
                window.removeEventListener("touchmove", this.handleTouchMove),
                window.removeEventListener("touchend", this.handleTouchEnd),
                window.removeEventListener(
                  "touchcancel",
                  this.handleTouchCancel
                ),
                document.removeEventListener("keydown", this.handleKeyDown, !0))
              : t !== "UNLOADED" &&
                n === "UNLOADED" &&
                (this.bodyScrollEnable(),
                window.removeEventListener("resize", this.handleResize),
                (o =
                  (r = this.refModalImg.current) == null
                    ? void 0
                    : r.removeEventListener) == null ||
                  o.call(r, "transitionend", this.handleImgTransitionEnd),
                (s = (i = this.refDialog.current) == null ? void 0 : i.close) ==
                  null || s.call(i))
      }),
      (this.getDialogContainer = () => {
        let t = document.querySelector("[data-rmiz-portal]")
        return (
          t == null &&
            ((t = document.createElement("div")),
            t.setAttribute("data-rmiz-portal", ""),
            document.body.appendChild(t)),
          t
        )
      }),
      (this.setId = () => {
        const t = () => Math.random().toString(16).slice(-4)
        this.setState({ id: t() + t() + t() })
      }),
      (this.setAndTrackImg = () => {
        var n, r
        const t = this.refContent.current
        t &&
          ((this.imgEl = t.querySelector(Mee)),
          this.imgEl
            ? ((r =
                (n = this.contentNotFoundChangeObserver) == null
                  ? void 0
                  : n.disconnect) == null || r.call(n),
              this.imgEl.addEventListener("load", this.handleImgLoad),
              this.imgEl.addEventListener("click", this.handleZoom),
              this.state.loadedImgEl || this.handleImgLoad(),
              (this.imgElResizeObserver = new ResizeObserver((o) => {
                const i = o[0]
                i != null &&
                  i.target &&
                  ((this.imgEl = i.target),
                  this.setState({ styleGhost: qg(this.imgEl) }))
              })),
              this.imgElResizeObserver.observe(this.imgEl),
              this.contentChangeObserver ||
                ((this.contentChangeObserver = new MutationObserver(() => {
                  this.setState({ styleGhost: qg(this.imgEl) })
                })),
                this.contentChangeObserver.observe(t, {
                  attributes: !0,
                  childList: !0,
                  subtree: !0,
                })))
            : this.contentNotFoundChangeObserver ||
              ((this.contentNotFoundChangeObserver = new MutationObserver(
                this.setAndTrackImg
              )),
              this.contentNotFoundChangeObserver.observe(t, {
                childList: !0,
                subtree: !0,
              })))
      }),
      (this.handleIfZoomChanged = (t) => {
        const { isZoomed: n } = this.props
        !t && n ? this.zoom() : t && !n && this.unzoom()
      }),
      (this.handleImgLoad = () => {
        const t = LS(this.imgEl)
        if (!t) return
        const n = new Image()
        kp(this.imgEl) &&
          ((n.sizes = this.imgEl.sizes),
          (n.srcset = this.imgEl.srcset),
          (n.crossOrigin = this.imgEl.crossOrigin)),
          (n.src = t)
        const r = () => {
          this.setState({ loadedImgEl: n, styleGhost: qg(this.imgEl) })
        }
        n.decode()
          .then(r)
          .catch(() => {
            if (DS(n)) {
              r()
              return
            }
            n.onload = r
          })
      }),
      (this.handleZoom = () => {
        var t, n
        this.hasImage() &&
          ((n = (t = this.props).onZoomChange) == null || n.call(t, !0))
      }),
      (this.handleUnzoom = () => {
        var t, n
        ;(n = (t = this.props).onZoomChange) == null || n.call(t, !1)
      }),
      (this.handleBtnUnzoomClick = (t) => {
        t.preventDefault(), t.stopPropagation(), this.handleUnzoom()
      }),
      (this.handleDialogCancel = (t) => {
        t.preventDefault()
      }),
      (this.handleDialogClick = (t) => {
        ;(t.target === this.refModalContent.current ||
          t.target === this.refModalImg.current) &&
          (t.stopPropagation(), this.handleUnzoom())
      }),
      (this.handleDialogClose = (t) => {
        t.stopPropagation(), this.handleUnzoom()
      }),
      (this.handleKeyDown = (t) => {
        ;(t.key === "Escape" || t.keyCode === 27) &&
          (t.preventDefault(), t.stopPropagation(), this.handleUnzoom())
      }),
      (this.handleWheel = (t) => {
        t.ctrlKey ||
          (t.stopPropagation(),
          queueMicrotask(() => {
            this.handleUnzoom()
          }))
      }),
      (this.handleTouchStart = (t) => {
        if (t.touches.length > 1) {
          this.isScaling = !0
          return
        }
        t.changedTouches.length === 1 &&
          t.changedTouches[0] &&
          (this.touchYStart = t.changedTouches[0].screenY)
      }),
      (this.handleTouchMove = (t) => {
        var r, o
        const n =
          (o = (r = window.visualViewport) == null ? void 0 : r.scale) != null
            ? o
            : 1
        if (
          this.props.canSwipeToUnzoom &&
          !this.isScaling &&
          n <= 1 &&
          this.touchYStart != null &&
          t.changedTouches[0]
        ) {
          this.touchYEnd = t.changedTouches[0].screenY
          const i = Math.max(this.touchYStart, this.touchYEnd),
            s = Math.min(this.touchYStart, this.touchYEnd)
          Math.abs(i - s) > this.props.swipeToUnzoomThreshold &&
            ((this.touchYStart = void 0),
            (this.touchYEnd = void 0),
            this.handleUnzoom())
        }
      }),
      (this.handleTouchEnd = () => {
        ;(this.isScaling = !1),
          (this.touchYStart = void 0),
          (this.touchYEnd = void 0)
      }),
      (this.handleTouchCancel = () => {
        ;(this.isScaling = !1),
          (this.touchYStart = void 0),
          (this.touchYEnd = void 0)
      }),
      (this.handleResize = () => {
        this.setState({ shouldRefresh: !0 })
      }),
      (this.hasImage = () =>
        this.imgEl &&
        (this.state.loadedImgEl || uf(this.imgEl)) &&
        window.getComputedStyle(this.imgEl).display !== "none"),
      (this.zoom = () => {
        var t, n, r, o
        this.bodyScrollDisable(),
          (n = (t = this.refDialog.current) == null ? void 0 : t.showModal) ==
            null || n.call(t),
          (o =
            (r = this.refModalImg.current) == null
              ? void 0
              : r.addEventListener) == null ||
            o.call(r, "transitionend", this.handleImgTransitionEnd),
          this.setState({ modalState: "LOADING" })
      }),
      (this.unzoom = () => {
        this.setState({ modalState: "UNLOADING" })
      }),
      (this.handleImgTransitionEnd = () => {
        clearTimeout(this.timeoutTransitionEnd),
          this.state.modalState === "LOADING"
            ? this.setState({ modalState: "LOADED" })
            : this.state.modalState === "UNLOADING" &&
              this.setState({ shouldRefresh: !1, modalState: "UNLOADED" })
      }),
      (this.ensureImgTransitionEnd = () => {
        if (this.refModalImg.current) {
          const t = window.getComputedStyle(
              this.refModalImg.current
            ).transitionDuration,
            n = parseFloat(t)
          if (n) {
            const r = n * (t.endsWith("ms") ? 1 : 1e3) + 50
            this.timeoutTransitionEnd = setTimeout(
              this.handleImgTransitionEnd,
              r
            )
          }
        }
      }),
      (this.bodyScrollDisable = () => {
        this.prevBodyAttrs = {
          overflow: document.body.style.overflow,
          width: document.body.style.width,
        }
        const t = document.body.clientWidth
        ;(document.body.style.overflow = "hidden"),
          (document.body.style.width = `${t}px`)
      }),
      (this.bodyScrollEnable = () => {
        ;(document.body.style.width = this.prevBodyAttrs.width),
          (document.body.style.overflow = this.prevBodyAttrs.overflow),
          (this.prevBodyAttrs = PS)
      }),
      (this.loadZoomImg = () => {
        var r, o, i
        const {
            props: { zoomImg: t },
          } = this,
          n = t == null ? void 0 : t.src
        if (n) {
          const s = new Image()
          ;(s.sizes = (r = t == null ? void 0 : t.sizes) != null ? r : ""),
            (s.srcset = (o = t == null ? void 0 : t.srcSet) != null ? o : ""),
            (s.crossOrigin =
              (i = t == null ? void 0 : t.crossOrigin) != null ? i : void 0),
            (s.src = n)
          const a = () => {
            this.setState({ isZoomImgLoaded: !0 })
          }
          s.decode()
            .then(a)
            .catch(() => {
              if (DS(s)) {
                a()
                return
              }
              s.onload = a
            })
        }
      }),
      (this.UNSAFE_handleSvg = () => {
        var o, i, s, a, l
        const { imgEl: t, refModalImg: n, styleModalImg: r } = this
        if (uf(t)) {
          const c = t.cloneNode(!0)
          Tee(c),
            (c.style.width = `${r.width || 0}px`),
            (c.style.height = `${r.height || 0}px`),
            c.addEventListener("click", this.handleUnzoom),
            (s =
              (i = (o = n.current) == null ? void 0 : o.firstChild) == null
                ? void 0
                : i.remove) == null || s.call(i),
            (l = (a = n.current) == null ? void 0 : a.appendChild) == null ||
              l.call(a, c)
        }
      })
  }
  render() {
    const {
        handleBtnUnzoomClick: t,
        handleDialogCancel: n,
        handleDialogClick: r,
        handleDialogClose: o,
        handleUnzoom: i,
        handleZoom: s,
        imgEl: a,
        props: {
          a11yNameButtonUnzoom: l,
          a11yNameButtonZoom: c,
          children: u,
          classDialog: d,
          IconUnzoom: f,
          IconZoom: p,
          isZoomed: g,
          wrapElement: v,
          ZoomContent: b,
          zoomImg: y,
          zoomMargin: x,
        },
        refContent: E,
        refDialog: w,
        refModalContent: C,
        refModalImg: S,
        refWrap: M,
        state: {
          id: N,
          isZoomImgLoaded: R,
          loadedImgEl: B,
          modalState: V,
          shouldRefresh: j,
          styleGhost: U,
        },
      } = this,
      W = `rmiz-modal-${N}`,
      ee = `rmiz-modal-img-${N}`,
      I = Z1(a),
      O = kp(a),
      _ = uf(a),
      A = Eee(a),
      P = LS(a),
      H = O ? a.sizes : void 0,
      X = O ? a.srcset : void 0,
      ae = O ? a.crossOrigin : void 0,
      ve = !!(y != null && y.src),
      he = this.hasImage(),
      xe = A ? `${c}: ${A}` : c,
      Ae = V === "LOADING" || V === "LOADED",
      je = he ? "found" : "not-found",
      Fe = V === "UNLOADED" || V === "UNLOADING" ? "hidden" : "visible",
      Ze = { visibility: V === "UNLOADED" ? "visible" : "hidden" }
    this.styleModalImg = he
      ? Nee({
          hasZoomImg: ve,
          imgSrc: P,
          isSvg: _,
          isZoomed: g && Ae,
          loadedImgEl: B,
          offset: x,
          shouldRefresh: j,
          targetEl: a,
        })
      : {}
    let dt = null
    if (he) {
      const kt =
          O || I
            ? G.createElement("img", {
                alt: A,
                crossOrigin: ae,
                sizes: H,
                src: P,
                srcSet: X,
                ...(R && V === "LOADED" ? y : {}),
                "data-rmiz-modal-img": "",
                height: this.styleModalImg.height || void 0,
                id: ee,
                ref: S,
                style: this.styleModalImg,
                width: this.styleModalImg.width || void 0,
              })
            : _
              ? G.createElement("div", {
                  "data-rmiz-modal-img": !0,
                  ref: S,
                  style: this.styleModalImg,
                })
              : null,
        ft = G.createElement(
          "button",
          {
            "aria-label": l,
            "data-rmiz-btn-unzoom": "",
            onClick: t,
            type: "button",
          },
          G.createElement(f, null)
        )
      dt = b
        ? G.createElement(b, {
            buttonUnzoom: ft,
            modalState: V,
            img: kt,
            onUnzoom: i,
          })
        : G.createElement(G.Fragment, null, kt, ft)
    }
    return G.createElement(
      v,
      { "aria-owns": W, "data-rmiz": "", ref: M },
      G.createElement(v, { "data-rmiz-content": je, ref: E, style: Ze }, u),
      he &&
        G.createElement(
          v,
          { "data-rmiz-ghost": "", style: U },
          G.createElement(
            "button",
            {
              "aria-label": xe,
              "data-rmiz-btn-zoom": "",
              onClick: s,
              type: "button",
            },
            G.createElement(p, null)
          )
        ),
      he &&
        vh.createPortal(
          G.createElement(
            "dialog",
            {
              "aria-labelledby": ee,
              "aria-modal": "true",
              className: d,
              "data-rmiz-modal": "",
              id: W,
              onClick: r,
              onClose: o,
              onCancel: n,
              ref: w,
              role: "dialog",
            },
            G.createElement("div", { "data-rmiz-modal-overlay": Fe }),
            G.createElement(
              "div",
              { "data-rmiz-modal-content": "", ref: C },
              dt
            )
          ),
          this.getDialogContainer()
        )
    )
  }
  componentDidMount() {
    this.setId(),
      this.setAndTrackImg(),
      this.handleImgLoad(),
      this.UNSAFE_handleSvg()
  }
  componentWillUnmount() {
    var t, n, r, o, i, s, a, l, c, u, d, f
    this.state.modalState !== "UNLOADED" && this.bodyScrollEnable(),
      (n = (t = this.contentChangeObserver) == null ? void 0 : t.disconnect) ==
        null || n.call(t),
      (o =
        (r = this.contentNotFoundChangeObserver) == null
          ? void 0
          : r.disconnect) == null || o.call(r),
      (s = (i = this.imgElResizeObserver) == null ? void 0 : i.disconnect) ==
        null || s.call(i),
      (l = (a = this.imgEl) == null ? void 0 : a.removeEventListener) == null ||
        l.call(a, "load", this.handleImgLoad),
      (u = (c = this.imgEl) == null ? void 0 : c.removeEventListener) == null ||
        u.call(c, "click", this.handleZoom),
      (f =
        (d = this.refModalImg.current) == null
          ? void 0
          : d.removeEventListener) == null ||
        f.call(d, "transitionend", this.handleImgTransitionEnd),
      window.removeEventListener("wheel", this.handleWheel),
      window.removeEventListener("touchstart", this.handleTouchStart),
      window.removeEventListener("touchmove", this.handleTouchMove),
      window.removeEventListener("touchend", this.handleTouchEnd),
      window.removeEventListener("touchcancel", this.handleTouchCancel),
      window.removeEventListener("resize", this.handleResize),
      document.removeEventListener("keydown", this.handleKeyDown, !0)
  }
  componentDidUpdate(t, n) {
    this.handleModalStateChange(n.modalState),
      this.UNSAFE_handleSvg(),
      this.handleIfZoomChanged(t.isZoomed)
  }
}
wD.defaultProps = {
  a11yNameButtonUnzoom: "Minimize image",
  a11yNameButtonZoom: "Expand image",
  canSwipeToUnzoom: !0,
  IconUnzoom: yee,
  IconZoom: bee,
  swipeToUnzoomThreshold: 10,
  wrapElement: "div",
  zoomMargin: 0,
}
const Y1 = m.memo(
  m.forwardRef(({ children: e, className: t, ...n }, r) =>
    h.jsx("div", {
      ref: r,
      className: q(
        "absolute right-3 top-3 flex flex-row rounded px-0.5 opacity-0 group-hover/node-image:opacity-100",
        "border-[0.5px] bg-[var(--mt-bg-secondary)] [backdrop-filter:saturate(1.8)_blur(20px)]",
        t
      ),
      ...n,
      children: e,
    })
  )
)
Y1.displayName = "ActionWrapper"
const Np = m.memo(
  m.forwardRef(({ icon: e, tooltip: t, className: n, ...r }, o) =>
    h.jsxs(Ih, {
      children: [
        h.jsx(Dh, {
          asChild: !0,
          children: h.jsx(et, {
            ref: o,
            variant: "ghost",
            className: q(
              "relative flex h-7 w-7 flex-row rounded-none p-0 text-muted-foreground hover:text-foreground",
              "bg-transparent hover:bg-transparent",
              n
            ),
            ...r,
            children: e,
          }),
        }),
        h.jsx(Tu, { side: "bottom", children: t }),
      ],
    })
  )
)
Np.displayName = "ActionButton"
const Aee = [
    {
      key: "onView",
      icon: h.jsx(cG, { className: "size-4" }),
      tooltip: "View image",
    },
    {
      key: "onDownload",
      icon: h.jsx(UK, { className: "size-4" }),
      tooltip: "Download image",
    },
    {
      key: "onCopy",
      icon: h.jsx(DK, { className: "size-4" }),
      tooltip: "Copy image to clipboard",
    },
    {
      key: "onCopyLink",
      icon: h.jsx(eG, { className: "size-4" }),
      tooltip: "Copy image link",
      isLink: !0,
    },
  ],
  ED = m.memo(({ shouldMerge: e = !1, isLink: t = !1, ...n }) => {
    const [r, o] = m.useState(!1),
      i = m.useCallback((a, l) => {
        a.preventDefault(), a.stopPropagation(), l == null || l()
      }, []),
      s = m.useMemo(() => Aee.filter((a) => t || !a.isLink), [t])
    return h.jsx(Y1, {
      className: q({ "opacity-100": r }),
      children: e
        ? h.jsxs(M1, {
            open: r,
            onOpenChange: o,
            children: [
              h.jsx(O1, {
                asChild: !0,
                children: h.jsx(Np, {
                  icon: h.jsx(VA, { className: "size-4" }),
                  tooltip: "Open menu",
                  onClick: (a) => a.preventDefault(),
                }),
              }),
              h.jsx(vm, {
                className: "w-56",
                align: "end",
                children: s.map(({ key: a, icon: l, tooltip: c }) =>
                  h.jsx(
                    ym,
                    {
                      onClick: (u) => i(u, n[a]),
                      children: h.jsxs("div", {
                        className: "flex flex-row items-center gap-2",
                        children: [l, h.jsx("span", { children: c })],
                      }),
                    },
                    a
                  )
                ),
              }),
            ],
          })
        : s.map(({ key: a, icon: l, tooltip: c }) =>
            h.jsx(Np, { icon: l, tooltip: c, onClick: (u) => i(u, n[a]) }, a)
          ),
    })
  })
ED.displayName = "ImageActions"
const Ree = ({ editor: e, node: t, src: n, onViewClick: r }) => {
    const o = m.useMemo(() => Wy(n), [n]),
      i = m.useCallback(() => {
        r(!0)
      }, [r]),
      s = m.useCallback(() => {
        e.commands.downloadImage({ src: t.attrs.src, alt: t.attrs.alt })
      }, [e.commands, t.attrs.alt, t.attrs.src]),
      a = m.useCallback(() => {
        e.commands.copyImage({ src: t.attrs.src })
      }, [e.commands, t.attrs.src]),
      l = m.useCallback(() => {
        e.commands.copyLink({ src: t.attrs.src })
      }, [e.commands, t.attrs.src]),
      c = m.useCallback(() => {
        e.commands.command(({ tr: u, dispatch: d }) => {
          const { selection: f } = u,
            p = u.doc.nodeAt(f.from)
          return p && p.type.name === "image" && d
            ? (u.deleteSelection(), !0)
            : !1
        })
      }, [e.commands])
    return {
      isLink: o,
      onView: i,
      onDownload: s,
      onCopy: a,
      onCopyLink: l,
      onRemoveImg: c,
    }
  },
  CD = m.forwardRef(function ({ className: t, ...n }, r) {
    return h.jsxs("svg", {
      ref: r,
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      className: q("animate-spin", t),
      ...n,
      children: [
        h.jsx("circle", {
          className: "opacity-25",
          cx: "12",
          cy: "12",
          r: "10",
          stroke: "currentColor",
          strokeWidth: "4",
        }),
        h.jsx("path", {
          className: "opacity-75",
          fill: "currentColor",
          d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z",
        }),
      ],
    })
  })
CD.displayName = "Spinner"
const SD = m.memo(CD),
  _D = m.memo(() =>
    h.jsx("div", {
      className: q(
        "flex flex-row items-center justify-center",
        "absolute inset-0 rounded bg-[var(--mt-overlay)] opacity-100 transition-opacity"
      ),
      children: h.jsx(SD, { className: "size-7" }),
    })
  )
_D.displayName = "ImageOverlay"
const Zg = 600,
  Iee = 120,
  $S = 120,
  Dee = (e) => ({
    src: typeof e == "string" ? e : e.src,
    id: typeof e == "string" ? pu() : e.id,
  }),
  Lee = ({ editor: e, node: t, selected: n, updateAttributes: r }) => {
    const { src: o, width: i, height: s, fileName: a } = t.attrs,
      l = m.useRef(!1),
      c = m.useMemo(() => (typeof o == "string" ? o : o.src), [o]),
      [u, d] = m.useState({
        src: c,
        isServerUploading: !1,
        imageLoaded: !1,
        isZoomed: !1,
        error: !1,
        naturalSize: { width: i, height: s },
      }),
      f = m.useRef(null),
      [p, g] = m.useState(null),
      v = m.useCallback(
        ({ width: A, height: P }) => {
          r({ width: A, height: P })
        },
        [r]
      ),
      b = u.naturalSize.width / u.naturalSize.height,
      y = Zg * b,
      x = f.current
        ? parseFloat(
            getComputedStyle(f.current).getPropertyValue("--editor-width")
          )
        : 1 / 0,
      {
        isLink: E,
        onView: w,
        onDownload: C,
        onCopy: S,
        onCopyLink: M,
        onRemoveImg: N,
      } = Ree({
        editor: e,
        node: t,
        src: u.src,
        onViewClick: (A) => d((P) => ({ ...P, isZoomed: A })),
      }),
      {
        currentWidth: R,
        currentHeight: B,
        updateDimensions: V,
        initiateResize: j,
        isResizing: U,
      } = vee({
        initialWidth: i != null ? i : u.naturalSize.width,
        initialHeight: s != null ? s : u.naturalSize.height,
        contentWidth: u.naturalSize.width,
        contentHeight: u.naturalSize.height,
        gridInterval: 0.1,
        onDimensionsChange: v,
        minWidth: $S,
        minHeight: Iee,
        maxWidth: x > 0 ? x : y,
      }),
      W = m.useMemo(() => R <= 180, [R]),
      ee = m.useCallback(
        (A) => {
          const P = A.target,
            H = { width: P.naturalWidth, height: P.naturalHeight }
          d((X) => ({ ...X, naturalSize: H, imageLoaded: !0 })),
            r({
              width: P.width || H.width,
              height: P.height || H.height,
              alt: P.alt,
              title: P.title,
            }),
            i || V((X) => ({ ...X, width: H.width }))
        },
        [i, r, V]
      ),
      I = m.useCallback(() => {
        d((A) => ({ ...A, error: !0, imageLoaded: !0 }))
      }, []),
      O = m.useCallback(
        (A) => (P) => {
          g(A), j(A)(P)
        },
        [j]
      ),
      _ = m.useCallback(() => {
        g(null)
      }, [])
    return (
      m.useEffect(() => {
        U || _()
      }, [U, _]),
      m.useEffect(() => {
        ;(async () => {
          var X
          if (!c.startsWith("blob:") || l.current) return
          l.current = !0
          const P = e.options.extensions.find((ae) => ae.name === "image"),
            { uploadFn: H } =
              (X = P == null ? void 0 : P.options) != null ? X : {}
          if (!H) {
            try {
              const ae = await Pq(c)
              d((ve) => ({ ...ve, src: ae })), r({ src: ae })
            } catch {
              d((ae) => ({ ...ae, error: !0 }))
            }
            return
          }
          try {
            d((je) => ({ ...je, isServerUploading: !0 }))
            const ve = await (await fetch(c)).blob(),
              he = new File([ve], a, { type: ve.type }),
              xe = await H(he, e),
              Ae = Dee(xe)
            d((je) => ({ ...je, ...Ae, isServerUploading: !1 })), r(Ae)
          } catch {
            d((ve) => ({ ...ve, error: !0, isServerUploading: !1 }))
          }
        })()
      }, [e, a, c, r]),
      h.jsx(SK, {
        ref: f,
        "data-drag-handle": !0,
        className: "relative text-center leading-none",
        children: h.jsx("div", {
          className:
            "group/node-image relative mx-auto rounded-md object-contain",
          style: {
            maxWidth: `min(${y}px, 100%)`,
            width: R,
            maxHeight: Zg,
            aspectRatio: `${u.naturalSize.width} / ${u.naturalSize.height}`,
          },
          children: h.jsxs("div", {
            className: q(
              "relative flex h-full cursor-default flex-col items-center gap-2 rounded",
              { "outline outline-2 outline-offset-1 outline-primary": n || U }
            ),
            children: [
              h.jsxs("div", {
                className: "h-full contain-paint",
                children: [
                  h.jsxs("div", {
                    className: "relative h-full",
                    children: [
                      u.isServerUploading &&
                        !u.error &&
                        h.jsx("div", {
                          className:
                            "absolute inset-0 flex items-center justify-center",
                          children: h.jsx(SD, { className: "size-7" }),
                        }),
                      u.error &&
                        h.jsxs("div", {
                          className:
                            "absolute inset-0 flex flex-col items-center justify-center",
                          children: [
                            h.jsx(YK, { className: "size-8 text-destructive" }),
                            h.jsx("p", {
                              className: "mt-2 text-sm text-muted-foreground",
                              children: "Failed to load image",
                            }),
                          ],
                        }),
                      h.jsx(Oee, {
                        isZoomed: u.isZoomed,
                        onZoomChange: () => d((A) => ({ ...A, isZoomed: !1 })),
                        children: h.jsx("img", {
                          className: q(
                            "h-auto rounded object-contain transition-shadow",
                            { "opacity-0": !u.imageLoaded || u.error }
                          ),
                          style: {
                            maxWidth: `min(100%, ${y}px)`,
                            minWidth: `${$S}px`,
                            maxHeight: Zg,
                          },
                          width: R,
                          height: B,
                          src: u.src,
                          onError: I,
                          onLoad: ee,
                          alt: t.attrs.alt || "",
                          title: t.attrs.title || "",
                          id: t.attrs.id,
                        }),
                      }),
                    ],
                  }),
                  u.isServerUploading && h.jsx(_D, {}),
                  e.isEditable &&
                    u.imageLoaded &&
                    !u.error &&
                    !u.isServerUploading &&
                    h.jsxs(h.Fragment, {
                      children: [
                        h.jsx(Gy, {
                          onPointerDown: O("left"),
                          className: q("left-1", {
                            hidden: U && p === "right",
                          }),
                          isResizing: U && p === "left",
                        }),
                        h.jsx(Gy, {
                          onPointerDown: O("right"),
                          className: q("right-1", {
                            hidden: U && p === "left",
                          }),
                          isResizing: U && p === "right",
                        }),
                      ],
                    }),
                ],
              }),
              u.error &&
                h.jsx(Y1, {
                  children: h.jsx(Np, {
                    icon: h.jsx(mG, { className: "size-4" }),
                    tooltip: "Remove image",
                    onClick: N,
                  }),
                }),
              !U &&
                !u.error &&
                !u.isServerUploading &&
                h.jsx(ED, {
                  shouldMerge: W,
                  isLink: E,
                  onView: w,
                  onDownload: C,
                  onCopy: S,
                  onCopyLink: M,
                }),
            ],
          }),
        }),
      })
    )
  },
  X1 = (e, t, n) => {
    const r = e instanceof Error ? e : new Error("Unknown error")
    n == null || n(r, t)
  },
  Pee = (e) => {
    const [t, n] = e.split(","),
      r = t.split(":")[1].split(";")[0],
      o = r.split("/")[1],
      i = atob(n),
      s = new Uint8Array(i.length)
    for (let l = 0; l < i.length; l++) s[l] = i.charCodeAt(l)
    return { blob: new Blob([s], { type: r }), extension: o }
  },
  $ee = async (e) => {
    const t = await fetch(e)
    if (!t.ok) throw new Error("Failed to fetch image")
    const n = await t.blob(),
      r = n.type.split(/\/|\+/)[1]
    return { blob: n, extension: r }
  },
  Bee = async (e) => (e.startsWith("data:") ? Pee(e) : $ee(e)),
  jee = async (e, t, n) => {
    const r = URL.createObjectURL(e),
      o = document.createElement("a")
    ;(o.href = r),
      (o.download = `${t}.${n}`),
      document.body.appendChild(o),
      o.click(),
      document.body.removeChild(o),
      URL.revokeObjectURL(r)
  },
  Fee = async (e, t) => {
    var i
    const { src: n, alt: r } = e,
      o = r || "image"
    try {
      const { blob: s, extension: a } = await Bee(n)
      await jee(s, o, a),
        (i = t.onActionSuccess) == null ||
          i.call(t, { ...e, action: "download" })
    } catch (s) {
      X1(s, { ...e, action: "download" }, t.onActionError)
    }
  },
  zee = async (e, t) => {
    var r
    const { src: n } = e
    try {
      const i = await (await fetch(n)).blob()
      await navigator.clipboard.write([new ClipboardItem({ [i.type]: i })]),
        (r = t.onActionSuccess) == null ||
          r.call(t, { ...e, action: "copyImage" })
    } catch (o) {
      X1(o, { ...e, action: "copyImage" }, t.onActionError)
    }
  },
  Uee = async (e, t) => {
    var r
    const { src: n } = e
    try {
      await navigator.clipboard.writeText(n),
        (r = t.onActionSuccess) == null ||
          r.call(t, { ...e, action: "copyLink" })
    } catch (o) {
      X1(o, { ...e, action: "copyLink" }, t.onActionError)
    }
  },
  Vee = gee.extend({
    atom: !0,
    addOptions() {
      var e
      return {
        ...((e = this.parent) == null ? void 0 : e.call(this)),
        allowedMimeTypes: [],
        maxFileSize: 0,
        uploadFn: void 0,
        onToggle: void 0,
        downloadImage: void 0,
        copyImage: void 0,
        copyLink: void 0,
      }
    },
    addAttributes() {
      return {
        src: { default: null },
        alt: { default: null },
        title: { default: null },
        id: { default: null },
        width: { default: null },
        height: { default: null },
        fileName: { default: null },
      }
    },
    addCommands() {
      return {
        setImages:
          (e) =>
          ({ commands: t }) => {
            const [n, r] = yp(e, {
              allowedMimeTypes: this.options.allowedMimeTypes,
              maxFileSize: this.options.maxFileSize,
              allowBase64: this.options.allowBase64,
            })
            return (
              r.length > 0 &&
                this.options.onValidationError &&
                this.options.onValidationError(r),
              n.length > 0
                ? t.insertContent(
                    n.map((o) => {
                      if (o.src instanceof File) {
                        const i = URL.createObjectURL(o.src),
                          s = pu()
                        return {
                          type: this.type.name,
                          attrs: {
                            id: s,
                            src: i,
                            alt: o.alt,
                            title: o.title,
                            fileName: o.src.name,
                          },
                        }
                      } else
                        return {
                          type: this.type.name,
                          attrs: {
                            id: pu(),
                            src: o.src,
                            alt: o.alt,
                            title: o.title,
                            fileName: null,
                          },
                        }
                    })
                  )
                : !1
            )
          },
        downloadImage: (e) => () => (
          (this.options.downloadImage || Fee)(
            { ...e, action: "download" },
            this.options
          ),
          !0
        ),
        copyImage: (e) => () => (
          (this.options.copyImage || zee)(
            { ...e, action: "copyImage" },
            this.options
          ),
          !0
        ),
        copyLink: (e) => () => (
          (this.options.copyLink || Uee)(
            { ...e, action: "copyLink" },
            this.options
          ),
          !0
        ),
        toggleImage:
          () =>
          ({ editor: e }) => {
            const t = document.createElement("input")
            return (
              (t.type = "file"),
              (t.accept = this.options.allowedMimeTypes.join(",")),
              (t.onchange = () => {
                const n = t.files
                if (!n) return
                const [r, o] = yp(Array.from(n), {
                  allowedMimeTypes: this.options.allowedMimeTypes,
                  maxFileSize: this.options.maxFileSize,
                  allowBase64: this.options.allowBase64,
                })
                return o.length > 0 && this.options.onValidationError
                  ? (this.options.onValidationError(o), !1)
                  : (r.length === 0 ||
                      (this.options.onToggle &&
                        this.options.onToggle(e, r, e.state.selection.from)),
                    !1)
              }),
              t.click(),
              !0
            )
          },
      }
    },
    onTransaction({ transaction: e }) {
      e.steps.forEach((t) => {
        t instanceof Mt &&
          t.slice.size === 0 &&
          e.before.content.cut(t.from, t.to).forEach((r) => {
            var o, i
            if (r.type.name === "image") {
              const s = r.attrs
              s.src.startsWith("blob:") && URL.revokeObjectURL(s.src),
                (i = (o = this.options).onImageRemoved) == null || i.call(o, s)
            }
          })
      })
    },
    addNodeView() {
      return MK(Lee, { className: "block-node" })
    },
  }),
  Hee =
    "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
  Wee =
    "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
  cl = (e, t) => {
    for (const n in t) e[n] = t[n]
    return e
  },
  qy = "numeric",
  Zy = "ascii",
  Yy = "alpha",
  vc = "asciinumeric",
  Yl = "alphanumeric",
  Xy = "domain",
  kD = "emoji",
  Kee = "scheme",
  Gee = "slashscheme",
  Yg = "whitespace"
function qee(e, t) {
  return e in t || (t[e] = []), t[e]
}
function Ji(e, t, n) {
  t[qy] && ((t[vc] = !0), (t[Yl] = !0)),
    t[Zy] && ((t[vc] = !0), (t[Yy] = !0)),
    t[vc] && (t[Yl] = !0),
    t[Yy] && (t[Yl] = !0),
    t[Yl] && (t[Xy] = !0),
    t[kD] && (t[Xy] = !0)
  for (const r in t) {
    const o = qee(r, n)
    o.indexOf(e) < 0 && o.push(e)
  }
}
function Zee(e, t) {
  const n = {}
  for (const r in t) t[r].indexOf(e) >= 0 && (n[r] = !0)
  return n
}
function Cn(e = null) {
  ;(this.j = {}), (this.jr = []), (this.jd = null), (this.t = e)
}
Cn.groups = {}
Cn.prototype = {
  accepts() {
    return !!this.t
  },
  go(e) {
    const t = this,
      n = t.j[e]
    if (n) return n
    for (let r = 0; r < t.jr.length; r++) {
      const o = t.jr[r][0],
        i = t.jr[r][1]
      if (i && o.test(e)) return i
    }
    return t.jd
  },
  has(e, t = !1) {
    return t ? e in this.j : !!this.go(e)
  },
  ta(e, t, n, r) {
    for (let o = 0; o < e.length; o++) this.tt(e[o], t, n, r)
  },
  tr(e, t, n, r) {
    r = r || Cn.groups
    let o
    return (
      t && t.j ? (o = t) : ((o = new Cn(t)), n && r && Ji(t, n, r)),
      this.jr.push([e, o]),
      o
    )
  },
  ts(e, t, n, r) {
    let o = this
    const i = e.length
    if (!i) return o
    for (let s = 0; s < i - 1; s++) o = o.tt(e[s])
    return o.tt(e[i - 1], t, n, r)
  },
  tt(e, t, n, r) {
    r = r || Cn.groups
    const o = this
    if (t && t.j) return (o.j[e] = t), t
    const i = t
    let s,
      a = o.go(e)
    if (
      (a
        ? ((s = new Cn()),
          cl(s.j, a.j),
          s.jr.push.apply(s.jr, a.jr),
          (s.jd = a.jd),
          (s.t = a.t))
        : (s = new Cn()),
      i)
    ) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const l = cl(Zee(s.t, r), n)
          Ji(i, l, r)
        } else n && Ji(i, n, r)
      s.t = i
    }
    return (o.j[e] = s), s
  },
}
const Te = (e, t, n, r, o) => e.ta(t, n, r, o),
  pt = (e, t, n, r, o) => e.tr(t, n, r, o),
  BS = (e, t, n, r, o) => e.ts(t, n, r, o),
  Q = (e, t, n, r, o) => e.tt(t, n, r, o),
  fo = "WORD",
  Qy = "UWORD",
  ND = "ASCIINUMERICAL",
  TD = "ALPHANUMERICAL",
  yu = "LOCALHOST",
  Jy = "TLD",
  e0 = "UTLD",
  df = "SCHEME",
  sa = "SLASH_SCHEME",
  Q1 = "NUM",
  t0 = "WS",
  J1 = "NL",
  yc = "OPENBRACE",
  bc = "CLOSEBRACE",
  Tp = "OPENBRACKET",
  Mp = "CLOSEBRACKET",
  Op = "OPENPAREN",
  Ap = "CLOSEPAREN",
  Rp = "OPENANGLEBRACKET",
  Ip = "CLOSEANGLEBRACKET",
  Dp = "FULLWIDTHLEFTPAREN",
  Lp = "FULLWIDTHRIGHTPAREN",
  Pp = "LEFTCORNERBRACKET",
  $p = "RIGHTCORNERBRACKET",
  Bp = "LEFTWHITECORNERBRACKET",
  jp = "RIGHTWHITECORNERBRACKET",
  Fp = "FULLWIDTHLESSTHAN",
  zp = "FULLWIDTHGREATERTHAN",
  Up = "AMPERSAND",
  ex = "APOSTROPHE",
  Vp = "ASTERISK",
  Wo = "AT",
  Hp = "BACKSLASH",
  Wp = "BACKTICK",
  Kp = "CARET",
  Yo = "COLON",
  tx = "COMMA",
  Gp = "DOLLAR",
  jr = "DOT",
  qp = "EQUALS",
  nx = "EXCLAMATION",
  Zn = "HYPHEN",
  xc = "PERCENT",
  Zp = "PIPE",
  Yp = "PLUS",
  Xp = "POUND",
  wc = "QUERY",
  rx = "QUOTE",
  MD = "FULLWIDTHMIDDLEDOT",
  ox = "SEMI",
  Fr = "SLASH",
  Ec = "TILDE",
  Qp = "UNDERSCORE",
  OD = "EMOJI",
  Jp = "SYM"
var AD = Object.freeze({
  __proto__: null,
  WORD: fo,
  UWORD: Qy,
  ASCIINUMERICAL: ND,
  ALPHANUMERICAL: TD,
  LOCALHOST: yu,
  TLD: Jy,
  UTLD: e0,
  SCHEME: df,
  SLASH_SCHEME: sa,
  NUM: Q1,
  WS: t0,
  NL: J1,
  OPENBRACE: yc,
  CLOSEBRACE: bc,
  OPENBRACKET: Tp,
  CLOSEBRACKET: Mp,
  OPENPAREN: Op,
  CLOSEPAREN: Ap,
  OPENANGLEBRACKET: Rp,
  CLOSEANGLEBRACKET: Ip,
  FULLWIDTHLEFTPAREN: Dp,
  FULLWIDTHRIGHTPAREN: Lp,
  LEFTCORNERBRACKET: Pp,
  RIGHTCORNERBRACKET: $p,
  LEFTWHITECORNERBRACKET: Bp,
  RIGHTWHITECORNERBRACKET: jp,
  FULLWIDTHLESSTHAN: Fp,
  FULLWIDTHGREATERTHAN: zp,
  AMPERSAND: Up,
  APOSTROPHE: ex,
  ASTERISK: Vp,
  AT: Wo,
  BACKSLASH: Hp,
  BACKTICK: Wp,
  CARET: Kp,
  COLON: Yo,
  COMMA: tx,
  DOLLAR: Gp,
  DOT: jr,
  EQUALS: qp,
  EXCLAMATION: nx,
  HYPHEN: Zn,
  PERCENT: xc,
  PIPE: Zp,
  PLUS: Yp,
  POUND: Xp,
  QUERY: wc,
  QUOTE: rx,
  FULLWIDTHMIDDLEDOT: MD,
  SEMI: ox,
  SLASH: Fr,
  TILDE: Ec,
  UNDERSCORE: Qp,
  EMOJI: OD,
  SYM: Jp,
})
const ao = /[a-z]/,
  Bl = /\p{L}/u,
  Xg = /\p{Emoji}/u,
  lo = /\d/,
  Qg = /\s/,
  jS = "\r",
  Jg = `
`,
  Yee = "",
  Xee = "",
  ev = ""
let Fd = null,
  zd = null
function Qee(e = []) {
  const t = {}
  Cn.groups = t
  const n = new Cn()
  Fd == null && (Fd = FS(Hee)),
    zd == null && (zd = FS(Wee)),
    Q(n, "'", ex),
    Q(n, "{", yc),
    Q(n, "}", bc),
    Q(n, "[", Tp),
    Q(n, "]", Mp),
    Q(n, "(", Op),
    Q(n, ")", Ap),
    Q(n, "<", Rp),
    Q(n, ">", Ip),
    Q(n, "", Dp),
    Q(n, "", Lp),
    Q(n, "", Pp),
    Q(n, "", $p),
    Q(n, "", Bp),
    Q(n, "", jp),
    Q(n, "", Fp),
    Q(n, "", zp),
    Q(n, "&", Up),
    Q(n, "*", Vp),
    Q(n, "@", Wo),
    Q(n, "`", Wp),
    Q(n, "^", Kp),
    Q(n, ":", Yo),
    Q(n, ",", tx),
    Q(n, "$", Gp),
    Q(n, ".", jr),
    Q(n, "=", qp),
    Q(n, "!", nx),
    Q(n, "-", Zn),
    Q(n, "%", xc),
    Q(n, "|", Zp),
    Q(n, "+", Yp),
    Q(n, "#", Xp),
    Q(n, "?", wc),
    Q(n, '"', rx),
    Q(n, "/", Fr),
    Q(n, ";", ox),
    Q(n, "~", Ec),
    Q(n, "_", Qp),
    Q(n, "\\", Hp),
    Q(n, "", MD)
  const r = pt(n, lo, Q1, { [qy]: !0 })
  pt(r, lo, r)
  const o = pt(r, ao, ND, { [vc]: !0 }),
    i = pt(r, Bl, TD, { [Yl]: !0 }),
    s = pt(n, ao, fo, { [Zy]: !0 })
  pt(s, lo, o), pt(s, ao, s), pt(o, lo, o), pt(o, ao, o)
  const a = pt(n, Bl, Qy, { [Yy]: !0 })
  pt(a, ao), pt(a, lo, i), pt(a, Bl, a), pt(i, lo, i), pt(i, ao), pt(i, Bl, i)
  const l = Q(n, Jg, J1, { [Yg]: !0 }),
    c = Q(n, jS, t0, { [Yg]: !0 }),
    u = pt(n, Qg, t0, { [Yg]: !0 })
  Q(n, ev, u),
    Q(c, Jg, l),
    Q(c, ev, u),
    pt(c, Qg, u),
    Q(u, jS),
    Q(u, Jg),
    pt(u, Qg, u),
    Q(u, ev, u)
  const d = pt(n, Xg, OD, { [kD]: !0 })
  Q(d, "#"), pt(d, Xg, d), Q(d, Yee, d)
  const f = Q(d, Xee)
  Q(f, "#"), pt(f, Xg, d)
  const p = [
      [ao, s],
      [lo, o],
    ],
    g = [
      [ao, null],
      [Bl, a],
      [lo, i],
    ]
  for (let v = 0; v < Fd.length; v++) $o(n, Fd[v], Jy, fo, p)
  for (let v = 0; v < zd.length; v++) $o(n, zd[v], e0, Qy, g)
  Ji(Jy, { tld: !0, ascii: !0 }, t),
    Ji(e0, { utld: !0, alpha: !0 }, t),
    $o(n, "file", df, fo, p),
    $o(n, "mailto", df, fo, p),
    $o(n, "http", sa, fo, p),
    $o(n, "https", sa, fo, p),
    $o(n, "ftp", sa, fo, p),
    $o(n, "ftps", sa, fo, p),
    Ji(df, { scheme: !0, ascii: !0 }, t),
    Ji(sa, { slashscheme: !0, ascii: !0 }, t),
    (e = e.sort((v, b) => (v[0] > b[0] ? 1 : -1)))
  for (let v = 0; v < e.length; v++) {
    const b = e[v][0],
      x = e[v][1] ? { [Kee]: !0 } : { [Gee]: !0 }
    b.indexOf("-") >= 0
      ? (x[Xy] = !0)
      : ao.test(b)
        ? lo.test(b)
          ? (x[vc] = !0)
          : (x[Zy] = !0)
        : (x[qy] = !0),
      BS(n, b, b, x)
  }
  return (
    BS(n, "localhost", yu, { ascii: !0 }),
    (n.jd = new Cn(Jp)),
    { start: n, tokens: cl({ groups: t }, AD) }
  )
}
function RD(e, t) {
  const n = Jee(t.replace(/[A-Z]/g, (a) => a.toLowerCase())),
    r = n.length,
    o = []
  let i = 0,
    s = 0
  for (; s < r; ) {
    let a = e,
      l = null,
      c = 0,
      u = null,
      d = -1,
      f = -1
    for (; s < r && (l = a.go(n[s])); )
      (a = l),
        a.accepts()
          ? ((d = 0), (f = 0), (u = a))
          : d >= 0 && ((d += n[s].length), f++),
        (c += n[s].length),
        (i += n[s].length),
        s++
    ;(i -= d),
      (s -= f),
      (c -= d),
      o.push({ t: u.t, v: t.slice(i - c, i), s: i - c, e: i })
  }
  return o
}
function Jee(e) {
  const t = [],
    n = e.length
  let r = 0
  for (; r < n; ) {
    let o = e.charCodeAt(r),
      i,
      s =
        o < 55296 ||
        o > 56319 ||
        r + 1 === n ||
        (i = e.charCodeAt(r + 1)) < 56320 ||
        i > 57343
          ? e[r]
          : e.slice(r, r + 2)
    t.push(s), (r += s.length)
  }
  return t
}
function $o(e, t, n, r, o) {
  let i
  const s = t.length
  for (let a = 0; a < s - 1; a++) {
    const l = t[a]
    e.j[l] ? (i = e.j[l]) : ((i = new Cn(r)), (i.jr = o.slice()), (e.j[l] = i)),
      (e = i)
  }
  return (i = new Cn(n)), (i.jr = o.slice()), (e.j[t[s - 1]] = i), i
}
function FS(e) {
  const t = [],
    n = []
  let r = 0,
    o = "0123456789"
  for (; r < e.length; ) {
    let i = 0
    for (; o.indexOf(e[r + i]) >= 0; ) i++
    if (i > 0) {
      t.push(n.join(""))
      for (let s = parseInt(e.substring(r, r + i), 10); s > 0; s--) n.pop()
      r += i
    } else n.push(e[r]), r++
  }
  return t
}
const bu = {
  defaultProtocol: "http",
  events: null,
  format: zS,
  formatHref: zS,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null,
}
function ix(e, t = null) {
  let n = cl({}, bu)
  e && (n = cl(n, e instanceof ix ? e.o : e))
  const r = n.ignoreTags,
    o = []
  for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase())
  ;(this.o = n), t && (this.defaultRender = t), (this.ignoreTags = o)
}
ix.prototype = {
  o: bu,
  ignoreTags: [],
  defaultRender(e) {
    return e
  },
  check(e) {
    return this.get("validate", e.toString(), e)
  },
  get(e, t, n) {
    const r = t != null
    let o = this.o[e]
    return (
      o &&
      (typeof o == "object"
        ? ((o = n.t in o ? o[n.t] : bu[e]),
          typeof o == "function" && r && (o = o(t, n)))
        : typeof o == "function" && r && (o = o(t, n.t, n)),
      o)
    )
  },
  getObj(e, t, n) {
    let r = this.o[e]
    return typeof r == "function" && t != null && (r = r(t, n.t, n)), r
  },
  render(e) {
    const t = e.render(this)
    return (this.get("render", null, e) || this.defaultRender)(t, e.t, e)
  },
}
function zS(e) {
  return e
}
function ID(e, t) {
  ;(this.t = "token"), (this.v = e), (this.tk = t)
}
ID.prototype = {
  isLink: !1,
  toString() {
    return this.v
  },
  toHref(e) {
    return this.toString()
  },
  toFormattedString(e) {
    const t = this.toString(),
      n = e.get("truncate", t, this),
      r = e.get("format", t, this)
    return n && r.length > n ? r.substring(0, n) + "" : r
  },
  toFormattedHref(e) {
    return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this)
  },
  startIndex() {
    return this.tk[0].s
  },
  endIndex() {
    return this.tk[this.tk.length - 1].e
  },
  toObject(e = bu.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex(),
    }
  },
  toFormattedObject(e) {
    return {
      type: this.t,
      value: this.toFormattedString(e),
      isLink: this.isLink,
      href: this.toFormattedHref(e),
      start: this.startIndex(),
      end: this.endIndex(),
    }
  },
  validate(e) {
    return e.get("validate", this.toString(), this)
  },
  render(e) {
    const t = this,
      n = this.toHref(e.get("defaultProtocol")),
      r = e.get("formatHref", n, this),
      o = e.get("tagName", n, t),
      i = this.toFormattedString(e),
      s = {},
      a = e.get("className", n, t),
      l = e.get("target", n, t),
      c = e.get("rel", n, t),
      u = e.getObj("attributes", n, t),
      d = e.getObj("events", n, t)
    return (
      (s.href = r),
      a && (s.class = a),
      l && (s.target = l),
      c && (s.rel = c),
      u && cl(s, u),
      { tagName: o, attributes: s, content: i, eventListeners: d }
    )
  },
}
function wm(e, t) {
  class n extends ID {
    constructor(o, i) {
      super(o, i), (this.t = e)
    }
  }
  for (const r in t) n.prototype[r] = t[r]
  return (n.t = e), n
}
const US = wm("email", {
    isLink: !0,
    toHref() {
      return "mailto:" + this.toString()
    },
  }),
  VS = wm("text"),
  ete = wm("nl"),
  Ud = wm("url", {
    isLink: !0,
    toHref(e = bu.defaultProtocol) {
      return this.hasProtocol() ? this.v : `${e}://${this.v}`
    },
    hasProtocol() {
      const e = this.tk
      return e.length >= 2 && e[0].t !== yu && e[1].t === Yo
    },
  }),
  qn = (e) => new Cn(e)
function tte({ groups: e }) {
  const t = e.domain.concat([
      Up,
      Vp,
      Wo,
      Hp,
      Wp,
      Kp,
      Gp,
      qp,
      Zn,
      Q1,
      xc,
      Zp,
      Yp,
      Xp,
      Fr,
      Jp,
      Ec,
      Qp,
    ]),
    n = [
      Yo,
      tx,
      jr,
      nx,
      xc,
      wc,
      rx,
      ox,
      Rp,
      Ip,
      yc,
      bc,
      Mp,
      Tp,
      Op,
      Ap,
      Dp,
      Lp,
      Pp,
      $p,
      Bp,
      jp,
      Fp,
      zp,
    ],
    r = [
      Up,
      ex,
      Vp,
      Hp,
      Wp,
      Kp,
      Gp,
      qp,
      Zn,
      yc,
      bc,
      xc,
      Zp,
      Yp,
      Xp,
      wc,
      Fr,
      Jp,
      Ec,
      Qp,
    ],
    o = qn(),
    i = Q(o, Ec)
  Te(i, r, i), Te(i, e.domain, i)
  const s = qn(),
    a = qn(),
    l = qn()
  Te(o, e.domain, s),
    Te(o, e.scheme, a),
    Te(o, e.slashscheme, l),
    Te(s, r, i),
    Te(s, e.domain, s)
  const c = Q(s, Wo)
  Q(i, Wo, c), Q(a, Wo, c), Q(l, Wo, c)
  const u = Q(i, jr)
  Te(u, r, i), Te(u, e.domain, i)
  const d = qn()
  Te(c, e.domain, d), Te(d, e.domain, d)
  const f = Q(d, jr)
  Te(f, e.domain, d)
  const p = qn(US)
  Te(f, e.tld, p), Te(f, e.utld, p), Q(c, yu, p)
  const g = Q(d, Zn)
  Q(g, Zn, g), Te(g, e.domain, d), Te(p, e.domain, d), Q(p, jr, f), Q(p, Zn, g)
  const v = Q(p, Yo)
  Te(v, e.numeric, US)
  const b = Q(s, Zn),
    y = Q(s, jr)
  Q(b, Zn, b), Te(b, e.domain, s), Te(y, r, i), Te(y, e.domain, s)
  const x = qn(Ud)
  Te(y, e.tld, x),
    Te(y, e.utld, x),
    Te(x, e.domain, s),
    Te(x, r, i),
    Q(x, jr, y),
    Q(x, Zn, b),
    Q(x, Wo, c)
  const E = Q(x, Yo),
    w = qn(Ud)
  Te(E, e.numeric, w)
  const C = qn(Ud),
    S = qn()
  Te(C, t, C), Te(C, n, S), Te(S, t, C), Te(S, n, S), Q(x, Fr, C), Q(w, Fr, C)
  const M = Q(a, Yo),
    N = Q(l, Yo),
    R = Q(N, Fr),
    B = Q(R, Fr)
  Te(a, e.domain, s),
    Q(a, jr, y),
    Q(a, Zn, b),
    Te(l, e.domain, s),
    Q(l, jr, y),
    Q(l, Zn, b),
    Te(M, e.domain, C),
    Q(M, Fr, C),
    Q(M, wc, C),
    Te(B, e.domain, C),
    Te(B, t, C),
    Q(B, Fr, C)
  const V = [
    [yc, bc],
    [Tp, Mp],
    [Op, Ap],
    [Rp, Ip],
    [Dp, Lp],
    [Pp, $p],
    [Bp, jp],
    [Fp, zp],
  ]
  for (let j = 0; j < V.length; j++) {
    const [U, W] = V[j],
      ee = Q(C, U)
    Q(S, U, ee), Q(ee, W, C)
    const I = qn(Ud)
    Te(ee, t, I)
    const O = qn()
    Te(ee, n),
      Te(I, t, I),
      Te(I, n, O),
      Te(O, t, I),
      Te(O, n, O),
      Q(I, W, C),
      Q(O, W, C)
  }
  return Q(o, yu, x), Q(o, J1, ete), { start: o, tokens: AD }
}
function nte(e, t, n) {
  let r = n.length,
    o = 0,
    i = [],
    s = []
  for (; o < r; ) {
    let a = e,
      l = null,
      c = null,
      u = 0,
      d = null,
      f = -1
    for (; o < r && !(l = a.go(n[o].t)); ) s.push(n[o++])
    for (; o < r && (c = l || a.go(n[o].t)); )
      (l = null),
        (a = c),
        a.accepts() ? ((f = 0), (d = a)) : f >= 0 && f++,
        o++,
        u++
    if (f < 0) (o -= u), o < r && (s.push(n[o]), o++)
    else {
      s.length > 0 && (i.push(tv(VS, t, s)), (s = [])), (o -= f), (u -= f)
      const p = d.t,
        g = n.slice(o - u, o)
      i.push(tv(p, t, g))
    }
  }
  return s.length > 0 && i.push(tv(VS, t, s)), i
}
function tv(e, t, n) {
  const r = n[0].s,
    o = n[n.length - 1].e,
    i = t.slice(r, o)
  return new e(i, n)
}
const rte = (typeof console < "u" && console && console.warn) || (() => {}),
  ote =
    "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",
  Qe = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1,
  }
function ite() {
  return (
    (Cn.groups = {}),
    (Qe.scanner = null),
    (Qe.parser = null),
    (Qe.tokenQueue = []),
    (Qe.pluginQueue = []),
    (Qe.customSchemes = []),
    (Qe.initialized = !1),
    Qe
  )
}
function HS(e, t = !1) {
  if (
    (Qe.initialized &&
      rte(
        `linkifyjs: already initialized - will not register custom scheme "${e}" ${ote}`
      ),
    !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
  )
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`)
  Qe.customSchemes.push([e, t])
}
function ste() {
  Qe.scanner = Qee(Qe.customSchemes)
  for (let e = 0; e < Qe.tokenQueue.length; e++)
    Qe.tokenQueue[e][1]({ scanner: Qe.scanner })
  Qe.parser = tte(Qe.scanner.tokens)
  for (let e = 0; e < Qe.pluginQueue.length; e++)
    Qe.pluginQueue[e][1]({ scanner: Qe.scanner, parser: Qe.parser })
  return (Qe.initialized = !0), Qe
}
function sx(e) {
  return (
    Qe.initialized || ste(), nte(Qe.parser.start, e, RD(Qe.scanner.start, e))
  )
}
sx.scan = RD
function DD(e, t = null, n = null) {
  if (t && typeof t == "object") {
    if (n) throw Error(`linkifyjs: Invalid link type ${t}; must be a string`)
    ;(n = t), (t = null)
  }
  const r = new ix(n),
    o = sx(e),
    i = []
  for (let s = 0; s < o.length; s++) {
    const a = o[s]
    a.isLink &&
      (!t || a.t === t) &&
      r.check(a) &&
      i.push(a.toFormattedObject(r))
  }
  return i
}
function ate(e) {
  return e.length === 1
    ? e[0].isLink
    : e.length === 3 && e[1].isLink
      ? ["()", "[]"].includes(e[0].value + e[2].value)
      : !1
}
function lte(e) {
  return new rt({
    key: new At("autolink"),
    appendTransaction: (t, n, r) => {
      const o = t.some((c) => c.docChanged) && !n.doc.eq(r.doc),
        i = t.some((c) => c.getMeta("preventAutolink"))
      if (!o || i) return
      const { tr: s } = r,
        a = BV(n.doc, [...t])
      if (
        (KV(a).forEach(({ newRange: c }) => {
          const u = FV(r.doc, c, (p) => p.isTextblock)
          let d, f
          if (
            (u.length > 1
              ? ((d = u[0]),
                (f = r.doc.textBetween(
                  d.pos,
                  d.pos + d.node.nodeSize,
                  void 0,
                  " "
                )))
              : u.length &&
                r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") &&
                ((d = u[0]), (f = r.doc.textBetween(d.pos, c.to, void 0, " "))),
            d && f)
          ) {
            const p = f.split(" ").filter((y) => y !== "")
            if (p.length <= 0) return !1
            const g = p[p.length - 1],
              v = d.pos + f.lastIndexOf(g)
            if (!g) return !1
            const b = sx(g).map((y) => y.toObject(e.defaultProtocol))
            if (!ate(b)) return !1
            b.filter((y) => y.isLink)
              .map((y) => ({ ...y, from: v + y.start + 1, to: v + y.end + 1 }))
              .filter((y) =>
                r.schema.marks.code
                  ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code)
                  : !0
              )
              .filter((y) => e.validate(y.value))
              .filter((y) => e.shouldAutoLink(y.value))
              .forEach((y) => {
                u1(y.from, y.to, r.doc).some((x) => x.mark.type === e.type) ||
                  s.addMark(y.from, y.to, e.type.create({ href: y.href }))
              })
          }
        }),
        !!s.steps.length)
      )
        return s
    },
  })
}
function cte(e) {
  return new rt({
    key: new At("handleClickLink"),
    props: {
      handleClick: (t, n, r) => {
        var o, i
        if (r.button !== 0 || !t.editable) return !1
        let s = r.target
        const a = []
        for (; s.nodeName !== "DIV"; ) a.push(s), (s = s.parentNode)
        if (!a.find((f) => f.nodeName === "A")) return !1
        const l = gA(t.state, e.type.name),
          c = r.target,
          u =
            (o = c == null ? void 0 : c.href) !== null && o !== void 0
              ? o
              : l.href,
          d =
            (i = c == null ? void 0 : c.target) !== null && i !== void 0
              ? i
              : l.target
        return c && u ? (window.open(u, d), !0) : !1
      },
    },
  })
}
function ute(e) {
  return new rt({
    key: new At("handlePasteLink"),
    props: {
      handlePaste: (t, n, r) => {
        const { state: o } = t,
          { selection: i } = o,
          { empty: s } = i
        if (s) return !1
        let a = ""
        r.content.forEach((c) => {
          a += c.textContent
        })
        const l = DD(a, { defaultProtocol: e.defaultProtocol }).find(
          (c) => c.isLink && c.value === a
        )
        return !a || !l
          ? !1
          : e.editor.commands.setMark(e.type, { href: l.href })
      },
    },
  })
}
const dte = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
function Fi(e, t) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp",
  ]
  return (
    t &&
      t.forEach((r) => {
        const o = typeof r == "string" ? r : r.scheme
        o && n.push(o)
      }),
    !e ||
      e
        .replace(dte, "")
        .match(
          new RegExp(
            `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
            "i"
          )
        )
  )
}
const fte = Rr.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: !1,
    exitable: !0,
    onCreate() {
      this.options.validate &&
        !this.options.shouldAutoLink &&
        ((this.options.shouldAutoLink = this.options.validate),
        console.warn(
          "The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead."
        )),
        this.options.protocols.forEach((e) => {
          if (typeof e == "string") {
            HS(e)
            return
          }
          HS(e.scheme, e.optionalSlashes)
        })
    },
    onDestroy() {
      ite()
    },
    inclusive() {
      return this.options.autolink
    },
    addOptions() {
      return {
        openOnClick: !0,
        linkOnPaste: !0,
        autolink: !0,
        protocols: [],
        defaultProtocol: "http",
        HTMLAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow",
          class: null,
        },
        isAllowedUri: (e, t) => !!Fi(e, t.protocols),
        validate: (e) => !!e,
        shouldAutoLink: (e) => !!e,
      }
    },
    addAttributes() {
      return {
        href: {
          default: null,
          parseHTML(e) {
            return e.getAttribute("href")
          },
        },
        target: { default: this.options.HTMLAttributes.target },
        rel: { default: this.options.HTMLAttributes.rel },
        class: { default: this.options.HTMLAttributes.class },
      }
    },
    parseHTML() {
      return [
        {
          tag: "a[href]",
          getAttrs: (e) => {
            const t = e.getAttribute("href")
            return !t ||
              !this.options.isAllowedUri(t, {
                defaultValidate: (n) => !!Fi(n, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol,
              })
              ? !1
              : null
          },
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return this.options.isAllowedUri(e.href, {
        defaultValidate: (t) => !!Fi(t, this.options.protocols),
        protocols: this.options.protocols,
        defaultProtocol: this.options.defaultProtocol,
      })
        ? ["a", lt(this.options.HTMLAttributes, e), 0]
        : ["a", lt(this.options.HTMLAttributes, { ...e, href: "" }), 0]
    },
    addCommands() {
      return {
        setLink:
          (e) =>
          ({ chain: t }) => {
            const { href: n } = e
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!Fi(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? t().setMark(this.name, e).setMeta("preventAutolink", !0).run()
              : !1
          },
        toggleLink:
          (e) =>
          ({ chain: t }) => {
            const { href: n } = e
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!Fi(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? t()
                  .toggleMark(this.name, e, { extendEmptyMarkRange: !0 })
                  .setMeta("preventAutolink", !0)
                  .run()
              : !1
          },
        unsetLink:
          () =>
          ({ chain: e }) =>
            e()
              .unsetMark(this.name, { extendEmptyMarkRange: !0 })
              .setMeta("preventAutolink", !0)
              .run(),
      }
    },
    addPasteRules() {
      return [
        Ts({
          find: (e) => {
            const t = []
            if (e) {
              const { protocols: n, defaultProtocol: r } = this.options,
                o = DD(e).filter(
                  (i) =>
                    i.isLink &&
                    this.options.isAllowedUri(i.value, {
                      defaultValidate: (s) => !!Fi(s, n),
                      protocols: n,
                      defaultProtocol: r,
                    })
                )
              o.length &&
                o.forEach((i) =>
                  t.push({
                    text: i.value,
                    data: { href: i.href },
                    index: i.start,
                  })
                )
            }
            return t
          },
          type: this.type,
          getAttributes: (e) => {
            var t
            return {
              href: (t = e.data) === null || t === void 0 ? void 0 : t.href,
            }
          },
        }),
      ]
    },
    addProseMirrorPlugins() {
      const e = [],
        { protocols: t, defaultProtocol: n } = this.options
      return (
        this.options.autolink &&
          e.push(
            lte({
              type: this.type,
              defaultProtocol: this.options.defaultProtocol,
              validate: (r) =>
                this.options.isAllowedUri(r, {
                  defaultValidate: (o) => !!Fi(o, t),
                  protocols: t,
                  defaultProtocol: n,
                }),
              shouldAutoLink: this.options.shouldAutoLink,
            })
          ),
        this.options.openOnClick === !0 && e.push(cte({ type: this.type })),
        this.options.linkOnPaste &&
          e.push(
            ute({
              editor: this.editor,
              defaultProtocol: this.options.defaultProtocol,
              type: this.type,
            })
          ),
        e
      )
    },
  }),
  pte = fte.extend({
    inclusive: !1,
    parseHTML() {
      return [
        {
          tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])',
        },
      ]
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["a", lt(this.options.HTMLAttributes, e), 0]
    },
    addOptions() {
      var e
      return {
        ...((e = this.parent) == null ? void 0 : e.call(this)),
        openOnClick: !1,
        HTMLAttributes: { class: "link" },
      }
    },
    addProseMirrorPlugins() {
      var t
      const { editor: e } = this
      return [
        ...(((t = this.parent) == null ? void 0 : t.call(this)) || []),
        new rt({
          props: {
            handleKeyDown: (n, r) => {
              const { selection: o } = e.state
              return (
                r.key === "Escape" &&
                  o.empty !== !0 &&
                  e.commands.focus(o.to, { scrollIntoView: !1 }),
                !1
              )
            },
            handleClick(n, r) {
              const { schema: o, doc: i, tr: s } = n.state,
                a = cm(i.resolve(r), o.marks.link)
              if (!a) return
              const { from: l, to: c } = a,
                u = Math.min(l, c),
                d = Math.max(l, c)
              if (r < u || r > d) return
              const f = i.resolve(u),
                p = i.resolve(d),
                g = s.setSelection(new _e(f, p))
              n.dispatch(g)
            },
          },
        }),
      ]
    },
  }),
  hte = ct.create({
    name: "selection",
    addProseMirrorPlugins() {
      const { editor: e } = this
      return [
        new rt({
          key: new At("selection"),
          props: {
            decorations(t) {
              return t.selection.empty || e.isFocused === !0 || !e.isEditable
                ? null
                : mt.create(t.doc, [
                    pn.inline(t.selection.from, t.selection.to, {
                      class: "selection",
                    }),
                  ])
            },
          },
        }),
      ]
    },
  }),
  mte = ct.create({
    addKeyboardShortcuts() {
      return { "Mod-\\": () => this.editor.commands.unsetAllMarks() }
    },
  }),
  gte = ct.create({
    name: "resetMarksOnEnter",
    addKeyboardShortcuts() {
      return {
        Enter: ({ editor: e }) =>
          e.isActive("bold") ||
          e.isActive("italic") ||
          e.isActive("strike") ||
          e.isActive("underline") ||
          e.isActive("code")
            ? (e.commands.splitBlock({ keepMarks: !1 }), !0)
            : !1,
      }
    },
  }),
  vte = (e) => {
    const {
      key: t,
      editor: n,
      onPaste: r,
      onDrop: o,
      onValidationError: i,
      allowedMimeTypes: s,
      maxFileSize: a,
    } = e
    return new rt({
      key: t || new At("fileHandler"),
      props: {
        handleDrop(l, c) {
          var g
          c.preventDefault(), c.stopPropagation()
          const { dataTransfer: u } = c
          if (!(u != null && u.files.length)) return
          const d = l.posAtCoords({ left: c.clientX, top: c.clientY }),
            [f, p] = yp(Array.from(u.files), {
              allowedMimeTypes: s,
              maxFileSize: a,
              allowBase64: e.allowBase64,
            })
          p.length > 0 && i && i(p),
            f.length > 0 &&
              o &&
              o(n, f, (g = d == null ? void 0 : d.pos) != null ? g : 0)
        },
        handlePaste(l, c) {
          c.preventDefault(), c.stopPropagation()
          const { clipboardData: u } = c
          if (!(u != null && u.files.length)) return
          const [d, f] = yp(Array.from(u.files), {
              allowedMimeTypes: s,
              maxFileSize: a,
              allowBase64: e.allowBase64,
            }),
            p = u.getData("text/html")
          f.length > 0 && i && i(f), d.length > 0 && r && r(n, d, p)
        },
      },
    })
  },
  yte = ct.create({
    name: "fileHandler",
    addOptions() {
      return { allowBase64: !1, allowedMimeTypes: [], maxFileSize: 0 }
    },
    addProseMirrorPlugins() {
      return [
        vte({ key: new At(this.name), editor: this.editor, ...this.options }),
      ]
    },
  }),
  bte = /^\s*(\[([( |x])?\])\s$/,
  xte = Rn.create({
    name: "taskItem",
    addOptions() {
      return { nested: !1, HTMLAttributes: {}, taskListTypeName: "taskList" }
    },
    content() {
      return this.options.nested ? "paragraph block*" : "paragraph+"
    },
    defining: !0,
    addAttributes() {
      return {
        checked: {
          default: !1,
          keepOnSplit: !1,
          parseHTML: (e) => {
            const t = e.getAttribute("data-checked")
            return t === "" || t === "true"
          },
          renderHTML: (e) => ({ "data-checked": e.checked }),
        },
      }
    },
    parseHTML() {
      return [{ tag: `li[data-type="${this.name}"]`, priority: 51 }]
    },
    renderHTML({ node: e, HTMLAttributes: t }) {
      return [
        "li",
        lt(this.options.HTMLAttributes, t, { "data-type": this.name }),
        [
          "label",
          [
            "input",
            { type: "checkbox", checked: e.attrs.checked ? "checked" : null },
          ],
          ["span"],
        ],
        ["div", 0],
      ]
    },
    addKeyboardShortcuts() {
      const e = {
        Enter: () => this.editor.commands.splitListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
      }
      return this.options.nested
        ? { ...e, Tab: () => this.editor.commands.sinkListItem(this.name) }
        : e
    },
    addNodeView() {
      return ({ node: e, HTMLAttributes: t, getPos: n, editor: r }) => {
        const o = document.createElement("li"),
          i = document.createElement("label"),
          s = document.createElement("span"),
          a = document.createElement("input"),
          l = document.createElement("div")
        return (
          (i.contentEditable = "false"),
          (a.type = "checkbox"),
          a.addEventListener("mousedown", (c) => c.preventDefault()),
          a.addEventListener("change", (c) => {
            if (!r.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked
              return
            }
            const { checked: u } = c.target
            r.isEditable &&
              typeof n == "function" &&
              r
                .chain()
                .focus(void 0, { scrollIntoView: !1 })
                .command(({ tr: d }) => {
                  const f = n()
                  if (typeof f != "number") return !1
                  const p = d.doc.nodeAt(f)
                  return (
                    d.setNodeMarkup(f, void 0, {
                      ...(p == null ? void 0 : p.attrs),
                      checked: u,
                    }),
                    !0
                  )
                })
                .run(),
              !r.isEditable &&
                this.options.onReadOnlyChecked &&
                (this.options.onReadOnlyChecked(e, u) ||
                  (a.checked = !a.checked))
          }),
          Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
            o.setAttribute(c, u)
          }),
          (o.dataset.checked = e.attrs.checked),
          (a.checked = e.attrs.checked),
          i.append(a, s),
          o.append(i, l),
          Object.entries(t).forEach(([c, u]) => {
            o.setAttribute(c, u)
          }),
          {
            dom: o,
            contentDOM: l,
            update: (c) =>
              c.type !== this.type
                ? !1
                : ((o.dataset.checked = c.attrs.checked),
                  (a.checked = c.attrs.checked),
                  !0),
          }
        )
      }
    },
    addInputRules() {
      return [
        tl({
          find: bte,
          type: this.type,
          getAttributes: (e) => ({ checked: e[e.length - 1] === "x" }),
        }),
      ]
    },
  }),
  wte = Rn.create({
    name: "taskList",
    addOptions() {
      return { itemTypeName: "taskItem", HTMLAttributes: {} }
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`
    },
    parseHTML() {
      return [{ tag: `ul[data-type="${this.name}"]`, priority: 51 }]
    },
    renderHTML({ HTMLAttributes: e }) {
      return [
        "ul",
        lt(this.options.HTMLAttributes, e, { "data-type": this.name }),
        0,
      ]
    },
    addCommands() {
      return {
        toggleTaskList:
          () =>
          ({ commands: e }) =>
            e.toggleList(this.name, this.options.itemTypeName),
      }
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-9": () => this.editor.commands.toggleTaskList() }
    },
  }),
  Ete = wte.extend({
    addOptions() {
      var e
      return {
        ...((e = this.parent) == null ? void 0 : e.call(this)),
        defaultLanguage: null,
        HTMLAttributes: { class: "list-node" },
      }
    },
  }),
  Cte = xte.extend({
    renderHTML({ node: e }) {
      return [
        "li",
        {
          "data-type": "taskItem",
          style: "display: flex; align-items: center; gap: 8px;",
        },
        [
          "input",
          { type: "checkbox", checked: e.attrs.checked ? "checked" : null },
        ],
        ["span", {}, 0],
      ]
    },
  })
function Ste(e, t) {
  const n = m.useRef(Date.now()),
    r = m.useRef(null)
  return m.useCallback(
    (...o) => {
      ;(() => {
        Date.now() - n.current >= t
          ? (e(...o), (n.current = Date.now()))
          : (r.current && clearTimeout(r.current),
            (r.current = setTimeout(
              () => {
                e(...o), (n.current = Date.now())
              },
              t - (Date.now() - n.current)
            )))
      })()
    },
    [e, t]
  )
}
const _te = (e) => [
    jY.configure({
      horizontalRule: !1,
      codeBlock: !1,
      paragraph: { HTMLAttributes: { class: "text-node" } },
      heading: { HTMLAttributes: { class: "heading-node" } },
      blockquote: { HTMLAttributes: { class: "block-node" } },
      bulletList: { HTMLAttributes: { class: "list-node" } },
      orderedList: { HTMLAttributes: { class: "list-node" } },
      code: { HTMLAttributes: { class: "inline", spellcheck: "false" } },
      dropcursor: { width: 2, class: "ProseMirror-dropcursor border" },
    }),
    pte,
    zZ,
    Vee.configure({
      allowedMimeTypes: ["image/*"],
      maxFileSize: 5 * 1024 * 1024,
      allowBase64: !0,
      uploadFn: async (t) => {
        await new Promise((r) => setTimeout(r, 3e3))
        const n = await zg(t)
        return { id: pu(), src: n }
      },
      onToggle(t, n, r) {
        t.commands.insertContentAt(
          r,
          n.map((o) => {
            const i = URL.createObjectURL(o)
            return {
              type: "image",
              attrs: {
                id: pu(),
                src: i,
                alt: o.name,
                title: o.name,
                fileName: o.name,
              },
            }
          })
        )
      },
      onImageRemoved({ id: t, src: n }) {
        console.log("Image removed", { id: t, src: n })
      },
      onValidationError(t) {
        t.forEach((n) => {
          Rd.error("Image validation error", {
            position: "bottom-right",
            description: n.reason,
          })
        })
      },
      onActionSuccess({ action: t }) {
        const n = {
          copyImage: "Copy Image",
          copyLink: "Copy Link",
          download: "Download",
        }
        Rd.success(n[t], {
          position: "bottom-right",
          description: "Image action success",
        })
      },
      onActionError(t, { action: n }) {
        const r = {
          copyImage: "Copy Image",
          copyLink: "Copy Link",
          download: "Download",
        }
        Rd.error(`Failed to ${r[n]}`, {
          position: "bottom-right",
          description: t.message,
        })
      },
    }),
    yte.configure({
      allowBase64: !0,
      allowedMimeTypes: ["image/*"],
      maxFileSize: 5 * 1024 * 1024,
      onDrop: (t, n, r) => {
        n.forEach(async (o) => {
          const i = await zg(o)
          t.commands.insertContentAt(r, { type: "image", attrs: { src: i } })
        })
      },
      onPaste: (t, n) => {
        n.forEach(async (r) => {
          const o = await zg(r)
          t.commands.insertContent({ type: "image", attrs: { src: o } })
        })
      },
      onValidationError: (t) => {
        t.forEach((n) => {
          Rd.error("Image validation error", {
            position: "bottom-right",
            description: n.reason,
          })
        })
      },
    }),
    pee,
    vZ,
    hte,
    FZ,
    mte,
    hee,
    gte,
    dee,
    mZ.configure({ placeholder: () => e }),
    Ete,
    Cte.configure({ nested: !0 }),
  ],
  kte = ({
    value: e,
    output: t = "html",
    placeholder: n = "",
    editorClassName: r,
    throttleDelay: o = 0,
    onUpdate: i,
    onBlur: s,
    ...a
  }) => {
    const l = Ste((p) => (i == null ? void 0 : i(p)), o),
      c = m.useCallback((p) => l(eS(p, t)), [t, l]),
      u = m.useCallback(
        (p) => {
          e && p.isEmpty && p.commands.setContent(e)
        },
        [e]
      ),
      d = m.useCallback((p) => (s == null ? void 0 : s(eS(p, t))), [t, s])
    return xK({
      extensions: _te(n),
      editorProps: {
        attributes: {
          autocomplete: "off",
          autocorrect: "off",
          autocapitalize: "off",
          class: q("focus:outline-none", r),
        },
      },
      onUpdate: ({ editor: p }) => c(p),
      onCreate: ({ editor: p }) => u(p),
      onBlur: ({ editor: p }) => d(p),
      ...a,
    })
  },
  Nte = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    toJSON: () => "{}",
  }
function Tte(e) {
  const [t, n] = m.useState(() => {
      var o
      return (o = e == null ? void 0 : e.getBoundingClientRect()) != null
        ? o
        : Nte
    }),
    r = m.useCallback(() => {
      if (!e) return
      const o = e.getBoundingClientRect()
      n((i) =>
        Math.round(i.width) === Math.round(o.width) &&
        Math.round(i.height) === Math.round(o.height) &&
        Math.round(i.x) === Math.round(o.x) &&
        Math.round(i.y) === Math.round(o.y)
          ? i
          : o
      )
    }, [e])
  return (
    m.useEffect(() => {
      if (!e) return
      const o = new ResizeObserver(r)
      return (
        o.observe(e),
        window.addEventListener("click", r),
        window.addEventListener("resize", r),
        () => {
          o.disconnect(),
            window.removeEventListener("click", r),
            window.removeEventListener("resize", r)
        }
      )
    }, [e, r]),
    t
  )
}
const LD = m.forwardRef(
  ({ as: e, name: t, children: n, style: r = {}, ...o }, i) => {
    const s = m.useRef(null),
      a = Tte(s.current)
    m.useImperativeHandle(i, () => s.current)
    const l = {
      [`--${t}-width`]: `${a.width}px`,
      [`--${t}-height`]: `${a.height}px`,
    }
    return h.jsx(e, { ...o, ref: s, style: { ...l, ...r }, children: n })
  }
)
LD.displayName = "MeasuredContainer"
const Mte = ({ editor: e }) =>
    h.jsx("div", {
      className: "shrink-0 overflow-x-auto border-b border-border p-2",
      children: h.jsxs("div", {
        className: "flex w-max items-center gap-px",
        children: [
          h.jsx(UR, { editor: e, activeLevels: [1, 2, 3, 4, 5, 6] }),
          h.jsx(bo, { orientation: "vertical", className: "mx-2 h-7" }),
          h.jsx(VR, {
            editor: e,
            activeActions: [
              "bold",
              "italic",
              "underline",
              "strikethrough",
              "code",
              "clearFormatting",
            ],
            mainActionCount: 3,
          }),
          h.jsx(bo, { orientation: "vertical", className: "mx-2 h-7" }),
          h.jsx(gI, { editor: e }),
          h.jsx(bo, { orientation: "vertical", className: "mx-2 h-7" }),
          h.jsx(vI, {
            editor: e,
            activeActions: ["orderedList", "bulletList", "taskList"],
            mainActionCount: 0,
          }),
          h.jsx(bo, { orientation: "vertical", className: "mx-2 h-7" }),
          h.jsx(SI, {
            editor: e,
            activeActions: ["codeBlock", "blockquote", "horizontalRule"],
            mainActionCount: 0,
          }),
        ],
      }),
    }),
  PD = m.forwardRef(
    (
      { value: e, onChange: t, className: n, editorContentClassName: r, ...o },
      i
    ) => {
      const s = kte({ value: e, onUpdate: t, ...o })
      return s
        ? h.jsxs(LD, {
            as: "div",
            name: "editor",
            ref: i,
            className: q(
              "flex h-auto min-h-72 w-full flex-col rounded-md border border-input shadow-sm focus-within:border-primary",
              n
            ),
            children: [
              h.jsx(Mte, { editor: s }),
              h.jsx(uK, {
                editor: s,
                className: q("minimal-tiptap-editor", r),
              }),
              h.jsx(hZ, { editor: s }),
            ],
          })
        : null
    }
  )
PD.displayName = "MinimalTiptapEditor"
const Ote = ({ form: e, index: t, open: n = !0, onDelete: r }) => {
    const o = `instructions.${t}`
    return h.jsxs(Au, {
      defaultOpen: n,
      children: [
        h.jsx(Ru, {
          asChild: !0,
          children: h.jsxs(et, {
            type: "button",
            variant: "outline",
            children: ["Edit Instruction #", t + 1],
          }),
        }),
        h.jsxs(yl, {
          "aria-describedby": "",
          children: [
            h.jsx(bl, {
              children: h.jsxs(xl, {
                children: ["Recipe Instruction #", t + 1],
              }),
            }),
            h.jsx(Ht, {
              control: e.control,
              name: o,
              render: ({ field: i }) =>
                h.jsxs(Dt, {
                  className: "mt-1",
                  children: [
                    h.jsx(Lt, {
                      children: h.jsx("div", {
                        className:
                          "flex w-full max-w-[80%] flex-col md:max-w-[600px]",
                        children: h.jsx("div", {
                          className:
                            "w-full min-w-0 overflow-hidden rounded-lg border",
                          children: h.jsx(PD, {
                            editorContentClassName: "p-5",
                            output: "html",
                            placeholder: "Enter instruction...",
                            autofocus: !0,
                            editable: !0,
                            editorClassName: "focus:outline-none w-full",
                            ...i,
                          }),
                        }),
                      }),
                    }),
                    h.jsx(Pt, {}),
                  ],
                }),
            }),
            h.jsx(et, {
              type: "button",
              variant: "destructive",
              onClick: r,
              className: "mt-4",
              children: "Delete Instruction",
            }),
          ],
        }),
      ],
    })
  },
  Ate = ({ form: e, index: t, open: n = !0, onDelete: r }) => {
    const o = `ingredients.${t}`
    return h.jsxs(Au, {
      defaultOpen: n,
      children: [
        h.jsx(Ru, {
          asChild: !0,
          children: h.jsxs(et, {
            type: "button",
            variant: "outline",
            children: ["Edit Ingredient #", t + 1],
          }),
        }),
        h.jsxs(yl, {
          "aria-describedby": "",
          children: [
            h.jsx(bl, {
              children: h.jsxs(xl, {
                children: ["Recipe Ingredient #", t + 1],
              }),
            }),
            h.jsxs("div", {
              className: "space-y-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: `${o}.ingredient`,
                  render: ({ field: i }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Ingredient" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            placeholder: "Enter ingredient name...",
                            ...i,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: `${o}.unit`,
                  render: ({ field: i }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Unit" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            placeholder: "e.g., grams, cups, tsp",
                            ...i,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: `${o}.quantity`,
                  render: ({ field: i }) =>
                    h.jsxs(Dt, {
                      children: [
                        h.jsx(Wt, { children: "Quantity" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            placeholder: "Enter quantity",
                            ...i,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
            h.jsx(et, {
              type: "button",
              variant: "destructive",
              onClick: r,
              className: "mt-4",
              children: "Delete Ingredient",
            }),
          ],
        }),
      ],
    })
  },
  Rte = ({ form: e, index: t, open: n = !0, onDelete: r }) => {
    const o = `equipment.${t}`
    return h.jsxs(Au, {
      defaultOpen: n,
      children: [
        h.jsx(Ru, {
          asChild: !0,
          children: h.jsxs(et, {
            type: "button",
            variant: "outline",
            children: ["Edit Equipment #", t + 1],
          }),
        }),
        h.jsxs(yl, {
          "aria-describedby": "",
          children: [
            h.jsx(bl, {
              children: h.jsxs(xl, { children: ["Recipe Equipment #", t + 1] }),
            }),
            h.jsx(Ht, {
              control: e.control,
              name: o,
              render: ({ field: i }) =>
                h.jsxs(Dt, {
                  children: [
                    h.jsx(Wt, { children: "Equipment name" }),
                    h.jsx(Lt, {
                      children: h.jsx(St, {
                        placeholder: "Enter equipment name...",
                        ...i,
                      }),
                    }),
                    h.jsx(Pt, {}),
                  ],
                }),
            }),
            h.jsx(et, {
              type: "button",
              variant: "destructive",
              onClick: r,
              className: "mt-4",
              children: "Delete Equipment",
            }),
          ],
        }),
      ],
    })
  }
function Ite({ form: e }) {
  const t = e.watch("instructions"),
    n = e.watch("ingredients"),
    r = e.watch("equipment"),
    o = () => {
      e.setValue("instructions", [...t, ""])
    },
    i = () => {
      e.setValue("ingredients", [
        ...n,
        { id: 0, ingredient: "", quantity: 0, unit: "", recipe_id: -1 },
      ])
    },
    s = () => {
      e.setValue("equipment", [...r, ""])
    },
    a = (u) => {
      const d = [...t]
      d.splice(u, 1), e.setValue("instructions", d)
    },
    l = (u) => {
      const d = [...n]
      d.splice(u, 1), e.setValue("ingredients", d)
    },
    c = (u) => {
      const d = [...r]
      d.splice(u, 1), e.setValue("equipment", d)
    }
  return h.jsxs("div", {
    className: "flex flex-col space-y-6 justify-center",
    children: [
      h.jsxs("div", {
        className: "flex space-x-4",
        children: [
          h.jsx("div", {
            className: "flex flex-1 flex-col space-y-4",
            children: t.map((u, d) =>
              h.jsx(
                Ote,
                {
                  form: e,
                  index: d,
                  open: t.length === 0 || t[d] === "",
                  onDelete: () => a(d),
                },
                d
              )
            ),
          }),
          h.jsx("div", {
            className: "flex flex-1 flex-col space-y-4",
            children: n.map((u, d) =>
              h.jsx(
                Ate,
                {
                  form: e,
                  index: d,
                  open: n.length === 0 || n[d].ingredient === "",
                  onDelete: () => l(d),
                },
                d
              )
            ),
          }),
          h.jsx("div", {
            className: "flex flex-1 flex-col space-y-4",
            children: r.map((u, d) =>
              h.jsx(
                Rte,
                {
                  form: e,
                  index: d,
                  open: r.length === 0 || r[d] === "",
                  onDelete: () => c(d),
                },
                d
              )
            ),
          }),
        ],
      }),
      h.jsxs("div", {
        className: "flex justify-center gap-4 pt-4",
        children: [
          h.jsx(et, {
            type: "button",
            onClick: o,
            variant: "default",
            children: "Add Instruction",
          }),
          h.jsx(et, {
            type: "button",
            onClick: i,
            variant: "default",
            children: "Add Ingredient",
          }),
          h.jsx(et, {
            type: "button",
            onClick: s,
            variant: "default",
            children: "Add Equipment",
          }),
        ],
      }),
    ],
  })
}
var ax = "Checkbox",
  [Dte, cne] = Wn(ax),
  [Lte, Pte] = Dte(ax),
  $D = m.forwardRef((e, t) => {
    const {
        __scopeCheckbox: n,
        name: r,
        checked: o,
        defaultChecked: i,
        required: s,
        disabled: a,
        value: l = "on",
        onCheckedChange: c,
        form: u,
        ...d
      } = e,
      [f, p] = m.useState(null),
      g = tt(t, (w) => p(w)),
      v = m.useRef(!1),
      b = f ? u || !!f.closest("form") : !0,
      [y = !1, x] = Ir({ prop: o, defaultProp: i, onChange: c }),
      E = m.useRef(y)
    return (
      m.useEffect(() => {
        const w = f == null ? void 0 : f.form
        if (w) {
          const C = () => x(E.current)
          return (
            w.addEventListener("reset", C),
            () => w.removeEventListener("reset", C)
          )
        }
      }, [f, x]),
      h.jsxs(Lte, {
        scope: n,
        state: y,
        disabled: a,
        children: [
          h.jsx(Le.button, {
            type: "button",
            role: "checkbox",
            "aria-checked": bi(y) ? "mixed" : y,
            "aria-required": s,
            "data-state": FD(y),
            "data-disabled": a ? "" : void 0,
            disabled: a,
            value: l,
            ...d,
            ref: g,
            onKeyDown: ge(e.onKeyDown, (w) => {
              w.key === "Enter" && w.preventDefault()
            }),
            onClick: ge(e.onClick, (w) => {
              x((C) => (bi(C) ? !0 : !C)),
                b &&
                  ((v.current = w.isPropagationStopped()),
                  v.current || w.stopPropagation())
            }),
          }),
          b &&
            h.jsx($te, {
              control: f,
              bubbles: !v.current,
              name: r,
              value: l,
              checked: y,
              required: s,
              disabled: a,
              form: u,
              style: { transform: "translateX(-100%)" },
              defaultChecked: bi(i) ? !1 : i,
            }),
        ],
      })
    )
  })
$D.displayName = ax
var BD = "CheckboxIndicator",
  jD = m.forwardRef((e, t) => {
    const { __scopeCheckbox: n, forceMount: r, ...o } = e,
      i = Pte(BD, n)
    return h.jsx(Kn, {
      present: r || bi(i.state) || i.state === !0,
      children: h.jsx(Le.span, {
        "data-state": FD(i.state),
        "data-disabled": i.disabled ? "" : void 0,
        ...o,
        ref: t,
        style: { pointerEvents: "none", ...e.style },
      }),
    })
  })
jD.displayName = BD
var $te = (e) => {
  const {
      control: t,
      checked: n,
      bubbles: r = !0,
      defaultChecked: o,
      ...i
    } = e,
    s = m.useRef(null),
    a = Lb(n),
    l = kh(t)
  m.useEffect(() => {
    const u = s.current,
      d = window.HTMLInputElement.prototype,
      p = Object.getOwnPropertyDescriptor(d, "checked").set
    if (a !== n && p) {
      const g = new Event("click", { bubbles: r })
      ;(u.indeterminate = bi(n)), p.call(u, bi(n) ? !1 : n), u.dispatchEvent(g)
    }
  }, [a, n, r])
  const c = m.useRef(bi(n) ? !1 : n)
  return h.jsx("input", {
    type: "checkbox",
    "aria-hidden": !0,
    defaultChecked: o != null ? o : c.current,
    ...i,
    tabIndex: -1,
    ref: s,
    style: {
      ...e.style,
      ...l,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0,
    },
  })
}
function bi(e) {
  return e === "indeterminate"
}
function FD(e) {
  return bi(e) ? "indeterminate" : e ? "checked" : "unchecked"
}
var zD = $D,
  Bte = jD
const eh = m.forwardRef(({ className: e, ...t }, n) =>
  h.jsx(zD, {
    ref: n,
    className: q(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      e
    ),
    ...t,
    children: h.jsx(Bte, {
      className: q("flex items-center justify-center text-current"),
      children: h.jsx(hN, { className: "h-4 w-4" }),
    }),
  })
)
eh.displayName = zD.displayName
function jte({ form: e }) {
  return h.jsxs("div", {
    className: "flex gap-5",
    children: [
      h.jsxs("div", {
        className: "relative flex flex-1 flex-col",
        children: [
          h.jsx("span", {
            className:
              "absolute -top-3 left-4 bg-background px-2 text-sm font-medium text-muted-foreground",
            children: "Servings",
          }),
          h.jsx(Co, {
            className: "flex h-full flex-col",
            children: h.jsxs(So, {
              className: "flex flex-1 flex-col gap-4 p-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: "servings",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      className: "mt-5",
                      children: [
                        h.jsx(Wt, { children: "Servings" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            placeholder: "Servings",
                            ...t,
                            min: 1,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: "isPerServing",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      className: "mt-5",
                      children: [
                        h.jsx(Wt, { children: "Calories per serving?" }),
                        h.jsx("br", {}),
                        h.jsx(Lt, {
                          children: h.jsx(eh, {
                            checked: t.value,
                            onCheckedChange: t.onChange,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
          }),
        ],
      }),
      h.jsxs("div", {
        className: "relative flex flex-1 flex-col",
        children: [
          h.jsx("span", {
            className:
              "absolute -top-3 left-4 bg-background px-2 text-sm font-medium text-muted-foreground",
            children: "Calories and fat",
          }),
          h.jsx(Co, {
            className: "flex h-full flex-col",
            children: h.jsxs(So, {
              className: "flex flex-1 flex-col gap-4 p-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: "nutrition.calories",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      className: "mt-5",
                      children: [
                        h.jsx(Wt, { children: "Calories" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            placeholder: "Calories",
                            ...t,
                            min: 0,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: "nutrition.fat",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      className: "mt-5",
                      children: [
                        h.jsx(Wt, { children: "Fat" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            placeholder: "Fat",
                            ...t,
                            min: 1,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
          }),
        ],
      }),
      h.jsxs("div", {
        className: "relative flex flex-1 flex-col",
        children: [
          h.jsx("span", {
            className:
              "absolute -top-3 left-4 bg-background px-2 text-sm font-medium text-muted-foreground",
            children: "Calories and fat",
          }),
          h.jsx(Co, {
            className: "flex h-full flex-col",
            children: h.jsxs(So, {
              className: "flex flex-1 flex-col gap-4 p-4",
              children: [
                h.jsx(Ht, {
                  control: e.control,
                  name: "nutrition.carbs",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      className: "mt-5",
                      children: [
                        h.jsx(Wt, { children: "Carbs" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            placeholder: "Carbs",
                            ...t,
                            min: 1,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
                h.jsx(Ht, {
                  control: e.control,
                  name: "nutrition.protein",
                  render: ({ field: t }) =>
                    h.jsxs(Dt, {
                      className: "mt-5",
                      children: [
                        h.jsx(Wt, { children: "Protein" }),
                        h.jsx(Lt, {
                          children: h.jsx(St, {
                            type: "number",
                            placeholder: "Protein",
                            ...t,
                            min: 1,
                          }),
                        }),
                        h.jsx(Pt, {}),
                      ],
                    }),
                }),
              ],
            }),
          }),
        ],
      }),
    ],
  })
}
const co = (e, t) => {
    let n = Rt.number({ required_error: e })
    return (
      (t == null ? void 0 : t.min) !== void 0 &&
        (n = n.min(t.min, { message: `Must be no less than ${t.min}` })),
      (t == null ? void 0 : t.max) !== void 0 &&
        (n = n.max(t.max, { message: `Must be no more than ${t.max}` })),
      Rt.preprocess((r) => {
        const o = parseInt(r, 10)
        return isNaN(o) ? void 0 : o
      }, n)
    )
  },
  Fte = Rt.object({
    name: Rt.string().min(1, { message: "A name is required" }),
    category: Rt.string().min(1, {
      message: "At least one category is required",
    }),
    rating: co("Rating is required", { min: 1, max: 5 }),
    prep_time: co("Preparation time is required"),
    cook_time: co("Cooking time is required"),
    servings: co("Number of servings is required"),
    title_image: Rt.union([
      Rt.instanceof(File),
      Rt.string().refine((e) => e.startsWith("data:image/"), {
        message: "Invalid image string",
      }),
    ]).transform((e) =>
      typeof e == "string"
        ? e
        : new Promise((t, n) => {
            const r = new FileReader()
            ;(r.onload = () => t(r.result)), (r.onerror = n), r.readAsDataURL(e)
          })
    ),
    isPerServing: Rt.boolean().default(!1),
    instructions: Rt.array(Rt.string()),
    ingredients: Rt.array(
      Rt.object({
        ingredient: Rt.string(),
        unit: Rt.string(),
        quantity: co("Ingredient quantity is required"),
      })
    ),
    equipment: Rt.array(Rt.string()),
    nutrition: Rt.object({
      calories: co("Amount of calories is required"),
      fat: co("Amount of fat is required"),
      carbs: co("Amount of carbs is required"),
      protein: co("Amount of protein is required"),
    }),
  })
function UD({ id: e = -1 }) {
  const [t, n] = m.useState(0),
    [, r] = bh(),
    { db: o, error: i, loading: s } = ab(),
    a = I$({
      resolver: $$(Fte),
      mode: "onChange",
      defaultValues: {
        ingredients: [],
        instructions: [],
        equipment: [],
        isPerServing: !1,
      },
    })
  m.useEffect(() => {
    if (!e) return
    const d = async () => {
      const f = await DN(o, e)
      a.reset({
        name: f == null ? void 0 : f.recipe.name,
        category: f == null ? void 0 : f.recipe.category,
        rating: (f == null ? void 0 : f.recipe.rating) || 0,
        prep_time: (f == null ? void 0 : f.recipe.prep_time) || 0,
        cook_time: (f == null ? void 0 : f.recipe.cook_time) || 0,
        servings: (f == null ? void 0 : f.recipe.servings) || 0,
        title_image: f == null ? void 0 : f.recipe.title_image,
        isPerServing: !0,
        instructions:
          f == null ? void 0 : f.directions.map((p) => p.description),
        ingredients:
          f == null
            ? void 0
            : f.ingredients.map((p) => ({
                ingredient: p.ingredient,
                unit: p.unit,
                quantity: p.quantity || 0,
              })),
        equipment: f == null ? void 0 : f.equipment.map((p) => p.equipment),
        nutrition: {
          calories: Math.ceil((f == null ? void 0 : f.nutrition.calories) || 0),
          fat: (f == null ? void 0 : f.nutrition.fat) || 0,
          protein: (f == null ? void 0 : f.nutrition.protein) || 0,
          carbs: (f == null ? void 0 : f.nutrition.carbs) || 0,
        },
      })
    }
    e != -1 && !s && d()
  }, [e, o])
  const l = m.useCallback(
      async (d) =>
        e != -1
          ? (await gP(o, e, {
              ...d,
              ingredients: d.ingredients.map((f) => ({ ...f, id: e })),
              equipment: d.equipment.map((f) => ({ equipment: f, id: e })),
            }),
            e)
          : await mP(o, d),
      [o]
    ),
    c = (d) => {
      l(d).then((f) => {
        r("/details/" + f)
      })
    },
    u = [
      { component: h.jsx(Sj, { form: a }), title: "Recipe Information" },
      {
        component: h.jsx(Ite, { form: a }),
        title: "Ingredients and Instructions",
      },
      { component: h.jsx(jte, { form: a }), title: "Nutrition" },
    ]
  return i
    ? h.jsx(vj, {
        open: !0,
        children: h.jsxs(NM, {
          children: [
            h.jsxs(TM, {
              children: [
                h.jsx(OM, {
                  children: "An error occured while trying to load database",
                }),
                h.jsx(AM, { children: "Try to reopen the app." }),
              ],
            }),
            h.jsx(MM, { children: h.jsx(RM, { children: "Close" }) }),
          ],
        }),
      })
    : h.jsx(wj, {
        ...a,
        children: h.jsx("form", {
          onSubmit: a.handleSubmit(c),
          className: "h-full",
          children: h.jsxs(Co, {
            className: "mx-auto my-10 max-w-6xl overflow-hidden shadow-lg",
            children: [
              h.jsxs(ob, {
                className:
                  "flex items-center justify-between border-b px-6 py-4",
                children: [
                  h.jsxs("div", {
                    children: [
                      h.jsxs("h2", {
                        className: "text-2xl font-bold",
                        children: [e !== -1 ? "Edit" : "Create", " Recipe"],
                      }),
                      h.jsx("p", {
                        className: "text-muted-foreground",
                        children: u[t].title,
                      }),
                    ],
                  }),
                  h.jsxs("div", {
                    className: "flex gap-2",
                    children: [
                      t > 0 &&
                        h.jsx(et, {
                          type: "button",
                          variant: "outline",
                          onClick: () => n(t - 1),
                          children: "Back",
                        }),
                      t < u.length - 1
                        ? h.jsx(et, {
                            type: "button",
                            onClick: (d) => {
                              d.preventDefault(), n(t + 1)
                            },
                            children: "Next",
                          })
                        : h.jsx(et, { type: "submit", children: "Submit" }),
                    ],
                  }),
                ],
              }),
              h.jsx(So, {
                className:
                  "flex max-h-[calc(100vh-150px)] flex-col overflow-auto p-6",
                children: u[t].component,
              }),
            ],
          }),
        }),
      })
}
const zte = UD,
  Ute = ({ id: e, db: t }) => {
    const [n, r] = bh(),
      [o, i] = m.useState(!1),
      [s, a] = m.useState(!1),
      l = async () => {
        a(!0)
        try {
          await uP(t, e), r("/")
        } catch (c) {
          console.error("Failed to delete recipe:", c)
        } finally {
          a(!1)
        }
      }
    return h.jsxs(Au, {
      open: o,
      onOpenChange: i,
      children: [
        h.jsx(Ru, {
          asChild: !0,
          children: h.jsx(et, {
            variant: "destructive",
            className: "ml-1",
            children: "Delete",
          }),
        }),
        h.jsxs(yl, {
          children: [
            h.jsxs(bl, {
              children: [
                h.jsx(xl, { children: "Confirm Deletion" }),
                h.jsx(Hb, {
                  children:
                    "Are you sure you want to delete this recipe? This action cannot be undone.",
                }),
              ],
            }),
            h.jsxs(jM, {
              children: [
                h.jsx(et, {
                  variant: "outline",
                  onClick: () => i(!1),
                  disabled: s,
                  children: "Cancel",
                }),
                h.jsx(et, {
                  variant: "destructive",
                  onClick: l,
                  disabled: s,
                  children: s
                    ? h.jsxs(h.Fragment, {
                        children: [
                          h.jsx(mL, { className: "mr-2 h-4 w-4 animate-spin" }),
                          "Deleting...",
                        ],
                      })
                    : "Delete Recipe",
                }),
              ],
            }),
          ],
        }),
      ],
    })
  },
  Vte = ({ src: e, alt: t, className: n = "", ...r }) => {
    const [o, i] = m.useState(!1)
    return o
      ? h.jsxs("div", {
          className: `flex h-full w-full items-center justify-center rounded-xl bg-gray-200 ${n}`,
          children: [
            h.jsx(iL, { size: 40, className: "text-gray-500" }),
            h.jsx("span", {
              className: "ml-2 text-gray-500",
              children: t != null ? t : "Image not available",
            }),
          ],
        })
      : h.jsx("img", {
          src: e,
          alt: t,
          className: `${n}`,
          onError: () => i(!0),
          ...r,
        })
  }
function Hte({ id: e }) {
  var s, a
  const { db: t } = ab(),
    [n, r] = m.useState(null),
    [o, i] = bh()
  return (
    m.useEffect(() => {
      if (!e) return
      ;(async () => {
        const c = Number(e)
        if (isNaN(c)) return
        const u = await DN(t, c)
        r(u)
      })()
    }, [e, t]),
    h.jsxs("div", {
      className: "mx-auto mt-16 h-auto w-11/12 max-w-6xl overflow-auto p-4",
      children: [
        h.jsxs("div", {
          className:
            "flex flex-col items-center gap-6 rounded-xl bg-gray-900 p-6 shadow-lg md:flex-row",
          children: [
            h.jsx("div", {
              className: "w-full md:w-1/3",
              children: h.jsx(Vte, {
                src: n == null ? void 0 : n.recipe.title_image,
                alt: `Image for "${n == null ? void 0 : n.recipe.name}"`,
                className: "h-48 w-full rounded-xl object-cover",
              }),
            }),
            h.jsxs("div", {
              className: "w-full space-y-2 md:w-2/3",
              children: [
                h.jsx("h1", {
                  className: "text-2xl font-semibold",
                  children: n == null ? void 0 : n.recipe.name,
                }),
                h.jsxs("p", {
                  className: "text-sm text-gray-400",
                  children: [
                    (n == null
                      ? void 0
                      : n.recipe.category.split(",").length) == 1
                      ? "Category"
                      : "Categories",
                    ": ",
                    n == null ? void 0 : n.recipe.category,
                  ],
                }),
                h.jsxs("div", {
                  className: "flex flex-wrap items-center gap-2",
                  children: [
                    h.jsx(Pf, {
                      variant: "secondary",
                      children: "".repeat(
                        (s = n == null ? void 0 : n.recipe.rating) != null
                          ? s
                          : 0
                      ),
                    }),
                    h.jsx(Pf, {
                      variant:
                        n != null && n.recipe.favourite ? "default" : "outline",
                      children:
                        n != null && n.recipe.favourite
                          ? " Favorite"
                          : " Not Favorite",
                    }),
                  ],
                }),
                h.jsxs("div", {
                  className: "flex flex-wrap gap-4 text-sm text-gray-400",
                  children: [
                    h.jsxs("span", {
                      children: [
                        "Prep: ",
                        n == null ? void 0 : n.recipe.prep_time,
                        " mins",
                      ],
                    }),
                    h.jsxs("span", {
                      children: [
                        "Cook: ",
                        n == null ? void 0 : n.recipe.cook_time,
                        " mins",
                      ],
                    }),
                    h.jsxs("span", {
                      children: [
                        "Servings: ",
                        n == null ? void 0 : n.recipe.servings,
                      ],
                    }),
                  ],
                }),
                h.jsxs("div", {
                  className: "flex gap-2 pt-2",
                  children: [
                    h.jsx(et, {
                      onClick: () =>
                        i("/edit/" + (n == null ? void 0 : n.recipe.id)),
                      children: "Edit",
                    }),
                    h.jsx(Ute, {
                      id:
                        (a = n == null ? void 0 : n.recipe.id) != null ? a : -1,
                      db: t,
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
        h.jsxs("div", {
          className: "mt-6 grid grid-cols-1 gap-6 md:grid-cols-2",
          children: [
            (n == null ? void 0 : n.nutrition) &&
              h.jsxs("div", {
                className: "rounded-xl bg-gray-900 p-4 shadow",
                children: [
                  h.jsx("h2", {
                    className: "mb-3 text-lg font-bold",
                    children: "Nutrition Info",
                  }),
                  h.jsxs("div", {
                    className: "grid grid-cols-2 gap-2 text-sm",
                    children: [
                      h.jsxs("div", {
                        children: [
                          h.jsx("span", {
                            className: "font-semibold",
                            children: "Calories:",
                          }),
                          " ",
                          new Intl.NumberFormat("pl-PL", {
                            useGrouping: !0,
                          }).format(n.nutrition.calories) + " cal",
                        ],
                      }),
                      h.jsxs("div", {
                        className: "flex flex-col",
                        children: [
                          h.jsxs("div", {
                            children: [
                              h.jsx("span", {
                                className: "font-semibold",
                                children: "Fat:",
                              }),
                              " ",
                              n.nutrition.fat,
                              "g",
                            ],
                          }),
                          h.jsxs("div", {
                            children: [
                              h.jsx("span", {
                                className: "font-semibold",
                                children: "Carbs:",
                              }),
                              " ",
                              n.nutrition.carbs,
                              "g",
                            ],
                          }),
                          h.jsxs("div", {
                            children: [
                              h.jsx("span", {
                                className: "font-semibold",
                                children: "Protein:",
                              }),
                              " ",
                              n.nutrition.protein,
                              "g",
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            (n == null ? void 0 : n.ingredients) &&
              h.jsxs("div", {
                className: "rounded-xl bg-gray-900 p-4 shadow",
                children: [
                  h.jsx("h2", {
                    className: "mb-3 text-lg font-bold",
                    children: "Ingredients",
                  }),
                  h.jsx("ul", {
                    className: "space-y-2",
                    children: n.ingredients.map((l) =>
                      h.jsxs(
                        "li",
                        {
                          className: "flex items-center gap-3",
                          children: [
                            h.jsx(eh, { className: "h-5 w-5" }),
                            h.jsxs("span", {
                              children: [
                                h.jsxs("span", {
                                  className: "font-semibold",
                                  children: [l.quantity, " ", l.unit],
                                }),
                                " ",
                                l.ingredient,
                              ],
                            }),
                          ],
                        },
                        l.id
                      )
                    ),
                  }),
                ],
              }),
          ],
        }),
        (n == null ? void 0 : n.directions) &&
          h.jsxs("div", {
            className: "mt-6 rounded-xl bg-gray-900 p-4 shadow",
            children: [
              h.jsx("h2", {
                className: "mb-3 text-lg font-bold",
                children: "Directions",
              }),
              h.jsx("ol", {
                className: "space-y-3",
                children: n.directions.map((l, c) =>
                  h.jsxs(
                    "li",
                    {
                      className: "flex gap-3",
                      children: [
                        h.jsx("div", {
                          className: "flex min-w-6 items-start pt-1",
                          children: h.jsxs("span", {
                            className: "font-semibold text-blue-400",
                            children: [c + 1, "."],
                          }),
                        }),
                        h.jsxs("div", {
                          className: "flex-1",
                          children: [
                            l.title &&
                              h.jsx("h3", {
                                className: "font-semibold text-blue-400",
                                children: l.title,
                              }),
                            h.jsx("div", {
                              dangerouslySetInnerHTML: {
                                __html: l.description,
                              },
                            }),
                          ],
                        }),
                      ],
                    },
                    l.id
                  )
                ),
              }),
            ],
          }),
        (n == null ? void 0 : n.equipment) &&
          h.jsxs("div", {
            className: "mt-6 rounded-xl bg-gray-900 p-4 shadow",
            children: [
              h.jsx("h2", {
                className: "mb-3 text-lg font-bold",
                children: "Equipment",
              }),
              h.jsx("ul", {
                className: "grid grid-cols-2 gap-2 md:grid-cols-3",
                children: n.equipment.map((l) =>
                  h.jsxs(
                    "li",
                    {
                      className: "flex items-center gap-2",
                      children: [
                        h.jsx(eh, { className: "h-5 w-5" }),
                        l.equipment,
                      ],
                    },
                    l.id
                  )
                ),
              }),
            ],
          }),
      ],
    })
  )
}
function Wte({ id: e }) {
  return h.jsx(UD, { id: e })
}
nv.createRoot(document.getElementById("root")).render(
  h.jsx(G.StrictMode, {
    children: h.jsx(Zv, {
      hook: Yv,
      children: h.jsxs(Zv, {
        hook: Yv,
        children: [
          h.jsx(cd, {
            path: "/",
            children: h.jsx(yd, { children: h.jsx(yP, {}) }),
          }),
          h.jsx(cd, {
            path: "/create",
            children: h.jsx(yd, { children: h.jsx(zte, {}) }),
          }),
          h.jsx(cd, {
            path: "/details/:id",
            children: (e) =>
              h.jsx(yd, { children: h.jsx(Hte, { id: parseInt(e.id) }) }),
          }),
          h.jsx(cd, {
            path: "/edit/:id",
            children: (e) =>
              h.jsx(yd, { children: h.jsx(Wte, { id: parseInt(e.id) }) }),
          }),
        ],
      }),
    }),
  })
)
